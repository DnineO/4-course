/************************************************************************
                          Лабораторная работа N3

                                Пример 2.

                               TESTDLL.CPP

     Пример библиотеки DLL, экспортирующей функцию при явном связывании

************************************************************************/
#include <windows.h>

/* Функция GetSomeString() является внутренней функцией DLL и не экспортируется.
   Таким образом, другие приложения не имеют прямого доступа к ее коду. Как
   правило, типичная DLL содержит некоторое количество  внутренних функций,
   выполняющих реальную работу, а также несколько экспортируемых  функций,
   которые выполняют роль интерфейса между DLL и приложениями. При этом
   экспортируемые функции могут вызывать внутренние функции DLL как показано
   в данном примере.
*/

LPSTR GetSomeString ()          // Функция GetSomeString () просто
{                               // возвращает строку текста
   return "Hello from DLL!\n";
}


/* Функция Test() является экспортируемой, т.е. доступна другим приложениям.
   Для этого она должна быть описана со специальным модификатором, который
   определяется используемой версией компилятора. В случае с C++ Builder -
   __declspec (dllexport). При использовании этого модификатора функция будет
   помещена в таблицу экспорта DLL и станет доступна внешним приложениям.
   Прототип функции в вызывающей программе должен соответствовать ее описанию
   в коде DLL, за исключением модификатора __declspec (dllexport).

   Особенностью явного связывания является то, что в вызывающей программе
   должно быть известно ВНУТРЕНЕЕ имя функции в DLL. Компиляторы С++ используют
   т.н. расширение имен (name mangling), предназначенное для поддержки
   перегруженных функций. При расширении имен внутреннее имя функции отличается
   от имени в тексте программы, поскольку к нему дописываются специальные
   символы расширения. Таким образом, попытка вызвать функцию из DLL по имени
   будет неудачной (имя функции, переданное вызывающим приложением и внутренее
   имя функции будут отличаться). Один из способов обхода данной проблемы - 
   отключение расширения имен. Это достигается использованием специального 
   модификатора EXTERN "C". При этом внутренее имя функции будет почти
   совпадать с именем в тексте программы, но содержать символ _ в начале имени.
   Например, функция Test, описанная как  extern "C", будет иметь внутреннее
   имя _Test  т.п.
*/

extern "C" LPSTR  __declspec (dllexport) Test (void)
{
   return GetSomeString ();
}


// Функция DllEntryPoint является стандартной точкой входа для DLL, т.е.
// аналогом WinMain для приложений (еще она может называться DllMain). 
// Как правило, она применяется достаточно редко  - в случаях, когда 
// требуется выполнять какие-то инициализационные действия при загрузке DLL,
// поскольку  DllEntryPoint выполняется автоматически при загрузке DLL.

BOOL WINAPI DllEntryPoint (HINSTANCE, DWORD, DWORD)
{
    return 1;    // DllEntryPoint просто возвращает TRUE и ничего не делает
}

