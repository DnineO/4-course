// dllmain.cpp : Определяет точку входа для приложения DLL.
#include "pch.h"
#include <windows.h>

//BOOL APIENTRY DllMain( HMODULE hModule,
//                       DWORD  ul_reason_for_call,
//                       LPVOID lpReserved
//                     )
//{
//    switch (ul_reason_for_call)
//    {
//    case DLL_PROCESS_ATTACH:
//    case DLL_THREAD_ATTACH:
//    case DLL_THREAD_DETACH:
//    case DLL_PROCESS_DETACH:
//        break;
//    }
//    return TRUE;
//}



/* Функция GetSomeString() является внутренней функцией DLL и не экспортируется.
   Таким образом, другие приложения не имеют прямого доступа к ее коду. Как
   правило, типичная DLL содержит некоторое количество  внутренних функций,
   выполняющих реальную работу, а также несколько экспортируемых  функций,
   которые выполняют роль интерфейса между DLL и приложениями. При этом
   экспортируемые функции могут вызывать внутренние функции DLL как показано
   в данном примере.
*/

LPCWSTR GetSomeString()				        // Функция GetSomeString () просто	
{								// возвращает строку текста       
    return (LPCWSTR)(L"Hello from DLL!\n");
}


/* Функция Test() является экспортируемой, т.е. доступна другим приложениям.
   Для этого она должна быть описана со специальным модификатором, который
   определяется используемой версией компилятора. В данном случае -
   __declspec (dllexport). При использовании этого модификатора функция будет
   помещена в таблицу экспорта DLL и станет доступна внешним приложениям.
   Прототип функции в вызывающей программе должен соответствовать ее описанию
   в коде DLL, за исключением модификатора __declspec (dllexport).

   Особенностью явного связывания является то, что в вызывающей программе
   должно быть известно ВНУТРЕНЕЕ имя функции в DLL. Компиляторы С++ используют
   т.н. расширение имен (name mangling), предназначенное для поддержки
   перегруженных функций. При расширении имен внутреннее имя функции отличается
   от имени в тексте программы, поскольку к нему дописываются специальные
   символы расширения. Таким образом, попытка вызвать функцию из DLL по имени
   будет неудачной (имя функции, переданное вызывающим приложением и внутренее
   имя функции будут отличаться). Один из способов обхода данной проблемы -
   отключение расширения имен. Это достигается использованием специального
   модификатора EXTERN "C". При этом внутренее имя функции будет совпадать
   с именем в тексте программы.
*/

extern "C" LPCWSTR  __declspec (dllexport) Test(void)
{
    return GetSomeString();
}

// Функция DllEntryPoint является стандартной точкой входа для DLL, т.е.
// аналогом WinMain для приложений (еще она может называться DllMain). 
// Как правило, она применяется достаточно редко  - в случаях, когда 
// требуется выполнять какие-то инициализационные действия при загрузке DLL,
// поскольку  DllEntryPoint выполняется автоматически при загрузке DLL.

BOOL WINAPI DllEntryPoint(HINSTANCE, DWORD, DWORD)
{
    return 1;				// DllEntryPoint просто возвращает TRUE и ничего не делает
}