<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=win-1251">
</head>
<body text=black bgcolor=white link=blue vlink=blue alink=red>
<link rel=stylesheet type=text/css href=../../1.css>
<font color=red><h2 align=center>Шаг 41 - Списки и Свет.</h2></font>
В этом шаге посмотрим как сделать две вещи:
<ul>
<li>создать источник света и вращать его
<li>что такое список и как его использовать
</ul>
Чесно говоря, я устал от этого <b>MFC</b>, захотелось сделать маленькую и шуструю программку. Поэтому я сделал этот шаг на <b>API</b>. Кроме того, как мне кажется, на <b>MFC</b> достаточно сложно сделать программу с максимальной производительностью. (собствено говоря ни одна игровая программа не использует <b>MFC</b>,  <b>OWL</b>, <b>VCL</b> и т.д.) Хотя все это не имеет значения. Главное - это правильно подойти к поставленной  задаче. Делать <b>CAD</b> систему на <b>API</b> неразумно, равно как и писать <b>3D</b> шутер с <b>MFC</b>. Так что лучше всего уметь и так и так ;)
<p>Ну ладно, теперь к нашим баранам.
Сначала о списках. Список - это некоторый набор команд <b>OpenGL</b>, который можно создать один раз, например, перед началом работы программы, а потом им пользоваться вызывая его. По логике он аналогичен процедуре (или функции, как хотите). Отличие его от процедуры в том, что при формировании списка библиотека сохраняет его в каком-то своем, оптимизированном формате и вызовы списка приводят к значительно меньшим вычислительным затратам чем вызов функции, делающей тоже самое. Особенно хорошо это заметно на картах, где операции со списками реализованы аппаратно.
<p>Давайте посмотрим как создать список:
<pre>
void CalculateList()
{
	CUBE_LIST = glGenLists(1);
	glNewList(CUBE_LIST, GL_COMPILE);
		DrawCube();
	glEndList();
}
</pre>
Для того, чтобы занести в список некоторую последовательность команд надо поместить их между командными скобками <b>glNewList</b> и <b>glEndList</b>. Первый аргумент команды <b>glNewList</b> - номер списка. Вы можете использовать большое количество списков в своей программе и каждый из них будет иметь свой номер. В принципе можно самому задавать числа, но для того чтобы избежать наложений рекомендуется использовать специальную команду, которая генерирует номера списков и первый номер возвращает в вашу переменную. В качестве аргумента она принимает количество номеров списков, которое вы хотите получить.
<p>Например, запись <b>CUBE_LIST = glGenLists(5)</b> зарезервирует для вас 5 номеров списков и первый номер попадет в переменную <b>CUBE_LIST</b>. Посмотрите код функции <b>DrawCube</b>, он такой же как и в <a href=37.html>шаге 37</a>. Просто все команды рисования куба заносятся в список. Я выделил эти команды в отдельную функцию для того, чтобы в будущем вернуться к этому примеру (доработав его, конечно) и посмотреть количество <b>fps</b> в режиме со списками и без.
<p>Но это потом. Сейчас посмотрим как использовать этот список:
<pre>
GLvoid Draw()
{
	static GLfloat rot = 0.0f;

	glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	glPushMatrix();
	glColor3f (1.0, 1.0, 0.5);
	glCallList(CUBE_LIST);
	glRotatef(rot, 0.0f, 1.0f, 1.0f);

	glPushMatrix();
	glLightfv(GL_LIGHT0, GL_POSITION, light0_Position);
	glTranslatef(light0_Position[0],light0_Position[1],light0_Position[2]);
	glScalef(0.1f, 0.1f, 0.1f);
	glCallList(CUBE_LIST);
	glPopMatrix();

	rot+=1.0f;
	glPopMatrix();

	SwapBuffers(hDC);
}
</pre>
В начале работы мы заталкиваем в стек текущую матрицу <b>glPushMatrix()</b>, чтобы не портить её ;). Устанавливаем цвет примитивов - <b>glColor3f (1.0, 1.0, 0.5)</b>. Вызываем список для рисования большого куба - <b>glCallList(CUBE_LIST)</b>. Поворачиваем модельную систему координат на угол <b>rot</b> относительно осей <b>Y</b> и <b>Z</b>. Опять прячем в стек уже повернутую систему координат - <b>glPushMatrix()</b>.
<p>Устанавливаем источник света в заданную позицию при помощи оператора:<pre>	glLightfv(GL_LIGHT0, GL_POSITION, light0_Position)</pre>.
<p>Переносим систему координат в ту точку где стоит источник света:
<pre>glTranslatef(light0_Position[0],light0_Position[1],light0_Position[2])
</pre>
Масштабируем систему координат, т.е. уменьшаем в 10 раз по всем осям функцией <b>glScalef(0.1f, 0.1f, 0.1f)</b>.
<br>Вызываем список, т.е. опять рисуем кубик, но меньшего размера и в другом месте :) (<b>glCallList(CUBE_LIST)</b>)
<br>Восстанавливаем матрицу (<b>glPopMatrix()</b>)
<Br>Увеличиваем угол (<b>rot+=1.0f</b>)
<br>И восстанавливаем исходную матрицу (<b>glPopMatrix()</b>)

<p>Вот и все дела. Единственный момент, который мы еще не видели раньше - положение источника света. Все характеристики источников света (не только положение, но и его тип, интенсивность и т.д.) задаются при помощи одной команды <b>glLightfv</b>, где 1-й аргумент это имя источника, второй говорит какое свойство источника будет задано 3-м аргументом. В нашем случае есть глобальный массив <b>light0_Position</b> и он определяет где будет находится источник.
<p>В проекте есть еще несколько вспомогательных функций, которые настраивают видовые координаты, включают режим освещения и сам источник света, включают буффер глубины и т.д., но все эти функции мы уже много раз писали в <b>MFC</b> проектиках. Поэтому посмотрите их в проекте. Сюда я не буду их вставлять.
<p>Ну вот. Посмотрите на кубики, а я пока напишу текст к следующему шагу, где будет 2 источника света ;)
<p><hr><center><font size=2><a href=prog/41.zip>Загрузить проект</a> | <a href=40.html>Предыдущий шаг</a> | <a href=42.html>Следующий Шаг</a> | <a href=opengl1.html>Оглавление</a></font></center>
<hr><center><font size=2>By <a href="mailto:kirill@scsc.ru@SUBJECT=OpenGLByStep">Kirill V. Ratkin</a>.</center></body></html>
