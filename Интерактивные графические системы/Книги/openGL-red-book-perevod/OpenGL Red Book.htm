<html xmlns:v="urn:schemas-microsoft-com:vml"
xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns:st1="urn:schemas-microsoft-com:office:smarttags"
xmlns="http://www.w3.org/TR/REC-html40">

<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 10">
<meta name=Originator content="Microsoft Word 10">
<link rel=File-List href="OpenGL%20Red%20Book.files/filelist.xml">
<link rel=Edit-Time-Data href="OpenGL%20Red%20Book.files/editdata.mso">
<!--[if !mso]>
<style>
v\:* {behavior:url(#default#VML);}
o\:* {behavior:url(#default#VML);}
w\:* {behavior:url(#default#VML);}
.shape {behavior:url(#default#VML);}
</style>
<![endif]-->
<title>Глава 1</title>
<o:SmartTagType namespaceuri="urn:schemas-microsoft-com:office:smarttags"
 name="place"/>
<o:SmartTagType namespaceuri="urn:schemas-microsoft-com:office:smarttags"
 name="metricconverter"/>
<o:SmartTagType namespaceuri="urn:schemas-microsoft-com:office:smarttags"
 name="City"/>
<o:SmartTagType namespaceuri="urn:schemas-microsoft-com:office:smarttags"
 name="State"/>
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>Айкаевы</o:Author>
  <o:LastAuthor>Все</o:LastAuthor>
  <o:Revision>3</o:Revision>
  <o:TotalTime>60</o:TotalTime>
  <o:Created>2005-07-27T12:29:00Z</o:Created>
  <o:LastSaved>2005-07-27T12:29:00Z</o:LastSaved>
  <o:Pages>180</o:Pages>
  <o:Words>177844</o:Words>
  <o:Characters>1013717</o:Characters>
  <o:Company>Дом</o:Company>
  <o:Lines>8447</o:Lines>
  <o:Paragraphs>2378</o:Paragraphs>
  <o:CharactersWithSpaces>1189183</o:CharactersWithSpaces>
  <o:Version>10.6403</o:Version>
 </o:DocumentProperties>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:WordDocument>
  <w:ActiveWritingStyle Lang="RU" VendorID="1" DLLVersion="512" NLCheck="0">0</w:ActiveWritingStyle>
  <w:PunctuationKerning/>
  <w:Compatibility>
   <w:BreakWrappedTables/>
   <w:SnapToGridInCell/>
   <w:WrapTextWithPunct/>
   <w:UseAsianBreakRules/>
  </w:Compatibility>
  <w:BrowserLevel>MicrosoftInternetExplorer4</w:BrowserLevel>
 </w:WordDocument>
</xml><![endif]--><!--[if !mso]><object
 classid="clsid:38481807-CA0E-42D2-BF39-B33AF135CC4D" id=ieooui></object>
<style>
st1\:*{behavior:url(#ieooui) }
</style>
<![endif]-->
<style>
<!--
 /* Font Definitions */
 @font-face
	{font-family:Helvetica;
	panose-1:2 11 5 4 2 2 2 2 2 4;
	mso-font-charset:0;
	mso-generic-font-family:swiss;
	mso-font-format:other;
	mso-font-pitch:variable;
	mso-font-signature:3 0 0 0 1 0;}
@font-face
	{font-family:Courier;
	panose-1:2 7 4 9 2 2 5 2 4 4;
	mso-font-charset:0;
	mso-generic-font-family:modern;
	mso-font-format:other;
	mso-font-pitch:fixed;
	mso-font-signature:3 0 0 0 1 0;}
@font-face
	{font-family:"Tms Rmn";
	panose-1:2 2 6 3 4 5 5 2 3 4;
	mso-font-charset:0;
	mso-generic-font-family:roman;
	mso-font-format:other;
	mso-font-pitch:variable;
	mso-font-signature:3 0 0 0 1 0;}
@font-face
	{font-family:Helv;
	panose-1:2 11 6 4 2 2 2 3 2 4;
	mso-font-charset:0;
	mso-generic-font-family:swiss;
	mso-font-format:other;
	mso-font-pitch:variable;
	mso-font-signature:3 0 0 0 1 0;}
@font-face
	{font-family:"New York";
	panose-1:2 4 5 3 6 5 6 2 3 4;
	mso-font-charset:0;
	mso-generic-font-family:roman;
	mso-font-format:other;
	mso-font-pitch:variable;
	mso-font-signature:3 0 0 0 1 0;}
@font-face
	{font-family:System;
	panose-1:0 0 0 0 0 0 0 0 0 0;
	mso-font-charset:0;
	mso-generic-font-family:swiss;
	mso-font-format:other;
	mso-font-pitch:variable;
	mso-font-signature:3 0 0 0 1 0;}
@font-face
	{font-family:Wingdings;
	panose-1:5 0 0 0 0 0 0 0 0 0;
	mso-font-charset:2;
	mso-generic-font-family:auto;
	mso-font-pitch:variable;
	mso-font-signature:0 268435456 0 0 -2147483648 0;}
@font-face
	{font-family:"MS Mincho";
	panose-1:2 2 6 9 4 2 5 8 3 4;
	mso-font-alt:"\FF2D\FF33 \660E\671D";
	mso-font-charset:128;
	mso-generic-font-family:roman;
	mso-font-format:other;
	mso-font-pitch:fixed;
	mso-font-signature:1 134676480 16 0 131072 0;}
@font-face
	{font-family:Batang;
	panose-1:2 3 6 0 0 1 1 1 1 1;
	mso-font-alt:\BC14\D0D5;
	mso-font-charset:129;
	mso-generic-font-family:auto;
	mso-font-format:other;
	mso-font-pitch:fixed;
	mso-font-signature:1 151388160 16 0 524288 0;}
@font-face
	{font-family:SimSun;
	panose-1:2 1 6 0 3 1 1 1 1 1;
	mso-font-alt:\5B8B\4F53;
	mso-font-charset:134;
	mso-generic-font-family:auto;
	mso-font-format:other;
	mso-font-pitch:variable;
	mso-font-signature:1 135135232 16 0 262144 0;}
@font-face
	{font-family:PMingLiU;
	panose-1:2 1 6 1 0 1 1 1 1 1;
	mso-font-alt:\65B0\7D30\660E\9AD4;
	mso-font-charset:136;
	mso-generic-font-family:auto;
	mso-font-format:other;
	mso-font-pitch:variable;
	mso-font-signature:1 134742016 16 0 1048576 0;}
@font-face
	{font-family:"MS Gothic";
	panose-1:2 11 6 9 7 2 5 8 2 4;
	mso-font-alt:"\FF2D\FF33 \30B4\30B7\30C3\30AF";
	mso-font-charset:128;
	mso-generic-font-family:modern;
	mso-font-format:other;
	mso-font-pitch:fixed;
	mso-font-signature:1 134676480 16 0 131072 0;}
@font-face
	{font-family:Dotum;
	panose-1:2 11 6 0 0 1 1 1 1 1;
	mso-font-alt:\B3CB\C6C0;
	mso-font-charset:129;
	mso-generic-font-family:modern;
	mso-font-format:other;
	mso-font-pitch:fixed;
	mso-font-signature:1 151388160 16 0 524288 0;}
@font-face
	{font-family:SimHei;
	panose-1:2 1 6 0 3 1 1 1 1 1;
	mso-font-alt:\9ED1\4F53;
	mso-font-charset:134;
	mso-generic-font-family:modern;
	mso-font-format:other;
	mso-font-pitch:fixed;
	mso-font-signature:1 135135232 16 0 262144 0;}
@font-face
	{font-family:MingLiU;
	panose-1:2 1 6 9 0 1 1 1 1 1;
	mso-font-alt:\7D30\660E\9AD4;
	mso-font-charset:136;
	mso-generic-font-family:modern;
	mso-font-format:other;
	mso-font-pitch:fixed;
	mso-font-signature:1 134742016 16 0 1048576 0;}
@font-face
	{font-family:Mincho;
	panose-1:2 2 6 9 4 3 5 8 3 5;
	mso-font-alt:\660E\671D;
	mso-font-charset:128;
	mso-generic-font-family:roman;
	mso-font-format:other;
	mso-font-pitch:fixed;
	mso-font-signature:1 134676480 16 0 131072 0;}
@font-face
	{font-family:Gulim;
	panose-1:2 11 6 0 0 1 1 1 1 1;
	mso-font-alt:\AD74\B9BC;
	mso-font-charset:129;
	mso-generic-font-family:roman;
	mso-font-format:other;
	mso-font-pitch:fixed;
	mso-font-signature:1 151388160 16 0 524288 0;}
@font-face
	{font-family:Century;
	panose-1:2 4 6 3 5 7 5 2 3 3;
	mso-font-charset:0;
	mso-generic-font-family:roman;
	mso-font-format:other;
	mso-font-pitch:variable;
	mso-font-signature:3 0 0 0 1 0;}
@font-face
	{font-family:"Angsana New";
	panose-1:2 2 6 3 5 4 5 2 3 4;
	mso-font-charset:222;
	mso-generic-font-family:roman;
	mso-font-format:other;
	mso-font-pitch:variable;
	mso-font-signature:16777217 0 0 0 65536 0;}
@font-face
	{font-family:"Cordia New";
	panose-1:2 11 3 4 2 2 2 2 2 4;
	mso-font-charset:222;
	mso-generic-font-family:roman;
	mso-font-format:other;
	mso-font-pitch:variable;
	mso-font-signature:16777217 0 0 0 65536 0;}
@font-face
	{font-family:Mangal;
	panose-1:0 0 4 0 0 0 0 0 0 0;
	mso-font-charset:1;
	mso-generic-font-family:roman;
	mso-font-format:other;
	mso-font-pitch:variable;
	mso-font-signature:32768 0 0 0 0 0;}
@font-face
	{font-family:Latha;
	panose-1:0 0 4 0 0 0 0 0 0 0;
	mso-font-charset:1;
	mso-generic-font-family:roman;
	mso-font-format:other;
	mso-font-pitch:variable;
	mso-font-signature:1048576 0 0 0 0 0;}
@font-face
	{font-family:Sylfaen;
	panose-1:1 10 5 2 5 3 6 3 3 3;
	mso-font-charset:0;
	mso-generic-font-family:roman;
	mso-font-format:other;
	mso-font-pitch:variable;
	mso-font-signature:16778883 0 512 0 13 0;}
@font-face
	{font-family:Vrinda;
	panose-1:0 0 4 0 0 0 0 0 0 0;
	mso-font-charset:1;
	mso-generic-font-family:roman;
	mso-font-format:other;
	mso-font-pitch:variable;
	mso-font-signature:0 0 0 0 0 0;}
@font-face
	{font-family:Raavi;
	panose-1:0 0 4 0 0 0 0 0 0 0;
	mso-font-charset:1;
	mso-generic-font-family:roman;
	mso-font-format:other;
	mso-font-pitch:variable;
	mso-font-signature:0 0 0 0 0 0;}
@font-face
	{font-family:Shruti;
	panose-1:0 0 4 0 0 0 0 0 0 0;
	mso-font-charset:1;
	mso-generic-font-family:roman;
	mso-font-format:other;
	mso-font-pitch:variable;
	mso-font-signature:0 0 0 0 0 0;}
@font-face
	{font-family:Sendnya;
	panose-1:0 0 4 0 0 0 0 0 0 0;
	mso-font-charset:1;
	mso-generic-font-family:roman;
	mso-font-format:other;
	mso-font-pitch:variable;
	mso-font-signature:0 0 0 0 0 0;}
@font-face
	{font-family:Gautami;
	panose-1:0 0 4 0 0 0 0 0 0 0;
	mso-font-charset:1;
	mso-generic-font-family:roman;
	mso-font-format:other;
	mso-font-pitch:variable;
	mso-font-signature:0 0 0 0 0 0;}
@font-face
	{font-family:Tunga;
	panose-1:0 0 4 0 0 0 0 0 0 0;
	mso-font-charset:1;
	mso-generic-font-family:roman;
	mso-font-format:other;
	mso-font-pitch:variable;
	mso-font-signature:0 0 0 0 0 0;}
@font-face
	{font-family:"Estrangella Edessa";
	panose-1:0 0 0 0 0 0 0 0 0 0;
	mso-font-charset:1;
	mso-generic-font-family:roman;
	mso-font-format:other;
	mso-font-pitch:variable;
	mso-font-signature:0 0 0 0 0 0;}
@font-face
	{font-family:"Arial Unicode MS";
	panose-1:0 0 0 0 0 0 0 0 0 0;
	mso-font-charset:0;
	mso-generic-font-family:roman;
	mso-font-format:other;
	mso-font-pitch:variable;
	mso-font-signature:3 0 0 0 1 0;}
@font-face
	{font-family:Tahoma;
	panose-1:2 11 6 4 3 5 4 4 2 4;
	mso-font-charset:204;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:553679495 -2147483648 8 0 66047 0;}
@font-face
	{font-family:Verdana;
	panose-1:2 11 6 4 3 5 4 4 2 4;
	mso-font-charset:204;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:536871559 0 0 0 415 0;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
h1
	{mso-margin-top-alt:auto;
	margin-right:0cm;
	mso-margin-bottom-alt:auto;
	margin-left:0cm;
	text-align:center;
	mso-pagination:widow-orphan;
	mso-outline-level:1;
	font-size:12.0pt;
	font-family:Verdana;
	color:black;
	font-weight:bold;}
h2
	{mso-margin-top-alt:auto;
	margin-right:0cm;
	mso-margin-bottom-alt:auto;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	mso-outline-level:2;
	font-size:12.0pt;
	font-family:Verdana;
	color:black;
	font-weight:bold;}
h3
	{mso-style-next:Обычный;
	margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:3;
	font-size:13.0pt;
	font-family:Arial;
	font-weight:bold;}
a:link, span.MsoHyperlink
	{color:blue;
	text-decoration:underline;
	text-underline:single;}
a:visited, span.MsoHyperlinkFollowed
	{color:blue;
	text-decoration:underline;
	text-underline:single;}
p
	{mso-margin-top-alt:auto;
	margin-right:0cm;
	mso-margin-bottom-alt:auto;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
pre
	{margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt;
	font-size:10.0pt;
	font-family:"Courier New";
	mso-fareast-font-family:"Times New Roman";}
p.text, li.text, div.text
	{mso-style-name:text;
	mso-margin-top-alt:auto;
	margin-right:0cm;
	mso-margin-bottom-alt:auto;
	margin-left:0cm;
	text-align:justify;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:Verdana;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	color:black;}
span.black-small1
	{mso-style-name:black-small1;
	mso-ansi-font-size:8.0pt;
	mso-bidi-font-size:8.0pt;
	font-family:Verdana;
	mso-ascii-font-family:Verdana;
	mso-hansi-font-family:Verdana;
	color:black;}
p.issue, li.issue, div.issue
	{mso-style-name:issue;
	mso-margin-top-alt:auto;
	margin-right:0cm;
	mso-margin-bottom-alt:auto;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	background:#6699CC;
	border:none;
	mso-border-bottom-alt:solid #F3F3F3 .75pt;
	padding:0cm;
	mso-padding-alt:0cm 0cm 2.0pt 0cm;
	font-size:8.0pt;
	font-family:Tahoma;
	mso-fareast-font-family:"Times New Roman";
	color:white;}
p.caption, li.caption, div.caption
	{mso-style-name:caption;
	mso-margin-top-alt:auto;
	margin-right:0cm;
	mso-margin-bottom-alt:auto;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	background:#003366;
	border:none;
	mso-border-bottom-alt:solid #F3F3F3 .75pt;
	padding:0cm;
	mso-padding-alt:0cm 0cm 2.0pt 0cm;
	font-size:8.0pt;
	font-family:Tahoma;
	mso-fareast-font-family:"Times New Roman";
	color:white;}
p.black, li.black, div.black
	{mso-style-name:black;
	mso-margin-top-alt:auto;
	margin-right:0cm;
	mso-margin-bottom-alt:auto;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:Verdana;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	color:black;}
p.black-small, li.black-small, div.black-small
	{mso-style-name:black-small;
	mso-margin-top-alt:auto;
	margin-right:0cm;
	mso-margin-bottom-alt:auto;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	font-size:8.0pt;
	font-family:Verdana;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	color:black;}
p.code, li.code, div.code
	{mso-style-name:code;
	mso-margin-top-alt:auto;
	margin-right:0cm;
	mso-margin-bottom-alt:auto;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	background:#FAFAFA;
	border:none;
	mso-border-alt:solid #D1D7DC .75pt;
	padding:0cm;
	mso-padding-alt:0cm 0cm 0cm 0cm;
	font-size:8.5pt;
	font-family:Courier;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Courier New";
	color:black;}
p.warning, li.warning, div.warning
	{mso-style-name:warning;
	mso-margin-top-alt:auto;
	margin-right:0cm;
	mso-margin-bottom-alt:auto;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	background:lemonchiffon;
	font-size:10.0pt;
	font-family:"Courier New";
	mso-fareast-font-family:"Times New Roman";
	color:black;}
p.normal, li.normal, div.normal
	{mso-style-name:normal;
	mso-margin-top-alt:auto;
	margin-right:0cm;
	mso-margin-bottom-alt:auto;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	border:none;
	mso-border-alt:solid black .75pt;
	padding:0cm;
	mso-padding-alt:0cm 4.0pt 0cm 4.0pt;
	font-size:8.0pt;
	font-family:Verdana;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	color:black;}
p.gen, li.gen, div.gen
	{mso-style-name:gen;
	mso-margin-top-alt:auto;
	margin-right:0cm;
	mso-margin-bottom-alt:auto;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	font-size:9.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	color:black;}
p.genmed, li.genmed, div.genmed
	{mso-style-name:genmed;
	mso-margin-top-alt:auto;
	margin-right:0cm;
	mso-margin-bottom-alt:auto;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	font-size:8.5pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	color:black;}
p.gensmall, li.gensmall, div.gensmall
	{mso-style-name:gensmall;
	mso-margin-top-alt:auto;
	margin-right:0cm;
	mso-margin-bottom-alt:auto;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	font-size:7.5pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	color:black;}
p.ccode, li.ccode, div.ccode
	{mso-style-name:ccode;
	mso-margin-top-alt:auto;
	margin-right:0cm;
	mso-margin-bottom-alt:auto;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.prototype, li.prototype, div.prototype
	{mso-style-name:prototype;
	mso-margin-top-alt:auto;
	margin-right:0cm;
	mso-margin-bottom-alt:auto;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
ins
	{mso-style-type:export-only;
	text-decoration:none;}
span.msoIns
	{mso-style-type:export-only;
	mso-style-name:"";
	text-decoration:underline;
	text-underline:single;}
span.msoDel
	{mso-style-type:export-only;
	mso-style-name:"";
	text-decoration:line-through;
	color:red;}
@page Section1
	{size:595.3pt 841.9pt;
	margin:2.0cm 42.5pt 2.0cm 3.0cm;
	mso-header-margin:35.4pt;
	mso-footer-margin:35.4pt;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
 /* List Definitions */
 @list l0
	{mso-list-id:2054168;
	mso-list-template-ids:-1020751180;}
@list l0:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l1
	{mso-list-id:2898892;
	mso-list-template-ids:-1814145428;}
@list l1:level1
	{mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l2
	{mso-list-id:29653535;
	mso-list-template-ids:-1243705088;}
@list l2:level1
	{mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l3
	{mso-list-id:34089518;
	mso-list-template-ids:-402508084;}
@list l3:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l4
	{mso-list-id:37125673;
	mso-list-template-ids:-1699990744;}
@list l4:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l5
	{mso-list-id:66849799;
	mso-list-template-ids:478979880;}
@list l5:level1
	{mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l6
	{mso-list-id:79449010;
	mso-list-template-ids:1757571138;}
@list l6:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l7
	{mso-list-id:158541174;
	mso-list-template-ids:-1013290830;}
@list l7:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l8
	{mso-list-id:234946866;
	mso-list-template-ids:-35193310;}
@list l8:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l9
	{mso-list-id:349113641;
	mso-list-template-ids:953846086;}
@list l9:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l10
	{mso-list-id:386346224;
	mso-list-template-ids:1800046124;}
@list l10:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l11
	{mso-list-id:422723331;
	mso-list-template-ids:1046885870;}
@list l11:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l12
	{mso-list-id:434596884;
	mso-list-template-ids:326503288;}
@list l12:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l13
	{mso-list-id:477764545;
	mso-list-template-ids:109486912;}
@list l13:level1
	{mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l14
	{mso-list-id:499126496;
	mso-list-template-ids:846470456;}
@list l14:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l15
	{mso-list-id:529490092;
	mso-list-template-ids:-589919682;}
@list l15:level1
	{mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l16
	{mso-list-id:570654290;
	mso-list-template-ids:-879751066;}
@list l16:level1
	{mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l16:level2
	{mso-level-number-format:alpha-lower;
	mso-level-tab-stop:72.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l17
	{mso-list-id:572661016;
	mso-list-template-ids:-1772602458;}
@list l17:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l18
	{mso-list-id:590821267;
	mso-list-template-ids:-1994389468;}
@list l18:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l19
	{mso-list-id:592982760;
	mso-list-template-ids:1340211964;}
@list l19:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l20
	{mso-list-id:619413125;
	mso-list-template-ids:419169264;}
@list l20:level1
	{mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l21
	{mso-list-id:675227340;
	mso-list-template-ids:1513362354;}
@list l21:level1
	{mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l22
	{mso-list-id:678695403;
	mso-list-template-ids:1333418050;}
@list l22:level1
	{mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l23
	{mso-list-id:704865646;
	mso-list-template-ids:-123147496;}
@list l23:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l24
	{mso-list-id:739668134;
	mso-list-template-ids:-1531169046;}
@list l24:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l25
	{mso-list-id:822115481;
	mso-list-template-ids:-1217496256;}
@list l25:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l26
	{mso-list-id:880947051;
	mso-list-template-ids:-1254331118;}
@list l26:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l27
	{mso-list-id:897253607;
	mso-list-template-ids:-1961700198;}
@list l27:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l28
	{mso-list-id:1003705928;
	mso-list-template-ids:-1365968816;}
@list l28:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l29
	{mso-list-id:1012731031;
	mso-list-template-ids:1985658666;}
@list l29:level1
	{mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l30
	{mso-list-id:1028524579;
	mso-list-template-ids:608331966;}
@list l30:level1
	{mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l31
	{mso-list-id:1087773683;
	mso-list-template-ids:-1040035980;}
@list l31:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l32
	{mso-list-id:1129474036;
	mso-list-template-ids:-1589214156;}
@list l32:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l33
	{mso-list-id:1146314721;
	mso-list-template-ids:297042446;}
@list l33:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l34
	{mso-list-id:1239830562;
	mso-list-template-ids:-212563454;}
@list l34:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l35
	{mso-list-id:1273825523;
	mso-list-template-ids:291173638;}
@list l35:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l36
	{mso-list-id:1280601100;
	mso-list-template-ids:-1191045630;}
@list l36:level1
	{mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l37
	{mso-list-id:1289047562;
	mso-list-template-ids:1231736412;}
@list l37:level1
	{mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l38
	{mso-list-id:1352217269;
	mso-list-template-ids:-106262696;}
@list l38:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l39
	{mso-list-id:1392925020;
	mso-list-template-ids:-622144590;}
@list l39:level1
	{mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l40
	{mso-list-id:1403940893;
	mso-list-template-ids:-1000188056;}
@list l40:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l41
	{mso-list-id:1413048429;
	mso-list-template-ids:-1000559008;}
@list l41:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l42
	{mso-list-id:1549880789;
	mso-list-template-ids:883994964;}
@list l42:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l43
	{mso-list-id:1567296634;
	mso-list-template-ids:-1126532596;}
@list l43:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l44
	{mso-list-id:1603686705;
	mso-list-template-ids:1739850786;}
@list l44:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l45
	{mso-list-id:1680111111;
	mso-list-template-ids:2060895022;}
@list l45:level1
	{mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l46
	{mso-list-id:1703899790;
	mso-list-template-ids:551740002;}
@list l46:level1
	{mso-level-start-at:2;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l47
	{mso-list-id:1710834678;
	mso-list-template-ids:-760981422;}
@list l47:level1
	{mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l48
	{mso-list-id:1717847336;
	mso-list-template-ids:-1193515086;}
@list l48:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l49
	{mso-list-id:1777367056;
	mso-list-template-ids:-1305692202;}
@list l49:level1
	{mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l50
	{mso-list-id:1777558981;
	mso-list-template-ids:114332092;}
@list l50:level1
	{mso-level-number-format:alpha-lower;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l51
	{mso-list-id:1784112006;
	mso-list-template-ids:-865273840;}
@list l51:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l52
	{mso-list-id:1798067532;
	mso-list-template-ids:660125254;}
@list l52:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l53
	{mso-list-id:1811746158;
	mso-list-template-ids:-1285794778;}
@list l53:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l54
	{mso-list-id:1811823189;
	mso-list-template-ids:553044032;}
@list l54:level1
	{mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l54:level2
	{mso-level-number-format:alpha-lower;
	mso-level-tab-stop:72.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l55
	{mso-list-id:1829132446;
	mso-list-template-ids:-579284060;}
@list l55:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l56
	{mso-list-id:1866556212;
	mso-list-template-ids:837743770;}
@list l56:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l57
	{mso-list-id:1955285366;
	mso-list-template-ids:167003338;}
@list l57:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l58
	{mso-list-id:1968776841;
	mso-list-template-ids:314706870;}
@list l58:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l59
	{mso-list-id:1981498951;
	mso-list-template-ids:-1834594936;}
@list l59:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l60
	{mso-list-id:1998993421;
	mso-list-template-ids:476057338;}
@list l60:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l61
	{mso-list-id:2016682805;
	mso-list-template-ids:-468567424;}
@list l61:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l62
	{mso-list-id:2039768170;
	mso-list-template-ids:-202238424;}
@list l62:level1
	{mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l63
	{mso-list-id:2041391005;
	mso-list-template-ids:-148491328;}
@list l63:level1
	{mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l64
	{mso-list-id:2059282465;
	mso-list-template-ids:1681948474;}
@list l64:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l65
	{mso-list-id:2059358332;
	mso-list-template-ids:-1112116436;}
@list l65:level1
	{mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l66
	{mso-list-id:2065987808;
	mso-list-template-ids:-28782002;}
@list l66:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l67
	{mso-list-id:2077237874;
	mso-list-template-ids:1016210478;}
@list l67:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l68
	{mso-list-id:2107728630;
	mso-list-template-ids:-1709934210;}
@list l68:level1
	{mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
ol
	{margin-bottom:0cm;}
ul
	{margin-bottom:0cm;}
-->
</style>
<!--[if gte mso 10]>
<style>
 /* Style Definitions */
 table.MsoNormalTable
	{mso-style-name:"Обычная таблица";
	mso-tstyle-rowband-size:0;
	mso-tstyle-colband-size:0;
	mso-style-noshow:yes;
	mso-style-parent:"";
	mso-padding-alt:0cm 5.4pt 0cm 5.4pt;
	mso-para-margin:0cm;
	mso-para-margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Times New Roman";}
</style>
<![endif]-->
</head>

<body lang=RU link=blue vlink=blue style='tab-interval:35.4pt'>

<div class=Section1>

<p class=MsoNormal><span lang=EN-US style='font-size:26.0pt;color:maroon;
mso-ansi-language:EN-US'>OpenGL Red Book (</span><span style='font-size:26.0pt;
color:maroon'>русская версия</span><span lang=EN-US style='font-size:26.0pt;
color:maroon;mso-ansi-language:EN-US'>)</span><span style='font-size:26.0pt;
color:maroon'><o:p></o:p></span></p>

<h3><span style='font-size:12.0pt;font-family:Verdana;color:black'>Содержание<o:p></o:p></span></h3>

<p class=MsoNormal style='text-indent:27.0pt'><span style='font-size:10.0pt;
mso-bidi-font-size:12.0pt;font-family:Verdana;color:black'><a href="#Глава1">Глава
1. Введение в <span lang=EN-US style='mso-ansi-language:EN-US'>OpenGL</span></a><o:p></o:p></span></p>

<p class=MsoNormal style='text-indent:27.0pt'><span style='font-size:10.0pt;
mso-bidi-font-size:12.0pt;font-family:Verdana;color:black'><a href="#Глава2">Глава
2. Управление состоянием и рисование геометрических объектов</a><o:p></o:p></span></p>

<p class=MsoNormal style='text-indent:27.0pt'><span style='font-size:10.0pt;
mso-bidi-font-size:12.0pt;font-family:Verdana;color:black'><a href="#Глава3">Глава
3. Вид</a><o:p></o:p></span></p>

<p class=MsoNormal style='text-indent:27.0pt'><span style='font-size:10.0pt;
mso-bidi-font-size:12.0pt;font-family:Verdana;color:black'><a href="#Глава4">Глава
4. Цвет</a><o:p></o:p></span></p>

<p class=MsoNormal style='text-indent:27.0pt'><span style='font-size:10.0pt;
mso-bidi-font-size:12.0pt;font-family:Verdana;color:black'><a href="#Глава5">Глава
5. Освещение</a><o:p></o:p></span></p>

<p class=MsoNormal style='text-indent:27.0pt'><span style='font-size:10.0pt;
mso-bidi-font-size:12.0pt;font-family:Verdana;color:black'><a href="#Глава6">Глава
6. Цветовое наложение, сглаживание, туман и смещение полигонов</a><o:p></o:p></span></p>

<p class=MsoNormal style='text-indent:27.0pt'><span style='font-size:10.0pt;
mso-bidi-font-size:12.0pt;font-family:Verdana;color:black'><a href="#Глава7">Глава
7. Списки отображения</a><o:p></o:p></span></p>

<p class=MsoNormal style='text-indent:27.0pt'><span style='font-size:10.0pt;
mso-bidi-font-size:12.0pt;font-family:Verdana;color:black'><a href="#Глава8">Глава
8. Отображение пикселей, битовых карт, шрифтов и изображений</a><o:p></o:p></span></p>

<p class=MsoNormal style='text-indent:27.0pt'><span style='font-size:10.0pt;
mso-bidi-font-size:12.0pt;font-family:Verdana;color:black'><a href="#Глава9">Глава
9. Текстурирование</a><o:p></o:p></span></p>

<p class=MsoNormal style='text-indent:27.0pt'><span style='font-size:10.0pt;
mso-bidi-font-size:12.0pt;font-family:Verdana;color:black'><a href="#Глава10">Глава
10. Буфер кадра</a><o:p></o:p></span></p>

<p class=MsoNormal style='text-indent:27.0pt'><span style='font-size:10.0pt;
mso-bidi-font-size:12.0pt;font-family:Verdana;color:black'><a href="#Глава11">Глава
11. Тесселяция и квадрические поверхности</a><o:p></o:p></span></p>

<p class=MsoNormal style='text-indent:27.0pt'><span style='font-size:10.0pt;
mso-bidi-font-size:12.0pt;font-family:Verdana;color:black'><a href="#Глава12">Глава
12. Вычислители и NURBS</a><o:p></o:p></span></p>

<p class=MsoNormal style='text-indent:27.0pt'><span style='font-size:10.0pt;
mso-bidi-font-size:12.0pt;font-family:Verdana;color:black'><a href="#Глава13">Глава
13. Режим выбора и обратный режим</a><o:p></o:p></span></p>

<p class=MsoNormal style='text-indent:27.0pt'><span style='font-size:10.0pt;
mso-bidi-font-size:12.0pt;font-family:Verdana;color:black'><a href="#Глава14">Глава
14. Трюки и советы</a><o:p></o:p></span></p>

<p class=MsoNormal style='text-indent:27.0pt'><span style='font-size:10.0pt;
mso-bidi-font-size:12.0pt;font-family:Verdana;color:black'><a
href="#ПриложениеA">Приложение A. Переменные состояния</a><o:p></o:p></span></p>

<p class=MsoNormal style='text-indent:27.0pt'><span style='font-size:10.0pt;
mso-bidi-font-size:12.0pt;font-family:Verdana;color:black'><a
href="#ПриложениеB">Приложение <span lang=EN-US style='mso-ansi-language:EN-US'>B</span>.
Вычисление векторов нормалей</a><o:p></o:p></span></p>

<p class=MsoNormal style='text-indent:27.0pt'><span lang=EN-US
style='font-size:10.0pt;mso-bidi-font-size:12.0pt;font-family:Verdana;
color:black;mso-ansi-language:EN-US'><a href="#ПриложениеC"><span lang=RU
style='mso-ansi-language:RU'>Приложение </span>C<span lang=RU style='mso-ansi-language:
RU'>. Основы </span>GLUT</a></span><span style='font-size:10.0pt;mso-bidi-font-size:
12.0pt;font-family:Verdana;color:black'><o:p></o:p></span></p>

<p class=MsoNormal style='text-indent:27.0pt'><span lang=EN-US
style='font-size:10.0pt;mso-bidi-font-size:12.0pt;font-family:Verdana;
color:black;mso-ansi-language:EN-US'><a href="#ПриложениеD"><span lang=RU
style='mso-ansi-language:RU'>Приложение </span>D<span lang=RU style='mso-ansi-language:
RU'>. Порядок операций</span></a></span><span style='font-size:10.0pt;
mso-bidi-font-size:12.0pt;font-family:Verdana;color:black'><o:p></o:p></span></p>

<p class=MsoNormal style='text-indent:27.0pt'><span style='font-size:10.0pt;
mso-bidi-font-size:12.0pt;font-family:Verdana;color:black'><a
href="#ПриложениеE">Приложение E. Однородные координаты и матрицы преобразований</a><o:p></o:p></span></p>

<p class=MsoNormal style='text-indent:27.0pt'><span style='font-size:10.0pt;
mso-bidi-font-size:12.0pt;font-family:Verdana;color:black'><a
href="#ПриложениеF">Приложение F. Советы</a><o:p></o:p></span></p>

<p class=MsoNormal style='text-indent:27.0pt'><span lang=EN-US
style='font-size:10.0pt;mso-bidi-font-size:12.0pt;font-family:Verdana;
color:black;mso-ansi-language:EN-US'><a href="#ПриложениеG"><span lang=RU
style='mso-ansi-language:RU'>Приложение </span>G<span lang=RU style='mso-ansi-language:
RU'>. Инвариантность </span>OpenGL</a></span><span style='font-size:10.0pt;
mso-bidi-font-size:12.0pt;font-family:Verdana;color:black'><o:p></o:p></span></p>

<p class=MsoNormal style='text-indent:27.0pt'><span style='font-size:10.0pt;
mso-bidi-font-size:12.0pt;font-family:Verdana;color:black'><a
href="#ПриложениеH">Приложение H. OpenGL и оконные системы</a><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Verdana'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><a name=Глава1><span style='display:none;mso-hide:all'><o:p>&nbsp;</o:p></span></a></p>

<h1 align=left style='text-align:left'><span style='mso-bookmark:Глава1'>Глава
1. Введение в OpenGL</span></h1>

<span style='mso-bookmark:Глава1'></span>

<h2>1.1 Что такое OpenGL?</h2>

<p class=text align=left style='text-align:left'>OpenGL – это программный
интерфейс к графической аппаратуре. Этот интерфейс состоит приблизительно из
250 отдельных команд (около 200 команд в самой OpenGL и еще 50 в библиотеке
утилит), которые используются для указания объектов и операций, которые необходимо
выполнить, чтобы получить интерактивное приложение, работающее с трехмерной
графикой. </p>

<p class=text align=left style='text-align:left'>Библиотека OpenGL разработана
как обобщенный, независимый интерфейс, который может быть реализован для
различного аппаратного обеспечения. По этой причине сама OpenGL не включает
функций для создания окон или для захвата пользовательского ввода; для этих
операций вы должны использовать средства той операционной системы, в которой вы
работаете. По тем же причинам в OpenGL нет высокоуровневых функций для описания
моделей трехмерных объектов. Такие команды позволили бы вам описывать
относительно сложные фигуры, такие как автомобили, части человеческого тела или
молекулы. При использовании библиотеки OpenGL вы должны строить необходимые
модели при помощи небольшого набора геометрических примитивов – точек, линий и
многоугольников (полигонов). </p>

<p class=text align=left style='text-align:left'>Тем не менее, библиотека,
предоставляющая описанные возможности может быть построена поверх OpenGL.
Библиотека утилит OpenGL (OpenGL Utility Library -- GLU) предоставляет множество
средств для моделирования, например, квадрические поверхности, кривые и
поверхности типа NURBS. GLU – стандартная часть любой реализации OpenGL.
Существуют также и более высокоуровневые библиотеки, например, Fahrenheit Scene
Graph (FSG), которые построены с использованием OpenGL и распространяются
отдельно для многих ее реализаций. </p>

<p class=text align=left style='text-align:left'>В следующем списке коротко
описаны основные графические операции, которые выполняет OpenGL для вывода
изображения на экран. </p>

<p class=text align=left style='text-align:left'>1. Конструирует фигуры из
геометрических примитивов, создавая математическое описание объектов
(примитивами в OpenGL считаются точки, линии, полигоны, битовые карты и
изображения).<br>
2. Позиционирует объекты в трехмерном пространстве и выбирает точку наблюдения
для осмотра полученной композиции.<br>
3. Вычисляет цвета для всех объектов. Цвета могут быть определены приложением,
получены из расчета условий освещенности, вычислены при помощи текстур,
наложенных на объекты или из любой комбинации этих факторов.<br>
4. Преобразует математическое описание объектов и ассоциированной с ними
цветовой информации в пиксели на экране. Этот процесс называется растеризацией
(или растровой разверткой). </p>

<p class=text align=left style='text-align:left'>В течение всех этих этапов
OpenGL может производить и другие операции, например, удаление частей объектов,
скрытых другими объектами. В дополнение к этому, после того, как сцена
растеризована, но до того, как она выводится на экран, вы можете производить
некоторые операции с пиксельными данными, если это необходимо. </p>

<p class=text align=left style='text-align:left'>В некоторых реализациях
(например, в реализации для системы X Window), OpenGL разработана таким
образом, чтобы работать даже в том случае, если компьютер, которые отображает
графику не то же самый, на котором запущена ваша графическая программа. Это
может происходить в случае, если работа происходит в сетевом окружении,
состоящем из множества компьютеров, соединенных между собой. В данной ситуации
компьютер, на котором функционирует программа, и вызываются команды OpenGL,
является клиентом, в то время как компьютер, осуществляющий отображение,
является сервером. Формат пересылки команд OpenGL от клиента серверу (или
протокол) всегда один и тот же, так что программа может работать по сети даже в
том случае, если клиент и сервер – совершенно различные компьютеры. В несетевом
случае один и тот же компьютер является и клиентом, и сервером. </p>

<h2>1.2 Немного OpenGL кода</h2>

<p class=text align=left style='text-align:left'>Поскольку при помощи
библиотеки OpenGL можно делать так много вещей, программа, использующая ее,
может быть весьма сложна. Однако базовая структура полезной программы может
быть достаточно простой: ее задачами являются инициализация нескольких
переменных или переключателей, контролирующих, как OpenGL осуществляет
визуализацию изображения и, далее, указание объектов для отображения. </p>

<p class=text align=left style='text-align:left'>До того, как будет приведен
небольшой пример, определимся с некоторыми терминами. Визуализация (rendering)
– это процесс, с помощью которого компьютер создает изображения из моделей. Эти
модели или объекты строятся из геометрических примитивов – точек, линий и
полигонов, которые в свою очередь, определяются своими вершинами (vertices). </p>

<p class=text align=left style='text-align:left'>Результирующее изображение
состоит из пикселей отображенных на экране. Пиксель – это самый маленький
видимый элемент, который монитор может поместить на свой экран. </p>

<p class=text align=left style='text-align:left'>Информация о пикселях
(например, какого цвета они должны быть) организована в памяти в виде битовых
поверхностей (bitplanes). Битовая плоскость – это область памяти, содержащая
один бит информации на каждый пиксель экрана. Этот бит может определять,
например, насколько красным должен быть конкретный пиксель. Сами битовые
плоскости организованы в буфер кадра, который содержит всю информацию
необходимую монитору, чтобы контролировать цвет и интенсивность всех пикселей
на экране. </p>

<p class=text align=left style='text-align:left'>Теперь посмотрим, на что может
быть похожа OpenGL – программа. Пример 1-1 отображает белый квадрат на черном
фоне, показанный на рисунке 1. </p>

<p class=text align=left style='text-align:left'>Рисунок 1.1. Белый квадрат на
черном фоне </p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Verdana;
color:black'><!--[if gte vml 1]><v:shapetype id="_x0000_t75" coordsize="21600,21600"
 o:spt="75" o:preferrelative="t" path="m@4@5l@4@11@9@11@9@5xe" filled="f"
 stroked="f">
 <v:stroke joinstyle="miter"/>
 <v:formulas>
  <v:f eqn="if lineDrawn pixelLineWidth 0"/>
  <v:f eqn="sum @0 1 0"/>
  <v:f eqn="sum 0 0 @1"/>
  <v:f eqn="prod @2 1 2"/>
  <v:f eqn="prod @3 21600 pixelWidth"/>
  <v:f eqn="prod @3 21600 pixelHeight"/>
  <v:f eqn="sum @0 0 1"/>
  <v:f eqn="prod @6 1 2"/>
  <v:f eqn="prod @7 21600 pixelWidth"/>
  <v:f eqn="sum @8 21600 0"/>
  <v:f eqn="prod @7 21600 pixelHeight"/>
  <v:f eqn="sum @10 21600 0"/>
 </v:formulas>
 <v:path o:extrusionok="f" gradientshapeok="t" o:connecttype="rect"/>
 <o:lock v:ext="edit" aspectratio="t"/>
</v:shapetype><v:shape id="_x0000_i1025" type="#_x0000_t75" alt="" style='width:180.75pt;
 height:183pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image001.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов.mht!http://www.progz.ru/images/opengl/chapter1/1-1.gif"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=241 height=244
src="OpenGL%20Red%20Book.files/image001.gif" v:shapes="_x0000_i1025"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Пример 1-1. Фрагмент OpenGL –
кода </p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>#include
  &lt;все_что_необходимо.h&gt; <o:p></o:p></span></p>
  <p class=text align=left style='text-align:left'><span style='mso-bidi-font-family:
  "Courier New"'>main()<br>
  {<br>
  ИнициализироватьОкно(); <o:p></o:p></span></p>
  <p class=text align=left style='text-align:left'><span style='mso-bidi-font-family:
  "Courier New"'>glClearColor(0.0,0.0,0.0);<br>
  glClear(GL_COLOR_BUFFER_BIT);<br>
  glColor3f(1.0,1.0,1.0);<br>
  glOrtho(0.0,1.0,0.0,1.0,-1.0,1.0);<br>
  glBegin(GL_POLYGON);<br>
  glVertex3f(0.25,0.25,0.0);<br>
  glVertex3f(0.75,0.25,0.0);<br>
  glVertex3f(0.75,0.75,0.0);<br>
  glVertex3f(0.25,0.75,0.0);<br>
  glEnd();<br>
  glFlush(); <o:p></o:p></span></p>
  <p class=text align=left style='text-align:left'><span style='mso-bidi-font-family:
  "Courier New"'>ОбновитьОкно();<br>
  } <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Первая строка функции <strong><span
style='font-family:Verdana'>main()</span></strong> инициализирует окно на
экране. <strong><span style='font-family:Verdana'>ИнициализироватьОкно()</span></strong>
обозначает то место в тексте, куда надо поместить функции создания окна, зависимые
от оконной системы, в которой вы работаете и не являющиеся командами OpenGL.
Две следующих строки являются командами OpenGL, окрашивающими окно в черный
цвет: <strong><span style='font-family:Verdana'>glClearColor()</span></strong>
задает цвет, в который окно будет окрашиваться при его очистке, <strong><span
style='font-family:Verdana'>glClear()</span></strong> как раз и очищает окно.
После того, как «очищающий цвет» задан, окно всегда будет окрашиваться именно в
него при вызовах <strong><span style='font-family:Verdana'>glClear()</span></strong>.
Этот цвет может быть изменен повторным вызовом <strong><span style='font-family:
Verdana'>glClearColor()</span></strong>. Похожим же образом <strong><span
style='font-family:Verdana'>glColor3f()</span></strong> задает цвет, который
будет использоваться для рисования объектов – в данном случае белый. Начиная с
этого момента, все объекты будут рисоваться белыми до тех пор, пока не
последует замена этого цвета на другой при помощи одной из команд OpenGL. </p>

<p class=text align=left style='text-align:left'>Следующая OpenGL – команда,
использованная в программе, <strong><span style='font-family:Verdana'>glOrtho()</span></strong>,
определяет координатную систему, на которую полагается OpenGL при отрисовке
финального изображения и проецировании изображения на экран. Вызовы,
заключенные в команды <strong><span style='font-family:Verdana'>glBegin()</span></strong>
и <strong><span style='font-family:Verdana'>glEnd()</span></strong>, определяют
объект, который следует нарисовать – в данном случае полигон с 4 вершинами.
«Углы» полигона определяются командами <strong><span style='font-family:Verdana'>glVertex3f()</span></strong>.
Как можно догадаться по значениям аргументов, которые являются координатами (x,
y, z), полигон представляет собой квадрат в плоскости z=0. </p>

<p class=text align=left style='text-align:left'>Наконец, вызов <strong><span
style='font-family:Verdana'>glFlush()</span></strong> позволяет быть уверенным
в том, что команды OpenGL действительно выполнились, а не были сохранены в
буфере в ожидании дальнейших команд. <strong><span style='font-family:Verdana'>ОбновитьОкно()</span></strong>
– это опять-таки метка для функций, зависящих от оконной системы. </p>

<p class=text align=left style='text-align:left'>На самом деле этот фрагмент кода
не слишком хорошо структурирован. Могут возникнуть вопросы: «Что если мы
попытаемся изменить размер окна или переместить его?» «Необходимо ли
устанавливать координатную систему каждый раз при отрисовке квадрата?» Позже <strong><span
style='font-family:Verdana'>ИнициализироватьОкно()</span></strong> и <strong><span
style='font-family:Verdana'>ОбновитьОкно()</span></strong> будут заменены на
реально работающие вызовы, которые, однако, требуют реструктуризации кода, что
сделает его более эффективным. </p>

<h2>1.3 Синтаксис команд OpenGL</h2>

<p class=text align=left style='text-align:left'>Как можно было заметить из
простой программы, приведенной в предыдущем разделе, в названии команд OpenGL
используется префикс <strong><span style='font-family:Verdana'>gl</span></strong>
и заглавные буквы для отделения слов, составляющих название команды (вспомним,
например, <strong><span style='font-family:Verdana'>glClearColor()</span></strong>).
Подобным же образом OpenGL определяет константы, начинающиеся с GL_ со всеми
заглавными буквами и символом подчеркивания для отделения слов (например,
GL_COLOR_BUFFER_BIT). </p>

<p class=text align=left style='text-align:left'>Кроме того, можно было
обратить внимание на казалось бы лишние буквы и цифры в названии некоторых
команд (например, <st1:metricconverter ProductID="3f"><strong><span
 style='font-family:Verdana'>3f</span></strong></st1:metricconverter> в <strong><span
style='font-family:Verdana'>glColor3f()</span></strong> и <strong><span
style='font-family:Verdana'>glVertex3f()</span></strong>). Действительно, слова
<strong><span style='font-family:Verdana'>Color</span></strong> (цвет) в
названии <strong><span style='font-family:Verdana'>glColor3f()</span></strong>
достаточно, чтобы определить команду меняющую текущий цвет. Однако в библиотеке
определено несколько версий такой команды, принимающих данные в различных
форматах. Более конкретно, <strong><span style='font-family:Verdana'>3</span></strong>
в названии команды <strong><span style='font-family:Verdana'>glColor3f()</span></strong>
означает, что она получает три аргумента, существует и другая версия,
получающая четыре аргумента. Буква <strong><span style='font-family:Verdana'>f</span></strong>
означает, что аргументы имеют формат числа с плавающей точкой. Подобное
соглашение об именовании команд позволяет программисту использовать желаемый,
более удобный для него формат аргументов. </p>

<p class=text align=left style='text-align:left'>Некоторые команды воспринимают
до восьми различных типов данных. Буквы, используемые в качестве суффиксов для
указания конкретного типа данных в реализации OpenGL для ISO - стандарта языка
C приведены в таблице 1-1. Отдельные реализации OpenGL (например, для языка C++
или Ada) могут не следовать описанной схеме точно. </p>

<p class=text align=left style='text-align:left'>Таблица 1-1. Суффиксы команд и
соответствующие им типы аргументов </p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Суффиксы</span></strong><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Тип данных</span></strong><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Типично соответствующий тип языка С</span></strong><span
  style='font-size:8.0pt;font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Тип, определенный в OpenGL</span></strong><span
  style='font-size:8.0pt;font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>b<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>целое 8 бит<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>signed char<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLbyte<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>s<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>целое 16 бит<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>short<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLshort<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>i<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>целое 32 бита<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>int или long<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLint, GLsizei<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>f<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>число с плавающей точкой 32 бита<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>float<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLfloat, GLclampf<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:5'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>d<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>число с плавающей точкой 64 бита<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>double<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLdouble, GLclampd<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:6'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>ud<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>беззнаковое целое 8 бит<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>unsigned char<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLubyte, GLboolean<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:7'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>us<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>беззнаковое целое 16 бит<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>unsigned short<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLushort<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:8;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>ui<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>беззнаковое целое 32 бита<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>unsigned int </span><span
  style='font-size:8.0pt;font-family:Verdana;color:black'>или</span><span
  lang=EN-US style='font-size:8.0pt;font-family:Verdana;color:black;mso-ansi-language:
  EN-US'> unsigned long<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLuint, GLenum, GLbitfield<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Таким образом, следующие две
команды </p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>glVertex2i(1,3);<br>
  glVertex2f(1.0,3.0); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>эквивалентны за тем исключением,
что первая принимает координаты вершины в виде 32-разрядного целого, а вторая –
в виде числа с плавающей точкой одинарной точности. </p>

<div align=center>

<table class=MsoNormalTable border=0 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:lemonchiffon;mso-padding-left-alt:
 15.0pt;mso-padding-right-alt:15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:10.0pt;font-family:"Courier New";
  color:black'>Замечание: Производители реализаций OpenGL имеют право выбирать,
  какие типы данных языка C использовать, для представления типов OpenGL. Если
  в тексте программы использовать типы, определенные OpenGL, вместо явного
  указания типов языка C, можно избежать проблем при переносе приложения на
  другую реализацию OpenGL. <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Некоторые команды последней
буквой в своем имени могут иметь v, это означает, что команда принимает
указатель на вектор (или массив) величин, а не несколько отдельных аргументов.
Многие команды имеют и векторную, и не векторную версии, но среди тех, которые
не попадают в это число, одни работают только с индивидуальными аргументами, в
то время как другие в обязательном порядке требуют указатель на вектор величин
в качестве части или всех своих аргументов. Следующий фрагмент показывает
пример использования векторной и не векторной версии команды установки текущего
цвета. </p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>glColor3f(1.0,0.0,0.0);<br>
  GLfloat color_array[]={1.0,0.0,0.0};<br>
  glColor3fv(color_array); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Кроме всего прочего, OpenGL
определяет тип GLvoid, который чаще всего применяется в векторных версиях
команд.<br>
Далее в этом пособии будем мы ссылаться на команды по их базовому имени и
звездочке в конце (например, <strong><span style='font-family:Verdana'>glColor*()</span></strong>),
что означает, что приводимая информация относится ко всем версиям определенной
команды. Если информация специфична только для подмножества версий одной
команды, это будет отмечено при помощи добавления к вышеописанной записи части
суффикса (например, <strong><span style='font-family:Verdana'>glVertex*v()</span></strong>
означает все векторные версии команды установки вершины). </p>

<h2>1.4 OpenGL как машина состояния (state machine)</h2>

<p class=text align=left style='text-align:left'>OpenGL – это машина состояния.
Вы задаете различные переменные состояния, и они остаются в действии, сохраняя
свое состояние, до тех пор, пока вы же их не измените. Как вы уже видели,
текущий цвет – это переменная состояния. Вы можете установить цвет в красный,
синий, белый и так далее, и после этого все объекты будут рисоваться этим
цветом до тех пор, пока вы его не измените на что–либо другое. Текущий цвет –
это только одна из многих переменных состояния, имеющихся в OpenGL. Другие
управляют такими аспектами, как текущая видовая и проекционная трансформации,
шаблоны для линий и полигонов, режимы отображения полигонов, соглашения об
упаковке пикселей, позиции и характеристики источников света, параметры
материалов для объектов и многое другое. Многие переменные относятся к
возможностям OpenGL, которые можно включать или выключать командами <strong><span
style='font-family:Verdana'>glEnable()</span></strong> или <strong><span
style='font-family:Verdana'>glDisable()</span></strong>. </p>

<p class=text align=left style='text-align:left'>Каждая переменная состояния
имеет свое значение по умолчанию, и в любой момент вы можете опросить систему
на предмет ее текущего значения. Обычно, чтобы это сделать, используется одна
из следующих 6 команд: <strong><span style='font-family:Verdana'>glGetBooleanv()</span></strong>,
<strong><span style='font-family:Verdana'>glGetDoublev()</span></strong>, <strong><span
style='font-family:Verdana'>glGetFloatv()</span></strong>, <strong><span
style='font-family:Verdana'>glGetIntegerv()</span></strong>, <strong><span
style='font-family:Verdana'>glGetPointerv()</span></strong>, <strong><span
style='font-family:Verdana'>glIsEnabled()</span></strong>. Выбор конкретной
команды зависит от того, в каком формате вы ожидаете ответ на запрос. Для
некоторых переменных состояния имеются более специфические команды опроса (такие
как, <strong><span style='font-family:Verdana'>glGetLight*()</span></strong>, <strong><span
style='font-family:Verdana'>glGetError()</span></strong> или <strong><span
style='font-family:Verdana'>glGetPolygonStipple()</span></strong>). Кроме того,
вы можете сохранять наборы значений переменных состояния в стеке атрибутов
командами <strong><span style='font-family:Verdana'>glPushAttrib()</span></strong>
или <strong><span style='font-family:Verdana'>glPushClientAttrib()</span></strong>,
временно изменять их значения и позже восстанавливать из стека командами <strong><span
style='font-family:Verdana'>glPopAttrib()</span></strong> или <strong><span
style='font-family:Verdana'>glPopClientAttrib()</span></strong>. Для временного
изменения переменных состояния и восстановления их исходных значений следует
пользоваться именно этими командами, так как они реализованы более эффективно
по сравнению с отдельными командами запросов. </p>

<h2>1.5 Конвейер визуализации OpenGL</h2>

<p class=text align=left style='text-align:left'>Большинство реализаций OpenGL
имеют сходный порядок операций или этапов обработки, называемый конвейером
визуализации OpenGL (OpenGL rendering pipeline). Этот порядок показан на
рисунке 1-2 и, хотя он не является жестким правилом для всех реализаций, тем не
менее, дает представление о том, что делает OpenGL. </p>

<p class=text align=left style='text-align:left'>Диаграмма демонстрирует
конвейер (в духе сборочных линий Генри Форда), который используется OpenGL для
обработки данных. Геометрические данные (вершины, линии и полигоны) проходят
путь, включающий оценку и повершинные операции, в то время как пиксельные
данные (пиксели, изображения и битовые карты) в части общего процесса
обрабатываются иначе. Оба типа данных проходят через одинаковые финальные шаги (растеризация
и операции над фрагментами) до того, как результирующие пиксельные данные
записываются в буфер кадра. </p>

<p class=text align=left style='text-align:left'>Рисунок 1.2. Порядок операций </p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Verdana;
color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1026" type="#_x0000_t75"
 alt="" style='width:6in;height:555pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image002.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов.mht!http://www.progz.ru/images/opengl/chapter1/1-2.gif"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=576 height=740
src="OpenGL%20Red%20Book.files/image002.gif" v:shapes="_x0000_i1026"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Теперь более детально
рассмотрим ключевые этапы конвейера визуализации OpenGL. </p>

<h2>1.5.1 Списки</h2>

<p class=text align=left style='text-align:left'>Все данные, геометрические или
пиксельные могут быть сохранены в списках (display lists) для текущего или
последующего использования. (Альтернативой занесению данных в списки является
их немедленная обработка, известная как непосредственный режим.) Когда
исполняется список, сохраненные в нем данные обрабатываются также, как если бы
они поступали в непосредственном режиме. </p>

<h2>1.5.2 Вычислители</h2>

<p class=text align=left style='text-align:left'>Все геометрические примитивы
описываются своими вершинами. Параметрические кривые и поверхности могут быть
изначально описаны с помощью контрольных точек и полиномиальных функций,
называемых базисными функциями. Вычислители предоставляют метод для определения
реальных вершин, представляющих поверхность, по ее контрольным точкам. Этот
метод – полиномиальная аппроксимация, он позволяет получить нормаль
поверхности, координаты текстуры, цвета и значения координат в пространстве. </p>

<h2>1.5.3 Повершинные операции</h2>

<p class=text align=left style='text-align:left'>Для геометрических данных
следующим этапом является выполнение повершинных операций (per-vertex
operations). В течение этого этапа вершины преобразуются в примитивы. Некоторые
типы вершинных данных трансформируются матрицами чисел с плавающей точкой
размерности 4х4. Пространственные координаты проецируются с позиции в 3D мире в
позицию на вашем экране. </p>

<p class=text align=left style='text-align:left'>Если активизированы
дополнительные возможности библиотеки OpenGL, то этот этап становится еще более
сложным. Если используется текстурирование, координаты текстуры могут быть
сгенерированы и изменены на этом шаге. Если используется освещение, вычисления,
связанные с ним, производятся с использованием трансформированных вершин,
нормалей поверхностей, позиций источников света, свойств материала, а также
другой информации, позволяющей вычислить цветовую величину. </p>

<h2>1.5.4 Сборка примитивов</h2>

<p class=text align=left style='text-align:left'>Отсечение – большая часть
сборки примитивов – это уничтожение частей геометрии, выпадающих за
полупространство, определенное плоскостью. Отсечение точек просто отвергает или
не отвергает вершину; отсечение линий или полигонов может добавить
дополнительные вершины в зависимости от ситуации (того, как именно линия или
полигон отсекаются). </p>

<p class=text align=left style='text-align:left'>В любом случае, после этого
процесса производится перспективное разделение, которое заставляет более
дальние объекты выглядеть меньше, чем ближние. Затем выполняются операции с
портом просмотра (viewport) и глубиной (координатой z). Если включено
распознавание лицевых граней, и примитив является полигоном, то на этом шаге грань
может быть отвергнута в зависимости от теста на лицевые грани. В зависимости от
режима рисования полигонов, они могут быть нарисованы в виде точек или линий. </p>

<p class=text align=left style='text-align:left'>Результатом этого этапа
являются завершенные примитивы, то есть трансформированные и отсеченные вершины
со связанными цветом, глубиной и, иногда, координатами текстуры. </p>

<h2>1.5.5 Операции над пикселями</h2>

<p class=text align=left style='text-align:left'>В то время как геометрические
данные движутся по конвейеру своим путем, пиксельные данные двигаются иным
маршрутом. Первым делом массивы данных из системной памяти распаковываются, то
есть преобразуются из какого-либо формата, в формат с необходимым числом
компонент. Далее данные масштабируются, базируются и обрабатываются пиксельными
картами. Результат сжимается и записывается в текстурную память или отправляется
на этап растеризации. </p>

<p class=text align=left style='text-align:left'>Если пиксельные данные
читаются из буфера кадра, над ними выполняются пиксельные операции
(pixel-transfer operations). Затем результаты упаковываются в соответствующий
формат и возвращаются в массив в системной памяти. </p>

<p class=text align=left style='text-align:left'>Существуют специальные
операции копирования пикселей (pixel copy operations) для копирования данных из
одной части буфера кадра в другие или из буфера кадра в текстурную память. </p>

<h2>1.5.6 Наложение текстуры</h2>

<p class=text align=left style='text-align:left'>Приложения OpenGL могут
накладывать текстурные изображения на геометрические объекты, чтобы заставить
их выглядеть более реалистично. Если используется несколько изображений
текстур, разумно поместить их в объекты текстуры, чтобы можно было легко
переключаться между ними. </p>

<p class=text align=left style='text-align:left'>Некоторые реализации OpenGL
могут иметь дополнительные ресурсы для ускорения операций с текстурами.
Например, может существовать специализированная быстрая текстурная память. Если
такая память присутствует, текстурным объектам могут быть назначены приоритеты,
чтобы управлять использованием этого ограниченного и весьма ценного ресурса. </p>

<h2>1.5.7 Растеризация</h2>

<p class=text align=left style='text-align:left'>Растеризация – это процесс
преобразования геометрических и пиксельных данных во фрагменты. Каждый фрагмент
соответствует пикселю в буфере кадра. Шаблоны линий и полигонов, толщина линии,
размер точек, модель заливки, вычисления связанные с наложением для поддержки
сглаживания принимаются в расчет при развертке двух вершин в линию или
вычислении внутренних пикселей полигона. Каждый фрагмент имеет ассоциированные
с ним значения цвета и глубины. </p>

<h2>1.5.8 Операции над фрагментами</h2>

<p class=text align=left style='text-align:left'>До того, как величины будут
сохранены в буфере кадра, над ними производится серия операций, которые могут
изменить или даже выбросить некоторые фрагменты. Все эти операции могут быть
включены или выключены. </p>

<p class=text align=left style='text-align:left'>Первая операция, которая может
быть произведена – это текстурирование, когда из текстурной памяти для каждого
фрагмента генерируется и накладывается на него тексел (элемент текстуры). Также
могут производиться (в порядке выполнения) вычисления тумана, тест отреза
(scissor test), альфа-тест, тест трафарета (stencil test) и тест буфера глубины
(для удаления невидимых поверхностей). Если фрагмент не проходит один из
включенных тестов, это может закончить его путь по конвейеру. Далее могут быть
произведены наложение, смешивание цветов (dithering), логические операции и
маскирование с помощью битовой маски. Наконец, фрагмент заносится в
соответствующий буфер, где становится пикселем. </p>

<h2>1.6 Библиотеки, связанные с OpenGL</h2>

<p class=text align=left style='text-align:left'>OpenGL предоставляет мощный,
но примитивный набор команд и все высокоуровневое рисование должно
производиться в терминах этих команд. Кроме того, программы OpenGL должны
использовать нижележащие механизмы оконной системы. Существует несколько
библиотек, которые могут облегчить программирование. Среди них имеются следующие:
</p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Symbol;mso-ascii-font-family:
Verdana;color:black'>·</span><span style='font-size:10.0pt;font-family:Verdana;
color:black'><span style='mso-spacerun:yes'>  </span>OpenGL Utility Library
(GLU) содержит несколько функций, которые используют низкоуровневые команды
OpenGL для выполнения таких операций, как установка специфических матриц
видовой ориентации и проекций, триангуляции полигонов и визуализации поверхностей.
Эта библиотека предоставляется как часть любой реализации OpenGL. <o:p></o:p></span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Symbol;mso-ascii-font-family:
Verdana;color:black'>·</span><span style='font-size:10.0pt;font-family:Verdana;
color:black'><span style='mso-spacerun:yes'>  </span>Для каждой оконной системы
существует библиотека, расширяющая возможности этой оконной системы для
поддержки OpenGL. Для машин, где используется системы X Window расширения OpenGL
(GLX) предоставляются в виде добавочных функций с префиксом <strong><span
style='font-family:Verdana'>glX</span></strong>. Для Microsoft Windows
95/98/Me/NT/200/XP функции WGL предоставляют интерфейс от Windows к OpenGL.
Почти все они имеют префикс <strong><span style='font-family:Verdana'>wgl</span></strong>.
Для IBM OS/2 функции менеджера презентаций имеют префикс <strong><span
style='font-family:Verdana'>pgl</span></strong>. Для Apple существует интерфейс
AGL, чьи функции имеют соответствующий префикс (<strong><span style='font-family:
Verdana'>agl</span></strong>). <o:p></o:p></span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Symbol;mso-ascii-font-family:
Verdana;color:black'>·</span><span style='font-size:10.0pt;font-family:Verdana;
color:black'><span style='mso-spacerun:yes'>  </span>OpenGL Utility Toolkit
(GLUT) – это независимая от оконной системы библиотека, написанная Марком
Килгардом, чтобы скрыть сложности API различных оконных систем. Все функции
библиотеки имеют префикс <strong><span style='font-family:Verdana'>glut</span></strong>.
Исходный код библиотеки GLUT для систем Microsoft Windows 95/98/NT/Me/XP и X
Window может быть получен по Интернет – адресу <a
href="http://reality.sgi.com/opengl/glut3/glut3.html"><span style='color:#003399;
text-decoration:none;text-underline:none'>http://reality.sgi.com/opengl/glut3/glut3.html</span></a>.
На данной странице помимо самого кода содержится информация о текущей версии
GLUT. <o:p></o:p></span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Symbol;mso-ascii-font-family:
Verdana;color:black'>·</span><span style='font-size:10.0pt;font-family:Verdana;
color:black'><span style='mso-spacerun:yes'>  </span>Fahrenheit Scene Graph
(FSG) – объектно-ориентированный набор, основанный на OpenGL, он предоставляет
объекты и методы для создания интерактивных трехмерных графических приложений.
FSG, написанный на C++, предоставляет заранее построенные объекты и встроенную
модель событий для взаимодействия с пользователем, высокоуровневые компоненты
приложений для создания и редактирования трехмерных сцен, а также возможность
обмена данными в различных форматах. FSG распространяется совершенно отдельно
от OpenGL. <o:p></o:p></span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Symbol;mso-ascii-font-family:
Verdana;color:black'>·</span><span style='font-size:10.0pt;font-family:Verdana;
color:black'><span style='mso-spacerun:yes'>  </span>Используя OpenGL, компания
Silicon Graphics создала вспомогательную библиотеку для упрощения написания
программ – примеров (OpenGL Auxiliary Library -- GLAUX). Код этой библиотеки
поставляется в составе Microsoft Platform SDK и может быть использован в
пользовательских программах или в образовательных целях. <o:p></o:p></span></p>

<h2>1.7 Заголовочные файлы</h2>

<p class=text align=left style='text-align:left'>Для всех OpenGL приложений
необходимо включать заголовочный файл gl.h. Также большинство приложений
используют GLU и должны включать файл glu.h. Таким образом, практически каабой
исходный файл приложения OpenGL начинается со следующих строк: </p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>#include
  &lt;GL/gl.h&gt;<br>
  #include &lt;GL/glu.h&gt;<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Для систем Microsoft Windows
требуется включение файла windows.h до включения gl.h или glu.h, так как
некоторые макросы, используемые в этих файлах, определены внутри windows.h.<br>
Если вы хотите получить доступ к библиотеке поддержки OpenGL оконной системой,
например GLX, AGL, PGL или WGL, должны быть включены дополнительные файлы.
Например, для вызовов функций GLX, требуется добавить в код следующие строки: </p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>#include
  &lt;X11/Xlib.h&gt;<br>
  #include &lt;GL/glx.h&gt;<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Для Microsoft Windows доступ к
функциям WGL можно получить включением строки: </p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>#include &lt;windows.h&gt;<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Если предполагается
использовать GLUT для управления задачами, связанными с окнами, следует
добавить ее заголовочный файл: </p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>#include &lt;GL/glut.h&gt;<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='margin:0cm;margin-bottom:.0001pt;text-align:
left'><span style='display:none;mso-hide:all'><o:p>&nbsp;</o:p></span></p>

<div align=center>

<table class=MsoNormalTable border=0 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:lemonchiffon;mso-padding-left-alt:
 15.0pt;mso-padding-right-alt:15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:10.0pt;font-family:"Courier New";
  color:black'>Замечание: glut.h гарантирует, что включены также gl.h и glu.h,
  так что нет необходимости включать все три файла. glut.h также гарантирует,
  что все специфичные для оконной системы макросы определены должным образом,
  до включения gl.h и glu.h. Для повышения переносимости GLUT-программ,
  включайте только glut.h и не включайте gl.h или glu.h. <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Многие приложения OpenGL также
используют стандартную библиотеку языка C, поэтому является частой практикой
включать в исходный текст заголовочные файлы не связанные с графикой: </p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>#include
  &lt;stdlib.h&gt;<br>
  #include &lt;stdio.h&gt;<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<h2>1.8 Сборка проекта</h2>

<p class=text align=left style='text-align:left'>Помимо включения в исходный
текст директив компилятора для добавления заголовочных файлов необходимо также
проследить за тем, что во время сборки проекта к нему будут добавлены нужные
библиотеки импорта. Например, в операционных системах Microsoft Windows
библиотека OpenGL (в любой ее реализации) представлена динамической библиотекой
opengl32.dll, а GLU – файлом glu32.dll. Библиотека импорта, присоединенная к
проекту вашего приложения, позволяет ему во время выполнения загружать нужные
динамические библиотеки и вызывать их функции. Для названных динамических
библиотек соответствующими библиотеками импорта являются opengl32.lib и
glu32.lib, находящиеся, как правило, в одном из подкаталогов компилятора. </p>

<p class=text align=left style='text-align:left'>Если помимо средств
операционной или оконной системы вы используете еще какие-либо библиотеки, то,
возможно, придется добавлять в проект и другие библиотеки импорта. Иногда (как,
например, в случае с GLUT) в самом заголовочном файле содержится директива
компилятору включить в проект нужные библиотеки импорта, но так бывает не
всегда. Сигналом к тому, что нужные ссылки на библиотеки отсутствуют, чаще
всего, является то, что компилятор просто отказывается собирать проект. </p>

<p class=text align=left style='text-align:left'>Кроме того, нужные
динамические библиотеки должны быть в зоне досягаемости вашего готового
приложения. Как правило, это означает, что они должны находиться либо в одном
каталоге с исполняемым файлом, либо (и это случается чаще) они должны быть
помещены в системную директорию Microsoft Windows (конкретный путь зависит от
конкретного компьютера, но в общем виде этот путь можно записать как [Каталог
Windows]\System). </p>

<h2>1.9 GLUT</h2>

<p class=text align=left style='text-align:left'>Как вы уже знаете, OpenGL
содержит набор команд, но разработана как независимая от оконной или
операционной системы. Как следствие, в ней нет команд для открытия окон или
чтения событий от клавиатуры или мыши. К несчастью нельзя создать полноценное
приложение без того, чтобы, как минимум, открыть окно, а наиболее интересные
приложения требуют взаимодействия с пользователем посредством устройств ввода
или используют иные средства операционной или оконной системы. Во многих
случаях завершенные программы представляют собой наиболее интересные примеры,
поэтому мы будем использовать GLUT для упрощения открытия окон, захвата
пользовательского ввода и так далее. Если у вас имеется реализация OpenGL и
GLUT для вашей системы, все примеры будут работать без изменений (или почти без
изменений). </p>

<p class=text align=left style='text-align:left'>Кроме того, в отличие от
OpenGL, чьи команды ограничены рисованием примитивов, GLUT содержит функции для
рисования более сложных трехмерных объектов, таких как сфера, куб, торус
(бублик) и чайник. (Обратите внимание на то, что GLU также содержит функции для
рисования этих объектов, а также цилиндров, конусов и многого другого.) </p>

<p class=text align=left style='text-align:left'>Библиотеки GLUT может быть
недостаточно для построения полномасштабного OpenGL приложения (например, в
силу отсутствия полного контроля над форматом пикселей или созданием контекста
OpenGL), но это хорошая начальная точка для изучения OpenGL. Остальная часть
данного раздела посвящена наиболее часто применяемым группам функций GLUT.
Функции неуказанные здесь, рассмотрены в приложении A данного пособия. </p>

<h2>1.9.1 Управление окном</h2>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void
  glutInit (int argc, char **argv); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'><strong><span
style='font-family:Verdana'>glutInit()</span></strong> должна быть вызвана до
любых других GLUT – функций, так как она инициализирует саму библиотеку GLUT. <strong><span
style='font-family:Verdana'>glutInit()</span></strong> также обрабатывает
параметры командной строки, но сами параметры зависят от конкретной оконной
системы. Для системы X Window, примерами могут быть –iconic, -geometry и
–display. (Параметры, передаваемые <strong><span style='font-family:Verdana'>glutInit()</span></strong>,
должны быть теми же самыми, что и параметры, передаваемые в функцию <strong><span
style='font-family:Verdana'>main()</span></strong>). </p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void
  glutInitDisplayMode (unsigned int mode); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Указывает режим отображения
(например, RGBA или индексный, одинарной или двойной буферизации) для окон,
создаваемых вызовами <strong><span style='font-family:Verdana'>glutCreateWindow()</span></strong>.
Вы также можете указывать, имеет ли окно ассоциированные с ним буфер или буферы
глубины, трафарета и аккумуляции. Аргумент mask – это битовая комбинация,
полученная при помощи операции OR и следующих констант: GLUT_RGBA или
GLUT_INDEX (для указания цветового режима), GLUT_SINGLE или GLUT_DOUBLE (для
указания режима буферизации), а также константы для включения различных буферов
GLUT_DEPTH, GLUT_STENCIL, GLUT_ACCUN. Например, для окна с двойной буферизаций,
RGBA – цветовым режимом и ассоциированными буферами глубины и трафарета,
используйте GLUT_DOUBLE | GLUT_RGBA | GLUT_DEPTH | GLUT_STENCIL. Значение по
умолчанию – GLUT_RGBA | GLUT_ SINGLE (окно с однократной буферизацией в RGBA -
режиме). </p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void
  glutInitWindowSize (int width, int height);<br>
  void glutInitWindowPosition (int x, int y); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Запрашивают окно определенного
размера и в определенном месте экрана соответственно. Аргументы (x, y)
определяют, где будет находиться угол окна относительно всего экрана. width и
height определяют размер окна (в пикселях). Начальные размеры и место
размещения окна могут быть перекрыты последующими вызовами. </p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>int glutCreateWindow (char
  *name); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Открывает окно с
предварительно установленными характеристиками (режимом отображения, размером и
так далее). Строка name может быть отображена в заголовке окна, но это зависит
от конкретной оконной системы. Окно не отображается до того, как произведен
вход в <strong><span style='font-family:Verdana'>glutMainLoop()</span></strong>,
поэтому до вызова этой функции нельзя рисовать что-либо в окно.<br>
Возвращаемая целая величина представляет собой уникальный идентификатор окна.
Этот идентификатор может быть использован для управления несколькими окнами в
одном приложении (каждое со своим контекстом OpenGL) и рисования в них. </p>

<h2>1.9.2 Функции управления событиями</h2>

<p class=text align=left style='text-align:left'>После того, как окно создано,
но до входа в главный цикл программы, вы должны зарегистрировать функции обратного
вызова, используя следующие функции GLUT. </p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void
  glutDisplayFunc (void (*func)(void)); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Позволяет указать функцию
(аргументом func), которая будет вызываться каждый раз, когда содержимое окна
требует перерисовки. Это может случиться, когда окно открывается,
разворачивается, освобождается его часть, ранее перекрытая другим окном, или
вызывается функция <strong><span style='font-family:Verdana'>glutPostRedisplay()</span></strong>.
</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void
  glutReshapeFunc (void (*func)(int width, int height)); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Позволяет указать функцию,
которая вызывается каждый раз при изменении размера окна или его позиции на
экране. Аргумент func – это указатель на функцию, которая принимает два
параметра: width – новая ширина окна и height – новая высота окна. Обычно func
вызывает <strong><span style='font-family:Verdana'>glViewport()</span></strong>
для отсечения графического вывода по новым размерам окна, а также настраивает
проекционную матрицу для сохранения пропорций спроецированного изображения в
соответствии с новыми размерами порта просмотра. Если <strong><span
style='font-family:Verdana'>glutReshapeFunc()</span></strong> не вызывается или
ей передается NULL (для отмены регистрации функции обратного вызова),
вызывается функция изменения метрик по умолчанию, которая вызывает glViewport
(0,0,width,height). </p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void
  glutKeyboardFunc (void (*func)(unsigned int key, int x, int y)); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Задает функцию func, которая
вызывается, когда нажимается клавиша, имеющая ASCII-код. Этот код передается
функции обратного вызова в параметре key. В параметрах x и y передается позиция
курсора мыши (относительно окна) в момент нажатия клавиши. </p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void
  glutMouseFunc (void (*func)(int button, int state, int width, int height)); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Указывает функцию, которая
вызывается при нажатии или отпускании кнопки мыши. Параметр<span lang=EN-US
style='mso-ansi-language:EN-US'> button </span>может<span style='mso-ansi-language:
EN-US'> </span>иметь<span style='mso-ansi-language:EN-US'> </span>значения<span
lang=EN-US style='mso-ansi-language:EN-US'> GLUT_LEFT_BUTTON,
GLUT_MIDDLE_BUTTON </span>или<span lang=EN-US style='mso-ansi-language:EN-US'>
GLUT_RIGHT_BUTTON. </span>Параметр state может иметь значения GLUT_UP или
GLUT_DOWN в зависимости от того отпущена или нажата кнопка мыши. В параметрах x
и y передаются координаты курсора мыши (относительно окна) в момент наступления
события. </p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void
  glutMotionFunc (void (*func)(int x, int y)); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Указывает функцию, которая
будет вызываться при движении мыши внутри окна в то время, как на ней нажата
одна или несколько клавиш. В параметрах x и y передаются координаты курсора
мыши (относительно окна) в текущий момент. </p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void glutPostRedisplay
  (void); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Помечает, что текущее окно
требует перерисовки. После этого при любой возможности будет вызвана функция
перерисовки окна, зарегистрированная вызовом <strong><span style='font-family:
Verdana'>glutDisplayFunc()</span></strong>. </p>

<h2>1.9.3 Загрузка палитры</h2>

<p class=text align=left style='text-align:left'>Если вы работаете в индексном
режиме, то можете к своему удивлению обнаружить, что в OpenGL нет команд для
загрузки цвета в цветовую таблицу. Дело в том, что процесс загрузки палитры
целиком зависит от оконной системы. В GLUT существует обобщенная функция для
загрузки одного цветового индекса с соответствующим RGB значением. </p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void
  glutSetColor (Glint index, GLfloat red, GLfloat green, GLfloat blue); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Загружает в палитру по индексу
index, RGB-значение, определенное параметрами red, green и blue. Последние три
параметра нормализуются до диапазона [0.0, 1.0]. </p>

<h2>1.9.4 Рисование трехмерных объектов</h2>

<p class=text align=left style='text-align:left'>Многие программы примеры
используют простые трехмерные объекты для иллюстрации различных методов и
техник визуализации изображения. GLUT содержит несколько функций для рисования
таких объектов. Все эти функции работают в непосредственном режиме. Каждая из
них имеет два варианта: первый рисует объект в виде проволочного каркаса и не
генерирует нормалей, второй рисует объект сплошным и генерирует нормали
поверхности (для чайника помимо этого генерируются координаты текстуры). Если
используется освещение, следует выбирать сплошную версию объекта. Все объекты
рисуются с учетом текущих параметров, например, цвета и характеристик
материала. Кроме того, все объекты рисуются центрированными относительно
текущих модельных координат. </p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void
  glutWireSphere (GLdouble radius, GLint slices, GLint stacks);<br>
  void glutSolidSphere (GLdouble radius, GLint slices, GLint stacks); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Рисуют проволочную или
сплошную сферу с радиусом radius, количеством частей (полигонов из которых
состоит сфера) slices – вокруг оси z и stacks – вдоль оси z. Для того, чтобы
понять, что означает вокруг оси z и вдоль нее, представьте себе, что вы
смотрите в длинную трубу. В данном случае направление вашего обзора совпадает с
осью z трубы. Она может быть мысленно разделена как вдоль (на длинные
фрагменты), так и поперек (на кольца). После таких разбиений труба фактически
состоит из множества мелких кусочков. В случае сферы количество разбиений
поперек задается параметром stacks, а количество разбиений вдоль – параметром
slices. Из этого следует, что чем больше разбиений, тем более гладкой выглядит
сфера на экране, но тем больше вычислений требуется для ее рисования. </p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void
  glutWireCube (GLdouble size);<br>
  void glutSolidCube (GLdouble size); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Рисуют проволочный или
сплошной куб с длиной ребра size. </p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void
  glutWireTorus (GLdouble innerRadius, GLdouble outerRadius, GLint nsides,
  GLint rings);<br>
  void glutSolidTorus (GLdouble innerRadius, GLdouble outerRadius, GLint
  nsides, GLint rings); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Рисуют проволочный или
сплошной торус (бублик) с внешним радиусом outerRadius и внутренним радиусом
innerRadius. Параметр rings задает желаемое число колец из которых будет
состоять торус, параметр nsides – из скольких частей будет состоять каждое
кольцо. </p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void
  glutWireCone (GLdouble radius, GLdouble height, GLint slices, GLint stacks);<br>
  void glutSolidCone (GLdouble radius, GLdouble height, GLint slices, GLint
  stacks); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Рисуют проволочный или
сплошной конус радиусом radius, высотой height. Значение параметров slices и
stacks аналогично таким же параметрам для сферы. </p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void glutWireIcosahedron
  (void);<br>
  void glutSolidIcosahedron (void);<br>
  void glutWireOctahedron (void);<br>
  void glutSolidOctahedron (void);<br>
  void glutWireTetrahedron (void);<br>
  void glutSolidTetrahedron (void);<br>
  void glutWireDodecahedron (GLdouble radius);<br>
  void glutSolidDodecahedron (GLdouble radius); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Рисуют проволочные или сплошные
икосаэдр, октаэдр, тетраэдр и додекаэдр соответственно (единственный параметр
последний пары функций задает радиус додекаэдра). </p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void
  glutWireTeapot (GLdouble size);<br>
  void glutSolidTeapot (GLdouble size); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Рисуют проволочный или
сплошной чайник размера size. </p>

<h2>1.9.5 Управление фоновым процессом</h2>

<p class=text align=left style='text-align:left'>Вы можете указать функцию,
которая будет вызываться в том случае, если нет других сообщений, то есть во
время простоя приложения. Это может быть полезно для выполнения анимации или
другой фоновой обработки. </p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void
  glutIdleFunc (void (*func)(void)); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Задает функцию, выполняемую в
случае, если больше приложению делать нечего (отсутствуют сообщения).
Выполнение этой функции обратного вызова можно отменить передачей <strong><span
style='font-family:Verdana'>glutIdleFunc()</span></strong> аргумента NULL. </p>

<h2>1.9.6 Запуск программы</h2>

<p class=text align=left style='text-align:left'>После того, как все настройки
выполнены, программы GLUT входят в цикл обработки сообщений функцией <strong><span
style='font-family:Verdana'>glutMainLoop()</span></strong>. </p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void glutMainLoop (void); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Вводит программу в цикл
обработки сообщений. Функции обратного вызова будут выполняться в случае
наступления соответствующих событий. </p>

<p class=text align=left style='text-align:left'>Пример 1-2 показывает, как с
помощью GLUT можно заставить работать программу, показанную в примере 1-1.
Обратите внимание на реструктуризацию кода. Для увеличения эффективности
операции, которые нужно выполнить только один раз (установка цвета фона и
координатной системы), теперь помещены в функцию <strong><span
style='font-family:Verdana'>init()</span></strong>. Операции по визуализации (и
пересчету) сцены находятся в функции <strong><span style='font-family:Verdana'>display()</span></strong>,
которая зарегистрирована в качестве дисплейной функции обратного вызова. </p>

<p class=text align=left style='text-align:left'>Пример 1-2. Простая OpenGL –
программа с использованием GLUT: hello.cpp </p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>#include &lt;GL/glut.h&gt; <o:p></o:p></span></p>
  <p class=text align=left style='text-align:left'><span style='mso-bidi-font-family:
  "Courier New"'>void init(void)<br>
  {<br>
  //Выбрать фоновый (очищающий) цвет<br>
  glClearColor(0.0,0.0,0.0,0.0); <o:p></o:p></span></p>
  <p class=text align=left style='text-align:left'><span lang=EN-US
  style='mso-bidi-font-family:"Courier New";mso-ansi-language:EN-US'>//</span><span
  style='mso-bidi-font-family:"Courier New"'>Установить</span><span
  style='mso-bidi-font-family:"Courier New";mso-ansi-language:EN-US'> </span><span
  style='mso-bidi-font-family:"Courier New"'>проекцию</span><span lang=EN-US
  style='mso-bidi-font-family:"Courier New";mso-ansi-language:EN-US'><br>
  glMatrixMode(GL_PROJECTION);<br>
  glLoadIdentity();<br>
  glOrtho(0.0,1.0,0.0,1.0,-1.0,1.0);<br>
  } <o:p></o:p></span></p>
  <p class=text align=left style='text-align:left'><span lang=EN-US
  style='mso-bidi-font-family:"Courier New";mso-ansi-language:EN-US'>void
  display(void)<br>
  {<br>
  //</span><span style='mso-bidi-font-family:"Courier New"'>Очистить</span><span
  style='mso-bidi-font-family:"Courier New";mso-ansi-language:EN-US'> </span><span
  style='mso-bidi-font-family:"Courier New"'>экран</span><span lang=EN-US
  style='mso-bidi-font-family:"Courier New";mso-ansi-language:EN-US'>
  glClear(GL_COLOR_BUFFER_BIT); <o:p></o:p></span></p>
  <p class=text align=left style='text-align:left'><span lang=EN-US
  style='mso-bidi-font-family:"Courier New";mso-ansi-language:EN-US'>//</span><span
  style='mso-bidi-font-family:"Courier New"'>Нарисовать</span><span
  style='mso-bidi-font-family:"Courier New";mso-ansi-language:EN-US'> </span><span
  style='mso-bidi-font-family:"Courier New"'>белый</span><span
  style='mso-bidi-font-family:"Courier New";mso-ansi-language:EN-US'> </span><span
  style='mso-bidi-font-family:"Courier New"'>полигон</span><span lang=EN-US
  style='mso-bidi-font-family:"Courier New";mso-ansi-language:EN-US'> (</span><span
  style='mso-bidi-font-family:"Courier New"'>квадрат</span><span lang=EN-US
  style='mso-bidi-font-family:"Courier New";mso-ansi-language:EN-US'>) </span><span
  style='mso-bidi-font-family:"Courier New"'>с</span><span style='mso-bidi-font-family:
  "Courier New";mso-ansi-language:EN-US'> </span><span style='mso-bidi-font-family:
  "Courier New"'>углами</span><span lang=EN-US style='mso-bidi-font-family:
  "Courier New";mso-ansi-language:EN-US'> //</span><span style='mso-bidi-font-family:
  "Courier New"'>в</span><span lang=EN-US style='mso-bidi-font-family:"Courier New";
  mso-ansi-language:EN-US'> (0.25, 0.25, 0.0) </span><span style='mso-bidi-font-family:
  "Courier New"'>и</span><span lang=EN-US style='mso-bidi-font-family:"Courier New";
  mso-ansi-language:EN-US'> (0.75, 0.75, 0.0)<br>
  glColor3f(1.0,1.0,1.0);<br>
  glBegin(GL_POLYGON);<br>
  glVertex3f(0.25,0.25,0.0);<br>
  glVertex3f(0.75,0.25,0.0);<br>
  glVertex3f(0.75,0.75,0.0);<br>
  glVertex3f(0.25,0.75,0.0);<br>
  glEnd(); <o:p></o:p></span></p>
  <p class=text align=left style='text-align:left'><span style='mso-bidi-font-family:
  "Courier New"'>//Не ждем. Начинаем выполнять буферизованные<br>
  //команды OpenGL<br>
  glFlush();<br>
  } <o:p></o:p></span></p>
  <p class=text align=left style='text-align:left'><span style='mso-bidi-font-family:
  "Courier New"'>//Установить начальные характеристики окна,<br>
  //открыть окно с заголовком «hello».<br>
  //Зарегистрировать дисплейную функцию обратного вызова<br>
  //Войти в главный цикл<br>
  int main(int argc, char **argv)<br>
  {<br>
  glutInit(&amp;argc,argv);<br>
  glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);<br>
  glutInitWindowSize(250,250);<br>
  glutInitWindowPosition(100,100);<br>
  glutCreateWindow(“hello”);<br>
  init();<br>
  glutDisplayFunc(display);<br>
  glutMainLoop(); <o:p></o:p></span></p>
  <p class=text align=left style='text-align:left'><span style='mso-bidi-font-family:
  "Courier New"'>return 0;<br>
  } <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<h2>1.9.7 Типы проектов</h2>

<p class=text align=left style='text-align:left'>Поскольку данное пособие
предназначено в основном для тех, кто программирует приложения для среды
Microsoft Windows, требуется сделать несколько важных замечаний. </p>

<p class=text align=left style='text-align:left'>Существует два основным типа
приложения для этой операционной системы: консольные и оконные. </p>

<p class=text align=left style='text-align:left'>Консольные приложения по
своему строению практически не отличаются от программ DOS запущенных под
Windows (однако являются 32-разрядными приложениями защищенного режима). При их
запуске система автоматически создает окно, в которое можно выводить текстовую
информацию языковыми средствами C без привлечения функций API операционной
системы. Тем не менее, само приложение может также создавать дополнительные
окна, если разработчику это требуется. Именно так и происходит при создании
консольных приложений с использованием GLUT и OpenGL. Система при запуске
создает консоль, а GLUT своим методом <strong><span style='font-family:Verdana'>glutCreateWindow()</span></strong>
создает еще одно окно. В этом случае весь графический вывод OpenGL направляется
в окно, созданное GLUT, а текстовый вывод функциями стандартной библиотеки C
(например, <strong><span style='font-family:Verdana'>printf(“текстовая строка”)</span></strong>
или <strong><span style='font-family:Verdana'>cout&lt;&lt;”текстовая строка”)</span></strong>
будет осуществляться в консольное окно. Это может быть весьма удобно, если
помимо графического вывода программа выполняет некоторые вычисления над
полученным изображением (определение минимальных и максимальных значений
компонент цвета, использование обратного режима OpenGL и так далее). Стартовой
точкой выполнения консольной программы является функция <strong><span
style='font-family:Verdana'>main()</span></strong>, в которую системой
передаются те самые параметры командной строки (если они есть), которые позже
должны быть переданы в <strong><span style='font-family:Verdana'>glutInit()</span></strong>.
</p>

<p class=text align=left style='text-align:left'>В случаях, когда лишнее
консольное окно приложению не нужно, лучше изначально создавать оконное
приложение. При его запуске вся ответственность по созданию окон ложится на
программиста и средства, которыми он пользуется, в нашем случае опять-таки на
GLUT. И вот здесь может возникнуть потенциальная проблема, которая происходит
из разницы между форматами передачи параметров командной строки в функцию <strong><span
style='font-family:Verdana'>main()</span></strong> и <strong><span
style='font-family:Verdana'>WinMain()</span></strong>. В первом случае
параметры передаются в функцию в виде массива строк, тогда как во втором – в
виде одной единственной строки, причем в этом случае количество параметров
неизвестно. В свою очередь <strong><span style='font-family:Verdana'>glutInit()</span></strong>
ожидает параметры в формате <strong><span style='font-family:Verdana'>main()</span></strong>
с указанием их числа. Существует несколько вариантов решения этой проблемы.
Если параметры вам нужны, следует создать (или позаимствовать) функцию разборки
единой командной строки на составляющие с выяснением их количества (это
довольно просто). Если же у вас нет нужды в параметрах командной строки можно
передать в <strong><span style='font-family:Verdana'>glutInit()</span></strong>
подделку следующего вида: </p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>char*
  argv=&quot;&quot;;<br>
  int argc=0;<br>
  glutInit(&amp;argc,&amp;argv); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Конечно, существуют и другие
варианты. </p>

<h2>1.10 Анимация</h2>

<p class=text align=left style='text-align:left'>Одна из самых впечатляющих
вещей, которую вы можете делать на компьютере – это рисование движущихся
картинок. Являетесь ли вы инженером, пытающимся увидеть разрабатываемую деталь
со всех сторон, пилотом, обучающимся летать на самолете с помощью симулятора
или профессионалом в области создания компьютерных игр, вам должно быть
абсолютно ясно, что анимация – это важная часть компьютерной графики. </p>

<p class=text align=left style='text-align:left'>В кинотеатре движение
достигается за счет проектирования серии картинок на экран со скоростью 24
кадра в секунду. Каждый кадр выдвигается на позицию перед лампой, открывается
шторка и кадр показывается на экране. Шторка моментально закрывается, пленка
передвигается к следующему кадру, он отображается на экране и так далее. Таким
образом, когда вы просматриваете 24 кадра за одну секунду, ваш мозг объединяет
их в непрерывную плавную анимацию. (Разрывы между кадрами были хорошо заметны в
старых фильмах Чарли Чаплина, так как в то время фильмы снимались и
показывались со скоростью 16 кадров в секунду.) Современные мониторы в среднем
перерисовывают изображение от 60 до 76 раз в секунду (хотя скорость может
достигать и 120 раз в секунду). Очевидно, что 60 кадров в секунду выглядят
более гладко, чем 30, а 120 намного лучше, чем 60. Однако, частота обновления
выше 120 кадров в секунду может находиться за гранью человеческого восприятия
(это зависит, в основном, от индивидуальных особенностей). </p>

<p class=text align=left style='text-align:left'>Ключевая причина, по которой
кинопроектор способен создать эффект движения заключается в том, что каждый
кадр уже готов на момент его показа. Предположим, что вы пытаетесь
воспроизвести анимацию, состоящую из миллиона кадров, с помощью программы вроде
следующей: </p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>Открыть_окно();<br>
  for(i=0;i&lt;1000000;i++)<br>
  {<br>
  Очистить_окно();<br>
  Нарисовать_кадр(i);<br>
  Подождать_пока_пройдет_одна_24я_часть_секунды();<br>
  } <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Если вы сложите время, которое
требуется вашей программе, чтобы нарисовать кадр на экране и время, необходимое
для очистки экрана, то выяснится, что программа выдает все более и более
неприятные результаты по мере того, как это суммарное время приближается к 1/24
части секунды. Предположим, что рисование занимает практически всю 1/24 часть
секунды. Тогда элементы изображения рисуемые первыми будут видны на экране
практически постоянно, а те, что рисуются в конце, будут похожи на приведение,
так как сразу после их отображения программа начнет стирать все изображение с
экрана и, таким образом, большую часть времени наблюдатель будет видеть на
месте этих элементов пустой фон. Проблема в том, что приведенная программа не
воспроизводит готовые кадры, а рисует каждый из них и наблюдатель это видит. </p>

<p class=text align=left style='text-align:left'>Большинство реализаций OpenGL
предоставляет двойную буферизацию – аппаратный или программный механизм,
который обеспечивает наличие двух полноценных цветовых буферов. Один
отображается на экране, пока второй отрисовывается. Когда рисование кадра окончено,
два буфера переключаются: тот, что только что был на экране, теперь
используется для рисования и наоборот. Этот процесс похож на отображение
проектором в кинотеатре пленки всего с двумя кадрами: пока один проецируется на
экран, художник стирает и перерисовывает другой – невидимый. До тех пор, пока
художник достаточно быстр, наблюдатель не заметит разницы между подобной
техникой и той, где все кадры уже готовы и просто показываются друг за другом.
С двойной буферизацией каждый кадр показывается только после того, как он
полностью готов. Наблюдатель никогда не увидит частично нарисованное
изображение. </p>

<p class=text align=left style='text-align:left'>Модифицированная для
использования двойной буферизации версия предыдущей программы может выглядеть
следующим образом: </p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>Открыть_окно_в_режиме_двойной_буферизации();<br>
  for(i=0;i&lt;1000000;i++)<br>
  {<br>
  Очистить_окно();<br>
  Нарисовать_кадр(i);<br>
  Переключить_буферы();<br>
  } <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<h2>1.11 Частота обновления экрана</h2>

<p class=text align=left style='text-align:left'>В некоторых реализациях
OpenGL, функция <strong><span style='font-family:Verdana'>Переключить_буферы()</span></strong>
помимо простого переключения буферов, ждет, пока закончится текущий период
обновления экрана, чтобы предыдущий кадр был полностью отображен и следующий
был нарисован с самого начала. Предположим, что ваша система обновляет экран 60
раз в секунду. Это означает, что наивысшая скорость смены кадров, которую вы
можете достичь – 60 кадров в секунду (frames per second -- fps) и если все ваши
кадры будут очищаться и перерисовываться менее чем за 1/60 долю секунды, ваша
анимация будет на этой скорости гладкой. </p>

<p class=text align=left style='text-align:left'>Часто случается, что кадр
слишком сложен, чтобы нарисовать его за 1/60 секунды, таким образом, каждый
кадр показывается на экране более чем один раз. Если, например, рисование кадра
занимает 1/45 секунды, вы получаете скорость 30 fps и ничем не занятое время в
размере 1/30-1/45=1/90 секунды, то есть треть времени рисования кадра на каждый
кадр. </p>

<p class=text align=left style='text-align:left'>Кроме того, частота обновления
монитора постоянна, что может вызвать неожиданные последствия для
быстродействия. Например, при частоте обновления монитора 60 раз в секунду,
анимация может идти со скоростями 60 fps, 30, fps, 20 fps, 15 fps, 12 fps и так
далее. Это означает, что если пишете приложение и постепенно добавляете детали,
сначала каждая деталь, которую вы добавляете, не оказывает воздействия на общее
быстродействие – анимация по-прежнему идет со скоростью 60 fps. Затем вы
добавляете еще одну деталь, и, система уже не может рисовать кадр за 1/60 долю
секунды, вследствие чего, неожиданно, быстродействие падает до 30 fps,
поскольку не нельзя переключить буферы при первой возможности. То же
происходит, если время рисования, затрачиваемое на каждый кадр, перешагивает
порог в 1/30 долю секунды – быстродействие снижается до 20 fps. </p>

<p class=text align=left style='text-align:left'>Если сложность сцены близка к
одному из волшебных чисел (1/60 секунды, 1/30 секунды, 1/20 секунды и так
далее), то из-за некоторых вариаций некоторые кадры могут рисоваться чуть
быстрее, а некоторые немного не укладываться в график. В этом случае скорость
анимации непостоянна, что может вести к неприятному внешнему виду. В таких
случаях, если не удается упростить медленные кадры, возможно, стоит добавить
небольшую паузу в быстрые, чтобы сохранять скорость анимации постоянной. Если
различные кадры вашей анимации драматически отличаются друг от друга по
сложности, может потребоваться более изощренный подход. </p>

<h2>1.12 Движение = Перерисовка + Переключение</h2>

<p class=text align=left style='text-align:left'>Структура реальных программ
анимации не слишком отличается от описания, приведенного в заголовке этого
раздела. Обычно намного легче перерисовать весь буфер, чем выяснять какие его
части нужно изменить. Это особенно верно для таких приложений как симуляторы полетов,
где даже небольшое изменение в ориентации самолета ведет к масштабным
изменениям вида за окнами кабины. </p>

<p class=text align=left style='text-align:left'>В большинстве анимационных
программ объекты сцены просто перерисовываются с учетом различных трансформаций
– изменяется точка обзора или положение наблюдателя, или машина немного
проезжает по дороге, или объект немного поворачивается. Если требуются обширные
вычисления не связанные с рисованием, то они могут ощутимо понизить
быстродействие в целом и скорость анимации в частности. Имейте в виду однако,
что часто пауза после вызова Переключить_буферы() может быть использована для
таких операций. </p>

<p class=text align=left style='text-align:left'>В OpenGL нет функции
Переключить_буферы(), так как данная возможность может не обеспечиваться
отдельными аппаратными средствами и, в любом случае, она сильно зависит от
оконной системы. Например, при использовании системы X Window (и работе без
дополнительных библиотек) можно использовать следующую GLX функцию: </p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void
  glXSwapBuffers (Display *dpy, Window window); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>В аналогичном случае для
системы Microsoft Windows функция будет выглядеть следующим образом: </p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>BOOL SwapBuffers (HDC hdc); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>При использовании GLUT следует
вызывать функцию: </p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void glutSwapBuffers (void); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Пример 1-3 иллюстрирует
использование <strong><span style='font-family:Verdana'>glutSwapBuffers()</span></strong>
для рисования вращающегося квадрата, показанного на рисунке 1-3. Этот пример
также показывает, как использовать GLUT для захвата пользовательского ввода и
включения/выключения функции фоновой обработки. В данном примере левая и правая
кнопки мыши соответственно включают и выключают вращение. </p>

<p class=text align=left style='text-align:left'>Рисунок 1.3. Вращающийся
квадрат в режиме двойной буферизации </p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Verdana;
color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1027" type="#_x0000_t75"
 alt="" style='width:468pt;height:101.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image003.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов.mht!http://www.progz.ru/images/opengl/chapter1/1-3.gif"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=624 height=135
src="OpenGL%20Red%20Book.files/image003.gif" v:shapes="_x0000_i1027"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Пример 1.3. Программа,
использующая двойную буферизацию: double.cpp </p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>#include
  &lt;GL/glut.h&gt; <o:p></o:p></span></p>
  <p class=text align=left style='text-align:left'><span lang=EN-US
  style='mso-bidi-font-family:"Courier New";mso-ansi-language:EN-US'>GLfloat
  spin=0.0; <o:p></o:p></span></p>
  <p class=text align=left style='text-align:left'><span lang=EN-US
  style='mso-bidi-font-family:"Courier New";mso-ansi-language:EN-US'>void
  init(void)<br>
  {<br>
  glClearColor(0.0,0.0,0.0,0.0);<br>
  glShadeModel(GL_FLAT);<br>
  } <o:p></o:p></span></p>
  <p class=text align=left style='text-align:left'><span lang=EN-US
  style='mso-bidi-font-family:"Courier New";mso-ansi-language:EN-US'>void
  display(void)<br>
  {<br>
  glClear(GL_COLOR_BUFFER_BIT);<br>
  glPushMatrix();<br>
  glRotatef(spin,0.0,0.0,1.0);<br>
  glColor3f(1.0,1.0,1.0);<br>
  glRectf(-25.0,-25.0,25.0,25.0);<br>
  glPopMatrix();<br>
  glutSwapBuffers();<br>
  } <o:p></o:p></span></p>
  <p class=text align=left style='text-align:left'><span lang=EN-US
  style='mso-bidi-font-family:"Courier New";mso-ansi-language:EN-US'>void
  spinDisplay(void)<br>
  {<br>
  spin=spin+1.0; <o:p></o:p></span></p>
  <p class=text align=left style='text-align:left'><span lang=EN-US
  style='mso-bidi-font-family:"Courier New";mso-ansi-language:EN-US'>if(spin&gt;360.0)
  spin=spin-360.0; <o:p></o:p></span></p>
  <p class=text align=left style='text-align:left'><span lang=EN-US
  style='mso-bidi-font-family:"Courier New";mso-ansi-language:EN-US'>glutPostRedisplay();<br>
  } <o:p></o:p></span></p>
  <p class=text align=left style='text-align:left'><span lang=EN-US
  style='mso-bidi-font-family:"Courier New";mso-ansi-language:EN-US'>void
  reshape(int w, int h)<br>
  {<br>
  glViewport(0,0,(GLsizei) w, (GLsizei) h);<br>
  glMatrixMode(GL_PROJECTION);<br>
  glLoadIdentity();<br>
  glOrtho(-50.0,50.0,-50.0,50.0,-1.0,1.0);<br>
  glMatrixMode(GL_MODELVIEW);<br>
  glLoadIdentity();<br>
  } <o:p></o:p></span></p>
  <p class=text align=left style='text-align:left'><span lang=EN-US
  style='mso-bidi-font-family:"Courier New";mso-ansi-language:EN-US'>//</span><span
  style='mso-bidi-font-family:"Courier New"'>При</span><span style='mso-bidi-font-family:
  "Courier New";mso-ansi-language:EN-US'> </span><span style='mso-bidi-font-family:
  "Courier New"'>нажатии</span><span style='mso-bidi-font-family:"Courier New";
  mso-ansi-language:EN-US'> </span><span style='mso-bidi-font-family:"Courier New"'>левой</span><span
  style='mso-bidi-font-family:"Courier New";mso-ansi-language:EN-US'> </span><span
  style='mso-bidi-font-family:"Courier New"'>кнопки</span><span
  style='mso-bidi-font-family:"Courier New";mso-ansi-language:EN-US'> </span><span
  style='mso-bidi-font-family:"Courier New"'>зарегистрировать</span><span
  lang=EN-US style='mso-bidi-font-family:"Courier New";mso-ansi-language:EN-US'><br>
  //</span><span style='mso-bidi-font-family:"Courier New"'>функцию</span><span
  style='mso-bidi-font-family:"Courier New";mso-ansi-language:EN-US'> </span><span
  style='mso-bidi-font-family:"Courier New"'>фоновой</span><span
  style='mso-bidi-font-family:"Courier New";mso-ansi-language:EN-US'> </span><span
  style='mso-bidi-font-family:"Courier New"'>обработки</span><span lang=EN-US
  style='mso-bidi-font-family:"Courier New";mso-ansi-language:EN-US'> (</span><span
  style='mso-bidi-font-family:"Courier New"'>поворота</span><span lang=EN-US
  style='mso-bidi-font-family:"Courier New";mso-ansi-language:EN-US'>)<br>
  //</span><span style='mso-bidi-font-family:"Courier New"'>При</span><span
  style='mso-bidi-font-family:"Courier New";mso-ansi-language:EN-US'> </span><span
  style='mso-bidi-font-family:"Courier New"'>нажатии</span><span
  style='mso-bidi-font-family:"Courier New";mso-ansi-language:EN-US'> </span><span
  style='mso-bidi-font-family:"Courier New"'>правой</span><span lang=EN-US
  style='mso-bidi-font-family:"Courier New";mso-ansi-language:EN-US'> – </span><span
  style='mso-bidi-font-family:"Courier New"'>отменить</span><span
  style='mso-bidi-font-family:"Courier New";mso-ansi-language:EN-US'> </span><span
  style='mso-bidi-font-family:"Courier New"'>регистрацию</span><span
  lang=EN-US style='mso-bidi-font-family:"Courier New";mso-ansi-language:EN-US'><br>
  void mouse(int button,int state,int x,int y)<br>
  {<br>
  switch(button)<br>
  {<br>
  case GLUT_LEFT_BUTTON:<br>
  if (state==GLUT_DOWN) glutIdleFunc(spinDisplay); break; <o:p></o:p></span></p>
  <p class=text align=left style='text-align:left'><span lang=EN-US
  style='mso-bidi-font-family:"Courier New";mso-ansi-language:EN-US'>case
  GLUT_RIGHT_BUTTON: if (state==GLUT_DOWN) glutIdleFunc(NULL); break;<br>
  }<br>
  } <o:p></o:p></span></p>
  <p class=text align=left style='text-align:left'><span lang=EN-US
  style='mso-bidi-font-family:"Courier New";mso-ansi-language:EN-US'>//</span><span
  style='mso-bidi-font-family:"Courier New"'>Запросить</span><span
  style='mso-bidi-font-family:"Courier New";mso-ansi-language:EN-US'> </span><span
  style='mso-bidi-font-family:"Courier New"'>режим</span><span
  style='mso-bidi-font-family:"Courier New";mso-ansi-language:EN-US'> </span><span
  style='mso-bidi-font-family:"Courier New"'>двойной</span><span
  style='mso-bidi-font-family:"Courier New";mso-ansi-language:EN-US'> </span><span
  style='mso-bidi-font-family:"Courier New"'>буферизации</span><span
  lang=EN-US style='mso-bidi-font-family:"Courier New";mso-ansi-language:EN-US'><br>
  //</span><span style='mso-bidi-font-family:"Courier New"'>Зарегистрировать</span><span
  style='mso-bidi-font-family:"Courier New";mso-ansi-language:EN-US'> </span><span
  style='mso-bidi-font-family:"Courier New"'>функции</span><span
  style='mso-bidi-font-family:"Courier New";mso-ansi-language:EN-US'> </span><span
  style='mso-bidi-font-family:"Courier New"'>обработки</span><span
  style='mso-bidi-font-family:"Courier New";mso-ansi-language:EN-US'> </span><span
  style='mso-bidi-font-family:"Courier New"'>мышиного</span><span
  style='mso-bidi-font-family:"Courier New";mso-ansi-language:EN-US'> </span><span
  style='mso-bidi-font-family:"Courier New"'>ввода</span><span lang=EN-US
  style='mso-bidi-font-family:"Courier New";mso-ansi-language:EN-US'><br>
  int main(int argc, char **argv)<br>
  {<br>
  glutInit(&amp;argc,argv);<br>
  glutInitDisplayMode(GLUT_DOUBLE|GLUT_RGB);<br>
  glutInitWindowSize(250,250);<br>
  glutInitWindowPosition(100,100);<br>
  glutCreateWindow(&quot;</span><span style='mso-bidi-font-family:"Courier New"'>Двойная</span><span
  style='mso-bidi-font-family:"Courier New";mso-ansi-language:EN-US'> </span><span
  style='mso-bidi-font-family:"Courier New"'>буферизация</span><span
  lang=EN-US style='mso-bidi-font-family:"Courier New";mso-ansi-language:EN-US'>&quot;);<br>
  init();<br>
  glutDisplayFunc(display);<br>
  glutReshapeFunc(reshape);<br>
  glutMouseFunc(mouse);<br>
  glutMainLoop(); <o:p></o:p></span></p>
  <p class=text align=left style='text-align:left'><span style='mso-bidi-font-family:
  "Courier New"'>return 0;<br>
  } <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Verdana'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><a name=Глава2><span style='display:none;mso-hide:all'><o:p>&nbsp;</o:p></span></a></p>

<p class=MsoNormal><span style='mso-bookmark:Глава2'><span style='display:none;
mso-hide:all'><o:p>&nbsp;</o:p></span></span></p>

<h1 align=left style='text-align:left'><span style='mso-bookmark:Глава2'>Глава
2. Управление состоянием и рисование геометрических объектов</span></h1>

<span style='mso-bookmark:Глава2'></span>

<p class=MsoNormal><a href="mailto:ahinar@list.ru"></a><span style='font-size:
10.0pt;font-family:Verdana'><span style='mso-spacerun:yes'> </span>Хотя вы
можете рисовать сложные и интересные картины, используя OpenGL, все они
конструируются из небольшого набора примитивных графических элементов. Это не
должно быть новостью – ведь Леонардо да Винчи работал лишь карандашами и
кистями.<o:p></o:p></span></p>

<h2>2.1 Необходимые приготовления</h2>

<p class=text align=left style='text-align:left'>В данном разделе будет
объяснено, как очистить окно до того как рисовать в нем, как устанавливать
цвета объектов, которые будут нарисованы, и как заставить процесс рисования
завершиться. Ни одна из этих операций не имеет прямого отношения к графическим
объектам, но любая программа, рисующая объекты, вынуждена иметь с ними дело.</p>

<h2>2.1.1 Очистка окна</h2>

<p class=text align=left style='text-align:left'>Рисование на экране компьютера
отличается от рисования на бумаге, так как бумага изначально является белой и
все, что вам нужно сделать – это нарисовать изображение. В случае компьютера,
память, хранящая изображение, обычно заполнена последней нарисованной
картинкой, так что нужно предварительно очистить ее некоторым цветом фона, до
начала того, как вы начнете рисовать новую сцену. Используемый цвет фона обычно
зависит от типа приложения. Для текстового редактора вы можете использовать
белый цвет (цвет бумаги) перед тем как выводить текст. Если вы создаете вид из
космического корабля, вы очищаете экран черным цветом перед тем, как рисовать
на нем звезды, планеты и корабли пришельцев. В некоторых случаях вам вообще нет
необходимости очищать экран, например, если вы изображаете некоторую сцену
внутри комнаты, все графическое окно будет заполнено после того, как вы
нарисуете все стены.К этому моменту вы можете задать вопрос: почему мы
постоянно говорим об <i>очистке</i> окна – почему просто не нарисовать
прямоугольник нужного цвета и такого размера, чтобы он перекрыл все окно?
Во-первых, специализированная команда очистки экрана может быть намного более
эффективно реализована, чем команды общего назначения. Кроме того, как вы
увидите позже, OpenGL позволяет устанавливать координатную систему, положение
наблюдателя и направление обзора, так что может быть достаточно сложно выяснить
нужный размер и положение для очищающего прямоугольника. И, наконец, на многих
компьютерах графическая аппаратура включает несколько буферов, а не только тот,
в котором содержатся пиксели текущего изображения. Эти буферы должны также
очищаться время от времени, и довольно удобно иметь одну единую команду,
которая может очищать любую их комбинацию.Вы также должны знать, как цвета
пикселей хранится в графической аппаратуре, называемой <i>битовыми плоскостями</i>.
Существует два метода хранения. Либо непосредственно красное, зеленое, синее и
альфа – значения (RGBA) пикселя сохраняются в битовых плоскостях, либо там
сохраняется единственный индекс, ссылающийся на цветовую таблицу. RGBA – режим
в наше время используется более часто. До поры до времени вы можете
игнорировать присутствие альфа – значения и не пытаться понять, что оно
означает.Как пример, следующие строки кода очищают окно в RGBA – режиме в белый
цвет: </p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>glClearColor(1.0,1.0,1.0,0.0);<br>
  glClear(GL_COLOR_BUFFER_BIT); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Первая строка белый цвет в
качестве очищающего, а следующая – очищает все окно этим цветом. Единственный
параметр <b>glClear()</b> указывает, какие буферы надо очистить. В нашем случае
программа очищает только цветовой буфер, где находится текущее изображение,
отображаемое на экране (или где находится предыдущее изображение, если вы
используете двойную буферизацию). Обычно, вы устанавливаете очищающий цвет
единожды, где-то в начале программы, а затем чистите буферы так часто, как это
необходимо. OpenGL сохраняет значение очищающего цвета в виде переменной
состояния и не требует указывать его каждый раз при очистке буферов.Например,
чтобы очистить не только буфер цвета, но и буфер глубины, следует использовать
следующую последовательность команд:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>glClearColor(1.0,1.0,1.0,0.0);<br>
  glClearDepth(1.0);<br>
  glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>В этом случае вызов <b>glClearColor()</b>
идентичен предыдущему, команда <b>glClearDepth()</b> указывает значение,
которое будет присвоено каждому пикселю в буфере глубины, и параметр команды <b>glClear()</b>
теперь состоит из двух констант, указывающих, какие буферы нужно очищать,
объединенных логическим ИЛИ. Следующая информация по команде <b>glClear()</b>
включает таблицу с именами буферов, которые можно очищать и соответствующие им
константы. </p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glClearColor</b>
  (GLclampf <i>red</i>, GLclampf <i>green</i>, GLclampf <i>blue</i>, GLclampf <i>alpha</i>);
  <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Устанавливает текущий цвет
очистки буфера цвета в RGBA – режиме. Если необходимо, значения <i>red</i>, <i>green</i>,
<i>blue</i> и <i>alpha</i> приводятся к диапазону [0, 1]. Цвет очистки по умолчанию
черный, то есть (0.0,0.0,0.0,0.0). </p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>glClear</b>
  (GLbitfield <i>mask</i>); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Очищает указанные буферы
указанными для них величинами очистки. Аргумент <i>mask</i> – это битовая
комбинация констант, перечисленных в таблице 2-1, полученная операцией ИЛИ.</p>

<p class=text align=left style='text-align:left'>Таблица 2-1. Буферы, которые
можно очищать</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Название буфера </span></strong><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Соответствующая константа </span></strong><span
  style='font-size:8.0pt;font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Буфер цвета <o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_COLOR_BUFFER_BIT<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Буфер глубины<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_DEPTH_BUFFER_BIT<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Буфер аккумуляции (аккумулятор)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_ACCUM_BUFFER_BIT<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Буфер трафарета<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_STENCIL_BUFFER_BIT <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>До того, как выполнять команду
очистки нескольких буферов, вы должны установить очищающие значения для каждого
из них, если хотите получить что-то кроме значений по умолчанию для RGBA –
цвета, значения глубины, цвета аккумуляции и индекса трафарета. В дополнение к
командам <b>glClearColor()</b> и <b>glClearDepth()</b> установки значений
очистки для буфера цвета и буфера глубины, <b>glClearIndex()</b>, <b>glClearAccum()</b>
и <b>glClearStencil()</b> указывают <i>цветовой индекс</i>, цвет аккумуляции и
индекс трафарета, которые будут использоваться для очистки соответствующих
буферов.</p>

<p class=text align=left style='text-align:left'>OpenGL позволяет указывать в
одной команде несколько буферов потому, что очистка, как правило, процесс
медленный, поскольку затрагивается каждый пиксель (а их могут быть миллионы), в
то же время некоторая графическая аппаратура позволяет запараллелевать процессы
очистки нескольких буферов. Аппаратура, которая не позволяет этого, выполняет
процессы очистки последовательно. Разница между</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
  <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>и</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>glClear(GL_COLOR_BUFFER_BIT);<br>
  glClear(GL_DEPTH_BUFFER_BIT) <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>заключается в том, что хотя
финальный эффект и одинаков, первый фрагмент на многих машинах может
выполняться быстрее и уж в любом случае не будет работать медленнее.</p>

<h2>2.1.1&nbsp; Установка цвета</h2>

<p class=text align=left style='text-align:left'>В OpenGL описание контура
рисуемого объекта не зависит от описания его цвета. Когда бы ни рисовался
геометрический объект, он рисуется с использованием текущей установленной
цветовой схемы. Цветовая схема может быть простой («рисовать все красным
цветом») или очень сложной («предположить, что объект сделан из голубого
пластика, на нем два ярко-желтых отблеска здесь и здесь и по всей сцене
распространяется слабый зеленый свет»). Обобщенно, программист сначала
устанавливает цвет или цветовую схему и затем рисует объекты. Пока цвет или
цветовая схема не изменены, все объекты рисуются с использованием
установленного цвета или цветовой схемы. Этот метод позволяет OpenGL –
программам достигать большего быстродействия, чем в том случае, если бы
библиотека не отслеживала текущий цвет.</p>

<p class=text align=left style='text-align:left'>Например, следующий псевдокод</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>Установить_текущий_цвет(красный);<br>
  Нарисовать_объект(A);<br>
  Нарисовать_объект(B);<br>
  Установить_текущий_цвет(зеленый);<br>
  Установить_текущий_цвет(синий);<br>
  Нарисовать_объект(C);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>рисует объекты A и B красным
цветом, а C – синим. Команда на 4 строке, которая устанавливает текущий цвет в
зеленый не имеет эффекта, так как сразу за ней (до каких-либо команд рисования)
в 5 строке текущий цвет вновь меняется, на этот раз, на синий.</p>

<p class=text align=left style='text-align:left'>Чтобы установить цвет,
используйте команду <b>glColor3f()</b>. Она принимает 3 параметра, каждый из
которых является числом с плавающей точкой в диапазоне между 0.0 и 1.0. Эти
параметры, по порядку, указывают красный, зеленый и синий <i>компоненты</i>
цвета. Вы можете думать об этих трех величинах как о задающих смесь из
красного, зеленого и синего цветов: 0.0 означает, что мы совсем не используем
данный компонент, 1.0 означает максимальное использование компонента. Таким
образом, код</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>glColor3f(1.0,0.0,0.0); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>делает текущий цвет ярко
красным настолько, насколько его может изобразить ваша система, а зеленый и
синий компоненты полностью отсутствуют. Если задать все нули, получится черный;
если задать все единицы, получится белый, если установить три величины равными
0.5 – получится серый (полпути между черным и белым). Далее приведены 8 команд
и цвета, которые они устанавливают.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>glColor3f(0.0,0.0,0.0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  черный<br>
  glColor3f(1.0,0.0,0.0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; красный<br>
  glColor3f(0.0,1.0,0.0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; зеленый<br>
  glColor3f(1.0,1.0,0.0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; желтый<br>
  glColor3f(0.0,0.0,1.0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; синий<br>
  glColor3f(1.0,0.0,1.0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; фиолетовый<br>
  glColor3f(0.0,1.0,1.0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; голубой<br>
  glColor3f(1.0,1.0,1.0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; белый <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<h2>2.1.2&nbsp; Приказ завершить рисование</h2>

<p class=text align=left style='text-align:left'>Как вы видели в разделе
«Конвейер визуализации OpenGL» главы 1, о большинстве современных графических
систем можно думать как о линии сборки. Центральный процессор (Central
Processing Unit – CPU) выполняет команду рисования. Возможно, иная аппаратура
производит геометрические трансформации. Производится отсечение, заливка и/или
текстурирование. Наконец, значения записываются на битовые плоскости для
отображения. В high-end архитектурах каждая из этих операций производится
отдельной частью аппаратуры, и каждая часть разработана таким образом, чтобы
очень быстро выполнять свою специфическую задачу. В таких архитектурах CPU не
нужно ждать пока завершится предыдущая команда рисования, чтобы начать
выполнение следующей. Пока CPU посылает вершину на конвейер, аппаратура
трансформации обрабатывает предыдущую, в то же время та вершина, что была до
нее, проходит этап отсечения и так далее. В таких системах ожидание CPU
завершения каждой команды, до начала выполнения следующей может привести к
изрядной потере быстродействия.</p>

<p class=text align=left style='text-align:left'>Кроме того, приложение может
выполняться более, чем на одном компьютере. Предположим, например, что
программа запущена на какой-нибудь машине (называемой клиентом), а вы
просматриваете результат рисования на своей рабочей станции или терминале
(называемом сервером), который подключен к клиенту через сеть. В этом случае
отправление каждой команды по сети по одной за раз может быть чудовищно
неэффективным, поскольку с каждой сетевой пересылкой могут быть связаны
серьезные затраты процессорных ресурсов, а также временные затраты. Обычно,
клиент объединяет несколько команд в один сетевой пакет перед тем, как его
отправлять. К несчастью, сетевой код на клиентской стороне обычно не знает (и у
него нет пути узнать), что графическая программа завершила рисование кадра или
сцены. В худшем случае этот код будет вечно дожидаться дополнительных команд,
которые нужны ему, чтобы заполнить пакет, и вы никогда не увидите финальное изображение.</p>

<p class=text align=left style='text-align:left'>По этой причине OpenGL
предоставляет команду <b>glFlush()</b>, которая заставляет клиента отправить
сетевой пакет даже в том случае, если он не полон. Если сети нет, и все команды
действительно выполняются немедленно на сервере, <b>glFlush()</b> может не
иметь никакого эффекта. Однако, если вы пишете программу и хотите, чтобы она
работала верно и в отсутствие и при наличии сети, вам следует включить вызов <b>glFlush()</b>
в конце каждого кадра или сцены. Обратите внимание на то, что <b>glFlush()</b>
не ждет, пока закончится рисование – она просто заставляет начать выполнение
рисования, таким образом, гарантируя, что все предыдущие команды будут <i>выполнены</i>
за конечное время, даже если больше команд рисования не поступит.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l44 level1 lfo1;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Существуют и другие ситуации, в которых <b>glFlush()</b>
может быть полезной:</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l44 level1 lfo1;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Программные построители изображений, строящие их
в системной памяти и не желающие постоянно обновлять экран.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l44 level1 lfo1;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Реализации, которые амортизируют цену старта
процесса за счет аккумулирования нескольких команд. Пример этого – описанная
выше ситуация с сетью.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>glFlush</b>(void); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Заставляет начать исполнение
вызванных команд OpenGL, гарантируя, тем самым, что они выполнятся за некоторое
конечное время.</p>

<p class=text align=left style='text-align:left'>Некоторые команды – например,
команды переключения буферов в режиме двойной буферизации – автоматически
выполняют <b>glFlush()</b> (или иную схожую операцию) до того, как сами могут
выполниться.</p>

<p class=text align=left style='text-align:left'>Если вам недостаточно <b>glFlush()</b>
попробуйте использовать <b>glFinish()</b>. Эта команда действует аналогично <b>glFlush()</b>,
а затем ждет от аппаратуры или сети подтверждения о том, что рисование в буфере
кадра окончено. <b>glFinish()</b> может понадобиться, если вы хотите
синхронизировать задачи – например, убедиться, что ваша трехмерная картина на
экране, чтобы потом с помощью Display PostScript нарисовать поверх нее заметки.
Другой пример, если вы хотите убедиться в том, что картинка нарисована, чтобы
начать принимать пользовательский ввод. После вызова <b>glFinish()</b>
программа блокируется до тех пор, пока не поступит подтверждение от аппаратуры,
что рисование окончено. Имейте ввиду, что чрезмерно частое использование <b>glFinish()</b>
может сильно понизить быстродействие приложения особенно в том случае, если оно
запускается по сети, так как <b>glFinish()</b> требует двустороннего сетевого
обмена между клиентом и сервером. Если для ваших нужд достаточно <b>glFlush()</b>,
используйте ее вместо <b>glFinish()</b>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>glFinish</b>(void);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Заставляет завершиться все
ранее вызванные команды OpenGL. Выхода из этой команды не происходит, пока все
ранее вызванные команды не отработают полностью.</p>

<h2>2.2&nbsp; Необходимые знания о координатных системах</h2>

<p class=text align=left style='text-align:left'>Если вы только что создали
окно, или передвинули имеющееся, или изменили его размер – во всех этих случаях
оконная система посылает сообщение уведомления в программу. Если в программе
используется GLUT, обработка уведомления автоматизирована – при получении
сообщения будет вызвана любая функция, зарегистрированная с помощью <b>glutReshapeFunc()</b>.
Обычно такая функция обратного вызова должна:</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l56 level1 lfo2;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Заново установить прямоугольный регион, в
который будет осуществляться вывод.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l56 level1 lfo2;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Определить координатную систему, которая будет
использоваться при рисовании объектов.</p>

<p class=text align=left style='text-align:left'>Функция в следующем примере
2-1 определяет простую двумерную систему координат.</p>

<p class=text align=left style='text-align:left'>Пример 2-1. Определение
простой двумерной координатной системы</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void
  reshape(int w, int h)<br>
  {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glViewport(0,0,(GLsizei)w, (GLsizei)h);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glMatrixMode(GL_PROJECTION);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glLoadIdentity();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gluOrtho2D(0,0,(GLdouble)w, (GLdouble)h);<br>
  } <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Внутренние части GLUT передают
этой функции два аргумента: длину и высоту (в пикселях) измененного окна. <b>glViewport()</b>
подгоняет размеры прямоугольника, в который осуществляется графический вывод
под размер всего окна. Три следующих вызова определяют координатную систему для
рисования таким образом, чтобы левый нижний угол имел координаты (0,0), в
правый верхний (<i>w</i>,<i>h</i>) (рисунок 2-1).</p>

<p class=text align=left style='text-align:left'>Представьте себе лист бумаги –
миллиметровки. В этом случае значения <i>w</i> и <i>h</i> в функции <b>reshape()</b>
представляют собой количество квадратов по строкам и столбцам листа. Далее вам
нужно определиться с осями координат. <b>gluOrtho2D()</b> помещает начало
координат в самый левый нижний квадрат листа и указывает, что каждый квадрат
представляет собой одну единицу. Теперь, когда вы будете рисовать точки, линии
и полигоны, они будут появляться на бумаге в легко предсказуемых квадратах.</p>

<p class=text align=left style='text-align:left'>Рисунок 2-1. Координатная
система, определенная величинами <i>w</i>=50 и <i>h</i>=50</p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1028" type="#_x0000_t75" alt="" style='width:180.75pt;height:185.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image004.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов2.mht!http://www.progz.ru/images/opengl/chapter2/2-1.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=241 height=247
src="OpenGL%20Red%20Book.files/image004.jpg" v:shapes="_x0000_i1028"><![endif]><o:p></o:p></span></p>

<h2>2.3 Описание точек, линий и полигонов</h2>

<p class=text align=left style='text-align:left'>Этот раздел объясняет, как
описывать геометрические примитивы в OpenGL. Все геометрические примитивы
описываются в терминах своих <i>вершин</i> – координат, которые определяют сами
точки примитива, конечные точки линии или углы полигона. Следующая секция
объясняет, как отображаются эти примитивы, и как вы можете контролировать их
отображение.</p>

<h2>2.3.1&nbsp; Что такое точки, линии и полигоны?</h2>

<p class=text align=left style='text-align:left'>Вероятно, у вас имеется
некоторое представление о математическом смысле терминов точка, линия и
полигон. Их смысл в OpenGL почти тот же самый, но не идентичный.</p>

<p class=text align=left style='text-align:left'>Одно из различий проистекает
из ограничений на компьютерные расчеты. В любой реализации OpenGL числа с
плавающей точкой имеют конечную точность и, следовательно, могут возникать
ошибки, связанные с округлением. Как следствие, координаты точек, линий и
полигонов в OpenGL страдают этим же недостатком. </p>

<p class=text align=left style='text-align:left'>Более важное различие
проистекает из ограничений растровых дисплеев. На таких дисплеях наименьшим
отображаемым элементом является пиксель и, хотя пиксель по размеру может быть
меньше 1/100 дюйма, он все равно значительно больше, чем математические понятия
бесконечно малого элемента (для точек) и бесконечно короткого (для линий).
Когда OpenGL производит вычисления, она предполагает, что точки представлены в
виде векторов с координатами в формате с плавающей точкой. Однако точка, как
правило (но не всегда), отображается на дисплее в виде одного пикселя, и
несколько точек, имеющих слегка различающиеся координаты, OpenGL может
нарисовать на одном и том же пикселе.</p>

<h2>2.3.1.1 Точки</h2>

<p class=text align=left style='text-align:left'>Точка определяется набором
чисел с плавающей точкой, называемым вершиной. Все внутренние вычисления
производятся в предположении, что координаты заданы в трехмерном пространстве.
Для вершин, которые пользователь определил как двумерные (то есть задал только
x- и y-координаты), OpenGL устанавливает z-координату равной 0.</p>

<p class=text align=left style='text-align:left'><b>Дополнительно:</b> OpenGL
работает в <i>однородных координатах</i> трехмерной проекционной геометрии,
таким образом, во внутренних вычислениях все вершины представлены четырьмя
числами с плавающей точкой (x,y,z,w). Если w отлично от 0, то эти координаты в
Евклидовой геометрии соответствуют точке (x/w,y/w,z/w). Вы можете указывать
w-координату в командах OpenGL, но это делается достаточно редко. Если
w-координата не указана, она принимается равной 1.0. </p>

<h2>2.3.1.2 Линии</h2>

<p class=text align=left style='text-align:left'>В OpenGL термин линия
относится к сегменту прямой (отрезку), а не к математическому понятию прямой,
которая предполагается бесконечной в обоих направлениях. Достаточно просто
задавать серию соединенных отрезков или даже закрытую последовательность
отрезков (рисунок 2-2). В любом случае отрезки описываются в терминах вершин на
их концах.</p>

<p class=text align=left style='text-align:left'>Рисунок 2-2. Два примера
соединенных сегментов линий (ломаная и замкнутая ломаная)</p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1029" type="#_x0000_t75" alt="" style='width:388.5pt;height:141.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image005.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов2.mht!http://www.progz.ru/images/opengl/chapter2/2-2.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=518 height=189
src="OpenGL%20Red%20Book.files/image005.jpg" v:shapes="_x0000_i1029"><![endif]><o:p></o:p></span></p>

<h2>2.3.1.3 Полигоны</h2>

<p class=text align=left style='text-align:left'>Полигон (или многоугольник) –
это область, ограниченная одной замкнутой ломаной, при этом каждый отрезок
ломаной описывается вершинами на его концах (вершинами полигона). Обычно
полигоны рисуются заполненными, но вы можете также рисовать полигоны в виде их
границ или в виде точек на концах отрезков, образующих полигон.</p>

<p class=text align=left style='text-align:left'>В общем случае полигоны могут
быть достаточно сложны, поэтому OpenGL накладывает очень серьезные ограничения
в отношении того, что считается полигональным примитивом. Во-первых, ребра
полигонов в OpenGL не могут пересекаться (в математике полигон, удовлетворяющий
этому условию, называется <i>простым</i>). Во-вторых, полигоны OpenGL должны
быть выпуклыми. Полигон является выпуклым, если отрезок, соединяющий две точки
полигона (точки могут быть и внутренними, и граничными) целиком лежит внутри
полигона (то есть все его точки также принадлежат полигону). На рисунке 2-3
приведены примеры нескольких допустимых и недопустимых полигонов. OpenGL не
накладывает ограничений на количество вершин полигона (и, как следствие, на
количество отрезков, определяющих его границу). Заметьте, что полигоны с дырами
не могут быть описаны, так как они не являются выпуклыми, и могут быть заданы
при помощи одной замкнутой ломаной. Если вы поставите OpenGL перед вопросом о
рисовании <i>невыпуклого</i> полигона, результат может быть не таким, какой вы
ожидаете. Например, на большинстве систем в ответ будет заполнена только
выпуклая оболочка полигона (на многих системах не произойдет и этого).</p>

<p class=text align=left style='text-align:left'>Рисунок 2-3. Допустимые и
недопустимые полигоны</p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1030" type="#_x0000_t75" alt="" style='width:427.5pt;height:108pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image006.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов2.mht!http://www.progz.ru/images/opengl/chapter2/2-3.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=570 height=144
src="OpenGL%20Red%20Book.files/image006.jpg" v:shapes="_x0000_i1030"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Причина, по которой OpenGL накладывает
подобные ограничения, заключается в том, что в аппаратуру намного проще
заложить функции визуализации некоторого определенного класса полигонов.
Простые полигоны визуализировать легко. Трудные случаи тяжело обнаружить
быстро. Для увеличения быстродействия OpenGL «скрещивает пальцы» и
предполагает, что все полигоны простые.</p>

<p class=text align=left style='text-align:left'>Многие реальные поверхности
состоят их непростых полигонов, невыпуклых полигонов или полигонов с дырами.
Поскольку каждый из таких полигонов может быть представлен в виде набора
простых выпуклых полигонов, в библиотеке GLU имеется набор методов для
построения более сложных объектов. Эти методы принимают описание сложного
полигона и выполняют <i>тесселяцию</i> (<i>teselation</i>), то есть разбиение
сложного полигона на группы более простых OpenGL – полигонов, которые в
последствие могут быть визуализированы и отображены.</p>

<p class=text align=left style='text-align:left'>Поскольку вершины в OpenGL
всегда трехмерны, точки, формирующие границу каждого конкретного полигона, не
обязательно лежат на одной плоскости пространства. (Конечно, во многих случаях
они лежат на одной плоскости – например, если z-координаты всех точек равны 0
или если полигон является <i>треугольником</i>.)</p>

<p class=text align=left style='text-align:left'>Если вершины полигона не лежат
в одной плоскости, то после различных пространственных трансформаций, изменения
точки наблюдения и проецирования на экран дисплея может оказаться, что эти
точки уже не определяют простой выпуклый полигон. Представим себе
четырехугольник, в котором точки немного отклоняются от единой плоскости, и
посмотрим на него со стороны ребра. В таких условиях может оказаться, что
полигон не является простым и, как следствие, может быть не визуализирован
верно (рисунок 2-4). Ситуация не является такой уж необычной в случае если вы
аппроксимируете изогнутые поверхности с помощью четырехугольников. Однако вы
всегда можете избежать подобных проблем, применяя треугольники, так как три
отдельно взятые точки всегда лежат в одной плоскости.</p>

<p class=text align=left style='text-align:left'>Рисунок 2-4. Пример неплоского
полигона, трансформированного в непростой</p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1031" type="#_x0000_t75" alt="" style='width:462.75pt;height:114.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image007.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов2.mht!http://www.progz.ru/images/opengl/chapter2/2-4.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=617 height=153
src="OpenGL%20Red%20Book.files/image007.jpg" v:shapes="_x0000_i1031"><![endif]><o:p></o:p></span></p>

<h2>2.3.1.4 Квадраты</h2>

<p class=text align=left style='text-align:left'>Поскольку квадраты часто
встречаются в графических приложениях, OpenGL предоставляет примитив, рисующий
заполненный квадрат и его команду <b>glRect*()</b>. Вы можете нарисовать
квадрат как полигон, но в вашей конкретной реализации OpenGL <b>glRect*()</b>
для квадратов может быть реализована более рационально.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glRect</b>{<b>sifd</b>}
  (TYPE <i>x1</i>, TYPE <i>y1</i>, TYPE <i>x2</i>, TYPE <i>y2</i>);<br>
  void <b>glRect</b>{<b>sifd</b>}<b>v</b> (TYPE *<i>v1</i>, TYPE *<i>v2</i>); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Рисует квадрат, определяемый
угловыми точками (<i>x1</i>,<i>y1</i>) и (<i>x2</i>,<i>y2</i>). Квадрат лежит в
плоскости <i>z</i>=0 и его стороны параллельны осям абсцисс и ординат. Если
используется векторная форма функции, углы задаются в виде двух указателей на
массивы, каждый из которых содержит пару (<i>x</i>,<i>y</i>).</p>

<p class=text align=left style='text-align:left'>Заметьте, что хотя по
умолчанию квадрат имеет определенную ориентацию в трехмерном пространстве, вы
можете изменить это за счет применения вращения или других трансформаций.</p>

<h2>2.3.1.5&nbsp;&nbsp;&nbsp; Кривые и изогнутые поверхности</h2>

<p class=text align=left style='text-align:left'>Любая плавная кривая или
поверхность может быть аппроксимирована с любой степенью точности короткими
отрезками или полигональными регионами. Таким образом, достаточное разделение
кривых или поверхностей на прямые отрезки или плоские полигоны может привести к
тому, что они по-прежнему будут выглядеть плавно изогнутыми (рисунок 2-5). Если
у вас есть сомнения относительно того, что это действительно работает,
представьте такое разбиение, при котором каждый отрезок или полигон короче или
меньше пикселя.</p>

<p class=text align=left style='text-align:left'>Рисунок 2-5. Аппроксимация кривых</p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1032" type="#_x0000_t75" alt="" style='width:5in;height:108pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image008.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов2.mht!http://www.progz.ru/images/opengl/chapter2/2-5.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=480 height=144
src="OpenGL%20Red%20Book.files/image008.jpg" v:shapes="_x0000_i1032"><![endif]><o:p></o:p></span></p>

<h2>2.3.2 Указание вершин</h2>

<p class=text align=left style='text-align:left'>При использовании OpenGL
каждый геометрический объект однозначно описывается в виде упорядоченного
набора вершин. Для указания вершины используется команда <b>glVertex*()</b>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=text align=left style='text-align:left'><span lang=EN-US
  style='mso-bidi-font-family:"Courier New";mso-ansi-language:EN-US'>void <b>glVertex</b>{<b>234</b>}{<b>sifd</b>}(TYPE
  <i>coords</i>);<br>
  void <b>glVertex</b>{<b>234</b>}{<b>sifd</b>}<b>v</b>(const TYPE *<i>coords</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Указывает одну вершину для
использования в описании геометрического объекта. Для каждой вершины вы можете
указывать от 2 (x,y) до 4 координат (x,y,z,w), выбирая соответствующую версию
команды. Если используется версия, где в явном виде не задаются z или w, то z
принимается равным 0, а w – равным 1. Вызовы <b>glVertex*()</b> имеют силу
только между вызовами команд <b>glBegin()</b> и <b>glEnd()</b>.</p>

<p class=text align=left style='text-align:left'>В примере 2-2 приводятся
некоторые варианты использования <b>glVertex*()</b>.</p>

<p class=text align=left style='text-align:left'>Пример 2-2. Варианты
допустимого использования glVertex*()</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>glVertex2s(1,5);<br>
  glVertex3d(0.7,5.224,3.1415926535898);<br>
  glVertex4f(2.1,1.3,-2.0,2.0);<br>
  &nbsp;<br>
  GLdouble dvect[3]={5.0,9.0,1992.0};<br>
  glVertex3dv(dvect);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Первый пример представляет
собой определение вершины с координатами в трехмерном пространстве (1,5,0).
(Вспомните, что если z не указано явно, оно принимается равным 0.) Координаты во
втором примере (0.7,5.224,3.1415926535898) (числа с плавающей точкой двойной
точности). В третьем примере указывается вершина с трехмерными координатами
(1.05, 0.65,&nbsp; -1.0). (В этом примере координаты указаны в однородном виде
и для приведения их к более привычному следовало разделить первые три цифры на
последнюю <i>w</i>=2.0.) В последнем примере <i>dvect</i> – это указатель на
массив, содержащий три дробных числа двойной точности.</p>

<p class=text align=left style='text-align:left'>На некоторых машинах векторная
форма <b>glVertex*()</b> работает более эффективно, поскольку в графическую
подсистему требуется передать только один параметр. Отдельная аппаратура может
быть способна отправлять целые серии команд в одном пакете. Если ваша машина
одна из таких, вам может быть выгодно организовывать данные таким образом,
чтобы координаты вершин были последовательно упакованы в памяти. В этом случае
можно достичь некоторого увеличения быстродействия за счет использования
операций с массивами вершин OpenGL.</p>

<h2>2.3.3 Рисование геометрических примитивов</h2>

<p class=text align=left style='text-align:left'>Теперь, когда вы знаете, как
задавать вершины, вам все еще нужно узнать, как заставить OpenGL создать из
этих вершин набор точек, линию или полигон. Для того чтобы это сделать, вам
следует обрамить каждый набор вершин вызовами команд <b>glBegin()</b> и <b>glEnd()</b>.
Аргумент, передаваемый <b>glBegin()</b>, определяет, какие графические
примитивы создаются на основе вершин. Пример 2-3 задает вершины для полигона на
рисунке 2-6.</p>

<p class=text align=left style='text-align:left'>Рисунок 2-6. Рисуем полигон
или набор точек.</p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1033" type="#_x0000_t75" alt="" style='width:340.5pt;height:119.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image009.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов2.mht!http://www.progz.ru/images/opengl/chapter2/2-6.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=454 height=159
src="OpenGL%20Red%20Book.files/image009.jpg" v:shapes="_x0000_i1033"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Пример 2-3 Конструирование
полигона</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>glBegin(GL_POLYGON);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glVertex2f(0.0,0.0);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glVertex2f(0.0,3.0);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glVertex2f(4.0,3.0);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glVertex2f(6.0,1.5);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glVertex2f(4.0,0.0);<br>
  glEnd(); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Если бы вы указали GL_POINTS
вместо GL_POLYGON в качестве примитивов, были бы построены пять точек,
показанных на рисунке 2-6. В таблице 2-2 перечислены возможные аргументы
команды <b>glBegin()</b> и соответствующие им типы примитивов.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>glBegin</b>(GLenum <i>mode</i>);
  <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Отмечает начало блока
вершинных данных, описывающего геометрические примитивы. Тип примитивов
задается аргументом <i>mode</i>, который может принимать значения,
перечисленные в таблице 2-2.</p>

<p class=text align=left style='text-align:left'>Таблица 2-2. Значения
аргумента <i>mode</i> (имена примитивов) для glBegin() и их смысл</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Значение</span></strong><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Соответствующие примитивы </span></strong><span
  style='font-size:8.0pt;font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_POINTS <o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>индивидуальные точки <o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_LINES <o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>вершины попарно интерпретируются как самостоятельные отрезки <o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_LINE_STRIP <o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>серия соединенных отрезков (ломаная) <o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_LINE_LOOP <o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>аналогично предыдущему, но, кроме того, автоматически
  добавляется отрезок, соединяющий первую и последнюю вершины (замкнутая
  ломаная) <o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:5'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TRIANGLES <o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>каждая тройка вершин интерпретируется как треугольник <o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:6'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TRIANGLE_STRIP <o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>цепочка соединенных треугольников <o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:7'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TRIANGLE_FAN<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>веер из соединенных треугольников <o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:8'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_QUADS <o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>каждая четверка вершин интерпретируется как четырехугольный
  полигон <o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:9'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_QUAD_STRIP <o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>цепочка соединенных четырехугольников <o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:10;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_POLYGON <o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>граница простого выпуклого полигона<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>На рисунке 2-7 показаны
примеры всех геометрических примитивов, перечисленных в таблице 2-2. Обратите
внимание, что в дополнение к точкам определено также несколько типов линий и
полигонов. Безусловно, вы можете нарисовать один и тот же примитив различными
методами. Как правило, выбираемый путь зависит от характера имеющихся вершинных
данных.</p>

<p class=text align=left style='text-align:left'>Рисунок 2-7. Типы
геометрических примитивов</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1034" type="#_x0000_t75" alt="" style='width:465.75pt;height:582pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image010.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов2.mht!http://www.progz.ru/images/opengl/chapter2/2-7.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=621 height=776
src="OpenGL%20Red%20Book.files/image010.jpg" v:shapes="_x0000_i1034"><![endif]></p>

<p class=text align=left style='text-align:left'>Когда вы будете читать
следующее описание, предполагайте, что между парой <b>glBegin()</b> и <b>glEnd()</b>
задано <i>n</i> вершин (V[0], V[1], V[2], ..., V[<i>n</i>-1]). </p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_POINTS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Рисует точку на месте каждой из <i>n</i> вершин <o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_LINES<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Рисует серию несоединенных между собой отрезков. Рисуются
  отрезки между V[0] и V[1] , между V[2] и V[3], и так далее. Если <i>n</i>
  нечетно, то последний отрезок рисуется между V[<i>n</i>-3] и V[<i>n</i>-2], а
  вершина <i>n</i>-1 игнорируется.<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_LINE_STRIP <o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Рисует отрезок между V[0] и V[1], между V[1] и V[2], и так
  далее. Последний отрезок рисуется между V[<i>n</i>-2] и V[<i>n</i>-1]. Таким
  образом, создается ломаная из <i>n-1</i> отрезков. Если <i>n</i> &lt; 2 не
  отображается ничего. Не существует ограничений на вершины, описывающие
  ломаную (или замкнутую ломаную). Отрезки могут любым образом пересекаться. <o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p><span style='font-size:8.0pt;font-family:Verdana;color:black'>GL_LINE_LOOP<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>То же, что и GL_LINE_STRIP, но, кроме того, рисуется отрезок
  между V[<i>n</i>-1] и V[0], замыкающий ломаную.<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TRIANGLES<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Рисует серию треугольников (полигонов с тремя сторонами)
  используя вершины V[0], V[1] и V[2], затем V[3], V[4] и V[5], и так далее.
  Если <i>n</i> не кратно 3, последние 1 или 2 вершины игнорируются.<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:5'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TRIANGLE_STRIP <o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Рисует серию треугольников, используя вершины V[0], V[1] и V[2],
  затем V[2], V[1] и V[3] (обратите внимание на порядок), затем V[2], V[3],
  V[4], и так далее. Такой порядок гарантирует, что все треугольники будут
  иметь одинаковую ориентацию и, таким образом, соединенные треугольники могут
  сформировать часть поверхности. Сохранение ориентации очень важно для
  некоторых операций (например, для отсечения нелицевых граней). Для того,
  чтобы нарисовался хотя бы один треугольник <i>n</i> должно быть больше или
  равно 3.<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:6'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TRIANGLE_FAN<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>То же, что и GL_TRIANGLE_STRIP, но порядок вершин следующий:
  V[0], V[1], V[2], затем V[0], V[2], V[3], затем V[0], V[3], V[4], и так
  далее. <o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:7'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_QUADS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Рисует серию четырехугольников (полигонов с четырьмя сторонами),
  используя вершины V[0], V[1], V[2], V[3], затем V[4], V[5], V[6], V[7], и так
  далее. Если <i>n</i> не кратно 4, последние 1, 2 или 3 вершины игнорируются.<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:8'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_QUAD_STRIP<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Рисует серию прямоугольников, используя следующий порядок
  вершин: V[0], V[1], V[3], V[2], затем V[2], V[3], V[5], V[4], затем V[4],
  V[5], V[7], V[6] и так далее. <i>n</i> должно быть не меньше 4, иначе ничего
  не будет нарисовано. Если <i>n</i> нечетно, последняя вершина игнорируется.<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:9;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_POLYGON<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Рисует полигон, используя точки V[0], V[1], V[2], ..., V[<i>n</i>-1]
  в качестве вершин. <i>n</i> должно быть не меньше 3 или ничего нарисовано не
  будет. Кроме того, описываемый полигон не должен иметь самопересечений и
  должен быть выпуклым. Если вершины не удовлетворяют этим условиям, результат
  непредсказуем.<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<h2>2.3.3.1 Ограничения на использование glBegin() и glEnd()</h2>

<p class=text align=left style='text-align:left'>Наиболее важная информация о
вершинах – это их координаты, которые указываются командой <b>glVertex*()</b>.
Вы также можете указывать для каждой вершины специфические данные, такие как
цвет, вектор нормали, координаты текстуры или любую их комбинацию, используя
специальные команды. Кроме того, некоторые другие команды допустимы между <b>glBegin()</b>
и <b>glEnd()</b>. Таблица 2-3 содержит полный список этих команд.</p>

<p class=text align=left style='text-align:left'>Таблица 2-3. Команды, допустимые
между вызовами glBegin() и glEnd().</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Команда</span></strong><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Назначение</span></strong><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glVertex*()</span></strong><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>установка координат вершины<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glColor*()</span></strong><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>установка текущего цвета<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glIndex*()</span></strong><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>установка текущего цветового индекса<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glNormal*()</span></strong><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>установка координат вектора нормали<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:5'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glTexCoord*()</span></strong><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>установка координат текстуры<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:6'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glMultiTexCoord*ARB()</span></strong><span style='font-size:
  8.0pt;font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>установка координат текстуры при мультитекстурировании<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:7'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glEdgeFlag*()</span></strong><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>контролирует рисование ребер<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:8'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glMaterial*()</span></strong><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>установка свойств материала<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:9'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glArrayElement()</span></strong><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>выделяет данные из массива вершин<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:10'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glEvalCoords*(),</span></strong><b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><br>
  <strong><span style='font-family:Verdana'>glEvalPoint*()</span></strong></span></b><span
  style='font-size:8.0pt;font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>генерирует координаты<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:11;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glCallList(), glCallLists()</span></strong><span
  style='font-size:8.0pt;font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>выполняет список отображения<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Никакие другие команды
недопустимы между <b>glBegin()</b> и <b>glEnd()</b>, и вызов большинства других
команд OpenGL вызовет ошибку. Некоторые команды, связанные с массивами вершин,
такие как <b>glEnableClientState()</b> и <b>glVertexPointer()</b> при вызове
внутри <b>glBegin()</b> и <b>glEnd()</b> ведут к неопределенным результатам, но
не обязательно генерируют ошибку. (Аналогично, функции оконной системы,
связанные с OpenGL, такие как функции <b>glX*()</b> ведут себя неопределенным
образом между <b>glBegin()</b> и <b>glEnd()</b>.) Ошибки, связанные с
употреблением недопустимых команд, достаточно трудно обнаруживать и поэтому
таких употреблений следует избегать.</p>

<p class=text align=left style='text-align:left'>Обратите внимание, однако, что
ограничения накладываются только на команды OpenGL и функции, связанные с ней.
Вы можете свободно помещать другие языковые конструкции и вызовы между <b>glBegin()</b>
и <b>glEnd()</b>. Пример 2-4, иллюстрирующий это, рисует окружность.</p>

<p class=text align=left style='text-align:left'>Пример 2-4. Языковые
конструкции между glBegin() и glEnd()</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>#define
  PI 3.1415926535898<br>
  GLint circle_points=100;<br>
  glBegin(GL_LINE_LOOP);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(i=0;i&lt;CIRCLE_POINTS;I++)<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  angle=2*PI*i/circle_points;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  glVertex2f(cos(angle),sin(angle));<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
  glEnd(); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=warning>Замечание: В примере приведен не самый эффективный способ
рисования окружности, особенно, если вы планируете делать это часто.
Используемые графические команды обычно достаточно быстры, но в приведенном
коде для каждой вершины рассчитывается угол, и вызываются функции <b>sin()</b>
и <b>cos()</b>. Кроме того, здесь присутствует наложение конца ломаной на ее
начало. Если вам необходимо рисовать множество окружностей, вычислите
координаты вершин единожды и создайте список отображения или используйте массив
вершин. </p>

<p class=text align=left style='text-align:left'>Если только <b>glVertex*()</b>
не используются для компиляции списка отображения, все они должны вызываться
только внутри командных скобок <b>glBegin()</b> и <b>glEnd()</b>, иначе <b>glVertex*()</b>
игнорируются. Если <b>glVertex*()</b> используются внутри списка отображения,
то и в этом случае командные скобки должны присутствовать: они должны обрамлять
либо обращения к <b>glVertex*()</b> внутри списка, либо команды исполнения
готового списка (например, <b>glCallList()</b>).</p>

<p class=text align=left style='text-align:left'>Несмотря на то, что между <b>glBegin()</b>
и <b>glEnd() </b>допустимо достаточно много команд, вершина создается только
при вызове команды <b>glVertex*()</b>. В момент вызова <b>glVertex*()</b>
OpenGL ассоциирует с создаваемой вершиной текущий цвет, координаты текстуры,
информацию о векторе нормали и так далее. Чтобы убедиться в этом, посмотрите на
следующий код. Первая точка рисуется красным цветом, вторая и третья – синим,
несмотря на дополнительные команды изменения текущего цвета.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>glBegin(GL_POINTS);<br>
  glColor3f(0.0,1.0,0.0); //зеленый<br>
  glColor3f(1.0,0.0,0.0); //красный<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glVertex(...);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glColor3f(1.0,1.0,0.0); //желтый<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glColor3f(0.0,0.0,1.0); //синий<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glVertex(...);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glVertex(...);<br>
  glEnd();<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Вы можете использовать любую
комбинацию 24 версий команды <b>glVertex*()</b> внутри <b>glBegin()</b> и <b>glEnd()</b>,
хотя в реальных приложениях вершинные данные имеют тенденцию сохранять свой
формат и поэтому, обычно достаточно одной версии. Если в вашем приложении
вызовы команд установки параметров вершин имеют достаточно постоянную
последовательность (например, <b>glColor*</b>, <b>glVertex*</b>, <b>glColor*</b>,
<b>glVertex*</b> и так далее), вы можете получить выигрыш по производительности
путем использования массивов вершин.</p>

<h2>2.4&nbsp; Основы управления состоянием</h2>

<p class=text align=left style='text-align:left'>В предыдущей секции вы видели
пример переменной состояния – текущего RGBA – цвета, и как он может быть
назначен примитиву. OpenGL управляет множеством переменных состояния. Объект
может быть отображен с учетом освещения, текстурирования, удаления невидимых
поверхностей, тумана, других <i>механизмов</i> (states), влияющих на его
внешний вид, и каждый из этих механизмов имеет множество, ассоциированных с
ним, переменных состояния.</p>

<p class=text align=left style='text-align:left'>По умолчанию, большинство из
этих механизмов OpenGL неактивно, так как они могут быть весьма дороги в смысле
производительности. Например, включение текстурирования практически наверняка
замедлит процесс визуализации примитива. Однако изображение будет лучше по качеству,
и будет выглядеть более реалистично.</p>

<p class=text align=left style='text-align:left'>Для включения или выключения
многих механизмов используются 2 простые команды:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glEnable
  </b>(GLenum <i>cap</i>);<br>
  void <b>glDisable </b>(GLenum <i>cap</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'><b>glEnable()</b> включает
механизм, <b>glDisable()</b> выключает его. Существует более 40 величин,
которые могут передаваться в качестве параметров <b>glEnable()</b> или <b>glDisable()</b>.
Вот некоторые примеры: GL_BLEND (контролирует наложение RGBA – величин),
GL_DEPTH_TEST (контролирует сравнение по глубине и обновление буфера глубины),
GL_LINE_STIPPLE (применение шаблонов для линий) и GL_LIGHTING (освещение).</p>

<p class=text align=left style='text-align:left'>Вы также можете проверить
включен или выключен определенный механизм:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>GLboolean <b>glIsEnabled</b>
  (GLenum <i>capability</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Возвращает GL_TRUE или
GL_FALSE в зависимости от того включен или выключен запрашиваемый механизм.</p>

<p class=text align=left style='text-align:left'>Механизмы, которые вы только
что видели, имеют два положения: включен или выключен. Однако большинство
команд OpenGL устанавливает значения более сложных переменных состояния.
Например, команда <b>glColor3f()</b> устанавливает 3 величины, которые являются
частью механизма GL_CURRENT_COLOR. Существует 5 команд опроса, используемых для
получения значений переменных из различных механизмов:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glGetBooleanv</b>
  (GLenum <i>pname</i>, GLboolean *<i>params</i>);<br>
  void <b>glGetIntegerv</b> (GLenum <i>pname</i>, GLint *<i>params</i>);<br>
  void <b>glGetFloatv</b> (GLenum <i>pname</i>, GLfloat *<i>params</i>);<br>
  void <b>glGetDoublev</b> (GLenum <i>pname</i>, GLdouble *<i>params</i>);<br>
  void <b>glGetPointerv</b> (GLenum <i>pname</i>, GLvoid *<i>params</i>); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Извлекают значения переменных
состояния булевского типа, целого типа, дробного типа одинарной и двойной точности
и типа указателя. Аргумент <i>pname</i> – символическая константа, определяющая
запрашиваемую переменную состояния, а <i>params</i> – указатель на массив
соответствующего типа, в который следует поместить возвращаемые данные.
Например, чтобы получить текущий RGBA – цвет используйте <b>glGetIntegerv</b>(GL_CURRENT_COLOR,
<i>params</i>) или <b>glGetFloatv</b>(GL_CURRENT_COLOR, <i>params</i>).
Конверсия типов (если она необходима) автоматически производится для того,
чтобы вернуть значения запрашиваемого типа. Эти команды опроса годятся для извлечения
значений почти всех (но не всех) переменных состояния. </p>

<h2>2.5&nbsp; Отображение точек, линий и полигонов</h2>

<p class=text align=left style='text-align:left'>По умолчанию, точка
отображается как один пиксель на экране, линия рисуется сплошной, в один
пиксель толщиной, полигоны рисуются со сплошной заливкой. Следующие параграфы
разъясняют, как можно изменить эту ситуацию.</p>

<h2>2.5.1&nbsp; Подробно о точках</h2>

<p class=text align=left style='text-align:left'>Для управления размером
рисуемых точек используйте <b>glPointSize()</b> и укажите желаемый размер (в
пикселях) как аргумент. </p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>glPointSize</b>
  (GLfloat <i>size</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Устанавливает длину и высоту
(в пикселях) для визуализируемой точки, <i>size</i> должен быть больше 0.0 и,
по умолчанию, равен 1.0.</p>

<p class=text align=left style='text-align:left'>&nbsp;Реальный набор пикселей
на экране, который будет нарисован для различных размеров точки зависит от
того, включен или выключен антиалиасинг. (Антиалиасинг – это техника
сглаживания рисуемых точек и линий.) Если антиалиасинг выключен (а он выключен
по умолчанию), дробные размеры точек округляются до ближайшего целого и для
каждой точки на экране будет нарисован квадратный регион пикселей. Таким образом,
если размер точки равен 1.0, будет нарисован квадрат с размерами 1 x 1 пиксель,
если размер точки 2.0 будет нарисован квадрат с размерами&nbsp; 2 x 2 пикселя и
так далее.</p>

<p class=text align=left style='text-align:left'>Когда антиалиасинг включен,
рисуется циркулярная группа пикселей, и пиксели по границе обычно имеют цвет с
пониженной интенсивностью для придания границе гладкого вида. В этом режиме
дробные размеры точек до целого не округляются (рисунок 2-8).</p>

<p class=text align=left style='text-align:left'>Рисунок 2-8. Точки разного
размера в разных режимах</p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1035" type="#_x0000_t75" alt="" style='width:351pt;height:145.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image011.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов2.mht!http://www.progz.ru/images/opengl/chapter2/2-8.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=468 height=194
src="OpenGL%20Red%20Book.files/image011.jpg" v:shapes="_x0000_i1035"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Большинство реализаций OpenGL
поддерживают точки очень большого размера. Вы можете запрашивать минимальный и
максимальный размеры для несглаженных точек, используя аргумент
GL_ALIASED_POINT_SIZE_RANGE в команде <b>glGetFloatv()</b>. Точно так же вы
можете запрашивать минимальный и максимальный размеры сглаженных точек,
используя в той же команде аргумент GL_SMOOTH_POINT_SIZE_RANGE. Допустимые
размеры сглаженных точек дискретно меняются в диапазоне от минимума до
максимума. Вызвав <b>glGetFloatv()</b> с параметром
GL_SMOOTH_POINT_SIZE_GRANULARITY, вы узнаете, с какой точностью сглаженные
точки отображаются на экране, то есть величину минимального изменения размера
точки внутри диапазона от минимума до максимума, имеющую видимый эффект
(величину гранулирования). Например, если вы запрашиваете <b>glPointSize</b>(<i>2.34</i>),
а величина гранулирования равна 0.1, размер точки будет округлен до 2.4.</p>

<p class=warning>Замечание: В некоторых случаях довольно трудно получить
указанные выше параметры, поскольку соответствующие константы могут быть не
определены в заголовочных файлах, поставляемых с вашим компилятором или
реализацией OpenGL. Однако, как правило, в этих файлах определена константа GL_POINTS_SIZE_RANGE
(по смыслу соответствующая GL_SMOOTH_POINT_SIZE_RANGE) и
GL_POINT_SIZE_GRANULARITY (соответствующая GL_SMOOTH_POINT_SIZE_GRANULARITY).
То же касается и параметров линий (максимальной и минимальной толщины и
гранулярности). Вполне возможна ситуация, когда в заголовочных файлах
определены лишь константы GL_LINE_WIDTH_RANGE (по результату аналогичная
GL_SMOOTH_LINE_WIDTH_RANGE) и GL_LINE_WIDTH_GRANULARITY (соответствующая
GL_SMOOTH_LINE_WIDTH_GRANULARITY). Вообще подобные сложности могут возникать и
в других случаях из-за различий в реализациях, версиях библиотеки, средствах
разработки и так далее. Благо, они не настолько часты. </p>

<h2>2.5.2&nbsp; Подробно о линиях</h2>

<p class=text align=left style='text-align:left'>В OpenGL вы можете рисовать
линии различной толщины, а также линии, имеющие шаблон – пунктирные, штриховые,
штрих – пунктирные и так далее.</p>

<h2>2.5.2.1&nbsp;&nbsp;&nbsp; Толщина линий</h2>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>glLineWidth</b>
  (GLfloat <i>width</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Устанавливает толщину линии в
пикселях, <i>width</i> должно быть больше 0.0 и по умолчанию равно 1.0.</p>

<p class=text align=left style='text-align:left'>Реальная визуализация линий
зависит от механизма антиалиасинга по аналогии с точками. Без антиалиасинга
значения толщины равные 1, 2 и 3 задают линии на экране в 1, 2 и 3 пикселя
толщиной. При включенном антиалиасинге для толщины допустимы дробные значения и
пиксели по границе линии обычно рисуются с меньшей интенсивностью. Как и в
случае с точками, конкретная реализация OpenGL может ограничивать толщину
несглаженной линии, максимальной толщиной сглаженной линии, округленной до
ближайшего целого. Вы можете получить диапазон поддерживаемых значений толщины
несглаженных линий посредством команды <b>glGetFloatv()</b> с аргументом
GL_ALIASED_LINE_WIDTH_RANGE. Чтобы получить минимум и максимум значений толщины
для сглаженных линий и величину гранулирования, поддерживаемые вашей
реализацией OpenGL, следует употребить с той же командой аргументы
GL_SMOOTH_LINE_WIDTH_RANGE и GL_SMOOTH_LINE_WIDTH_GRANULARITY соответственно.</p>

<p class=warning>Замечание: Имейте в виду, что по умолчанию линии имеют толщину
в 1 пиксель, так что они кажутся толще при низком разрешении монитора и тоньше
при высоком. Для мониторов это, как правило, не проблема, но если вы
используете OpenGL для вывода изображения на другое устройство, например,
плоттер высокого разрешения, линия в 1 пиксель толщиной может быть практически
неразличима. В подобных случаях приходится вычислять значения толщины для
каждого разрешения, принимая в расчет физический размер пикселя на экране или
устройстве. </p>

<p class=text align=left style='text-align:left'><b>Дополнительно:</b> При
рисовании несглаженных линий следует учесть, что их толщина измеряется вовсе не
перпендикулярно самой линии. Вместо этого толщина измеряется в направлении оси
ординат при условии, что |y2-y1|&lt;|x2-x1|(где (x1,y1) и (x2,y2) - координаты
концов отрезка) и в направлении оси абсцисс в иных случаях. Рисование
сглаженного отрезка определенной толщины полностью эквивалентно рисованию
закрашенного прямоугольника соответствующей высоты, центрированного отрезку в
один пиксель. </p>

<h2>2.5.2.2 Шаблоны отрезков</h2>

<p class=text align=left style='text-align:left'>Чтобы задать шаблон отрезка
(например, для получения пунктирных или штриховых отрезков) следует
использовать команду <b>glLineStipple()</b> и затем включить шаблонирование
командой <b>glEnable()</b>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>glLineStipple(1,0x3F07);<br>
  glEnable(GL_LINE_STIPPLE); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Verdana;
color:black;display:none;mso-hide:all'><o:p>&nbsp;</o:p></span></p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glLineStipple</b>
  (Glint <i>factor</i>, GLushort <i>pattern</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Устанавливает текущий шаблон
для отрезка. Аргумент <i>pattern</i> – это 16-битная серия из нулей и единиц,
определяющая, как будет рисоваться отрезок. Она повторяется по необходимости
для шаблонирования всего отрезка. Единица означает, что соответствующая точка
отрезка будет нарисована на экране, ноль означает, что точка нарисована не
будет (на попиксельной основе). Шаблон применяется, начиная с младшего бита
аргумента pattern. Шаблон может быть растянут с учетом значения фактора
повторения <i>factor</i>. Каждый бит шаблона при наложении на отрезок
расценивается как <i>factor</i> битов того же значения, идущих друг за другом.
Например, если в шаблоне встречаются подряд три единицы, а затем два нуля и <i>factor</i>
равен 3, то шаблон будет трактоваться как содержащий 9 единиц и 6 нулей.
Допустимые значения аргумента <i>factor</i> ограничены диапазоном от 1 до 256.
Шаблонирование должно быть включено передачей аргумента GL_LINE_STIPPLE в
функцию <b>glEnable()</b>. Оно блокируется передачей того же аргумента в <b>glDisable()</b>.</p>

<p class=text align=left style='text-align:left'>Итак, в предыдущем примере с
шаблоном равным 0x3F07 (что в двоичной системе счисления соответствует записи
0011111100000111) отрезок будет выведен на экран, начинаясь (по порядку) с 3
нарисованных пикселей, 5 отсутствующих, 6 нарисованных и 2 отсутствующих (если
вам кажется, что мы применили шаблон задом - наперед вспомните, что он
применяется, начиная с младшего бита). Если длина нашего отрезка на экране
больше 16 пикселей, начиная с 17-го, шаблон будет применен заново и так далее
до конца отрезка. Если бы <i>factor</i> был равен 2, шаблон был бы растянут, и
отрезок выглядел бы следующим образом: вначале 6 нарисованных пикселей, затем
10 отсутствующих, 12 нарисованных и 4 отсутствующих. На рисунке 2-9 показаны
отрезки, нарисованные с применением различных шаблонов и факторов повторения
шаблона. Если шаблонирование заблокировано, все отрезки рисуются таким же
образом, как если бы шаблон был установлен в 0xFFFF, а фактор повторения в 1.
Обратите внимание, что шаблонирование может применяться в комбинации с линиями
различной толщины.</p>

<p class=text align=left style='text-align:left'>Рисунок 2-9. Шаблонированные
отрезки</p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1036" type="#_x0000_t75" alt="" style='width:264pt;height:162.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image012.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов2.mht!http://www.progz.ru/images/opengl/chapter2/2-9.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=352 height=217
src="OpenGL%20Red%20Book.files/image012.jpg" v:shapes="_x0000_i1036"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Если рисуется ломаная (с
помощью GL_LINE_STRIP или GL_LINE_LOOP) то шаблон накладывается на нее
непрерывно, независимо от того, где кончается один сегмент и начинается другой.
В противовес этому для каждой индивидуальной линии (рисуемой с помощью
GL_LINES) шаблон начинается заново, даже если все команды указания вершин
вызываются внутри одного блока <b>glBegin()</b> – <b>glEnd()</b>.</p>

<p class=text align=left style='text-align:left'>Пример 2-5 иллюстрирует
результаты экспериментов с различными шаблонами и значениями толщины отрезков.
Он также показывает разницу между рисованием ломаной и отдельных отрезков.
Результаты работа программы показаны на рисунке 2-10.</p>

<p class=text align=left style='text-align:left'>Рисунок 2-10. Эксперименты с
шаблонами и толщиной отрезков</p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1037" type="#_x0000_t75" alt="" style='width:283.5pt;height:159pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image013.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов2.mht!http://www.progz.ru/images/opengl/chapter2/2-10.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=378 height=212
src="OpenGL%20Red%20Book.files/image013.jpg" v:shapes="_x0000_i1037"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Пример 2-5. Шаблоны отрезков.
Файл lines.cpp</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>#include <br>
  #define drawOneLine(x1,y1,x2,y2) glBegin(GL_LINES);glVertex2f((x1),(y1));glVertex2f((x2),(y2));glEnd();<br>
  <br>
  void init(void)<br>
  {<br>
  &nbsp;&nbsp; glClearColor(1.0,1.0,1.0,0.0);<br>
  &nbsp;&nbsp; glShadeModel(GL_FLAT);<br>
  }<br>
  &nbsp;<br>
  void display(void)<br>
  {<br>
  &nbsp;&nbsp; int i;<br>
  &nbsp;<br>
  &nbsp;&nbsp; glClear(GL_COLOR_BUFFER_BIT);<br>
  <br>
  &nbsp;&nbsp; //Черный цвет для всех линий<br>
  &nbsp;&nbsp; glColor3f(0.0,0.0,0.0);<br>
  <br>
  &nbsp;&nbsp; glEnable(GL_LINE_STIPPLE);<br>
  <br>
  &nbsp;&nbsp; //В первом ряду три линии с разными шаблонами<br>
  &nbsp;&nbsp; glLineWidth(1.0);<br>
  &nbsp;&nbsp; glLineStipple(1,0x0101); //Пунктирная<br>
  &nbsp;&nbsp; drawOneLine(50.0,125.0,150.0,125.0);<br>
  &nbsp;&nbsp; glLineStipple(1,0x00FF); //Штриховая<br>
  &nbsp;&nbsp; drawOneLine(150.0,125.0,250.0,125.0);<br>
  &nbsp;&nbsp; glLineStipple(1,0x1C47); //Штрих-пунктирная<br>
  &nbsp;&nbsp; drawOneLine(250.0,125.0,350.0,125.0);<br>
  <br>
  &nbsp;&nbsp; //Во втором ряду три толстые линии с аналогичными шаблонами<br>
  &nbsp;&nbsp; glLineWidth(5.0);<br>
  &nbsp;&nbsp; glLineStipple(1,0x0101); //Пунктирная<br>
  &nbsp;&nbsp; drawOneLine(50.0,100.0,150.0,100.0);<br>
  &nbsp;&nbsp; glLineStipple(1,0x00FF); //Штриховая<br>
  &nbsp;&nbsp; drawOneLine(150.0,100.0,250.0,100.0);<br>
  &nbsp;&nbsp; glLineStipple(1,0x1C47); //Штрих-пунктирная<br>
  &nbsp;&nbsp; drawOneLine(250.0,100.0,350.0,100.0);<br>
  &nbsp;<br>
  &nbsp;&nbsp; //В третьем ряду шесть штрих-пунктирных линий, объединенных в
  ломаную<br>
  &nbsp;&nbsp; glLineWidth(1.0);<br>
  &nbsp;&nbsp; glLineStipple(1,0x1C47); //Штрих-пунктирная<br>
  &nbsp;&nbsp; glBegin(GL_LINE_STRIP);<br>
  &nbsp;&nbsp; for (i=0;i&lt;7;i++)<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glVertex2f(50.0+((GLfloat)i*50.0),75.0);<br>
  &nbsp;&nbsp; glEnd();<br>
  <br>
  &nbsp;&nbsp; //В четвертом ряду шесть независимых линий того же шаблона<br>
  &nbsp;&nbsp; for (i=0;i&lt;6;i++)<br>
  &nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  drawOneLine(50.0+((GLfloat)i*50.0),50.0,50.0+((GLfloat)(i+1)*50.0),50.0);<br>
  &nbsp;&nbsp; }<br>
  <br>
  &nbsp;&nbsp; //В пятом ряду 1 штрих-пунктирная линия с фактором повторения=5<br>
  &nbsp;&nbsp; glLineStipple(5,0x1c47);<br>
  &nbsp;&nbsp; drawOneLine(50.0,25.0,350.0,25.0);<br>
  &nbsp;<br>
  &nbsp;&nbsp; glDisable(GL_LINE_STIPPLE);<br>
  &nbsp;&nbsp; glFlush();<br>
  }<br>
  &nbsp;<br>
  void reshape(int w,int h)<br>
  {<br>
  &nbsp;&nbsp; glViewport(0,0,(GLsizei) w, (GLsizei) h);<br>
  &nbsp;&nbsp; glMatrixMode(GL_PROJECTION);<br>
  &nbsp;&nbsp; glLoadIdentity();<br>
  &nbsp;&nbsp; gluOrtho2D(0.0,400.0,0.0,150.0);<br>
  }<br>
  &nbsp;<br>
  int main(int argc, char **argv)<br>
  {<br>
  &nbsp;&nbsp; glutInit(&amp;argc,argv);<br>
  &nbsp;&nbsp; glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);<br>
  &nbsp;&nbsp; glutInitWindowSize(400,150);<br>
  &nbsp;&nbsp; glutInitWindowPosition(100,100);<br>
  &nbsp;&nbsp; glutCreateWindow(&quot;Line Stipple Patterns&quot;);<br>
  &nbsp;&nbsp; init();<br>
  &nbsp;&nbsp; glutDisplayFunc(display);<br>
  &nbsp;&nbsp; glutReshapeFunc(reshape);<br>
  &nbsp;&nbsp; glutMainLoop();<br>
  &nbsp;&nbsp; return 0;<br>
  }<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<h2>2.5.3 Подробнее о полигонах</h2>

<p class=text align=left style='text-align:left'>Обычно полигоны рисуются в
виде закрашенной области пикселей, лежащих внутри их границ, но также они могут
быть нарисованы в виде самой границы (ломаной) или просто в виде точек,
соответствующих их вершинам. Возможна как полная заливка, так и применение
различных шаблонов. Если смежные полигоны разделяют ребро или вершину, то
пиксели, соответствующие на экране этому ребру или вершине рисуются только один
раз, то есть они включаются только в один из полигонов. Это делается для того, чтобы
для частично прозрачных полигонов ребра не рисовались дважды – это может
привести к тому, что такие ребра будут выглядеть темнее или ярче (в зависимости
от их цвета). Заметьте, что это может привести к тому, что узкие полигоны при
рисовании будут иметь дыры в одном или более рядов или столбцов пикселей.
Антиалиасинг для полигонов более сложен, чем для точек и отрезков.</p>

<h2>2.5.3.1 Закрашенные полигоны, полигоны в виде линий или точек</h2>

<p class=text align=left style='text-align:left'>У полигона две стороны или
грани—лицевая и обратная, и он может быть визуализирован по-разному в
зависимости от того, которая из сторон видна наблюдателю. Это позволяет вам
создавать изображения таким образом, как если бы вы заглядывали внутрь объекта
у которого лицевые и обратные части рисуются по-разному (например, сфера, разрезанная
пополам). Полигон также считается лицевым или обратным в зависимости от того,
какой из граней он повернут к наблюдателю. По умолчанию, лицевые и обратные
грани изображаются одинаково. Чтобы это изменить, а также, чтобы рисовать
только вершины или границы полигона, используйте команду <b>glPolygonMode()</b>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glPolygonMode</b>
  (GLenum <i>face</i>, GLenum <i>mode</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Управляет режимом отображения
для лицевых и обратных граней полигонов. Параметр <i>face</i> указывает, для
каких граней изменяется режим отображения и может принимать значения
GL_FRONT_AND_BACK (режим меняется и для лицевых и для обратных граней),
GL_FRONT (только для лицевых), GL_BACK (только для обратных). Параметр <i>mode</i>
может быть равен GL_POINT, GL_LINE или GL_FILL в зависимости от желаемого
режима отображения: точки, линии или заливка. По умолчанию оба типа граней
рисуются в виде заполненных областей пикселей (заливки</p>

<p class=text align=left style='text-align:left'>Например, если вы хотите
отображать лицевые грани в виде заливки, а обратные в виде линии по границе,
используйте две следующие команды:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>glPolygonMode(GL_FRONT,GL_FILL);<br>
  glPolygonMode(GL_BACK,GL_LINE); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<h2>2.5.3.2 Указание лицевых граней и удаление нелицевых граней</h2>

<p class=text align=left style='text-align:left'>По принятому соглашению, грань
полигона (и он сам на экране) считается лицевой, если ее вершины, начиная с
первой, отображаются на экране против часовой стрелки. Вы можете
сконструировать поверхность любого «разумного» тела (или ориентируемого тела,
например, сфера, торус, чашка – ориентируемы, лист Мёбиуса – нет) из полигонов
постоянной ориентации. Иными словами, вы можете сконструировать их с
использованием только полигонов, чьи вершины идут по часовой стрелке или только
полигонов, чьи вершины идут в обратном направлении (тело, собранное из
полигонов постоянной ориентации, и называется ориентируемым). </p>

<p class=text align=left style='text-align:left'>Представьте себе, что вы
долгое время описывали модель некоторой ориентируемой поверхности и вдруг
обнаружили, что по ошибке разместили полигоны обратными гранями наружу (то есть
гранями, вершины которых на экране идут по часовой стрелке). Вы можете указать
OpenGL, что считать лицевыми и обратными гранями с помощью команды <b>glFrontFace()</b>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>glFrontFace</b>
  (GLenum <i>mode</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Контролирует то, какие грани
OpenGL считает лицевыми. По умолчанию <i>mode</i> равняется GL_CCW, что
соответствует ориентации против часовой стрелки упорядоченного набора вершин
спроецированного полигона. Если в параметре <i>mode</i> указать GL_CW, то
лицевыми будут считаться грани, чьи вершины расположены по часовой стрелке. </p>

<p class=text align=left style='text-align:left'>Если сконструированная
поверхность, состоящая из непрозрачных полигонов постоянной ориентации, скажем
лицевых, полностью замкнута, ни одна из обратных граней полигонов никогда не
будет видна – они всегда будут закрыты лицевыми гранями. Если вы наблюдаете
снаружи поверхности, вы можете включить механизм удаления нелицевых (обратных)
граней, для того, чтобы OpenGL игнорировала и не рисовала грани, определенные
ею как обратные. Аналогичным образом, если вы находитесь внутри замкнутой
поверхности, вам видны только обратные грани, и вы можете заставить OpenGL
рисовать только их. Чтобы заставить OpenGL игнорировать лицевые или обратные
грани полигонов, используйте команду <b>glCullFace()</b> и включите удаление
невидимых граней командой <b>glEnable()</b>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>glCullFace</b>
  (GLenum <i>mode</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Задает, какие полигоны должны
игнорироваться и удаляться до их преобразования в экранные координаты. Параметр
<i>mode</i> может принимать значение GL_FRONT, GL_BACK или GL_FRONT_AND_BACK,
что соответствует лицевым, обратным или всем полигонам соответственно. Для
того, чтобы команда имела эффект, требуется включить механизм удаления
нелицевых граней с помощью параметра GL_CULL_FACE и команды <b>glEnable()</b>.
Чтобы выключить его тот же параметр должен быть передан в команду <b>glDisable()</b>.</p>

<p class=text align=left style='text-align:left'><b>Дополнительно:</b>
Технически решение о том, является ли грань полигона лицевой или обратной
зависит от знака его площади вычисленной в оконных координатах. Один из путей
рассчитать ее следующий: <!--[if gte vml 1]><v:shape id="_x0000_i1038" type="#_x0000_t75"
 alt="" style='width:154.5pt;height:39.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image014.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов2.mht!http://www.progz.ru/images/opengl/chapter2/form_1.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=206 height=53
src="OpenGL%20Red%20Book.files/image014.gif" v:shapes="_x0000_i1038"><![endif]>,
где <!--[if gte vml 1]><v:shape id="_x0000_i1039" type="#_x0000_t75" alt=""
 style='width:15.75pt;height:16.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image015.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов2.mht!http://www.progz.ru/images/opengl/chapter2/form_2.gif"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=21 height=22
src="OpenGL%20Red%20Book.files/image015.gif" v:shapes="_x0000_i1039"><![endif]>и
<!--[if gte vml 1]><v:shape id="_x0000_i1040" type="#_x0000_t75" alt=""
 style='width:15.75pt;height:16.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image016.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов2.mht!http://www.progz.ru/images/opengl/chapter2/form_3.gif"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=21 height=22
src="OpenGL%20Red%20Book.files/image016.gif" v:shapes="_x0000_i1040"><![endif]>i-ой
вершины, а <!--[if gte vml 1]><v:shape id="_x0000_i1041" type="#_x0000_t75"
 alt="" style='width:116.25pt;height:17.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image017.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов2.mht!http://www.progz.ru/images/opengl/chapter2/form_4.gif"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=155 height=23
src="OpenGL%20Red%20Book.files/image017.gif" v:shapes="_x0000_i1041"><![endif]>.
Предполагая, что указан режим GL_CCW, если a&gt;0, полигон считается лицевым. В
режиме GL_CW, полигон считается лицевым, при a&lt;0, иначе он считается
обратным (повернутым к наблюдателю своей обратной гранью).</p>

<h2>2.5.3.3 Шаблонирование полигонов</h2>

<p class=text align=left style='text-align:left'>По умолчанию, если полигон
рисуется в виде закрашенной области, он закрашивается одинаково по всей своей
площади, без просветов. Эту ситуацию можно изменить, определив шаблон заливки
полигона в виде матрицы 32 x 32 бита и установив его командой <b>glPolygonStipple().</b></p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glPolygonStipple</b>
  (const GLubyte *<i>mask</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Определяет текущий рисунок
шаблона заливки полигона. Параметр <i>mask</i> – это указатель на битовую карту
размером 32 x 32 бита, интерпретируемую в качестве маски, накладываемой на
полигон при рисовании (и при необходимости повторяемой). Там, где стоит 1 –
соответствующий пиксель полигона будет нарисован, а там, где появляется 0 –
пиксель нарисован не будет. Рисунок 2-12 показывает, как рисунок шаблона
конструируется из символов в параметре <i>mask</i>. Шаблонирование полигонов
включается и выключается с помощью аргумента GL_POLYGON_STIPPLE функций <b>glEnable()</b>
и <b>glDisable()</b>. Интерпретация <i>mask</i> зависит от GL_UNPACK*
параметров команды <b>glPixelStore*()</b>.</p>

<p class=text align=left style='text-align:left'>Кроме того, вы должны включить
шаблонирование полигонов:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>glEnable(GL_POLYGON_STIPPLE);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Используйте <b>glDisable()</b>
с аналогичным аргументом для выключения шаблонирования.</p>

<p class=text align=left style='text-align:left'>На рисунке 2-11 показаны
результаты рисования трех полигонов: одного нешаблонированного и двух
шаблонированных, каждый со своим рисунком. Сама программа приводится в примере
2-6. Инверсия готового полигона (рисунок 2-11) относительно шаблона (рисунок
2-12) происходит потому, что программа рисует полигоны белым цветом на черном
фоне (шаблон не влияет на цвет рисуемых точек, он просто определяет, какие
точки полигона будут нарисованы, а какие нет).</p>

<p class=text align=left style='text-align:left'>Рисунок 2-11. Шаблонированные
полигоны</p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1042" type="#_x0000_t75" alt="" style='width:245.25pt;height:93.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image018.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов2.mht!http://www.progz.ru/images/opengl/chapter2/2-11.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=327 height=125
src="OpenGL%20Red%20Book.files/image018.jpg" v:shapes="_x0000_i1042"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Рисунок 2-12. Интерпретация
рисунка шаблона заливки полигонов</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1043" type="#_x0000_t75" alt="" style='width:465.75pt;height:665.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image019.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов2.mht!http://www.progz.ru/images/opengl/chapter2/2-12.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=621 height=887
src="OpenGL%20Red%20Book.files/image019.jpg" v:shapes="_x0000_i1043"><![endif]></p>

<p class=text align=left style='text-align:left'>Пример 2-6. Шаблоны полигонов.
Файл polys.cpp</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>#include <br>
  void init(void)<br>
  {<br>
  &nbsp;&nbsp; glClearColor(0.0,0.0,0.0,0.0);<br>
  &nbsp;&nbsp; glShadeModel(GL_FLAT);<br>
  }<br>
  <br>
  void display(void)<br>
  {<br>
  &nbsp;&nbsp; GLubyte fly[]= {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x03,0x80,0x01,0xC0,0x06,0xC0,0x03,0x60,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x04,0x60,0x06,0x20,0x04,0x30,0x0C,0x20,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x04,0x18,0x18,0x20,0x04,0x0C,0x30,0x20,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x04,0x06,0x60,0x20,0x44,0x03,0xC0,0x22,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x44,0x01,0x80,0x22,0x44,0x01,0x80,0x22,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x44,0x01,0x80,0x22,0x44,0x01,0x80,0x22,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x44,0x01,0x80,0x22,0x44,0x01,0x80,0x22,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x66,0x01,0x80,0x66,0x33,0x01,0x80,0xCC,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x19,0x81,0x81,0x98,0x0C,0xC1,0x83,0x30,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x07,0xE1,0x87,0xE0,0x03,0x3F,0xFC,0xC0,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x03,0x31,0x8C,0xC0,0x03,0x33,0xCC,0xC0,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x06,0x64,0x26,0x60,0x0C,0xCC,0x33,0x30,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x18,0xCC,0x33,0x18,0x10,0xC4,0x23,0x08,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x10,0x63,0xC6,0x08,0x10,0x30,0x0C,0x08,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x10,0x18,0x18,0x08,0x10,0x00,0x00,0x08<br>
  &nbsp;&nbsp; };<br>
  <br>
  &nbsp;&nbsp; GLubyte halftone[] = {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xAA,0xAA,0xAA,0xAA,0x55,0x55,0x55,0x55,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xAA,0xAA,0xAA,0xAA,0x55,0x55,0x55,0x55,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xAA,0xAA,0xAA,0xAA,0x55,0x55,0x55,0x55,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xAA,0xAA,0xAA,0xAA,0x55,0x55,0x55,0x55,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xAA,0xAA,0xAA,0xAA,0x55,0x55,0x55,0x55,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xAA,0xAA,0xAA,0xAA,0x55,0x55,0x55,0x55,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xAA,0xAA,0xAA,0xAA,0x55,0x55,0x55,0x55,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xAA,0xAA,0xAA,0xAA,0x55,0x55,0x55,0x55,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xAA,0xAA,0xAA,0xAA,0x55,0x55,0x55,0x55,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xAA,0xAA,0xAA,0xAA,0x55,0x55,0x55,0x55,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xAA,0xAA,0xAA,0xAA,0x55,0x55,0x55,0x55,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xAA,0xAA,0xAA,0xAA,0x55,0x55,0x55,0x55,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xAA,0xAA,0xAA,0xAA,0x55,0x55,0x55,0x55,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xAA,0xAA,0xAA,0xAA,0x55,0x55,0x55,0x55,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xAA,0xAA,0xAA,0xAA,0x55,0x55,0x55,0x55,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xAA,0xAA,0xAA,0xAA,0x55,0x55,0x55,0x55<br>
  &nbsp;&nbsp; };<br>
  <br>
  &nbsp;&nbsp; glClear(GL_COLOR_BUFFER_BIT);<br>
  &nbsp;&nbsp; glColor3f(1.0,1.0,1.0);<br>
  <br>
  &nbsp;&nbsp; //Рисуем один нешаблонированный прямоугольник <br>
  &nbsp;&nbsp; //и два шаблоннированных<br>
  &nbsp;&nbsp; glRectf(25.0,25.0,125.0,125.0);<br>
  <br>
  &nbsp;&nbsp; glEnable(GL_POLYGON_STIPPLE);<br>
  &nbsp;&nbsp; glPolygonStipple(fly);<br>
  &nbsp;&nbsp; glRectf(125.0,25.0,225.0,125.0);<br>
  <br>
  &nbsp;&nbsp; glPolygonStipple(halftone);<br>
  &nbsp;&nbsp; glRectf(225.0,25.0,325.0,125.0);<br>
  &nbsp;&nbsp; glDisable(GL_POLYGON_STIPPLE);<br>
  <br>
  &nbsp;&nbsp; glFlush();<br>
  }<br>
  <br>
  void reshape(int w, int h)<br>
  {<br>
  &nbsp;&nbsp; glViewport(0,0,(GLsizei) w, (GLsizei) h);<br>
  &nbsp;&nbsp; glMatrixMode(GL_PROJECTION);<br>
  &nbsp;&nbsp; glLoadIdentity();<br>
  &nbsp;&nbsp; gluOrtho2D(0.0,350.0,0.0,150.0);<br>
  }<br>
  <br>
  int main(int argc, char **argv)<br>
  {<br>
  &nbsp;&nbsp; glutInit(&amp;argc,argv);<br>
  &nbsp;&nbsp; glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);<br>
  &nbsp;&nbsp; glutInitWindowSize(350,150);<br>
  &nbsp;&nbsp; glutCreateWindow(&quot;Polygon Stipple Patterns&quot;);<br>
  &nbsp;&nbsp; init();<br>
  &nbsp;&nbsp; glutDisplayFunc(display);<br>
  &nbsp;&nbsp; glutReshapeFunc(reshape);<br>
  &nbsp;&nbsp; glutMainLoop();<br>
  &nbsp;&nbsp; return 0;<br>
  }<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Ради повышения эффективности
можно использовать списки отображения OpenGL для хранения рисунков заливки
полигонов.</p>

<h2>2.5.3.4 Указание граничных ребер</h2>

<p class=text align=left style='text-align:left'><b>Дополнительно:</b> OpenGL
может визуализировать только выпуклые полигоны, однако на практике часто
требуется нарисовать полигон, не являющийся выпуклым. Для этого вы обычно
разделяете его на выпуклые полигоны – чаще всего треугольники, как показано на
рисунке 2-13 и рисуете эти треугольники. К несчастью, после декомпозиции вы не
можете использовать <b>glPolygonMode()</b> для рисования полигона в виде его
границы, поскольку помимо границы самого полигона, вы в этом случае получите еще
и границы всех треугольников, из которых он состоит. Для решения этой проблемы
вы можете указать OpenGL, является ли каждая конкретная вершина, начинающей
граничное ребро или нет (из двух вершин, образующих ребро, начинающей его
считается вершина с меньшим номером). OpenGL отслеживает эту информацию, храня
и передавая вместе с каждой вершиной соответствующий бит, показывающий,
является ли вершина границеобразующей (начинает ли она граничное ребро). При
таком подходе, во время рисования полигона в режиме GL_LINE ребра, не
являющиеся граничными, не рисуются. На рисунке 2-13, ребра, добавленные при
триангуляции и не являющиеся граничными, выделены пунктиром.</p>

<p class=text align=left style='text-align:left'>Рисунок 2-13. Декомпозиция
невыпуклого полигона</p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1044" type="#_x0000_t75" alt="" style='width:364.5pt;height:182.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image020.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов2.mht!http://www.progz.ru/images/opengl/chapter2/2-13.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=486 height=243
src="OpenGL%20Red%20Book.files/image020.jpg" v:shapes="_x0000_i1044"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>По умолчанию, все вершины
помечены как образующие границу, но вы можете контролировать установку флага
ребра с помощью команды <b>glEdgeFlag*()</b>. Эта команда используется между <b>glBegin()</b>
и <b>glEnd ()</b> и влияет на все вершины, перечисленные после нее до
следующего вызова <b>glEdgeFlag*()</b>. Команда влияет только на вершины,
указываемые для полигонов, треугольников и прямоугольников и не влияет на
вершины, перечисляемые для цепочек треугольников или прямоугольников
(GL_TRIANGLE_STRIP, GL_QUAD_STRIP).</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glEdgeFlag</b>
  (GLboolean <i>flag</i>);<br>
  void <b>glEdgeFlagv</b> (const GLboolean *<i>flag</i>); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Указывает, должна ли вершина
считаться границеобразующей (начинающей одно из граничных ребер). Если <i>flag</i>
равен GL_TRUE, флаг ребра для вершины устанавливается в TRUE (значение по
умолчанию) и все перечисляемые далее вершины считаются, начинающими граничные
ребра. Это происходит до тех пор, пока функция не вызвана еще раз с параметром
GL_FALSE. Вершины, следующие за этим вызовом, начинающими граничные ребра не
считаются и в режиме рисования полигонов GL_LINE на экране не отображаются.</p>

<p class=text align=left style='text-align:left'>Например, в листинге 2-7
рисуются линии, показанные на рисунке 2-14.</p>

<p class=text align=left style='text-align:left'>Рисунок 2-14. Полигон,
нарисованный в виде границы при использовании флага ребра.</p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1045" type="#_x0000_t75" alt="" style='width:213pt;height:149.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image021.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов2.mht!http://www.progz.ru/images/opengl/chapter2/2-14.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=284 height=199
src="OpenGL%20Red%20Book.files/image021.jpg" v:shapes="_x0000_i1045"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Пример 2-7. Пометка
границеобразующих вершин</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>glPolygonMode(GL_FRONT_AND_BACK,GL_LINE);<br>
  glBegin(GL_POLYGON);<br>
  &nbsp;&nbsp; glEdgeFlag(GL_TRUE);<br>
  &nbsp;&nbsp; glVertex3fv(V0);<br>
  &nbsp;&nbsp; glEdgeFlag(GL_FALSE);<br>
  &nbsp;&nbsp; glVertex3fv(V1);<br>
  &nbsp;&nbsp; glEdgeFlag(GL_TRUE);<br>
  &nbsp;&nbsp; glVertex3fv(V2);<br>
  glEnd();<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<h2>2.6 Вектор нормали</h2>

<p class=text align=left style='text-align:left'><i>Вектором нормали</i> (или
просто <i>нормалью</i>) называется вектор, который указывает в направлении
перпендикулярном поверхности. Для плоской поверхности это перпендикулярное
направление одинаково во всех точках, но в&nbsp; общем случае, для изогнутой
поверхности направление нормали может быть разным в каждой точке поверхности.
При использовании OpenGL вы можете указывать нормаль для всего полигона или для
каждой вершины. Вершины одного полигона могут разделять одну и ту же нормаль
(для плоских поверхностей) или иметь разные нормали (для изогнутых
поверхностей). Однако вы можете назначать нормали только в вершинах.</p>

<p class=text align=left style='text-align:left'>Вектора нормали объекта
определяют его ориентацию в пространстве – в частности, его ориентацию по
отношению к источникам света. Эти вектора нужны OpenGL для определения
количества света, падающего на вершины объекта (метод закраски Гуро). Вы
определяете вектора нормалей объекта в то же время, когда задаете его
геометрию.</p>

<p class=text align=left style='text-align:left'>Вы используете <b>glNormal*()</b>,
чтобы установить текущую нормаль в значения параметров, передаваемых команде.
При последующих вызовах <b>glVertex*()</b> текущая нормаль ассоциируется с
каждой вершиной. часто, каждая вершина имеет свою нормаль, что требует серии
дополнительных вызовов, как показано в примере 2-8.</p>

<p class=text align=left style='text-align:left'>Пример 2-8. Вектора нормали в
вершинах</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>glBegin(GL_POLYGON);<br>
  &nbsp;&nbsp; glNormal3fv(n0);<br>
  &nbsp;&nbsp; glVertex3fv(v0);<br>
  &nbsp;&nbsp; glNormal3fv(n1);<br>
  &nbsp;&nbsp; glVertex3fv(v1);<br>
  &nbsp;&nbsp; glNormal3fv(n2);<br>
  &nbsp;&nbsp; glVertex3fv(v2);<br>
  &nbsp;&nbsp; glNormal3fv(n3);<br>
  &nbsp;&nbsp; glVertex3fv(v3);<br>
  glEnd();<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Verdana;
color:black;display:none;mso-hide:all'><o:p>&nbsp;</o:p></span></p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glNormal3</b>{bsidf}(TYPE
  <i>nx</i>, TYPE <i>ny</i>, TYPE <i>nz</i>);<br>
  void <b>glNormal3</b>{bsidf}<b>v</b>(const TYPE *<i>v</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Устанавливает текущий вектор
нормали, определяемый аргументами. Невекторная версия команды (без <b>v</b>)
принимает три аргумента, определяющие вектор (<i>nx</i>,<i>ny</i>,<i>nz</i>),
принимаемый в качестве нормали. В качестве альтернативы вы можете использовать
векторную версию этой команды (с <b>v</b>) и передавать в качестве параметра
массив, содержащий три элемента, определяющих желаемую нормаль. При
использовании версий команды, работающих с типами <b>b</b>, <b>s</b> и <b>i</b>,
параметры линейно масштабируются до диапазона [-1.0, 1.0].</p>

<p class=text align=left style='text-align:left'>Имейте в виду, что в каждой
точке существует не один, а два вектора перпендикулярных поверхности, и они
указывают в противоположных направлениях. По принятому соглашению, нормалью
считается тот из них, который указывает «наружу» поверхности (а не «вовнутрь»).
(Если вы в программе перепутали понятия «наружу» и «вовнутрь», просто измените
каждый вектор нормали с (<i>x</i>, <i>y</i>, <i>z</i>) на (<i>-x</i>, <i>-y</i>,
<i>-z</i>)).</p>

<p class=text align=left style='text-align:left'>Также имейте в виду, что
поскольку нормали нужны только для указания направления, их длина по большей
части не имеет значения. Вы можете указывать нормали любой длины, но до того,
как смогут быть произведены вычисления, связанные с освещением, все нормали
должны быть преобразованы к длине равной 1. (Вектор, имеющий единичную длину,
называется <i>нормализованным</i>). В общем, вам следует указывать
нормализованные нормали. Для нормализации вектора поделите каждую из трех его
координат на его длину:</p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Verdana;
color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1046" type="#_x0000_t75"
 alt="" style='width:96.75pt;height:30.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image022.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов2.mht!http://www.progz.ru/images/opengl/chapter2/form_5.gif"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=129 height=41
src="OpenGL%20Red%20Book.files/image022.gif" v:shapes="_x0000_i1046"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Вектора нормалей остаются
нормализованными до тех пор, пока вы используете только повороты и переносы
своих объектов. Если же вы производите масштабирование, используете
специфическую матрицу преобразования или изначально указываете
ненормализованные вектора нормалей – вы должны заставить OpenGL нормализовать
векторы после преобразований. Чтобы это сделать, вызовите <b>glEnable(GL_NORMALIZE)</b>.</p>

<p class=text align=left style='text-align:left'>Если вы устанавливаете вектора
нормали единичной длины и применяете только равномерное масштабирование (с
сохранением одинаковых пропорций по всем осям), то для нормализации вы можете
также использовать <b>glEnable(GL_RESCALE_NORMAL)</b>. В этом случае для
возвращения нормалей к единичной длине OpenGL будет делить все их координаты на
одинаковую величину изменения масштаба, взятую из матрицы модельного
преобразования.</p>

<p class=text align=left style='text-align:left'>Заметьте, что автоматическая
нормализация или масштабирование обычно требуют дополнительных расчетов,
которые могут снизить быстродействие вашего приложения. Равномерное
масштабирование нормалей с помощью GL_RESCALE_NORMAL обычно менее расточительно
в смысле производительности, чем полномасштабная нормализация с помощью
GL_NORMALIZE. По умолчанию оба описанных механизма (и нормализация, и
масштабирование) выключены.</p>

<h2>2.7 Вершинные массивы</h2>

<p class=text align=left style='text-align:left'>Как вы могли заметить, для
визуализации геометрических примитивов OpenGL требует вызовов достаточно
большого числа функций. Например, рисование 20-стороннего полигона требует 22
вызовов функций: сначала <b>glBegin()</b>, за тем по одному вызову <b>glVertex*()</b>
для каждой из 20-ти вершин и, в завершении, <b>glEnd()</b>. В двух предыдущих
примерах кода ввод дополнительной информации (флагов ребра и нормалей к
поверхности) также приводил к дополнительным вызовам. В такой ситуации
количество вызываемых команд для рисования одного объекта может быстро
удвоиться или даже утроиться. Для некоторых систем дополнительные вызовы
функций могут привести к значительному снижению быстродействия вашего
приложения.</p>

<p class=text align=left style='text-align:left'>Еще одной проблемой является
излишняя обработка вершин, являющихся общими для нескольких смежных полигонов.
Например, куб на рисунке 2-15 состоит из 6-ти граней и 8-ми общих вершин. К
несчастью, при использовании стандартных методов описания этого объекта, каждая
вершина должна быть описана 3 раза: по одному разу для каждой грани, которая ее
использует. Таким образом, должны быть обработаны 24 вершины, хотя в принципе
достаточно всего 8-ми.</p>

<p class=text align=left style='text-align:left'>Рисунок 2-15. Шесть сторон,
восемь общих вершин</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1047" type="#_x0000_t75" alt="" style='width:2in;height:132.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image023.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов2.mht!http://www.progz.ru/images/opengl/chapter2/2-15.gif"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=192 height=177
src="OpenGL%20Red%20Book.files/image023.gif" v:shapes="_x0000_i1047"><![endif]></p>

<p class=text align=left style='text-align:left'>Механизм вершинных массивов
OpenGL позволяет вам указывать разнообразные данные, связанные с вершинами, при
помощи всего нескольких массивов и получать доступ к этим данным при помощи
всего нескольких вызовов команд. При использовании вершинных массивов все 20
вершин двадцатистороннего полигона могут быть помещены в один массив и переданы
для визуализации с помощью одной функции. Если кроме этого каждая вершина имеет
вектор нормали, все эти вектора могут быть помещены в другой массив и тоже вызваны
одной функцией.</p>

<p class=text align=left style='text-align:left'>Помещение данных в вершинные
массивы может увеличить быстродействие вашего приложения. Использование
вершинных массивов снижает количество вызовов функций, что увеличивает
быстродействие. Кроме того, использование вершинных массивов может устранить
избыточность при обработке общих вершин (но не обязательно – совместное
использование вершин поддерживается не всеми реализациями OpenGL). </p>

<p class=warning>Замечание: Вершинные массивы являются частью стандарта OpenGL
версии 1.1, но не были частью спецификации OpenGL 1.0. Тем не менее, в версии
1.0 некоторые поставщики реализовывали вершинные массивы в виде расширений. </p>

<p class=text align=left style='text-align:left'>Для визуализации геометрии с
помощью вершинных массивов необходимо выполнить три шага:</p>

<ol start=1 type=1>
 <li class=MsoNormal style='color:black;mso-margin-top-alt:auto;mso-margin-bottom-alt:
     auto;mso-list:l16 level1 lfo3;tab-stops:list 36.0pt'><span
     style='font-size:10.0pt;font-family:Verdana'>Активизировать (включить) от
     одного до шести массивов, каждый из которых применяется для хранения
     различных данных: координат вершин, RGBA – цветов, цветовых индексов,
     нормалей, координат текстуры или флагов ребра. <o:p></o:p></span></li>
 <li class=MsoNormal style='color:black;mso-margin-top-alt:auto;mso-margin-bottom-alt:
     auto;mso-list:l16 level1 lfo3;tab-stops:list 36.0pt'><span
     style='font-size:10.0pt;font-family:Verdana'>Поместить данные в массив или
     массивы. Доступ к массивам производится с помощью указателей на их
     местонахождение в памяти. В клиент-серверной модели эти данные сохраняются
     в адресном пространстве клиента. <o:p></o:p></span></li>
 <li class=MsoNormal style='color:black;mso-margin-top-alt:auto;mso-margin-bottom-alt:
     auto;mso-list:l16 level1 lfo3;tab-stops:list 36.0pt'><span
     style='font-size:10.0pt;font-family:Verdana'>Нарисовать геометрию с
     помощью имеющихся данных. OpenGL разрешает указатели и одновременно
     извлекает данные, касающиеся каждой вершины (координаты, цвет и так
     далее), из всех активизированных массивов. (В клиент-серверной модели
     данные передаются в адресное пространство сервера.) Существует три
     варианта извлечения данных: <o:p></o:p></span></li>
 <ol start=1 type=a>
  <li class=MsoNormal style='color:black;mso-margin-top-alt:auto;mso-margin-bottom-alt:
      auto;mso-list:l16 level2 lfo3;tab-stops:list 72.0pt'><span
      style='font-size:10.0pt;font-family:Verdana'>Доступ к индивидуальным
      элементам массива (элементом вершинного массива считается фрагмент
      данных, относящихся к одной вершине – две координаты, тройка значений
      компонентов цвета и так далее) <o:p></o:p></span></li>
  <li class=MsoNormal style='color:black;mso-margin-top-alt:auto;mso-margin-bottom-alt:
      auto;mso-list:l16 level2 lfo3;tab-stops:list 72.0pt'><span
      style='font-size:10.0pt;font-family:Verdana'>Создание списка
      индивидуальных элементов массива, которые нужно выбрать <o:p></o:p></span></li>
  <li class=MsoNormal style='color:black;mso-margin-top-alt:auto;mso-margin-bottom-alt:
      auto;mso-list:l16 level2 lfo3;tab-stops:list 72.0pt'><span
      style='font-size:10.0pt;font-family:Verdana'>Обработка
      последовательностей элементов массива. <o:p></o:p></span></li>
 </ol>
</ol>

<p class=text align=left style='text-align:left'>Метод доступа к данным может
зависеть от типа решаемой вами задачи.</p>

<p class=text align=left style='text-align:left'>Смешанные вершинные массивы
данных представляют собой другой часто используемый метод организации. Вместо
того, чтобы использовать до шести массивов, содержащих разные типы данных, вы
можете смешивать различные данные в одном единственном массиве.</p>

<h2>2.7.1&nbsp; Шаг 1: Включение массивов</h2>

<p class=text align=left style='text-align:left'>Первый шаг заключается в
вызове <b>glEnableClientState()</b> с параметром, определяющим выбранный для
активизации массив. Теоретически, вам может понадобиться до шести вызовов этой
функции для активизации всех шести имеющихся массивов. На практике, вы,
вероятно, будете использовать от одного до четырех массивов. Например, очень
маловероятно, что вы будете одновременно использовать массивы GL_COLOR_ARRAY
(массив цветов в режиме RGBA) и GL_INDEX_ARRAY (массив индексов цветов в
палитровых режимах), поскольку режим дисплея, используемый вашей программой,
поддерживает либо RGBA – цвета, либо цветовые индексы, но вряд ли оба
одновременно.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>glEnableClientState </b>(GLenum
  <i>array</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Применяется для активизации
массива. Единственный параметр может принимать значения GL_VERTEX_ARRAY (массив
координат вершин), GL_COLOR_ARRAY (массив цветов в режиме RGBA), GL_INDEX_ARRAY
(массив цветовых индексов для соответствующего режима), GL_NORMAL_ARRAY (массив
координат векторов нормалей), GL_TEXTURE_COORD_ARRAY (массив координат
текстуры) или GL_EDGE_FLAG_ARRAY (массив значений флага ребра).</p>

<p class=text align=left style='text-align:left'>Если в программе вы
используете освещение, вам может понадобиться определить вектор нормали для
каждой вершины. Чтобы сделать это с помощью вершинных массивов необходимо
включить не только массив координат вершин, но и массив координат векторов
нормали^</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>glEnableClientState(GL_VERTEX_ARRAY);<br>
  glEnableClientState(GL_NORMAL_ARRAY);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Представьте себе, что в
какой-то момент вы хотите выключить освещение и рисовать все геометрические
объекты одним цветом. Вам понадобится <b>glDisable()</b> для выключения
расчетов, связанных с освещением. Кроме того, вы, вероятно, захотите отключить
присваивание нормалей вершинам, так как без света – это лишняя трата времени.
Чтобы это сделать, вызовите:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>glDisableClientState(GL_NORMAL_ARRAY);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Verdana;
color:black;display:none;mso-hide:all'><o:p>&nbsp;</o:p></span></p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>glDisableClientState </b>(GLenum
  <i>array</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Указывает массив, который надо
выключить (то есть массив, из которого не нужно забирать данные при обработке).
Возможные значения параметра аналогичны значениям параметра <b>glEnableClientState()</b>.</p>

<p class=text align=left style='text-align:left'>Возможно, вы спрашиваете себя,
зачем архитекторам OpenGL понадобилось создавать эти новые длинные имена команд
(<b>gl*ClientState()</b>), почему нельзя было просто использовать пару <b>glEnable()</b>
/ <b>glDisable()</b>? Одна из причин заключается в том, что <b>glEnable()</b> /
<b>glDisable()</b> могут входить в список отображения, а спецификация вершинных
массивов – нет, так как данные остаются на клиентской стороне.</p>

<p class=text align=left style='text-align:left'>Для реализаций OpenGL,
поддерживающих расширение мультитекстурирования, включение и выключение
вершинных массивов влияет только на текущий элемент текстуры.</p>

<h2>2.7.2&nbsp; Шаг 2: Указание данных для массивов</h2>

<p class=text align=left style='text-align:left'>Передача данных для вершинных
массивов является достаточно прямолинейным процессом. Одна команда задает один
массив в пространстве клиента. Существует 6 различных команд для передачи
данных в 6 типов массивов. Кроме того, существует команда, позволяющая указать
в качестве источника данных для нескольких типов вершинных массивов, один
физический перекрестный массив.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glVertexPointer</b>
  (Glint <i>size</i>, GLenum <i>type</i>, GLsizei <i>stride</i>, const GLvoid *<i>pointer</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Позволяет указать, где
находятся данные для массива вершинных координат. <i>pointer</i> – это
указатель на область памяти, где содержится первая координата первой вершины. <i>type</i>
задает тип данных для каждой координаты в массиве (GL_SHORT, GL_INT, GL_FLOAT
или GL_DOUBLE). <i>size</i> – количество координат на одну вершину, должен
принимать значения 2, 3 или 4. <i>stride</i> – промежуток в памяти (в байтах)
между первой координатой предыдущей и первой координатой следующей вершины.
Если <i>stride</i> равен 0 (специальное значение), считается, что вершины
плотно упакованы в памяти.</p>

<p class=text align=left style='text-align:left'>Для указания данных к другим
пяти массивам, существует еще пять похожих команд:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glColorPointer</b>
  (Glint <i>size</i>, GLenum <i>type</i>, GLsizei <i>stride</i>, const GLvoid *<i>pointer</i>);<br>
  void <b>glIndexPointer</b> (GLenum <i>type</i>, GLsizei <i>stride</i>, const
  GLvoid *<i>pointer</i>);<br>
  void <b>glNormalPointer</b> (GLenum <i>type</i>, GLsizei <i>stride</i>, const
  GLvoid *<i>pointer</i>);<br>
  void <b>glTexCoordPointer</b> (Glint <i>size</i>, GLenum <i>type</i>, GLsizei
  <i>stride</i>, const GLvoid *<i>pointer</i>);<br>
  void <b>glEdgeFlagPointer </b>(GLsizei <i>stride</i>, const GLvoid *<i>pointer</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Главное различие этих команд
заключается в том, что для каких-то из них необходимо указывать тип данных и
количество элементов данных на каждую вершину, а для каких-то нет. Например, у
нормали к поверхности всегда три координаты, таким образом, нет смысла указывать
число элементов физического массива на одну нормаль. Флаг ребра всегда имеет
булевский тип, поэтому нет смысла указывать число и тип элементов физического
массива на каждую вершину. В таблице 2-4 перечислены возможные значения
параметров <i>size</i> и <i>type</i> для всех команд загрузки массивов, в
которых эти параметры присутствуют, а также значения, принимаемые OpenGL
изначально, для команд, где нет этих параметров в явном виде.</p>

<p class=text align=left style='text-align:left'>Таблица 2-4. Типы и количество
элементов (на одну вершину) вершинных массивов </p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;border:solid black 1.0pt;mso-border-alt:
 solid black .75pt;mso-padding-left-alt:3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Команда</span></strong><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Количество элементов на вершину</span></strong><span
  style='font-size:8.0pt;font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Тип элементов</span></strong><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glVertexPointer</span></strong><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>2,3, 4<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_SHORT, GL_INT, GL_FLOAT, GL_DOUBLE<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glNormalPointer</span></strong><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>не указывается – всегда 3<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_BYTE, GL_SHORT, GL_INT, GL_FLOAT,
  GL_DOUBLE<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glColorPointer</span></strong><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>3, 4<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT,
  GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, GL_DOUBLE<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glIndexPointer</span></strong><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>не указывается – всегда 1<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_UNSIGNED_BYTE, GL_SHORT, GL_INT,
  GL_FLOAT, GL_DOUBLE<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:5'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glTexCoordPointer</span></strong><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1, 2, 3, 4<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_SHORT, GL_INT, GL_FLOAT, GL_DOUBLE<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:6;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glEdgeFlagPointer</span></strong><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>не указывается – всегда 1<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>не указывается – всегда булевский тип<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Для реализаций OpenGL,
поддерживающих мультитекстурирование, указание массива координат текстуры с
помощью <b>glTexCoordPointer()</b> влияет только на текущий элемент текстуры.</p>

<p class=text align=left style='text-align:left'>В примере 2-9 вершинные
массивы используются одновременно для хранения координат вершин и их цветов в
режиме RGBA. Значения с плавающей точкой для RGB – цветов и соответствующие им
целые координаты вершин (<i>x</i>, <i>y</i>) загружаются в GL_COLOR_ARRAY
(массив цветов в режиме RGBA) и GL_VERTEX_ARRAY (массив координат вершин).</p>

<p class=text align=left style='text-align:left'>&nbsp;Пример 2-9. Включение и
загрузка вершинных массивов</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>GLint
  vertices[]= {25, 25,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  100, 325,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  175, 25,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  175, 325,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  250, 25,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  325, 325};<br>
  GLfloat colors[]= {1.0, 0.2, 0.2,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  0.2, 0.2, 1.0,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  0.8, 1.0, 0.2,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  0.75, 0.75, 0.75,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  0.35, 0.35, 0.35,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  0.5, 0.5, 0.5};<br>
  <br>
  glEnableClientState(GL_COLOR_ARRAY);<br>
  glEnableClientState(GL_VERTEX_ARRAY);<br>
  <br>
  glColorPointer(3,GL_FLOAT, 0, colors);<br>
  glVertexPointer(2,GL_INT, 0, vertices);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<h2>2.7.2.1&nbsp;&nbsp;&nbsp; Смещение</h2>

<p class=text align=left style='text-align:left'>Параметр <i>stride</i> команд <b>gl*Pointer()</b>
говорит OpenGL, как получать доступ к данным предоставляемого вами физического
массива. Этот параметр должен быть равен числу байт памяти между первым
элементом массива, относящимся к предыдущей вершине, и первым элементом,
относящимся к следующей вершине. Кроме того, параметр может быть равен 0 – эта
величина имеет специальное назначение. Например, предположим, что вы сохранили
RGB – цвета вершин и их координаты (<i>x</i>, <i>y</i>, <i>z</i>) в одном
физическом массиве:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>GLfloat interwined[]={<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.0, 0.2, 1.0, 100.0, 100.0, 0.0,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.0, 0.2, 0.2, 0.0, 200.0, 0.0,<br>
  &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;1.0, 1.0, 0.2, 100.0, 300.0, 0.0,<br>
  &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;0.2, 1.0, 0.2, 200.0, 300.0, 0.0,<br>
  &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;0.2, 1.0, 1.0, 300.0, 200.0, 0.0,<br>
  &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;0.2, 0.2, 1.0, 200.0, 100.0, 0.0}; <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=warning>Замечание: Важно четко понимать разницу между физическим
массивом и вершинным массивом. Физический массив представляет собой некоторый
диапазон памяти, где хранится некоторое количество элементов одинакового типа.
Например, вы можете объявить массив типа GLubyte. Элементом массива при этом
считается одна величина указанного при объявлении типа. Любой же вершинный
массив – понятие, не связанное прямо с физической памятью компьютера, поскольку
любая реализация OpenGL может реализовывать вершинные массивы тем способом,
который ее разработчики, считают эффективным. Кроме того, элементом любого
вершинного массива считаются все данные, относящиеся к одной вершине,
независимо от реального типа этих данных и количества компонент. Например, в
качестве источника данных для вершинного массива RGB-цветов вы можете задать
объявленный и определенный ранее физический массив типа GLubyte. Если вы
укажете, что каждый цвет состоит из трех компонент, то одним элементом
вершинного массива RGB – цветов будут считаться 3 байта, определяющих эти
компоненты для одной вершины. То есть в данном случае одним элементом
вершинного массива являются 3 элемента физического массива. Более того,
источник данных для вершинных массивов может и не являться физическим массивом
с простым типом элементов. Можно объявить массив сложных структур и
использовать его. В общем случае, описываемый здесь Шаг 2 как раз и нужен для
того, чтобы указать OpenGL, откуда брать данные для вершинных массивов и как их
трактовать. </p>

<p class=text align=left style='text-align:left'>Чтобы сослаться только на
цветовые значения массива <i>interwined</i>, следующий вызов начинает забирать
данные из начала массива (указатель на которое передается в виде <i>&amp;interwined[0]</i>),
затем сдвигается на 6*<b>sizeof</b>(GLfloat), что является размером в байтах
трех компонент цвета и трех координат одной вершины. Этого прыжка достаточно,
чтобы попасть на начало цветовых данных&nbsp; для следующей вершины.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>glColorPointer(3,GL_FLOAT,6*sizeof(GLfloat),&amp;interwined[0]);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Для получения координат
вершин, необходимо начать с 4-го элемента физического массива <i>interwined</i>
(помните, что в C нумерация элементов массива начинается с 0).</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>glVertexPointer(3,GL_FLOAT,
  6*sizeof(GLfloat),&amp;interwined[3]);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Если <i>stride</i> равен 0,
считается, что данные плотно упакованы в памяти и массив является гомогенным
(или однородным), то есть в нем только цвета, только координаты вершин, только
нормали и так далее.</p>

<h2>2.7.3&nbsp; Шаг 3: Разрешение данных</h2>

<p class=text align=left style='text-align:left'>До тех пор, пока не произошло
разрешение данных&nbsp; вершинных массивов, они остаются на клиентской стороне
и можно легко менять их содержимое. На третьем шаге данные извлекаются из
массивов и отправляются на сервер и далее обрабатываются конвейером
визуализации.</p>

<p class=text align=left style='text-align:left'>Данные могут быть извлечены из
одного элемента массива (по его индексу), из упорядоченного списка элементов
массива (который может определять какие именно данные следует обрабатывать, а
какие нет) или из последовательности элементов массива.</p>

<h2>2.7.3.1&nbsp;&nbsp;&nbsp; Разрешение одного элемента массива</h2>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>glArrayElement </b>(Glint
  <i>ith</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Извлекает данные для одной
вершины с индексом <i>ith</i> из всех включенных в текущий момент массивов. Для
массива с координатами вершин соответствующей сгенерированной командой будет <b>glVertex</b>[<i>size</i>][<i>type</i>]<b>v()</b>,
где <i>size</i> будет равен 2, 3 или 4, а <i>type</i> – s, i, f или d (для
GLshort, Glint, GLfloat и GLdouble соответственно). И <i>size</i>, и <i>type</i>
были ранее определены вызовом <b>glVertexPointer()</b>. Для других типов
массивов вызов <b>glArrayElement()</b> приведет к генерации команд <b>glEdgeFlagv()</b>,
<b>glTexCoord</b>[<i>size</i>][<i>type</i>]<b>v()</b>, <b>glColor</b>[<i>size</i>][<i>type</i>]<b>v()</b>,
<b>glIndex</b>[<i>type</i>]<b>v()</b> и <b>glNormal</b>[<i>type</i>]<b>v()</b>.
Если включен массив вершинных координат, команда <b>glVertex*v()</b> будет
вызвана последней, после исполнения до пяти других команд, если включены
соответствующие массивы.</p>

<p class=text align=left style='text-align:left'>Обычно <b>glArrayElement()</b>
вызывается между командами <b>glBegin()</b> и <b>glEnd()</b> (если <b>glArrayElement()</b>
вызывается за пределами этих командных скобок, он устанавливает текущее
значение для всех переменных состояния, соответствующих включенным массивам,
например, текущий цвет, текущий вектор нормали и так далее; если при этом
включен массив вершинных координат, то его данные ни на что не влияют,
поскольку не существует понятия текущей вершины). В примере 2-10 треугольник
рисуется с помощью данных, относящихся к третьей, четвертой и шестой вершинам
(следует опять-таки помнить, что в языке C нумерация массивов начинается с 0).</p>

<p class=text align=left style='text-align:left'>Пример 2-10. Использование
glArrayElement() для задания координат вершин и их цветов</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>glEnableClientState(GL_COLOR_ARRAY);<br>
  glEnableClientState(GL_VERTEX_ARRAY);<br>
  <br>
  glColorPointer(3,GL_FLOAT,0,colors);<br>
  glVertexPointer(2,GL_INT,0,vertices);<br>
  &nbsp;<br>
  glBegin(GL_TRIANGLES);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glArrayElement(2);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glArrayElement(3);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glArrayElement(5);<br>
  glEnd();<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>&nbsp;</span>В период выполнения последние пять
строк кода будут иметь такой же эффект, как</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=ccode><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>glBegin(GL_TRIANGLES);<br>
  &nbsp;&nbsp; glColor3fv(colors+(2*3));<br>
  &nbsp;&nbsp; glVertex2iv(vertices+(2*2));<br>
  &nbsp;&nbsp; glColor3fv(colors+(3*3));<br>
  &nbsp;&nbsp; glVertex2iv(vertices+(3*2));<br>
  &nbsp;&nbsp; glColor3fv(colors+(5*3));<br>
  &nbsp;&nbsp; glVertex2iv(vertices+(5*2));<br>
  glEnd();<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Поскольку при использовании <b>glArrayElement()</b>
происходит только один вызов на одну вершину, это может сократить общее
количество вызовов функций и тем самым увеличить быстродействие.</p>

<p class=text align=left style='text-align:left'>Имейте в виду, что если
содержимое массива изменяется между вызовами <b>glBegin()</b> и <b>glEnd()</b>,
нет гарантии, что вы получите оригинальные или измененные данные для
запрошенного элемента. Для большей предсказуемости результата не изменяйте
данные тех элементов массивов, доступ к которым может понадобиться до
завершения примитива.</p>

<h2>2.7.3.2&nbsp;&nbsp;&nbsp; Разрешение списка элементов массива</h2>

<p class=text align=left style='text-align:left'>Команду <b>glArrayElement() </b>удобно
применять для случайных выборок данных из вершинных массивов. Похожие команды <b>glDrawElements()</b>
и <b>glDrawRangeElements()</b> удобны для проведения случайных выборок данных в
более упорядоченной манере.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=ccode><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glDrawElements</b>
  (GLenum <i>mode</i>, GLsizei <i>count</i>, GLenum <i>type</i>, void *<i>indices</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Определяет<span
style='mso-ansi-language:EN-US'> </span>последовательность<span
style='mso-ansi-language:EN-US'> </span>геометрических<span style='mso-ansi-language:
EN-US'> </span>примитивов<span lang=EN-US style='mso-ansi-language:EN-US'>, </span>используя<span
style='mso-ansi-language:EN-US'> <i><span lang=EN-US>count</span></i><span
lang=EN-US> </span></span>элементов<span style='mso-ansi-language:EN-US'> </span>вершинных<span
style='mso-ansi-language:EN-US'> </span>массивов<span lang=EN-US
style='mso-ansi-language:EN-US'>, </span>индексы<span style='mso-ansi-language:
EN-US'> </span>которых<span style='mso-ansi-language:EN-US'> </span>находятся<span
style='mso-ansi-language:EN-US'> </span>в<span style='mso-ansi-language:EN-US'>
</span>массиве<span style='mso-ansi-language:EN-US'> <i><span lang=EN-US>indices</span></i><span
lang=EN-US>. <i>type</i> </span></span>может<span style='mso-ansi-language:
EN-US'> </span>принимать<span style='mso-ansi-language:EN-US'> </span>значение<span
lang=EN-US style='mso-ansi-language:EN-US'> GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT
</span>или<span lang=EN-US style='mso-ansi-language:EN-US'> GL_UNSIGNED_INT, </span>задавая<span
style='mso-ansi-language:EN-US'> </span>тип<span style='mso-ansi-language:EN-US'>
</span>данных<span style='mso-ansi-language:EN-US'> </span>в<span
style='mso-ansi-language:EN-US'> </span>массиве<span style='mso-ansi-language:
EN-US'> <i><span lang=EN-US>indices</span></i><span lang=EN-US>. </span></span>Параметр
<i>mode</i> указывает, какие примитивы следует построить, и может принимать те
же значения, что и единственный параметр <b>glBegin()</b>, например GL_POLYGON,
GL_LINE_LOOP, GL_LINES, GL_POINTS и так далее.</p>

<p class=text align=left style='text-align:left'>Эффект от вызова <b>glDrawElements()</b>
практически то же, что и от следующей последовательности команд:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>int
  i;<br>
  glBegin(mode);<br>
  &nbsp;&nbsp; for(i=0;i&lt;COUNT;I++)<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glArrayElement(indices[i]);<br>
  glEnd();<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>В дополнение <b>glDrawElements()</b>
проверяет <i>mode</i>, <i>count</i> и <i>type</i> на корректность значений.
Также, в отличие от предыдущих строк, вызов <b>glDrawElements()</b> оставляет
некоторые переменные в неопределенном состоянии. После исполнения <b>glDrawElements()</b>
текущие RGB – цвет, цветовой индекс, координаты нормали, координаты текстуры и
флаг ребра не определены (или неизвестны, непредсказуемы) если во время вызова
были включены соответствующие массивы.</p>

<p class=text align=left style='text-align:left'>При использовании <b>glDrawElements()</b>
индексы всех вершин каждой грани куба могут быть помещены в массив индексов.
Пример 2-11 демонстрирует два пути использования <b>glDrawElements()</b> для
визуализации куба. На рисунке 2-16 показана нумерация вершин, используемая в
примере 2-11.</p>

<p class=text align=left style='text-align:left'>Рисунок 2-16. Куб с
пронумерованными вершинами</p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1048" type="#_x0000_t75" alt="" style='width:212.25pt;height:177.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image024.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов2.mht!http://www.progz.ru/images/opengl/chapter2/2-16.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=283 height=237
src="OpenGL%20Red%20Book.files/image024.jpg" v:shapes="_x0000_i1048"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Пример 2-11. Два способа
использования glDrawElements()</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>GLubyte
  frontIndices[] = {4,5,6,7};<br>
  GLubyte rightIndices[] = {1,2,6,5};<br>
  GLubyte bottomIndices[] = {0,1,5,4};<br>
  GLubyte backIndices[] = {0,3,2,1};<br>
  GLubyte leftIndices[] = {0,4,7,3};<br>
  GLubyte topIndices[] = {2,3,7,6};<br>
  <br>
  glDrawElements(GL_QUADS,4,GL_UNSIGNED_BYTE,frontIndices);<br>
  glDrawElements(GL_QUADS,4,GL_UNSIGNED_BYTE,rightIndices);<br>
  glDrawElements(GL_QUADS,4,GL_UNSIGNED_BYTE,bottomIndices);<br>
  glDrawElements(GL_QUADS,4,GL_UNSIGNED_BYTE,backIndices);<br>
  glDrawElements(GL_QUADS,4,GL_UNSIGNED_BYTE,leftIndices);<br>
  glDrawElements(GL_QUADS,4,GL_UNSIGNED_BYTE,topIndices);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Или другой вариант – собираем
все индексы вместе:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>GLubyte
  allIndices[] ={4,5,6,7,1,2,6,5,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  0,1,5,4,0,3,2,1,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  0,4,7,3,2,3,7,6};<br>
  <br>
  glDrawElements(GL_QUADS,24,GL_UNSIGNED_BYTE,allIndices); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=warning>Замечание<span lang=EN-US style='mso-ansi-language:EN-US'>: </span>Вызов<span
style='mso-ansi-language:EN-US'> <b><span lang=EN-US>glDrawElements()</span></b><span
lang=EN-US> </span></span>между<span style='mso-ansi-language:EN-US'> <b><span
lang=EN-US>glBegin()</span></b><span lang=EN-US> </span></span>и<span
style='mso-ansi-language:EN-US'> <b><span lang=EN-US>glEnd()</span></b><span
lang=EN-US> </span></span>является<span style='mso-ansi-language:EN-US'> </span>ошибкой<span
lang=EN-US style='mso-ansi-language:EN-US'>. <o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Как и <b>glDrawElements()</b>,
команда <b>glDrawRangeElements()</b> удобна для случайной выборки данных из
массивов и визуализации этих данных. <b>glDrawRangeElements()</b> также
позволяет определить ограничения на диапазон допустимых значений индексов, что
может увеличить быстродействие программы. Для оптимального быстродействия,
некоторые реализации OpenGL могут еще до визуализации извлекать из вершинных
массивов ограниченное количество данных. <b>glDrawRangeElements()</b> позволяет
указать диапазон вершин, который будет кэширован таким образом.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glDrawRangeElements</b>
  (GLenum <i>mode</i>, GLuint <i>start</i>, GLuint <i>end</i>, GLsizei <i>count</i>,
  GLenum <i>type</i>, void *<i>indices</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Создает последовательность
геометрических примитивов, так же как и <b>glDrawElements()</b>, однако
накладывает дополнительные ограничения на значения принимаемых параметров.
Часть параметров <b>glDrawRangeElements()</b>, включая <i>mode</i> (тип
примитивов), <i>count</i> (количество элементов), <i>type</i> (тип данных) и <i>indices</i>
(массив индексов), имеет то же значение, что и аналогичные параметры <b>glDrawElements()</b>.
В <b>glDrawRangeElements()</b> присутствуют еще два параметра: <i>start</i> и <i>end</i>,
которые указывают диапазон допустимых значений для <i>indices</i>. Для того,
чтобы быть допустимыми, значения элементов массива indices должны лежать в
диапазоне между <i>start</i> и <i>end</i> включительно.</p>

<p class=text align=left style='text-align:left'>Указание в массиве <i>indices</i>
значений индексов вне диапазона [<i>start</i>, <i>end</i>] является ошибкой.
Однако реализация OpenGL не обязательно обнаруживает эту ошибку или рапортует о
ней. То есть, недопустимая величина индекса может генерировать ошибку OpenGL, а
может и нет. Что будет происходить в каждом конкретном случае, зависит от
каждой конкретной реализации.</p>

<p class=text align=left style='text-align:left'>Вы можете использовать <b>glGetIntegerv()</b>
с параметрами GL_MAX_ELEMENTS_VERTICES и GL_MAX_ELEMENTS_INDICES для того,
чтобы выяснить, соответственно, рекомендуемые максимум количества кэшируемых
вершин и максимальное количество индексов (то есть общее количество вершин,
которые должны быть визуализированы). Если <i>end</i>-<i>start</i>+1 больше,
чем рекомендованный максимум кэшируемых вершин, или если <i>count</i> больше
рекомендуемого максимума индексов, <b>glDrawRangeElements()</b> должна
по-прежнему работать корректно, но быстродействие может быть снижено.</p>

<p class=text align=left style='text-align:left'>Не является обязательной
ссылка на все вершины из диапазона [<i>start</i>, <i>end</i>]. Однако для многих
реализаций указание чрезмерно широкого диапазона вызовет ненужную обработку
большого числа вершин, на которые нет ссылок в массиве <i>indices</i>.</p>

<p class=text align=left style='text-align:left'>Возможно, что при
использовании <b>glArrayElements()</b>, <b>glDrawElements()</b> и <b>glDrawRangeElements()</b>,
ваша реализация OpenGL кэширует недавно обработанные (то есть преобразованные,
освещенные и так далее) вершины, позволяя вашему приложению повторно
использовать их, не передавая их на конвейер визуализации еще раз. Например,
означенный выше куб состоит из 6-ти граней (полигонов) и всего 8-ти вершин.
Каждая вершина используется 3-мя гранями. Без команд <b>gl*Elements() </b>визуализация
всех 6-ти граней потребовала бы обработки 24-х вершин, несмотря на то, что
обработка 16-ти из них являлась бы избыточной. Ваша реализация OpenGL может
минимизировать избыточную обработку, визуализировав всего 8 вершин. (Повторное
использование вершин может быть ограничено всеми вершинами, указанными в одном
вызове <b>glDrawElements()</b> или <b>glDrawRangeElements()</b>, или в случае <b>glArrayElement()</b>,
всеми вершинами, указанными внутри одного блока <b>glBegin()</b>/<b>glEnd()</b>.)</p>

<h2>2.7.3.3 Разрешение последовательности элементов массива</h2>

<p class=text align=left style='text-align:left'>В отличие от команд <b>glArrayElements()</b>,
<b>glDrawElements()</b> и <b>glDrawRangeElements()</b>, позволяющих
осуществлять случайную выборку элементов вершинных массивов, команда <b>glDrawArrays()</b>
осуществляет последовательную выборку.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glDrawArrays</b>
  (GLenum <i>mode</i>, Glint <i>first</i>, GLsizei <i>count</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Конструирует
последовательность геометрических примитивов, используя элементы включенных
вершинных массивов, начиная с индекса <i>first</i> и заканчивая индексом <i>first</i>+<i>count</i>-1.
Параметр <i>mode</i> указывает, какие примитивы следует построить, и может
принимать те же значения, что и единственный параметр <b>glBegin()</b>,
например GL_POLYGON, GL_LINE_LOOP, GL_LINES, GL_POINTS и так далее.</p>

<p class=text align=left style='text-align:left'>Эффект от вызова <b>glDrawArrays()</b>
аналогичен следующей последовательности команд:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>int
  i;<br>
  glBegin(mode);<br>
  &nbsp;&nbsp; for(i=0;i&lt;COUNT;I++)<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glArrayElement(first+i);<br>
  glEnd(); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Как и <b>glDrawElements()</b>,
<b>glDrawArrays()</b> производит проверку значений своих параметров на
допустимость и оставляет текущие RGB-цвет, цветовой индекс, координаты нормали,
координаты текстуры и флаг ребра в неопределенном состоянии, если
соответствующий массив был включен во время ее вызова.</p>

<h2>2.7.4 Смешанные массивы</h2>

<p class=text align=left style='text-align:left'><b>Дополнительно:</b> Ранее мы
рассматривали специальный случай смешанного массива. Тогда в массиве <i>interwined</i>
чередовались данные RGB –цветов и 3D – координат вершин. Доступ к ним был
получен с помощью команд <b>glColorPointer()</b> и <b>glVertexPointer()</b> и
правильного выбора значений параметра <i>stride</i>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>GLfloat interwined[]={1.0,
  0.2, 1.0, 100.0, 100.0, 0.0,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  1.0, 0.2, 0.2, 0.0, 200.0, 0.0,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  1.0, 1.0, 0.2, 100.0, 300.0, 0.0,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  0.2, 1.0, 0.2, 200.0, 300.0, 0.0,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  0.2, 1.0, 1.0, 300.0, 200.0, 0.0,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  0.2, 0.2, 1.0, 200.0, 100.0, 0.0}; <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Существует также команда <b>glInterleavedArrays()</b>,
которая позволяет задавать несколько вершинных массивов за один вызов. Кроме
того, <b>glInterleavedArrays()</b> включает и выключает выбранные массивы,
таким образом, объединяя действия на Шаге 1: Включение массивов и Шаге 2:
Указание данных для массивов. На самом деле массив <i>interwined</i> отвечает
одной из 14 возможных конфигураций данных смешанных массивов, поддерживаемых <b>glInterleavedArrays()</b>.
Таким образом, для того, чтобы использовать данные <i>interwined</i> в массиве
RGB-цветов и массиве координат вершин, а также для включения обоих этих
массивов, вызовите:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>glInterleavedArrays(GL_C3F_V3F,
  0, interwined);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Этот<span style='mso-ansi-language:
EN-US'> </span>вызов<span style='mso-ansi-language:EN-US'> <b><span lang=EN-US>glInterleavedArrays()</span></b><span
lang=EN-US> </span></span>включает<span style='mso-ansi-language:EN-US'> </span>массивы<span
lang=EN-US style='mso-ansi-language:EN-US'> GL_COLOR_ARRAY </span>и<span
lang=EN-US style='mso-ansi-language:EN-US'> GL_VERTEX_ARRAY </span>и<span
style='mso-ansi-language:EN-US'> </span>выключает<span style='mso-ansi-language:
EN-US'> </span>массивы<span lang=EN-US style='mso-ansi-language:EN-US'>
GL_INDEX_ARRAY, GL_TEXTURE_COORD_ARRAY, GL_NORMAL_ARRAY </span>и<span
lang=EN-US style='mso-ansi-language:EN-US'> GL_EDGE_FLAG_ARRAY.<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Кроме того, эта строка имеет
тот же эффект, что и вызовы <b>glColorPointer()</b> и <b>glVertexPointer()</b>,
задающие значения для шести вершин в каждом из указанных включаемых массивов.
После этого можно переходить к Шагу 3, вызывая <b>glArrayElement()</b>, <b>glDrawElements()</b>,
<b>glDrawRangeElements()</b> или <b>glDrawArrays()</b> для разрешения данных
массивов.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glInterleavedArrays</b>
  (GLenum <i>format</i>, GLsizei <i>stride</i>, void *<i>pointer</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Инициализирует все шесть
вершинных массивов, выключая не указанные и включая указанные в параметре <i>format</i>.
Параметр <i>format</i> должен быть равен одной из 14 символических констант,
соответствующих 14 конфигурациям данных. Значения <i>format</i> и их смысл
перечислены в таблице 2-5. Параметр <i>stride</i> позволяет указать байтовое
смещение между данными смежных вершин. Если <i>stride</i> равен 0, считается,
что вершинные данные плотно упакованы в массиве. Параметр <i>pointer</i> – это
адрес памяти, где хранится первый элемент данных физического массива,
относящийся к первой вершине (указатель на начало физического массива в
памяти).</p>

<p class=text align=left style='text-align:left'>Для реализаций OpenGL,
поддерживающих расширение мультитекстурирования <b>glInterleavedArrays()</b>
влияет только на активный элемент текстуры.</p>

<p class=text align=left style='text-align:left'>Заметьте, что <b>glInterleavedArrays()
</b>не поддерживает флаги ребра.</p>

<p class=text align=left style='text-align:left'>Объяснение механики <b>glInterleavedArrays()
</b>достаточно сложно и требует ссылок на пример 2-12 и таблицу 2-5. В этих
примере и таблице, вы увидите несколько переменных. Переменные <i>et</i>, <i>ec</i>
и <i>en</i>, содержат булевские значения и представляют соответственно
включенное или выключенное состояние массивов текстурных координат, цвета и
координат нормалей. Переменные <i>st</i>, <i>sc</i> и <i>sv</i> представляют
собой размеры (количество компонент) одного элемента в массивах координат
текстуры, цвета и координат вершин соответственно. <i>tc</i> представляет собой
тип данных для RGBA – цвета, поскольку это единственный массив, который при
применении <b>glInterleavedArrays() </b>может содержать недробные значения. <i>pc</i>,
<i>pn</i> и <i>pv</i> представляют собой вычисленные значения смещения (в
байтах) от начала данных в физическом массиве, относящихся к определенной
вершине, до начала значений цвета, координат нормали и самих координат той же
вершины, а <i>s</i> -- это вычисленное смещение между началом данных
физического массива, относящихся к предыдущей вершине и началом данных, относящихся
к следующей за ней вершиной (применяется в том случае, если пользователь не
указал свое смещение).</p>

<p class=text align=left style='text-align:left'>Эффект от вызова <b>glInterleavedArrays()
</b>аналогичен эффекту от выполнения последовательности команд в примере 2-12.
Для простоты понимания считайте <i>et</i>, <i>ec</i>, <i>en</i>, <i>st</i>, <i>sc</i>,
<i>sv</i>, <i>tc</i>, <i>pc</i>, <i>pn</i>, <i>pv</i> и <i>s</i> – функциями
значений параметра <i>format</i>, перечисленных в таблице 2-5. Вся векторная
арифметика производится в единицах равных <b>sizeof</b>(GLubyte) байт
(теоретически это не обязательно 1 байт).</p>

<p class=text align=left style='text-align:left'>Пример<span lang=EN-US
style='mso-ansi-language:EN-US'> 2-12. </span>Эффект<span style='mso-ansi-language:
EN-US'> </span>от<span style='mso-ansi-language:EN-US'> </span>вызова<span
lang=EN-US style='mso-ansi-language:EN-US'> glInterleavedArrays(format, stride,
pointer)<o:p></o:p></span></p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>int
  str;<br>
  <br>
  str=stride;<br>
  if(str==0)<br>
  &nbsp;&nbsp; str=s;<br>
  <br>
  glDisableClientState(GL_EDGE_FLAG_ARRAY);<br>
  glDisableClientState(GL_INDEX_ARRAY);<br>
  &nbsp;<br>
  if (et)<br>
  {<br>
  &nbsp;&nbsp; glEnableClientState(GL_TEXTURE_COORD_ARRAY);<br>
  &nbsp;&nbsp; glTexCoordPointer(st,GL_FLOAT,str,pointer);<br>
  }<br>
  else<br>
  &nbsp;&nbsp; glDisableClientState(GL_TEXTURE_COORD_ARRAY);<br>
  &nbsp;<br>
  if (ec)<br>
  {<br>
  &nbsp;&nbsp; glEnableClientState(GL_COLOR_ARRAY);<br>
  &nbsp;&nbsp; glColorPointer(sc, tc, str,pointer+pc);<br>
  }<br>
  else<br>
  &nbsp;&nbsp; glDisableClientState(GL_COLOR_ARRAY);<br>
  &nbsp;<br>
  if (en)<br>
  {<br>
  &nbsp;&nbsp; glEnableClientState(GL_NORMAL_ARRAY);<br>
  &nbsp;&nbsp; glNormalPointer(GL_FLOAT,str,pointer+pn);<br>
  }<br>
  else<br>
  &nbsp;&nbsp; glDisableClientState(GL_NORMAL_ARRAY);<br>
  &nbsp;<br>
  glEnableClientState(GL_VERTEX_ARRAY);<br>
  glVertexPointer(sv, GL_FLOAT,str,pointer+pv);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>В таблице 2-5, T и F
соответствуют True и False. f равно sizeof(GLfloat). с – sizeof(GLubyte)*4
(округленному до ближайшего произведения f, если необходимо).</p>

<p class=text align=left style='text-align:left'>Таблица 2-5. Конфигурации
данных, поддерживаемые командой glInterleavedArrays()</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Format</span></strong><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>et</span></strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>ec</span></strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>en</span></strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>st</span></strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>sc</span></strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>sv</span></strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>tc</span></strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>pc</span></strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>pn</span></strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>pv</span></strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>s</span></strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_V2F<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>F<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>F<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>F<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>&nbsp;<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>&nbsp;<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>2<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>&nbsp;<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>&nbsp;<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>&nbsp;<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><st1:metricconverter ProductID="2f"><span
   style='font-size:8.0pt;font-family:Verdana;color:black'>2f</span></st1:metricconverter><span
  style='font-size:8.0pt;font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_V3F<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>F<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>F<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>F<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>&nbsp;<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>&nbsp;<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>3<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>&nbsp;<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>&nbsp;<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>&nbsp;<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><st1:metricconverter ProductID="3f"><span
   style='font-size:8.0pt;font-family:Verdana;color:black'>3f</span></st1:metricconverter><span
  style='font-size:8.0pt;font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_C4UB_V2F<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>F<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>T<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>F<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>&nbsp;<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>4<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>2<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_UNSIGNED_BYTE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>&nbsp;<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>c<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>c+</span><st1:metricconverter ProductID="2f"><span
   style='font-size:8.0pt;font-family:Verdana;color:black'>2f</span></st1:metricconverter><span
  style='font-size:8.0pt;font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_C4UB_V3F<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>F<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>T<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>F<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>&nbsp;<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>4<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>3<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_UNSIGNED_BYTE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>&nbsp;<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>c<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>c+</span><st1:metricconverter ProductID="3f"><span
   style='font-size:8.0pt;font-family:Verdana;color:black'>3f</span></st1:metricconverter><span
  style='font-size:8.0pt;font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:5'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_C3F_V3F<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>F<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>T<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>F<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>&nbsp;<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>3<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>3<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FLOAT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>&nbsp;<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><st1:metricconverter ProductID="3f"><span
   style='font-size:8.0pt;font-family:Verdana;color:black'>3f</span></st1:metricconverter><span
  style='font-size:8.0pt;font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><st1:metricconverter ProductID="6f"><span
   style='font-size:8.0pt;font-family:Verdana;color:black'>6f</span></st1:metricconverter><span
  style='font-size:8.0pt;font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:6'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_N3F_V3F<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>F<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>F<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>T<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>&nbsp;<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>&nbsp;<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>3<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>&nbsp;<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>&nbsp;<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><st1:metricconverter ProductID="3f"><span
   style='font-size:8.0pt;font-family:Verdana;color:black'>3f</span></st1:metricconverter><span
  style='font-size:8.0pt;font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><st1:metricconverter ProductID="6f"><span
   style='font-size:8.0pt;font-family:Verdana;color:black'>6f</span></st1:metricconverter><span
  style='font-size:8.0pt;font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:7'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_C4F_N3F_V3F<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>F<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>T<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>T<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>&nbsp;<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>4<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>3<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FLOAT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><st1:metricconverter ProductID="4f"><span
   style='font-size:8.0pt;font-family:Verdana;color:black'>4f</span></st1:metricconverter><span
  style='font-size:8.0pt;font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><st1:metricconverter ProductID="7f"><span
   style='font-size:8.0pt;font-family:Verdana;color:black'>7f</span></st1:metricconverter><span
  style='font-size:8.0pt;font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><st1:metricconverter ProductID="10f"><span
   style='font-size:8.0pt;font-family:Verdana;color:black'>10f</span></st1:metricconverter><span
  style='font-size:8.0pt;font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:8'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_T2F_V3F<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>T<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>F<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>F<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>2<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>&nbsp;<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>3<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>&nbsp;<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>&nbsp;<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>&nbsp;<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><st1:metricconverter ProductID="2f"><span
   style='font-size:8.0pt;font-family:Verdana;color:black'>2f</span></st1:metricconverter><span
  style='font-size:8.0pt;font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><st1:metricconverter ProductID="5f"><span
   style='font-size:8.0pt;font-family:Verdana;color:black'>5f</span></st1:metricconverter><span
  style='font-size:8.0pt;font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:9'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_T4F_V4F<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>T<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>F<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>F<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>4<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>&nbsp;<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>4<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>&nbsp;<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>&nbsp;<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>&nbsp;<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><st1:metricconverter ProductID="4f"><span
   style='font-size:8.0pt;font-family:Verdana;color:black'>4f</span></st1:metricconverter><span
  style='font-size:8.0pt;font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><st1:metricconverter ProductID="8f"><span
   style='font-size:8.0pt;font-family:Verdana;color:black'>8f</span></st1:metricconverter><span
  style='font-size:8.0pt;font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:10'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_T2F_C4UB_V3F<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>T<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>T<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>F<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>2<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>4<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>3<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_UNSIGNED_BYTE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><st1:metricconverter ProductID="2f"><span
   style='font-size:8.0pt;font-family:Verdana;color:black'>2f</span></st1:metricconverter><span
  style='font-size:8.0pt;font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>&nbsp;<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>c+</span><st1:metricconverter ProductID="2f"><span
   style='font-size:8.0pt;font-family:Verdana;color:black'>2f</span></st1:metricconverter><span
  style='font-size:8.0pt;font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>c+</span><st1:metricconverter ProductID="5f"><span
   style='font-size:8.0pt;font-family:Verdana;color:black'>5f</span></st1:metricconverter><span
  style='font-size:8.0pt;font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:11'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_T2F_C3F_V3F<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>T<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>T<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>F<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>2<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>3<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>3<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FLOAT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><st1:metricconverter ProductID="2f"><span
   style='font-size:8.0pt;font-family:Verdana;color:black'>2f</span></st1:metricconverter><span
  style='font-size:8.0pt;font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>&nbsp;<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><st1:metricconverter ProductID="5f"><span
   style='font-size:8.0pt;font-family:Verdana;color:black'>5f</span></st1:metricconverter><span
  style='font-size:8.0pt;font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><st1:metricconverter ProductID="8f"><span
   style='font-size:8.0pt;font-family:Verdana;color:black'>8f</span></st1:metricconverter><span
  style='font-size:8.0pt;font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:12'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_T2F_N3F_V3F<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>T<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>F<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>T<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>2<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>&nbsp;<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>3<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>&nbsp;<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>&nbsp;<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><st1:metricconverter ProductID="2f"><span
   style='font-size:8.0pt;font-family:Verdana;color:black'>2f</span></st1:metricconverter><span
  style='font-size:8.0pt;font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><st1:metricconverter ProductID="5f"><span
   style='font-size:8.0pt;font-family:Verdana;color:black'>5f</span></st1:metricconverter><span
  style='font-size:8.0pt;font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><st1:metricconverter ProductID="8f"><span
   style='font-size:8.0pt;font-family:Verdana;color:black'>8f</span></st1:metricconverter><span
  style='font-size:8.0pt;font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:13'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_T2F_C4F_N3F_V3F<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>T<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>T<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>T<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>2<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>4<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>3<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FLOAT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><st1:metricconverter ProductID="2f"><span
   style='font-size:8.0pt;font-family:Verdana;color:black'>2f</span></st1:metricconverter><span
  style='font-size:8.0pt;font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><st1:metricconverter ProductID="6f"><span
   style='font-size:8.0pt;font-family:Verdana;color:black'>6f</span></st1:metricconverter><span
  style='font-size:8.0pt;font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><st1:metricconverter ProductID="9f"><span
   style='font-size:8.0pt;font-family:Verdana;color:black'>9f</span></st1:metricconverter><span
  style='font-size:8.0pt;font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><st1:metricconverter ProductID="12f"><span
   style='font-size:8.0pt;font-family:Verdana;color:black'>12f</span></st1:metricconverter><span
  style='font-size:8.0pt;font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:14;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_T4F_C4F_N3F_V4F<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>T<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>T<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>T<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>4<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>4<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>4<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FLOAT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><st1:metricconverter ProductID="4f"><span
   style='font-size:8.0pt;font-family:Verdana;color:black'>4f</span></st1:metricconverter><span
  style='font-size:8.0pt;font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><st1:metricconverter ProductID="8f"><span
   style='font-size:8.0pt;font-family:Verdana;color:black'>8f</span></st1:metricconverter><span
  style='font-size:8.0pt;font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><st1:metricconverter ProductID="11f"><span
   style='font-size:8.0pt;font-family:Verdana;color:black'>11f</span></st1:metricconverter><span
  style='font-size:8.0pt;font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><st1:metricconverter ProductID="15f"><span
   style='font-size:8.0pt;font-family:Verdana;color:black'>15f</span></st1:metricconverter><span
  style='font-size:8.0pt;font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Начинайте с использования
простых форматов, таких как GL_V2F, GL_V3F или GL_C3F_V3F. Если вы хотите
использовать форматы, включающие C4UB – часть, возможно, что для упаковки 4 беззнаковых
байтов в одно 32-битовое слово вам придется использовать структурные типы
данных, приведение типов или арифметику над указателями.</p>

<p class=text align=left style='text-align:left'>В некоторых реализациях OpenGL
использование смешанных массивов может увеличить быстродействие приложения. При
использовании смешанных массивов известен точный формат ваших данных. Вы точно
знаете, что ваши данные плотно упакованы, и доступ к ним может быть произведен
очень быстро. Без использования смешанных массивов, информация о смещениях и
размерах должна дополнительно проверяться, чтобы обнаружить, плотно ли данные
упакованы в памяти.</p>

<p class=warning>Замечание: Команда <b>glInterleavedArrays()</b> включает и
выключает определенные вершинные массивы и задает данные для включенных ей
вершинных массивов. Эта команда ничего не визуализирует и не рисует. Вы все еще
должны выполнить Шаг 3: Разрешение данных и вызвать <b>glArrayElement()</b>, <b>glDrawElements()</b>,
<b>glDrawRangeElements()</b> или <b>glDrawArrays() </b>для разрешения
указателей и визуализации графики. </p>

<h2>2.8 Группы атрибутов</h2>

<p class=text align=left style='text-align:left'>Ранее вы видели, как запрашивать
или устанавливать значения отдельных переменных состояния. Вы также можете
сохранять и восстанавливать значения наборов связанных по смыслу переменных
состояния с помощью одной команды.</p>

<p class=text align=left style='text-align:left'>OpenGL объединяет связанные по
смыслу переменные состояния в <i>группы атрибутов</i>. Например, группа
атрибутов GL_LINE_BIT состоит из 5 переменных состояния: толщины линии, статуса
механизма шаблонирования линии GL_LINE_STIPPLE, рисунка шаблона линии, счетчика
повтора шаблона и статуса механизма сглаживания линий GL_LINE_SMOOTH. С помощью
команд <b>glPushAttrib()</b> и <b>glPopAttrib()</b> вы можете сохранять и
восстанавливать значения всех этих пяти переменных состояния одновременно.</p>

<p class=text align=left style='text-align:left'>Некоторые переменные состояния
относятся более чем к одной группе атрибутов. Например, переменная состояния GL_CULL_FACE
является одновременно частью группы атрибутов полигона и группы включенных
атрибутов.</p>

<p class=text align=left style='text-align:left'>В OpenGL версии 1.1 существует
два различных стека атрибутов. В добавление к старому стеку (в котором
сохраняются и из которого восстанавливаются переменные состояния сервера),
существует также стек атрибутов клиента, доступ к которому можно получить
посредством команд <b>glPushClientAttrib()</b> и <b>glPopClientAttrib()</b>.</p>

<p class=text align=left style='text-align:left'>В общем случае, эти команды
работают быстрее, чем индивидуальные команды получения переменных состояния.
Некоторые величины могут обрабатываться и храниться внутри аппаратуры, и их
получение может быть весьма затратным в смысле производительности. Кроме того,
если вы работаете на удаленном клиенте, все данные атрибутов для сохранения и
восстановления должны быть переданы по сетевому соединению и обратно. Однако
OpenGL имеет стек атрибутов на самом сервере, что позволяет избежать ненужных
сетевых задержек.</p>

<p class=text align=left style='text-align:left'>Существует около 20 различных
групп атрибутов, которые могут быть сохранены и восстановлены командами <b>glPushAttrib()</b>
и <b>glPopAttrib()</b>. Также существует 2 клиентские группы, сохраняемые и
восстанавливаемые командами <b>glPushClientAttrib()</b> и <b>glPopClientAttrib()</b>.
И на сервере, и на клиенте атрибуты сохраняются в стеке, глубина которого
должна быть достаточной для сохранения как минимум 16 групп атрибутов (Реальная
глубина стеков в вашей реализации OpenGL может быть получена с помощью
параметров GL_MAX_ATTRIB_STACK_DEPTH и GL_MAX_CLIENT_ATTRIB_STACK_DEPTH команды
<b>glGetIntegerv()</b>.) Сохранение данных в полный стек или их извлечение из
пустого приведет к генерации ошибки.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glPushAttrib</b>
  (GLbitfield <i>mask</i>);<br>
  void <b>glPopAttrib</b> (void); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'><b>glPushAttrib()</b>
сохраняет все атрибуты, указанные битами в параметре mask, помещая их в стек
атрибутов. <b>glPopAttrib()</b> восстанавливает значения тех переменных
состояния, которые были сохранены командой <b>glPushAttrib()</b>. В таблице 2-6
перечислены возможные значения параметра <i>mask</i> команды <b>glPushAttrib()</b>.
Каждое значения представляет определенный набор переменных состояния. (Эти
значения могут комбинироваться с помощью логического ИЛИ.) Например,
GL_LIGHTING_BIT объединяет все переменные, связанные с освещением. К ним
относятся текущий цвет материала, все параметры света, список включенных
источников света, и направления для тех из них, которым они присущи. Когда
вызывается команда <b>glPopAttrib()</b> все эти переменные восстанавливаются в
сохраненные значения.</p>

<p class=text align=left style='text-align:left'>Специальная маска
GL_ALL_ATTRIB_BITS используется для сохранения и восстановления всех переменных
состояния во всех группах атрибутов.</p>

<p class=text align=left style='text-align:left'>Таблица 2-6. Группы атрибутов</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Битовая маска</span></b><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Группа атрибутов</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_ACCUM_BUFFER_BIT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>аккумулятор<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_ALL_ATTRIB_BITS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>---<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_COLOR_BUFFER_BIT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>цветовой буфер<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_CURRENT_BIT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>текущие<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:5'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_DEPTH_BUFFER_BIT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>буфер глубины<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:6'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_ENABLE_BIT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>включенные<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:7'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_EVAL_BIT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>вычислители<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:8'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FOG_BIT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>туман<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:9'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_HINT_BIT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>комплексные установки<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:10'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_LIGHTING_BIT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>освещение<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:11'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_LINE_BIT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>линия<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:12'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_LIST_BIT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>список<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:13'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_PIXEL_MODE_BIT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>пиксели<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:14'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_POINT_BIT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>точка<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:15'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_POLYGON_BIT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>полигон<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:16'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_POLYGON_STIPPLE_BIT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>шаблон полигона<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:17'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_SCISSOR_BIT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>отрез<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:18'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_STENCIL_BUFFER_BIT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>буфер трафарета<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:19'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TEXTURE_BIT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>текстура<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:20'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TRANSFORM_BIT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>трансформация<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:21;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_VIEWPORT_BIT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>порт просмотра<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Verdana;
color:black;display:none;mso-hide:all'><o:p>&nbsp;</o:p></span></p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glPushClientAttrib</b>
  (GLbitfield <i>mask</i>);<br>
  void <b>glPopClientAttrib</b> (void);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'><b>glPushClientAttrib()</b>
сохраняет все атрибуты, указанные битами в параметре mask, помещая их в стек
атрибутов на клиентской стороне. <b>glPopClientAttrib()</b> восстанавливает
значения тех переменных состояния, которые были сохранены последним вызовом <b>glPushClientAttrib()</b>.
В таблице 2-7 перечислены все возможные битовые маски, которые могут быть
совмещены в параметре mask команды <b>glPushClientAttrib()</b> для сохранения
любой комбинации клиентских атрибутов. Маска GL_ALL_CLIENT_ATTRIB_BITS означает
сохранение всех возможных групп атрибутов. Существуют две клиентские группы атрибутов
(обратного режима и выбора), которые не могут быть сохранены или восстановлены
с помощью механизма стека.Таблица 2-7. Клиентские группы атрибутов</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Битовая маска</span></b><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Группа атрибутов</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_CLIENT_PIXEL_STORE_BIT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>режимы хранения пикселей<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_CLIENT_VERTEX_ARRAY_BIT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>вершинные массивы<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>не может быть сохранена или восстановлена<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>обратного режима<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>не может быть сохранена или восстановлена<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>выбор<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<h2>2.9 Советы по построению полигональных моделей и поверхностей</h2>

<p class=text align=left style='text-align:left'>Далее перечислено несколько
техник, которые вы можете найти полезными при построении полигональных
аппроксимаций поверхностей. параметры освещения влияют на то, как будет
выглядеть модель после рисовании, кроме того, некоторые из перечисленных техник
намного более эффективны при использовании в соединении со списками
отображения. Имейте в виду, что если включен механизм расчетов, связанных с
освещением, то для получения ожидаемых результатов тем или иным путем должны
быть определены вектора нормалей.</p>

<p class=text align=left style='text-align:left'>Построение полигональных
моделей – это искусство, здесь нет предела опыту. Однако здесь перечислено
несколько советов, которые помогут сделать процесс построения моделей намного
более простым.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l31 level1 lfo4;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Сохраняйте ориентацию всех полигонов одинаковой.
Убедитесь, что при взгляде со стороны, все полигоны поверхности ориентированы в
одном направлении (вершины всех полигонов расположены по часовой стрелке или
против нее). Постоянство ориентации важно для отсечения нелицевых граней и
двухстороннего освещения. Попытайтесь следовать этому правилу с самого начала,
поскольку проблемы, связанные с его несоблюдением, очень сложно исправлять в
дальнейшем. (Если вы используете <b>glScale*()</b> для отражения геометрии
относительно какой-либо оси симметрии, вы можете изменить ориентацию с помощью <b>glFrontFace()</b>
для сохранения ее постоянства.)</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l31 level1 lfo4;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>При делении поверхности отслеживайте любые
нетреугольные полигоны. Три вершины треугольника гарантированно лежат в одной
плоскости; любой полигон с четырьмя и более вершинами не обязательно является
плоским. При просмотре с определенных точек ребра такого полигона могут
пересекаться, и OpenGL может неправильно его отобразить.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l31 level1 lfo4;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Помните, что всегда существует противоречие
между скоростью графического вывода и качеством изображения. Если вы разделите
поверхность на небольшое количество полигоны, они будут отображаться очень
быстро, но такая поверхность будет иметь негладкий, угловатый вид; если вы
разделите ее на миллионы крошечных полигонов, она будет очень хорошо выглядеть,
но ее вывод займет намного больше времени. В идеале вы можете передавать в
функцию или процедуру деления поверхности параметр, определяющий насколько
качественное дробление вы хотите осуществить. В этом случае, если поверхность
находится далеко от наблюдателя, вы можете использовать более грубое разделение
поверхности. Кроме того, используйте большие полигоны для относительно плоских
частей поверхности и большее количество маленьких полигонов для сильно
изогнутых ее областей.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l31 level1 lfo4;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Для высококачественных изображений неплохой
идеей является разделение контура поверхности на большее число фрагментов, чем
разделение внутренних частей. Это сложнее сделать, если предполагается, что
поверхность будет вращаться, поскольку в этом случае ее видимый контур будет
изменяться. Контурные ребра можно выявить с помощью векторов нормалей – в любой
точке такого ребра вектор нормали перпендикулярен вектору из этой точки к точке
обзора, то есть их скалярное произведение равно 0. Ваш алгоритм разделения
поверхности может быть написан с учетом возможности выбора более частого
дробления там, где произведение этих вектором приближается к 0.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l31 level1 lfo4;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Попытайтесь избежать T-пересечений в ваших
моделях (рисунок 2-17). Нет гарантии, что сегменты AB и BC будут отображены на
тех же пикселях, что и сегмент AC. Иногда это так, а иногда – нет, в
зависимости от применяемых трансформаций и ориентации поверхности. Это может
привести к появлению видимых «трещин» в поверхности.</p>

<p class=text align=left style='text-align:left'>Рисунок 2-17. Проблема
T-пересечения и ее решение</p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1049" type="#_x0000_t75" alt="" style='width:280.5pt;height:135.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image025.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов2.mht!http://www.progz.ru/images/opengl/chapter2/2-17.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=374 height=181
src="OpenGL%20Red%20Book.files/image025.jpg" v:shapes="_x0000_i1049"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l32 level1 lfo5;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Если вы строите замкнутую поверхность, при
замыкании границы убедитесь, что используете точно те же значения координат для
точек ее начала и конца, в противном случае, вы можете обнаружить видимые
трещины в поверхности из-за арифметических округлений. Далее приводится
неверных пример кода для рисования круга:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>//Не используйте этот код<br>
  #define PI 3.14159265<br>
  <br>
  //Количество отрезков, на которое мы подразделяем <br>
  //гладкую границу круга<br>
  #define EDGES 30<br>
  <br>
  glBegin(GL_LINE_STRIP);<br>
  &nbsp;&nbsp; for(i=0;i&lt;=EDGES;i++)<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glVertex2f(cos((2*PI*i)/EDGES),
  sin((2*PI*i)/EDGES));<br>
  glEnd();<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='margin-left:36.0pt;text-align:left'>В
действительности граница круга замкнется только в том случае, если ваш
компьютер сможет при расчете синуса и косинуса от 0 и (2*PI*EDGES/EDGES)
получить совершенно одинаковые величины. В противном случае начало и конец
окружности, ограничивающей круг, могут не совпасть по координатам и позже по
рисуемым пикселям и фигура не будет замкнутой. Однако на подобную точность
расчетов с плавающей точкой рассчитывать не стоит. Для исправления кода
убедитесь, что когда i==EDGES, вы используете для вычисления синуса и косинуса
не (2*PI*EDGES/EDGES), а 0. (Существует более простой способ – используйте
GL_LINE_LOOP вместо GL_LINE_STRIP и измените условие завершения цикла на i&lt;EDGES).</p>

<h2>2.9.1&nbsp; Пример: Построение Икосаэдра</h2>

<p class=text align=left style='text-align:left'>Для иллюстрации некоторых
вопросов, возникающих при аппроксимации поверхностей, рассмотрим простой пример
кода. Этот код создает обычный икосаэдр (который является Платоновым телом,
состоящим из 12 вершин и 20 граней, каждая из которых является треугольником).
Икосаэдр можно считать грубым приближением сферы. Пример 2-13 задает вершины и
треугольники, образующие икосаэдр и затем рисует икосаэдр.</p>

<p class=text align=left style='text-align:left'>Пример 2-13. Рисование
икосаэдра</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>#define X .525731112119133606<br>
  #define Z .850650808352039932<br>
  &nbsp;<br>
  GLfloat vdata[12][3] = {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {-X,0.0,Z},{X,0.0,Z},{-X,0.0,-Z},{X,0.0,-Z},<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {0.0,Z,X},{0.0,Z,-X},{0.0,-Z,X},{0.0,-Z,-X},<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {Z,X,0.0},{-Z,X,0.0},{Z,-X,0.0},{-Z,-X,0.0}<br>
  };<br>
  &nbsp;<br>
  GLuint tindices[20][3] = {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {1,4,0},{4,9,0},{4,5,9},{8,5,4},{1,8,4},<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {1,10,8},{10,3,8},{8,3,5},{3,2,5},{3,7,2},<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {3,10,7},{10,6,7},{6,11,7},{6,0,11},{6,1,0},<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {10,1,6},{11,0,9},{2,11,9},{5,2,9},{11,2,7}<br>
  };<br>
  &nbsp;<br>
  int i;<br>
  &nbsp;<br>
  glBegin(GL_TRIANGLES);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(i=0;i&lt;20;i++)<br>
  {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Здесь помещается информация о цвете<br>
  <br>
  &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;glVertex3fv(&amp;vdata[tindices[i][0]][0]);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glVertex3fv(&amp;vdata[tindices[i][1]][0]);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glVertex3fv(&amp;vdata[tindices[i][2]][0]);<br>
  }<br>
  glEnd(); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Странные числа X и Z выбраны
таким образом, чтобы расстояние от точки начала координат до любой из вершин
было равно 1.0. Координаты 12-ти вершин задаются в массиве <i>vdata</i>, где
координаты нулевой вершины {-X,0.0,Z}, координаты первой {X,0.0,Z} и так далее.
Массив <i>tindices</i> определяет, как нужно соединять вершины для получения
нужных треугольников. Например, вершинами первого треугольника являются
нулевая, четвертая и первая вершины из массива <i>vdata</i>. Если вершины для
каждого треугольника будут выбираться согласно указанному порядку, все
треугольники будут иметь одинаковую ориентацию.</p>

<p class=text align=left style='text-align:left'>Строка комментария о цветовой
информации должна быть заменена командой, устанавливающей цвет для i-ой грани.
Если это не будет сделано, все грани будут нарисованы одним цветом, и это
приведет к невозможности визуального определения того, что объект является
трехмерным. Вместо изменения цветов можно определить вектора нормалей и
использовать освещение, как описано в следующем подразделе.</p>

<p class=warning>Замечание: Во всех примерах данного раздела, если поверхность
должна быть нарисована более одного раза, вероятно, стоит сохранить вычисленные
координаты вершин и нормалей, чтобы не производить вычисления каждый раз при
рисовании поверхности. Вы можете сделать это посредством собственных структур
данных или списков отображения.</p>

<h2>2.9.1.1 Расчет нормалей для поверхности</h2>

<p class=text align=left style='text-align:left'>Если предполагается, что
поверхность будет освещена, вам необходимо определить вектора нормалей к
поверхности. Вектор нормали можно получить, вычислив нормализованное векторное
произведение двух векторов на этой поверхности. Для каждой плоской части
икосаэдра (то есть для каждого треугольника) все три вершины имеют одинаковый
вектор нормали. Таким образом, нормаль должна быть определена единожды для
каждого набора из трех вершин. Комментарий в предыдущем примере рисования
икосаэдра может быть заменен на код из примера 2-14.</p>

<p class=text align=left style='text-align:left'>Пример 2-14. Генерируем
вектора нормалей к поверхности</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>GLfloat
  d1[3], d2[3], norm[3];<br>
  for(j=0;j&lt;3;j++)<br>
  {<br>
  d1[j]=vdata[tindices[i][0]][j]-vdata[tindices[i][1]][j];<br>
  d2[j]=vdata[tindices[i][1]][j]-vdata[tindices[i][2]][j];<br>
  }<br>
  normcrossprod(d1,d2,norm);<br>
  glNormal3fv(norm);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Функция <b>normcrossprod()</b>
вычисляет нормализованное векторное произведение двух векторов, как показано в
примере 2-15.</p>

<p class=text align=left style='text-align:left'>Пример 2-15. Вычисление нормализованного
векторного произведения двух векторов</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void
  normalize(float v[3])<br>
  {<br>
  &nbsp;&nbsp; GLfloat d=sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]);<br>
  &nbsp;&nbsp; if(d==0.0)<br>
  &nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error(“</span><span style='font-size:8.5pt;
  font-family:Courier;mso-bidi-font-family:"Courier New";color:black'>Длина</span><span
  style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:"Courier New";
  color:black;mso-ansi-language:EN-US'> </span><span style='font-size:8.5pt;
  font-family:Courier;mso-bidi-font-family:"Courier New";color:black'>вектора</span><span
  style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:"Courier New";
  color:black;mso-ansi-language:EN-US'> </span><span style='font-size:8.5pt;
  font-family:Courier;mso-bidi-font-family:"Courier New";color:black'>равна</span><span
  lang=EN-US style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:
  "Courier New";color:black;mso-ansi-language:EN-US'> </span><st1:metricconverter
  ProductID="0”"><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
   mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>0”</span></st1:metricconverter><span
  lang=EN-US style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:
  "Courier New";color:black;mso-ansi-language:EN-US'>);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br>
  &nbsp;&nbsp; }<br>
  &nbsp;&nbsp; v[0]/=d;<br>
  &nbsp;&nbsp; v[1]/=d;<br>
  &nbsp;&nbsp; v[2]/=d;<br>
  }<br>
  &nbsp;<br>
  void normcrossprod(float v1[3], float v2[3], float out[3])<br>
  {<br>
  &nbsp;&nbsp; out[0]=v1[1]*v2[2]- v1[2]*v2[1];<br>
  &nbsp;&nbsp; out[1]=v1[2]*v2[0]- v1[0]*v2[2];<br>
  &nbsp;&nbsp; out[2]=v1[0]*v2[1]- v1[1]*v2[0];<br>
  &nbsp;&nbsp; normalize(out);<br>
  } <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Если вы используете икосаэдр в
качестве приближения равномерно закрашенной сферы, вам, возможно, потребуется
использовать нормали, которые перпендикулярны истинной поверхности сферы, а не
граням икосаэдра. Вектора нормалей для сферы вычисляются элементарно, поскольку
в каждой точке вектор нормали совпадает с вектором из центра сферы в эту точку.
Поскольку в приведенном примере икосаэдр имеет радиус равный 1, данные для
нормалей и данные координат вершин совпадают. Далее приводится код, рисующий
двадцатистороннюю аппроксимацию (икосаэдр) равномерно закрашенной сферы (в коде
предполагается, что кроме прочего включено освещение):</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>glBegin(GL_TRIANGLES);<br>
  &nbsp;&nbsp; for(i=0;i&lt;20;i++)<br>
  &nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glNormal3fv(&amp;vdata[tindices[i][0]][0]);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glVertex3fv(&amp;vdata[tindices[i][0]][0]);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glNormal3fv(&amp;vdata[tindices[i][1]][0]);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glVertex3fv(&amp;vdata[tindices[i][1]][0]);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glNormal3fv(&amp;vdata[tindices[i][2]][0]);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glVertex3fv(&amp;vdata[tindices[i][2]][0]);<br>
  &nbsp;&nbsp; }<br>
  glEnd(); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<h2>2.9.1.2 Улучшаем модель</h2>

<p class=text align=left style='text-align:left'>20-сторонняя аппроксимация
сферы выглядит не лучшим образом, если только она не находится далеко от
наблюдателя, однако существует простой способ улучшить качество изображения.
Представьте себе, что икосаэдр вписан в сферу (то есть все вершины икосаэдра
лежат на поверхности сферы) и разбейте каждый из его треугольников на 4, как
показано на рисунке 2-18 (заметьте, что в правой части рисунка AD=DB=AB/2,
BE=EC=DC/2 и AF=FC=AC/2). </p>

<p class=warning>Замечание: Вообще говоря, это только один из вариантов
разбиения треугольников. Например, можно разбить каждый треугольник не на 4
новых, а на 3, добавив новую вершину в точке пересечения биссектрис исходного
треугольника или в центре его тяжести. </p>

<p class=text align=left style='text-align:left'>Появившиеся в результате новые
вершины находятся внутри сферы, и мы должны притянуть их к поверхности сферы
путем нормализации (делением координат вершин на некоторый коэффициент, в результате
чего вектор из центра сферы к этой вершине будет иметь длину равную 1).
Подобный процесс разбиения может быть повторен несколько раз для получения
приближения требуемой точности.&nbsp; Объекты на рисунке 2-19 состоят из 20, 80
и 320 треугольников соответственно.</p>

<p class=text align=left style='text-align:left'>Пример 2-16 производит одно
дополнительное разбиение, создавая 80-стороннюю сферическую аппроксимацию.</p>

<p class=text align=left style='text-align:left'>Рисунок 2-18. Разбиение
треугольников</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1050" type="#_x0000_t75" alt="" style='width:324.75pt;height:176.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image026.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов2.mht!http://www.progz.ru/images/opengl/chapter2/2-18.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=433 height=235
src="OpenGL%20Red%20Book.files/image026.jpg" v:shapes="_x0000_i1050"><![endif]></p>

<p class=text align=left style='text-align:left'>Рисунок 2-19. Разбиение
увеличивает гладкость полигональной модели</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1051" type="#_x0000_t75" alt="" style='width:468pt;height:162.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image027.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов2.mht!http://www.progz.ru/images/opengl/chapter2/2-19.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=624 height=217
src="OpenGL%20Red%20Book.files/image027.jpg" v:shapes="_x0000_i1051"><![endif]></p>

<p class=text align=left style='text-align:left'>Пример 2-16. Единичное
разбиение</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void
  drawTriangle(float *v1, float *v2, float *v3)<br>
  {<br>
  &nbsp;&nbsp; glBegin(GL_TRIANGLES);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glNormal3fv(v1);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glVertex3fv(v1);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glNormal3fv(v2);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glVertex3fv(v2);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glNormal3fv(v3);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glVertex3fv(v3);<br>
  &nbsp;&nbsp;&nbsp;glEnd();<br>
  }<br>
  &nbsp;<br>
  void subdivine(float *v1, float *v2, float *v3)<br>
  {<br>
  &nbsp;&nbsp; GLfloat v12[3], v23[3], v31[3];<br>
  &nbsp;&nbsp; GLint i;<br>
  &nbsp;<br>
  &nbsp;&nbsp; for (i=0;i&lt;3;i++)<br>
  &nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v12[i]=(v1[i]+v2[i])/2.0;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v23[i]=(v2[i]+v3[i])/2.0;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v31[i]=(v3[i]+v1[i])/2.0;<br>
  &nbsp;&nbsp; }<br>
  &nbsp;&nbsp; normalize(v12);<br>
  &nbsp;&nbsp; normalize(v23);<br>
  &nbsp;&nbsp; normalize(v31);<br>
  &nbsp;&nbsp; drawTriangle(v1,v12,v31); <br>
  &nbsp;&nbsp; drawTriangle(v2,v23,v12);<br>
  &nbsp;&nbsp; drawTriangle(v3,v31,v23);<br>
  &nbsp;&nbsp; drawTriangle(v12,v23,v31);<br>
  }<br>
  &nbsp;<br>
  for(i=0;i&lt;20;i++)<br>
  {<br>
  &nbsp;&nbsp; subdivine(&amp;vdata[tindices[i][0]][0], <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;vdata[tindices[i][1]][0],<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;vdata[tindices[i][2]][0]);<br>
  } <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Пример 2-17 – это модификация
примера 2-16, осуществляющая рекурсивное разбиение треугольников до заданной
глубины. Если глубина (параметр <i>depth</i>) равна 0, разбиение не
производится, и треугольники рисуются «как есть». Если задана глубина равная 1,
разбиение производится 1 раз и так далее.</p>

<p class=text align=left style='text-align:left'>Пример 2-17. Рекурсивное
разбиение</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void
  subdivine(float *v1, float *v2, float *v3, long depth)<br>
  {<br>
  &nbsp;&nbsp; GLfloat v12[3], v23[3], v31[3];<br>
  &nbsp;&nbsp; GLint i;<br>
  &nbsp;<br>
  &nbsp;&nbsp; if(depth==0)<br>
  &nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; drawTriangle(v1,v2,v3);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br>
  &nbsp;&nbsp; }<br>
  &nbsp;<br>
  &nbsp;&nbsp; for (i=0;i&lt;3;i++)<br>
  &nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v12[i]=(v1[i]+v2[i])/2.0;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v23[i]=(v2[i]+v3[i])/2.0;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v31[i]=(v3[i]+v1[i])/2.0;<br>
  &nbsp;&nbsp; }<br>
  &nbsp;&nbsp; normalize(v12);<br>
  &nbsp;&nbsp; normalize(v23);<br>
  &nbsp;&nbsp; normalize(v31);<br>
  &nbsp;&nbsp; subdivine(v1,v12,v31,depth-1); <br>
  &nbsp;&nbsp; subdivine(v2,v23,v12,depth-1);<br>
  &nbsp;&nbsp; subdivine(v3,v31,v23,depth-1);<br>
  &nbsp;&nbsp; subdivine(v12,v23,v31,depth-1);<br>
  } <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<h2>2.9.1.3 Обобщенное разбиение</h2>

<p class=text align=left style='text-align:left'>Рекурсивное разбиение
(например, то, которое приведено в примере 2-17) обычно заканчивается, если
достигнут заданный уровень глубины рекурсии, или если степень кривизны
поверхности удовлетворяет некоторому критерию (особенно кривые части
поверхностей выглядят лучше при большем числе разбиений).</p>

<p class=text align=left style='text-align:left'>Рассмотрим более обобщенное
решение проблемы разбиения, считая, что некоторая поверхность параметризирована
двумя переменными <i>u[0]</i> и <i>u[1]</i>. Предположим, что существует две
функции:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void
  surf(GLfloat u[2],GLfloat vertex[3],GLfloat normal[3]);<br>
  float curv(GLfloat u[2]); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>При передаче <i>u[]</i>
функции <b>surf()</b>, возвращаются соответствующие трехмерные координаты
вершины и вектора нормали единичной длины. Если передать <i>u[]</i> в функцию <b>curv()</b>
вычисляется и возвращается кривизна поверхности в данной точке (за
дополнительными сведениями об измерении кривизны поверхности обратитесь к
литературе по аналитической геометрии).</p>

<p class=text align=left style='text-align:left'>В примере 2-18 представлена
рекурсивная функция, которая разбивает треугольники до достижения максимального
уровня вложенности или до тех пор, пока максимальная кривизна в трех вершинах
треугольника не станет меньше некоторого заданного значения.</p>

<p class=text align=left style='text-align:left'>Пример 2-18. Обобщенное
разбиение</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void subdivine(float
  u1[2],float u2[2],float u3[2],float cutoff,long depth)<br>
  {<br>
  &nbsp;&nbsp; GLfloat v1[3],v2[3],v3[3],n1[3],n2[3],n3[3];<br>
  &nbsp;&nbsp; GLfloat u12[2],u23[2],u31[2];<br>
  &nbsp;&nbsp; GLint i;<br>
  &nbsp;<br>
  &nbsp;&nbsp; if(depth==maxdepth || (curv(u1)&lt;cutoff))<br>
  &nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; surf(u1,v1,n1);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; surf(u2,v2,n2);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; surf(u3,v3,n3);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glBegin(GL_POLYGON);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glNormal3fv(n1);
  glVertex3fv(v1);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glNormal3fv(n2);
  glVertex3fv(v2);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glNormal3fv(n3);
  glVertex3fv(v3);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glEnd();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br>
  &nbsp;&nbsp; }<br>
  &nbsp;<br>
  &nbsp;&nbsp; for(i=0;i&lt;2;i++)<br>
  &nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; u12[i]=(u1[i]+u2[i])/2.0;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; u23[i]=(u2[i]+u3[i])/2.0;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; u31[i]=(u3[i]+u1[i])/2.0;<br>
  &nbsp;&nbsp; }<br>
  &nbsp;&nbsp; subdivine(u1,u12,u31,cutoff,depth+1);<br>
  &nbsp;&nbsp; subdivine(u2,u23,u12,cutoff,depth+1);<br>
  &nbsp;&nbsp; subdivine(u3,u31,u23,cutoff,depth+1);<br>
  &nbsp;&nbsp; subdivine(u12,u23,u31,cutoff,depth+1);<br>
  } <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Verdana'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><a name=Глава3><span style='display:none;mso-hide:all'><o:p>&nbsp;</o:p></span></a></p>

<h1 align=left style='text-align:left'><span style='mso-bookmark:Глава3'>Глава
3. Вид</span></h1>

<span style='mso-bookmark:Глава3'></span>

<p class=MsoNormal><a href="mailto:ahinar@list.ru"></a><span style='font-size:
10.0pt;font-family:Verdana'><span style='mso-spacerun:yes'> </span>В этой главе
объясняется, как проинструктировать OpenGL о том, каким образом она должна
рисовать геометрические модели, отображаемые на сцене. Вы должны решить, как
объекты будут расположены, и где будет находиться точка обзора. Можно оставить
позицию и точку обзора по умолчанию, но это делается достаточно редко.<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Главной целью компьютерной
графики (или, более точно, машинной графики) является создание двумерного
изображения трехмерных объектов (изображение должно быть двумерным, поскольку
оно выводится на плоский экран). Однако, при принятии большинства решений,
связанных с тем, что и как будет выводиться на экран, следует думать о
трехмерных координатах. Обычной человеческой ошибкой при создании трехмерных
сцен является то, что они слишком рано начинают думать о двумерной плоскости
экрана. Не думайте о пикселях! Вместо этого попытайтесь представить свою сцену
в трехмерном пространстве. Представьте, что вы создаете сцену в некотором
трехмерном пространстве, находящемся за экраном, внутри компьютера и оставьте компьютеру
все вычисления, связанные с тем, какие пиксели подсвечивать.</p>

<p class=text align=left style='text-align:left'>Трехмерные координаты объекта
преобразуются в позиции пикселей на экране серией из трех операций. </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l60 level1 lfo6;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Трансформации (преобразования), представленные
перемножением матриц, включают модельные, видовые и проекционные операции. К
таким операциям относятся вращение, перенос, масштабирование, отражение,
ортографическое и перспективное проецирование. Обычно для отображения сцены
используется комбинация из нескольких трансформаций. </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l60 level1 lfo6;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Поскольку сцена отображается в прямоугольном
окне, объекты (или их части), находящиеся вне окна должны быть отсечены. В
трехмерной компьютерной графике отсечение производится путем отбрасывания
объектов с одной стороны отсекающей плоскости. </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l60 level1 lfo6;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Наконец, должно быть установлено соответствие
между преобразованными координатами и экранными пикселями. Этот процесс
известен, как трансформация порта просмотра. </p>

<h2>3.1 Аналогия с фотокамерой</h2>

<p class=text align=left style='text-align:left'>Процесс трансформаций,
используемых для создания сцены, аналогичен получению фотографии с помощью
камеры. Как показано на рисунке 3-1 этапы для получения фотографии (или сцены
на экране монитора) должны быть следующими.</p>

<ol start=1 type=1>
 <li class=MsoNormal style='color:black;mso-margin-top-alt:auto;mso-margin-bottom-alt:
     auto;mso-list:l1 level1 lfo7;tab-stops:list 36.0pt'><span
     style='font-size:10.0pt;font-family:Verdana'>Установить треногу и
     направить камеру на сцену (видовые трансформации). <o:p></o:p></span></li>
 <li class=MsoNormal style='color:black;mso-margin-top-alt:auto;mso-margin-bottom-alt:
     auto;mso-list:l1 level1 lfo7;tab-stops:list 36.0pt'><span
     style='font-size:10.0pt;font-family:Verdana'>Расположить фотографируемые
     объекты нужным образом (модельные трансформации). <o:p></o:p></span></li>
 <li class=MsoNormal style='color:black;mso-margin-top-alt:auto;mso-margin-bottom-alt:
     auto;mso-list:l1 level1 lfo7;tab-stops:list 36.0pt'><span
     style='font-size:10.0pt;font-family:Verdana'>Выбрать линзы для камеры и
     масштаб (проекционные трансформации). <o:p></o:p></span></li>
 <li class=MsoNormal style='color:black;mso-margin-top-alt:auto;mso-margin-bottom-alt:
     auto;mso-list:l1 level1 lfo7;tab-stops:list 36.0pt'><span
     style='font-size:10.0pt;font-family:Verdana'>Определить насколько большой
     должна быть результирующая фотография – например, может понадобиться ее
     увеличение (трансформация порта просмотра). <o:p></o:p></span></li>
 <li class=MsoNormal style='color:black;mso-margin-top-alt:auto;mso-margin-bottom-alt:
     auto;mso-list:l1 level1 lfo7;tab-stops:list 36.0pt'><span
     style='font-size:10.0pt;font-family:Verdana'>После произведения этих шагов
     фотография может быть отпечатана, а изображение сцены – нарисовано. <o:p></o:p></span></li>
</ol>

<p class=text align=left style='text-align:left'>Рисунок 3-1. Аналогия с
фотокамерой</p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1052" type="#_x0000_t75" alt="" style='width:450pt;height:619.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image028.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов3.mht!http://www.progz.ru/images/opengl/chapter3/3-1.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=600 height=826
src="OpenGL%20Red%20Book.files/image028.jpg" v:shapes="_x0000_i1052"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Заметьте, что нумерация шагов
соответствует порядку, в котором вы задаете желаемые трансформации в вашей
программе, но не обязательно порядку, в котором над вершинами объектов
производятся соответствующие математические вычисления.</p>

<p class=text align=left style='text-align:left'>В коде программы видовые
трансформации должны быть определены до модельных, однако проекцию и порт
просмотра вы можете задавать в любой момент до самого рисования. Рисунок 3-2
демонстрирует порядок, в котором эти операции производятся вашим компьютером. </p>

<p class=text align=left style='text-align:left'>Рисунок 3-2. Этапы
преобразования вершин</p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1053" type="#_x0000_t75" alt="" style='width:282.75pt;height:485.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image029.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов3.mht!http://www.progz.ru/images/opengl/chapter3/3-2.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=377 height=647
src="OpenGL%20Red%20Book.files/image029.jpg" v:shapes="_x0000_i1053"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Чтобы задать видовое,
модельное или проекционное преобразование, вы заполняете матрицу <b>M </b>размерностью
4x4 элемента. Затем эта матрица множится на координаты каждой вершины, в
результате чего и происходит преобразование этих координат <i>v`=</i><b>M</b><i>v</i>.
(Помните, что вершина всегда имеет 4 координаты (<i>x</i>, <i>y</i>, <i>z</i>, <i>w</i>),
хотя в большинстве случаев <i>w=1</i>, а для двумерных изображений <i>z=0</i>.)
Заметьте, что видовые и модельные преобразования наряду с координатами вершин
автоматически применяются к нормалям к поверхности в этих вершинах. (Нормали
используются только в видовых координатах.) Это делается для того, чтобы
сохранить связь между вектором нормали и вершинными данными.</p>

<p class=text align=left style='text-align:left'>Видовые и модельные
преобразования, указанные вами, комбинируются в видовой матрице,<i> </i>применяемой
к входящим <i>объектным координатам</i> для получения <i>видовых координат</i>.
Если вы задаете дополнительные плоскости отсечения для удаления определенных
объектов со сцены или для создания разрезанного вида объектов – эти плоскости
используются на следующем шаге. После этого OpenGLприменяет матрицу проекции
для получения <i>усеченных координат</i>. Это преобразование определяет объем
видимости; объекты вне этого объема полностью или частично отсекаются
(отбрасываются) и не рисуются в финальной сцене. После этого производится
перспективное деление, то есть, деление координат <i>x</i>, <i>y</i>, <i>z </i>на
<i>w</i>, для получения <i>нормализованных координат устройства</i>. В
заключении, преобразованные координаты конвертируются в <i>оконные координаты</i>
с помощью трансформации порта просмотра. Вы можете манипулировать размерами
порта просмотра для растяжения или сжатия финального изображения.</p>

<p class=text align=left style='text-align:left'>Вы можете правильно
предположить, что для определения того, какие пиксели рисовать на экране,
достаточно координат <i>x</i> и <i>y</i>. Однако все преобразования
производятся также и над <i>z </i>– координатой. Таким образом, в конце
процесса преобразований величина соответствующей <i>z</i> – координаты верно
отражает глубину каждой вершины (исчисляемую в дистанции от экрана). Одно из
применений для&nbsp; значений глубины – избежать ненужного рисования. Например,
предположим, что две вершины имеют равные <i>x</i> и <i>y</i> – координаты, но
разную глубину. OpenGL может использовать эту информацию для определения того,
какие поверхности перекрыты другими поверхностями и, таким образом, не рисовать
невидимые поверхности. Кроме того, координата <i>z</i> в некоторых проекционных
матрицах при перемножении может влиять на результирующие значения координат <i>x</i>
и <i>y</i>.</p>

<p class=text align=left style='text-align:left'>Для указания всех описанных
трансформаций, вы должны знать, как математически производятся операции над
матрицами. За дополнительной информацией обратитесь к литературе по линейной
алгебре. </p>

<h2>3.1.1&nbsp; Простой пример: рисуем куб</h2>

<p class=text align=left style='text-align:left'>Пример 3-1 рисует куб, который
масштабируется модельной трансформацией. Видовая трансформация позиционирует и
наводит камеру на то место, где будет нарисован куб. Проекционная трансформация
и трансформация порта просмотра также указаны. После примера следуют разделы,
разбирающие пример 3-1. В них дается краткое описание команд трансформаций. </p>

<p class=text align=left style='text-align:left'>Рисунок 3-3.
Трансформированный куб</p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1054" type="#_x0000_t75" alt="" style='width:97.5pt;height:168.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image030.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов3.mht!http://www.progz.ru/images/opengl/chapter3/3-3.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=130 height=225
src="OpenGL%20Red%20Book.files/image030.jpg" v:shapes="_x0000_i1054"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Пример 3-1. Трансформированный
куб. Файл cube.cpp </p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>#include &lt;glut.h&gt;<br>
  <br>
  //Инициализация<br>
  void init(void)<br>
  {<br>
  &nbsp;&nbsp; glClearColor(0.0,0.0,0.0,0.0);<br>
  &nbsp;&nbsp; glShadeModel(GL_FLAT);<br>
  }<br>
  <br>
  //Отображение<br>
  void display(void)<br>
  {<br>
  &nbsp;&nbsp; glClear(GL_COLOR_BUFFER_BIT);<br>
  &nbsp;&nbsp; glColor3f(1.0,1.0,1.0);<br>
  <br>
  &nbsp;&nbsp; //Очистить матрицу<br>
  &nbsp;&nbsp; glLoadIdentity();<br>
  <br>
  &nbsp;&nbsp; //Видовая трансформация(камера)<br>
  &nbsp;&nbsp; gluLookAt(0.0,0.0,5.0,0.0,0.0,0.0,0.0,1.0,0.0);<br>
  <br>
  &nbsp;&nbsp; //Модельная трансформация<br>
  &nbsp;&nbsp; glScalef(1.0,2.0,1.0);<br>
  &nbsp;&nbsp; glutWireCube(1.0);<br>
  &nbsp;&nbsp; glFlush();<br>
  }<br>
  <br>
  //Изменение размеров окна<br>
  void reshape(int w, int h)<br>
  {<br>
  &nbsp;&nbsp; glViewport(0,0,(GLsizei) w, (GLsizei) h);<br>
  &nbsp;&nbsp; glMatrixMode(GL_PROJECTION);<br>
  &nbsp;&nbsp; glLoadIdentity();<br>
  &nbsp;&nbsp; glFrustum(-1.0,1.0,-1.0,1.0,1.5,20.0);<br>
  &nbsp;&nbsp; glMatrixMode(GL_MODELVIEW);<br>
  }<br>
  <br>
  int main(int argc, char** argv)<br>
  {<br>
  &nbsp;&nbsp; glutInit(&amp;argc,argv);<br>
  &nbsp;&nbsp; glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);<br>
  &nbsp;&nbsp; glutInitWindowSize(500,500);<br>
  &nbsp;&nbsp; glutInitWindowPosition(100,100);<br>
  &nbsp;&nbsp; glutCreateWindow(&quot;Transformed Cube&quot;);<br>
  &nbsp;&nbsp; init();<br>
  &nbsp;&nbsp; glutDisplayFunc(display);<br>
  &nbsp;&nbsp; glutReshapeFunc(reshape);<br>
  &nbsp;&nbsp; glutMainLoop();<br>
  &nbsp;&nbsp; return 0;<br>
  }<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<h2>3.1.1.1&nbsp;&nbsp;&nbsp; Видовая трансформация</h2>

<p class=text align=left style='text-align:left'>Помните о том, что видовая
трансформация аналогична позиционированию и наведению камеры. В приведенном
примере кода до того как будет определена видовая трансформация, <i>текущая
видовая матрица</i> должна быть установлена в единичную (четыре элемента на
главной диагонали равны 1, остальные 0). Этот шаг необходим, поскольку
большинство команд преобразований множат текущую матрицу на свою (указываемую)
и оставляют результат в качестве новой текущей матрицы. Если вы не очистите текущую
матрицу, загрузив в нее единичную, вы продолжите комбинировать матрицы
предыдущих преобразований с новыми, определяемыми вами. Иногда, это вам и
нужно, но иногда текущую матрицу следует очищать.</p>

<p class=text align=left style='text-align:left'>В примере 3-1, после
инициализации матрицы, видовая трансформация задается командой <b>gluLookAt()</b>.
Аргументы этой команды определяют, где находится камера (точка обзора), куда
она направлена, и какое направление считать верхним. Значения аргументов,
использованные здесь, помещают камеру в точку (0, 0, 5), наводят ее на точку
(0, 0, 0) и задают вектор направления вверх как (0, 1, 0). Вектор верхнего
направления задает ориентацию камеры.</p>

<p class=text align=left style='text-align:left'>Если бы <b>gluLookAt() </b>не
была вызвана, камера имела бы позицию и ориентацию по умолчанию. По умолчанию
камера расположена в начале координат (0, 0, 0), направлена вдоль
отрицательного направления оси z, и вектором верхнего направления имеет (0, 1,
0). Таким образом суммарный эффект от вызова команды <b>gluLookAt() </b>в
примере 3-1 заключается в перемещении камеры по оси zна 5 единиц.</p>

<h2>3.1.1.2&nbsp;&nbsp;&nbsp; Модельная трансформация</h2>

<p class=text align=left style='text-align:left'>Вы используете модельную
трансформацию для позиционирования и ориентирования модели. Например, вы можете
поворачивать, переносить или масштабировать модель, а также производить
комбинации этих операций. В примере 3-1, использована трансформация <b>glScalef()</b>.
Аргументами этой команды являются коэффициенты масштабирования модели по трем
осям. Если все три коэффициента равны 1.0 – команда не дает никакого эффекта. В
примере 3-1 куб рисуется с удвоенным масштабом по оси y. Таким образом, если бы
один из углов куба изначально имел координаты (3.0, 3.0, 3.0), он был бы
нарисован в точке (3.0, 6.0, 3.0). Эффект от этого преобразования в примере 3-1
трансформирует куб в параллепипед.</p>

<p class=text align=left style='text-align:left'>Заметьте, что вместо того,
чтобы передвигать камеру, вы могли бы отодвинуть куб от камеры (с помощью
модельного преобразования). Такая двойственность природы видовых и модельных
трансформаций заставляет думать об эффекте обоих типов преобразований
одновременно. В общем, не имеет смысла разделять эти эффекты, но иногда проще
думать о них тем или иным путем. Эта двойственность также одна из причин, по
которой видовые и модельные трансформации объединяются в <i>видовой матрице</i>
до воздействия на координаты.</p>

<p class=text align=left style='text-align:left'>Также заметьте, что видовые и
модельные трансформации включены в функцию <b>display()</b> вместе с вызовом
функции <b>glutWireCube()</b>, рисующей куб. Таким образом, <b>display()</b>
может использоваться несколько раз для перерисовки содержимого окна, например,
если оно было перемещено, и вы уверены, что каждый раз куб рисуется верно, с применением
нужных преобразований. Преимущества повторного использования <b>display()</b>
перевешивают недостаток, связанный с необходимостью загрузки единичной матрицы
до указания преобразований, особенно если иные преобразования могут быть заданы
между вызовами <b>display()</b>.</p>

<h2>3.1.1.3&nbsp;&nbsp;&nbsp; Проекционная трансформация</h2>

<p class=text align=left style='text-align:left'>Определение проекционной
трансформации походит на выбор линз для камеры. Вы можете думать об этом
преобразовании как о задающем поле просмотра или объем видимости и, таким
образом, определяющем какие объекты лежат внутри этого объема и как они
выглядят (до некоторой степени). Это эквивалентно выбору между широкоугольными,
нормальными или телефото – линзами. С широкоугольными линзами вы можете
охватить большее пространство, однако телефото – линзы позволяют фотографировать
объекты таким образом, как будто они ближе к вам, чем на самом деле. В
компьютерной графике вам нет необходимости платить 2000 долларов за 2000 –
миллиметровые телефото - линзы – как только вы включили свою рабочую станцию,
все, что вам нужно сделать – это указать меньшее число для объема видимости.</p>

<p class=text align=left style='text-align:left'>В дополнение к решениям об
объеме видимости, проекционная трансформация определяет, (как и следует из ее
имени) как объекты будут <i>проецироваться</i> на экран. Два основных типа
проекций реализовано в OpenGL в явном виде. Вы можете задавать связанные с ними
параметры различными способами, применяя несколько специальных команд. Первый
из этих типов проекций – перспективная проекция соответствует тому, как вы
видите в реальной жизни. Перспектива заставляет удаленные от вас объекты
выглядеть меньше. Например, если посмотреть на рельсовую дорогу, кажется, что
где-то далеко рельсы сходятся, чего на самом деле конечно не происходит. Если
вы пытаетесь создать реалистичное изображение, вероятно, вы захотите использовать
именно перспективную проекцию, которая в предыдущем примере кода задается
командой <b>glFrustum()</b>. </p>

<p class=text align=left style='text-align:left'>Проекции другого типа –
ортографические переносят объекты на экран без воздействия на их относительный
размер. Ортографическая проекция используется в архитектурных приложениях и
САПРах (Системах Автоматизированного Проектирования), где результирующее
изображение должно скорее отражать реальные размеры объектов, а не то, как они
выглядят. Архитекторы создают перспективные изображения для демонстрации того,
как конкретное здание или интерьер будут выглядеть с разных точек зрения, но
они используют ортографические проекции для создания чертежей.</p>

<p class=text align=left style='text-align:left'>До вызова <b>glFrustum()</b>,
задающего проекционную трансформацию, должны быть сделаны некоторые
приготовления. Как показано в функции <b>reshape()</b> примера 3-1, вначале
используется команда <b>glMatrixMode()</b> с параметром GL_PROJECTION. В
результате текущей матрицей становится <i>проекционная матрица</i>, и все
последующие задаваемые преобразования будут влиять именно на нее. Как вы можете
заметить, через несколько строк кода команда <b>glMatrixMode()</b> вызывается
снова, на этот раз с параметром GL_MODELVIEW. Таким образом, сообщается о том,
что с этого момента последующие преобразования будут влиять на видовую матрицу,
а не на проекционную.</p>

<p class=text align=left style='text-align:left'>Заметьте, что в коде
используется команда <b>glLoadIdentity()</b> для инициализации текущей
проекционной матрицы. В результате только задаваемая проекционная трансформация
будет иметь эффект. Теперь может быть вызвана <b>glFrustum()</b> с аргументами,
определяющими параметры проекционного преобразования. В предыдущем примере и
проекционное преобразование, и преобразование порта просмотра содержатся в
функции <b>reshape()</b>, которая вызывается, когда окно создается, а также
каждый раз при перемещении или изменении размеров окна. Это имеет смысл,
поскольку проецирование (соотношение ширина к высоте объема видимости проекции)
и воздействие орта просмотра непосредственно связаны с экраном или, более
конкретно с отношением размером окна на экране.</p>

<h2>3.1.1.4&nbsp;&nbsp;&nbsp; Трансформация порта просмотра</h2>

<p class=text align=left style='text-align:left'>Вместе проекционное
преобразование и преобразование порта просмотра определяет, каким образом
изображение будет перенесено на экран компьютера. Проекционное преобразование
задает механику того, как будет происходить перенос, преобразование порта просмотра
задает форму и размеры доступной области на экране, куда будет перенесено
изображение. Поскольку порт просмотра определяет регион, который изображение
будет занимать на экране, вы можете думать о трансформации порта просмотра как
об определяющей размер и место результирующей фотографии (фотография, например,
может быть увеличена или уменьшена).</p>

<p class=text align=left style='text-align:left'>Аргументы команды <b>glViewport()</b>
(задающей порт просмотра) задают начальную точку доступного экранного
пространства внутри окна (в данном примере (0, 0)), а также ширину и высоту
доступной области на экране. Все эти величины измеряются в экранных пикселях.
Вот почему эта команда должна быть вызвана из <b>reshape()</b>: если изменяется
размер окна, размер порта просмотра должен также измениться. Заметьте, что
ширина и высота задаются с использованием реальной ширины и высоты окна;
достаточно часто вам понадобится задавать порт просмотра именно таким образом,
вместо того, чтобы применять абсолютные значения.</p>

<h2>3.1.1.5&nbsp;&nbsp;&nbsp; Рисуем сцену</h2>

<p class=text align=left style='text-align:left'>После того, как все
необходимые преобразования были заданы, вы можете нарисовать сцену (или снять
фотографию). Во время рисования сцены OpenGLпреобразует каждую вершину каждого
объекта на сцене с помощью видовых и модельных преобразований. Далее каждая
вершина преобразуется в соответствии с проекционной трансформацией и
отсекается, если она лежит вне объема видимости, заданного проекционной
трансформацией. Наконец, оставшиеся преобразованные вершины делятся на wи
накладываются на порт просмотра.</p>

<h2>3.1.2&nbsp; Команды общего назначения для преобразований</h2>

<p class=text align=left style='text-align:left'>В этом разделе обсуждаются
некоторые команды OpenGL, которые вы можете счесть полезными для указания
преобразований. Вы уже видели две из этих команд: <b>glMatrixMode()</b> и <b>glLoadIdentity()</b>.
Две другие, описанные здесь команды – <b>glLoadMatrix*()</b> и <b>glMultMatrix*()</b>
– позволяют задать любую матрицу любого преобразования непосредственно и
умножить на нее текущую матрицу. Более специфические команды преобразований,
такие как, <b>gluLookAt()</b> и <b>glScale*()</b>, будут рассмотрены позже.</p>

<p class=text align=left style='text-align:left'>Как описано в предыдущем
разделе, вам следует определиться с тем, какую из матриц вы будете изменять
(видовую или проекционную) и лишь затем вызывать команды преобразований. Вы
выбираете матрицу с помощью <b>glMatrixMode()</b>. Если вы в разных частях кода
используете множество преобразований – важно не запутаться с тем, какая матрица
выбрана текущей в каждый момент времени. (Команда <b>glMatrixMode()</b> может
также использоваться для выбора текстурной матрицы в качестве текущей.) </p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>glMatrixMode</b>
  (GLenum <i>mode</i>); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Указывает, какая из матриц, а
именно видовая, проекционная или текстурная, будет изменена. Аргумент <i>mode</i>
может принимать значения GL_MODELVIEW (видовая матрица), GL_PROJECTION
(проекционная матрица) или GL_TEXTURE (текстурная матрица). Последующие команды
преобразований влияют на указанную матрицу. Заметьте, что в каждый момент
времени может быть изменена только одна матрица. По умолчанию видовая матрица
является текущей (подлежащей изменению) и все три матрицы являются единичными.</p>

<p class=text align=left style='text-align:left'>Вы используете команду <b>glLoadIdentity()</b>
для очистки текущей матрицы для будущих преобразований, поскольку эти
преобразования изменяют текущую матрицу. В большинстве случаев эта команда
всегда вызывается перед указанием проекционных и видовых преобразований, но вам
также может понадобиться очистить матрицу перед модельным преобразованием. </p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>glLoadIdentity</b>
  (void); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Устанавливает текущую
(подлежащую модификации) матрицу в единичную с размерностью 4 x4.</p>

<p class=text align=left style='text-align:left'>Если вы хотите загрузить в
качестве текущей некоторую специфическую матрицу (например, чтобы задать
какую-либо особенную проекцию), используйте <b>glLoadMatrix*()</b>. Похожим
образом используйте <b>glMultMatrix*()</b> для умножения текущей матрицы на
матрицу, переданную в качестве аргумента. Аргументом для обеих этих команд
выступает вектор, содержащий 16 величин (<!--[if gte vml 1]><v:shape id="_x0000_i1055"
 type="#_x0000_t75" alt="" style='width:81.75pt;height:18pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image031.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов3.mht!http://www.progz.ru/images/opengl/chapter3/form1.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=109 height=24
src="OpenGL%20Red%20Book.files/image031.gif" v:shapes="_x0000_i1055"><![endif]>),
задающих матрицу M следующим образом:</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1056" type="#_x0000_t75" alt="" style='width:170.25pt;height:85.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image032.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов3.mht!http://www.progz.ru/images/opengl/chapter3/form2.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=227 height=114
src="OpenGL%20Red%20Book.files/image032.gif" v:shapes="_x0000_i1056"><![endif]>.</p>

<p class=text align=left style='text-align:left'>Помните, что вы можете
повысить эффективность, применяя дисплейные списки (списки отображения) для
наиболее часто применяемых матриц, вместо того, чтобы пересчитывать их каждый
раз. (Часто OpenGLреализации должны вычислять обратную матрицу видовой матрицы
для корректного преобразования нормалей и отсекающих плоскостей в видовые
координаты.)</p>

<p class=warning>Замечание: Если вы программируете на C и объявляете матрицу
как <i>m[4][4]</i>, то элемент <i>m[i][j]</i> будет соответствовать элементу в <i>i</i>-ом
столбце и <i>j</i>-ой строке матрицы преобразования OpenGL. Однако это не
совсем обычно для языка C, поскольку по соглашению <i>m[i][j]</i> соответствует
элементу в <i>i</i>-ой строке и <i>j</i>-ом столбце. Иными словами в Cпринято
хранить матрицы по строкам, но OpenGLпри получении подобного указателя будет
трактовать его как матрицу, хранимую по столбцам. Во избежание ошибок
объявляйте матрицы в виде <i>m[16]</i>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=text align=left style='text-align:left'><span style='font-size:8.5pt;
  font-family:Courier;mso-bidi-font-family:"Courier New"'>void <b>glLoadMatrix</b>{fd}
  (const TYPE *<i>m</i>);</span><span style='mso-bidi-font-family:"Courier New"'>Умножает
  текущую матрицу на матрицу, заданную 16 величинами вектора <i>m</i> и
  сохраняет результат в качестве текущей матрицы. <o:p></o:p></span></p>
  <p class=MsoNormal><span style='font-size:10.0pt;font-family:Verdana;
  mso-bidi-font-family:"Courier New";color:black'><o:p>&nbsp;</o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Устанавливает 16 величин
текущей матрицы в значения, содержащиеся в <i>m</i>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=text align=left style='text-align:left'><span style='font-size:8.5pt;
  font-family:Courier;mso-bidi-font-family:"Courier New"'>void <b>glMultMatrix</b>{fd}
  (const TYPE *<i>m</i>);</span><span style='mso-bidi-font-family:"Courier New"'>Умножает
  текущую матрицу на матрицу, заданную 16 величинами вектора <i>m</i> и сохраняет
  результат в качестве текущей матрицы. <o:p></o:p></span></p>
  <p class=MsoNormal><span style='font-size:10.0pt;font-family:Verdana;
  mso-bidi-font-family:"Courier New";color:black'><o:p>&nbsp;</o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Умножает текущую матрицу на
матрицу, заданную 16 величинами вектора <i>m</i> и сохраняет результат в
качестве текущей матрицы.</p>

<p class=warning>Замечание: Все перемножения матриц в OpenGL производятся
следующим образом. Обозначим текущую матрицу как <b>C</b>, а матрицу, заданную
командой <b>glMultMatrix*()</b> или любой командой преобразования как <b>M</b>.
После умножения результирующей матрицей всегда является <b>CM</b>. Поскольку в
общем случае произведение матриц не коммутативно, порядок перемножения матриц
имеет большое значение. </p>

<h2>3.2&nbsp; Видовые и модельные преобразования </h2>

<p class=text align=left style='text-align:left'>Видовые и модельные
преобразования в OpenGLсильно связаны и, более того, объединены в одной видовой
матрице. Одна из самых сложных проблем, с которой сталкиваются новички в
компьютерной графике, состоит в понимании эффекта нескольких комбинированных
трехмерных преобразований. Как вы уже видели, существуют альтернативы в
понимании преобразований – вы можете передвинуть камеру в одном направлении или
объект – в обратном. Каждый из способов понимания преобразований имеет свои
недостатки и достоинства, но в определенных случаях один из них может более
естественно соответствовать эффекту от произведенной трансформации, чем другой.
Если вы найдете естественный подход для своего конкретного приложения, вам
будет намного проще визуализировать необходимые трансформации и затем написать
соответствующий код для манипуляций с матрицами. Первая часть этого раздела
посвящена того, как следует понимать преобразования. Затем рассмотрим
конкретные команды. Пока что мы будем использовать только команды матричных
манипуляций, уже виденные вами. Помните о том, что вы должны вызвать команду <b>glMatrixMode()</b>
с аргументом GL_MODELVIEWдо того, как производить модельные или видовые
преобразования.</p>

<h2>3.2.1&nbsp; Понимание преобразований</h2>

<p class=text align=left style='text-align:left'>Начнем с простого случая
включающего всего два преобразования: поворот против часовой стрелки на 45
градусов с центром в начале координат вдоль оси <i>z</i> и перенос вдоль оси <i>x</i>в
ее положительном направлении. Предположим, что объект достаточно мал по
сравнению с преобразованием (то есть мы можем увидеть результат преобразования)
и, что изначально он находится в начале координат. Если вы сначала повернете
объект, а затем перенесете его, он в результате окажется на оси <i>x</i>. Если
же вы сначала перенесете его по оси <i>x</i>, а затем повернете вокруг начала
координат, объект окажется на линии <i>y=x</i>, как показано на рисунке 3-4. В
общем случае порядок преобразования является весьма критичным. Если вы
выполняете преобразование A, а затем – преобразование B, вы практически во всех
случаях получите результат отличный от того, какой получили бы, производя
преобразования в обратном порядке.</p>

<p class=text align=left style='text-align:left'>&nbsp;Рисунок 3-4. Сначала
поворачиваем или сначала переносим </p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1057" type="#_x0000_t75" alt="" style='width:450pt;height:174pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image033.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов3.mht!http://www.progz.ru/images/opengl/chapter3/3-4.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=600 height=232
src="OpenGL%20Red%20Book.files/image033.jpg" v:shapes="_x0000_i1057"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Теперь поговорим о порядке, в
котором вы задаете серии преобразований. Все видовые и модельные преобразования
представлены в виде матриц размерностью 4x4. Каждый успешный вызов команды <b>glMultMatrix*()</b>
или другой команды преобразования умножает текущую видовую матрицу <b>C</b>на
новую (заданную вами явно или неявно) матрицу <b>M</b>, в результате чего
текущей матрицей становится <b>CM</b>. В итоге текущая видовая матрица
умножается на передаваемые по конвейеру вершины <b>v</b>. Этот процесс
означает, что последняя команда преобразования, вызванная в вашей программе, на
самом деле будет первой применена к вершинам: <b>CMv</b>. Таким образом, можно
смотреть на это как на необходимость задавать матрицы преобразований в обратном
порядке. Как и во многих других случаях, однако, как только вы научитесь
правильно думать об этом, обратный порядок начнет казаться прямым.</p>

<p class=text align=left style='text-align:left'>Рассмотрим следующий фрагмент
кода, рисующий точку с учетом трех преобразований. </p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>glMatrixMode(GL_MODELVIEW);<br>
  glLoadIdentity();<br>
  glMultMatrixf(N);&nbsp;&nbsp;&nbsp; //Применить преобразование N<br>
  glMultMatrixf(M);&nbsp;&nbsp;&nbsp; //Применить преобразование M<br>
  glMultMatrixf(L);&nbsp;&nbsp;&nbsp; //Применить преобразование L<br>
  glBegin(GL_POINTS);<br>
  &nbsp;&nbsp; glVertex3fv(v);&nbsp;&nbsp; //Нарисовать преобразованную вершину
  v<br>
  glEnd();<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>В этом коде видовая матрица
последовательно содержит матрицы <b>I</b> (единичную), <b>N</b>, <b>NM </b>и <b>NML</b>.
Преобразованные вершины будут равны <b>NMLv</b>. Таким образом, процесс
трансформации вершин можно записать в виде <b>N(M(Lv)) </b>– то есть сначала <b>L
</b>умножается на <b>v</b>, затем <b>M </b>– на <b>Lv</b> и, наконец, <b>N </b>–
на <b>MLv</b>. Заметьте, что преобразования действительно применяются к
вершинам в порядке обратном к тому, в котором вы их задавали. (На самом деле
вершина участвует лишь в одном перемножении, так как матрицы отдельных
преобразований – в данном примере <b>N</b>, <b>M </b>и <b>L</b>–предварительно
перемножены между собой и получена одна результирующая матрица вида.)</p>

<h2>3.2.1.1&nbsp;&nbsp;&nbsp; Фиксированная система координат</h2>

<p class=text align=left style='text-align:left'>Таким образом, если вам
нравится думать о преобразованиях в терминах фиксированной координатной системы
– в которой перемножение матриц влияет на позицию, ориентацию и масштабирование
вашей модели – вы должны думать о перемножениях как о происходящих в обратном
порядке относительно того, в котором они появляются в коде. Если бы вы хотели,
чтобы после всех операций объект появился на оси <i>x</i> в простом примере,
показанном в левой части рисунка 3-4 (вращение вокруг начала координат и
перенос по оси <i>x</i>), первым следовало бы произойти вращение, а затем
перенос. Однако, чтобы это сделать, вам следует изменить порядок операций на
обратный. В результате код должен выглядеть примерно следующим образом (в нем <b>R
</b>обозначает матрицу поворота, а <b>T </b>– матрицу переноса):</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>glMatrixMode(GL_MODELVIEW);<br>
  glLoadIdentity();<br>
  glMultMatrixf(T);&nbsp;&nbsp; //Перенос<br>
  glMultMatrixf(R);&nbsp;&nbsp; //Поворот<br>
  нарисовать_объект();<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<h2>3.2.1.2&nbsp;&nbsp;&nbsp; Изменение локальной системы координат</h2>

<p class=text align=left style='text-align:left'>Другой способ рассмотрения
матричных перемножений заключается в том, чтобы забыть о фиксированной системе
координат, в которой трансформируется модель и вместо этого представить себе локальную
систему координат, привязанную к рисуемому объекту. Все операции происходят
относительно этой изменяющейся системы координат. При таком подходе
оказывается, что матричные преобразования появляются в коде в своем
естественном порядке. (Независимо от точки зрения код всегда остается тем же
самым, но изменяется то, как вы его осознаете.) Рассматривая пример на рисунке
3-4, представьте себе координатную систему, привязанную к объекту. Операция
переноса сдвигает объект и его координатную систему по оси <i>x</i>. Затем
поворот совершается вокруг теперь уже перенесенного начала координат. Таким
образом, объект поворачивается на месте в своей позиции на оси.</p>

<p class=text align=left style='text-align:left'>Такой подход следует
использовать для приложений, рисующих, например, руку робота, в которой
присутствуют точки соединения объектов на плече, локте, запястье и на каждом из
пальцев. Для выяснения того, где должны быть кончики пальцев относительно тела,
следует начать с плеча, опуститься до запястья и далее, задавая необходимые
повороты и переносы в каждой точке соединения. Если думать об этом процессе в
терминах фиксированной системы координат и обратного порядка преобразований,
можно очень быстро запутаться.</p>

<p class=text align=left style='text-align:left'>Этот второй подход, однако,
может вызвать проблемы в тех случаях, когда применяется масштабирование, особенно,
если оно неравномерное (то есть по разным осям используются разные коэффициенты
растяжения/сжатия). После равномерного масштабирования с коэффициентом
растяжения/сжатия <i>k</i>перенос на <i>(a, b, c)</i> сдвигает вершину на
расстояния <i>(a*k,b*k,c*k)</i> поскольку координатная система растянута или
сжата. Неравномерное масштабирование вкупе с поворотами может вообще сделать
оси локальной координатной системы неперпендикулярными друг другу.</p>

<p class=text align=left style='text-align:left'>Как было отмечено выше, обычно
вы в своей программе задаете видовые трансформации перед всеми модельными. В
этом случае вершина модели сначала преобразуется к выбранной ориентации, а
затем преобразуется видовой операцией. Поскольку матричные перемножения должны
быть заданы в обратном порядке, видовые команды должны быть заданы первыми.
Заметьте, однако, что вы не обязаны задавать видовые или модельные
преобразования, если вы удовлетворены тем, что определено по умолчанию. Если
видовое преобразование не задано, то «камера» по умолчанию находится в начале
координат и направлена вдоль отрицательного направления оси <i>z</i>. Если не
заданы модельные трансформации – модель не двигается и сохраняет свою позицию,
ориентацию и размер.</p>

<p class=text align=left style='text-align:left'>Поскольку команды для
выполнения модельных преобразований могут быть использованы для выполнения
видовых преобразований, модельные преобразования <i>рассматриваются</i>
первыми, несмотря на то, что видовые преобразования должны первыми <i>задаваться</i>.
Данный порядок рассмотрения также соответствует тому, как думают многие
программисты при планировании своего кода. Часто сначала они пишут весь код,
необходимый для композиции сцены, включая команды преобразований для верного
расположения и ориентирования объектов сцены относительно друг друга. Далее они
решают, где они хотят поместить точку наблюдения и пишут соответствующий код
видового преобразования.</p>

<h2>3.2.2&nbsp; Модельные трансформации</h2>

<p class=text align=left style='text-align:left'>Существует три команды OpenGL
для модельных преобразований: <b>glTranslate*()</b>, <b>glRotate*()</b> и <b>glScale*()</b>.
Как вы можете предположить, эти команды трансформируют объект (или координатную
систему – в зависимости от того, как вы предпочитаете думать об этом),
перенося, поворачивая, увеличивая, уменьшая или отражая его. Все эти команды
эквивалентны созданию соответствующей матрицы переноса, поворота или
масштабирования с последующим вызовом <b>glMultMatrix*()</b> с этой матрицей в
качестве аргумента. Однако использование этих трех команд может быть быстрее,
чем <b>glMultMatrix*()</b> – OpenGL автоматически вычисляет для вас нужные
матрицы.</p>

<p class=text align=left style='text-align:left'>В следующем описании команд
каждая матричная манипуляция рассматривается в терминах того, что она делает с
вершинами геометрического объекта (при использовании подхода с фиксированной
системой координат) и в терминах того, что она делает с локальной системой
координат, привязанной к объекту (при использовании этого подхода).</p>

<h2>3.2.2.1&nbsp;&nbsp;&nbsp; Перенос</h2>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glTranslate</b>{fd}
  (TYPE <i>x</i>, TYPE <i>y</i>, TYPE <i>z</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Умножает текущую матрицу на
матрицу, передвигающую (переносящую) объект на расстояния <i>x</i>, <i>y</i>, <i>z</i>,
переданные в качестве аргументов команды, по соответствующим осям (или
перемещает локальную координатную систему на те же расстояния).</p>

<p class=text align=left style='text-align:left'>На рисунке 3-5 изображен
эффект команды <b>glTranslate*()</b>. </p>

<p class=text align=left style='text-align:left'>Рисунок 3-5. Перенос объекта</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1058" type="#_x0000_t75" alt="" style='width:225pt;height:204.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image034.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов3.mht!http://www.progz.ru/images/opengl/chapter3/3-5.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=300 height=273
src="OpenGL%20Red%20Book.files/image034.jpg" v:shapes="_x0000_i1058"><![endif]></p>

<p class=text align=left style='text-align:left'>Обратите внимание на то, что
использование (<i>0.0</i>, <i>0.0</i>, <i>0.0</i>) в качестве аргумента <b>glTranslate*()</b>
– это единичная операция, то есть она не влияет на объект или на его
координатную систему.</p>

<h2>3.2.2.2&nbsp;&nbsp;&nbsp; Поворот</h2>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glRotate</b>{fd}
  (TYPE <i>angle</i>, TYPE <i>x</i>, TYPE <i>y</i>, TYPE <i>z</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Умножает текущую матрицу на
матрицу, которая поворачивает объект (или локальную координатную систему) в
направлении против часовой стрелки вокруг луча из начала координат, проходящего
через точку (<i>x</i>, <i>y</i>, <i>z</i>). Параметр <i>angle</i>задает угол
поворота в градусах.</p>

<p class=text align=left style='text-align:left'>Результат выполнения <b>glRotatef</b>(<i>45.0</i>,
<i>0.0</i>,<i>0.0</i>,<i>1.0</i>), то есть поворот на 45 градусов вокруг оси <i>z</i>,
показан на рисунке 3-6.</p>

<p class=text align=left style='text-align:left'>Рисунок 3-6. Поворот объекта </p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1059" type="#_x0000_t75" alt="" style='width:225pt;height:182.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image035.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов3.mht!http://www.progz.ru/images/opengl/chapter3/3-6.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=300 height=243
src="OpenGL%20Red%20Book.files/image035.jpg" v:shapes="_x0000_i1059"><![endif]></p>

<p class=text align=left style='text-align:left'>Заметьте, что чем дальше
объект от оси вращения, тем больше орбита его поворота и тем заметнее сам
поворот. Также обратите внимание на то, что вызов <b>glRotate*()</b> с
параметром <i>angle </i>равным 0 не имеет никакого эффекта.</p>

<h2>3.2.2.3&nbsp;&nbsp;&nbsp; Масштабирование</h2>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glScale</b>{fd}
  (TYPE <i>x</i>, TYPE <i>y</i>, TYPE <i>z</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Умножает текущую матрицу на
матрицу, которая растягивает, сжимает или отражает объект вдоль координатный
осей. Каждая <i>x</i> -, <i>y</i>- и <i>z</i>- координата каждой точки объекта
будет умножена на соответствующий аргумент <i>x</i>, <i>y</i>или <i>z</i>команды
<b>glScale*()</b>. При рассмотрении преобразования с точки зрения локальной
координатной системы, оси этой системы растягиваются, сжимаются или отражаются
с учетом факторов <i>x</i>, <i>y </i>и <i>z</i>, и ассоциированный с этот
системой объект меняется вместе с ней.</p>

<p class=text align=left style='text-align:left'>На рисунке 3-7 показан эффект
команды <b>glScalef</b><i>(-2.0</i>,<i>0.5</i>,<i>1.0</i>);</p>

<p class=text align=left style='text-align:left'>Рисунок 3-7. Масштабирование и
отражение объекта </p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1060" type="#_x0000_t75" alt="" style='width:465pt;height:169.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image036.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов3.mht!http://www.progz.ru/images/opengl/chapter3/3-7.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=620 height=226
src="OpenGL%20Red%20Book.files/image036.jpg" v:shapes="_x0000_i1060"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><b>glScale*()</b> – это
единственная из трех команд модельных преобразований, изменяющая размер
объекта: масштабирование с величинами более <i>1.0</i> растягивает объект,
использование величин меньше <i>1.0</i> сжимает его. Масштабирование с
величиной <i>-1.0</i> отражает объект относительно оси или осей. Единичными
аргументами (то есть аргументами, не имеющими эффекта) являются (<i>1.0</i>, <i>1.0</i>,
<i>1.0</i>). Вообще следует ограничивать использование <b>glScale*()</b> теми
случаями, когда это действительно необходимо. Использование <b>glScale*()</b>
снижает быстродействие расчетов освещенности, так как вектора нормалей должны
быть нормализованы заново после преобразования.</p>

<p class=warning>Замечание: Величина масштабирования равная 0 приводит к
коллапсу всех координат объекта по оси или осям до 0. Обычно это не является
хорошей идеей, так как такая операция не может быть обращена. Говоря
математически, матрица не может быть обращена, а обратные матрицы необходимы
для многих расчетов, связанных с освещением. Иногда коллапс координат все же
имеет смысл: расчет теней на плоской поверхности – это типичный пример
применения коллапса. В общем, если координатная система должна быть подвергнута
коллапсу, следует использовать для этого проекционную матрицу, а не видовую. </p>

<h2>3.2.2.4&nbsp;&nbsp;&nbsp; Пример кода с модельными трансформациями</h2>

<p class=text align=left style='text-align:left'>Пример 3-2 – это фрагмент
программы, которая рисует треугольник 4 раза:</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l6 level1 lfo8;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Сплошной треугольник в виде контура без
модельных преобразований. </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l6 level1 lfo8;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Тот же треугольник, нарисованный штриховой
линией и перенесенный по оси x. </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l6 level1 lfo8;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Треугольник, нарисованный линией с длинным
штрихом, растянутый в 1.5 раза по оси x и сжатый в 1.5 раза по оси y. </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l6 level1 lfo8;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Повернутый треугольник, нарисованный пунктирной
линией. </p>

<p class=text align=left style='text-align:left'>Пример 3-2. Использование
модельных преобразований</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>glLoadIdentity();<br>
  glColor3f(1.0,1.0,1.0);<br>
  draw_triangle();<br>
  <br>
  glEnable(GL_LINE_STIPPLE);<br>
  glLineStipple(1,0xF0F0);<br>
  glLoadIdentity();<br>
  glTranslatef(-20.0,0.0,0.0);<br>
  draw_triangle();<br>
  <br>
  glLineStipple(1,0xF00F);<br>
  glLoadIdentity();<br>
  glScalef(1.5,0.5,1.0);<br>
  draw_triangle();<br>
  <br>
  glLineStipple(1,0x8888);<br>
  glLoadIdentity();<br>
  glRotatef(90.0,0.0,0.0,1.0);<br>
  draw_triangle();<br>
  glDisable(GL_LINE_STIPPLE);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Обратите внимание на
использование <b>glLoadIdentity()</b> для изоляции эффектов модельных
преобразований; инициализация матрицы единичными значениями предотвращает
кумулятивный эффект последующих преобразований. Несмотря на то, что <b>glLoadIdentity()</b>
позволяет добиться нужного результата, ее множественные вызовы могут быть
неэффективны, так как после каждого из них вам необходимо заново задавать
видовые и модельные преобразования. Для получения информации о более
эффективном способе изоляции преобразований смотрите раздел «Манипулирование
матричными стеками» далее в этой главе.</p>

<p class=warning>Замечание: Иногда программисты, пытаются заставить объект
вращаться, комбинируя на каждом шаге текущую матрицу с матрицей вращения на
небольшой угол (то есть как раз и используя кумулятивный эффект). Проблема в
том, что из-за ошибок округления комбинация тысяч небольших поворотов все
дальше уходит от реально желаемой величины поворота (этот процесс может даже
привести к чему-либо отличному от вращения вообще). Вместо этой техники, на
каждом шаге увеличивайте угол, инициализируйте видовую матрицу и исполняйте
новую команду поворота. </p>

<h2>3.2.3&nbsp; Видовые трансформации</h2>

<p class=text align=left style='text-align:left'>Видовое преобразование
изменяет позицию и ориентацию точки обзора. Если вы вспомните аналогию с
камерой, видовое преобразование устанавливает треногу для камеры и направляет
камеру на модель. Видовое преобразование аналогично передвижению и поворотам
камеры также обычно состоит из переносов и поворотов. Помните также, что для
достижения определенной композиции в результирующем изображении или фотографии
вы можете либо перемещать камеру, либо перемещать все объекты сцены в
противоположном направлении. Таким образом, модельное преобразование,
поворачивающее объекты сцены против часовой стрелки аналогично видовому
преобразованию, которое поворачивает камеру по часовой стрелке. И, наконец,
имейте в виду, что команды видового преобразования должны вызываться перед
всеми командами модельных преобразований, чтобы модельные преобразования были
применены к объектам первыми.</p>

<p class=text align=left style='text-align:left'>Вы можете производить видовые
преобразования любым из нескольких способов, описанных далее. Вы также можете
использовать расположение и ориентацию точки обзора по умолчанию, то есть ее
расположение в начале координат и направление просмотра вдоль отрицательного
направления оси <i>z</i>.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l8 level1 lfo9;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Используйте одну или несколько команд модельных
преобразований (<b>glTranslate*()</b> или <b>glRotate*()</b>). Вы можете думать
об эффекте этих преобразований как перемещении камеры, или как о перемещении
всех объектов сцены относительно стационарной камеры.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l8 level1 lfo9;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Используйте команду библиотеки утилит <b>gluLookAt()</b>
для определения точки и направления обзора. Эта команда инкапсулирует в себе
серию поворотов и переносов.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l8 level1 lfo9;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Создайте свою собственную (пользовательскую)
функцию, инкапсулирующую повороты и переносы. В некоторых приложениях такая
функция может понадобиться для того, чтобы можно было задавать видовую
трансформацию каким-либо специфическим путем. Например, вам может понадобиться
задавать преобразование в терминах полярных координат для камеры, вращающейся
вокруг объекта или в терминах углов наклона самолета в полете.</p>

<h2>3.2.3.1&nbsp;&nbsp;&nbsp; Использование glTranslate*() и glRotate*() </h2>

<p class=text align=left style='text-align:left'>Когда вы используете команды
модельных преобразований для эмуляции видовых, вы пытаете передвинуть точку
наблюдения в желаемом направлении, сохранив объекты неподвижными. Поскольку
точка наблюдения изначально находится в начала координат, и поскольку объекты
обычно конструируются там же (рисунок 3-8), вам, в общем, необходимо выполнить
некоторые преобразования, дабы объекты были видны. Заметьте, что изначально
камера указывает в отрицательном направлении оси <i>z</i>.</p>

<p class=text align=left style='text-align:left'>Рисунок 3-8. Объект и точка
обзора в начале координат </p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1061" type="#_x0000_t75" alt="" style='width:225pt;height:189pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image037.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов3.mht!http://www.progz.ru/images/opengl/chapter3/3-8.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=300 height=252
src="OpenGL%20Red%20Book.files/image037.jpg" v:shapes="_x0000_i1061"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>В простейшем случае вы можете
передвинуть точку наблюдения назад, от объектов; эффект будет такой же, как
если бы вы передвинули объекты вперед от точки наблюдения. Помните, что по
умолчанию «вперед» – это значит в отрицательном направлении оси <i>z</i>; если
вы повернете точку наблюдения, «вперед» будет иметь другой смысл. Таким
образом, чтобы поместить 5 единиц дистанции между точкой наблюдения и
объектами, переместив точку наблюдения (как показано на рисунке 3-9),
используйте следующую команду:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>glTranslatef(0.0,0.0,-5.0); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Эта команда передвигает
объекты сцены на -5 единиц вдоль оси <i>z</i>. Она также эквивалентна
передвижению камеры на +5 единиц вдоль оси <i>z</i>.</p>

<p class=text align=left style='text-align:left'>Рисунок 3-9. Разделение точки
наблюдения и объекта </p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1062" type="#_x0000_t75" alt="" style='width:465pt;height:193.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image038.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов3.mht!http://www.progz.ru/images/opengl/chapter3/3-9.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=620 height=258
src="OpenGL%20Red%20Book.files/image038.jpg" v:shapes="_x0000_i1062"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Теперь предположим, что вы
хотите наблюдать объекты со стороны. Должны ли вы в этом случае выполнить
команду поворота до или после команды переноса? Если вы мыслите в терминах
фиксированной системы координат, для начала представьте объекты и камеру в
начале координат. Сначала вы должны повернуть объекты, а затем отодвинуть их от
камеры, чтобы выбранная сторона была видна. Поскольку вы знаете, что при
подходе с фиксированной системой координат команды должны вызываться в обратном
порядке – в том, в котором они будут иметь эффект, вы знаете, что сначала
должны написать команду переноса, а затем – поворота.</p>

<p class=text align=left style='text-align:left'>Теперь используем подход с
локальной системой координат. В этом случае думайте о передвижении объекта и
его локальной системы координат от начала координат, а затем о повороте с
использованием теперь уже перенесенной системы координат. При таком подходе
команды вызываются в том же порядке, в котором они применяются, так что перенос
снова будет первым, а поворот – вторым. Таким образом, последовательность
команд преобразований для получения желаемого результата должна быть следующей:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>glTranslatef(0.0,0.0,-5.0);<br>
  glRotatef(90.0,0.0,1.0,0.0); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Если у вас возникают проблемы
с понимаем матричных манипуляций, попробуйте разобрать оба подхода с
фиксированной и локальной системами координат и оценить, имеет ли один из них
смысл. Заметьте, что в фиксированной системе координат вращение всегда
происходит вокруг фиксированного начала координат, а в локальной – вокруг
изменяющегося начала координат. Вы также можете попробовать использовать
команду библиотеки утилит <b>gluLookAt()</b>, которая описана далее.</p>

<h2>3.2.3.2&nbsp;&nbsp;&nbsp; Использование команды библиотеки утилит
gluLookAt()</h2>

<p class=text align=left style='text-align:left'>Часто программисты
конструируют сцену в районе начала координат или в некотором другом месте, а
затем хотят посмотреть на нее с определенной точки обзора для получения лучшего
вида. Как и говорит ее имя, команда из библиотеки утилит <b>gluLookAt()</b>
разработана как раз для подобных целей. Она принимает три набора аргументов,
которые задают точку наблюдения, прицельную точку (точку, на которую направлена
камера) и направление, которое следует считать верхним. Выберите точку обзора,
чтобы получить желаемый вид сцены. Прицельная точка, как правило, находится
где-то в середине сцены. (Если вы строите сцену в начале координат, то,
вероятно, оно и будет прицельной точкой.) Несколько сложнее, видимо, задать
верный вектор верхнего направления. Если вы строите сцену в или около начала
координат и считаете, что положительное направление оси yуказывает вверх, то
это и есть ваш вектор верхнего направления для <b>gluLookAt()</b>. Однако если
вы разрабатываете симулятор полетов, верхним является направление
перпендикулярное крыльям самолета.</p>

<p class=text align=left style='text-align:left'>Команда <b>gluLookAt()</b>
может быть полезна, например, если вы хотите скользить по ландшафту. С объемом
видимости симметричным по <i>x</i>и <i>y</i> точка (<i>eyex</i>, <i>eyey</i>, <i>eyez</i>)
может всегда задаваться как лежащая в центре изображения, и вы можете исполнять
серию команд для незначительного изменения этой точки, таким образом, скользя
по сцене.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>gluLookAt</b>
  (GLdouble <i>eyex</i>, GLdouble <i>eyey</i>, GLdouble <i>eyez</i>, GLdouble <i>centerx</i>,
  GLdouble <i>centery</i>, GLdouble <i>centerz</i>, <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  GLdouble <i>upx</i>, GLdouble <i>upy</i>, GLdouble <i>upz</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Задает видовую матрицу и
умножает на нее текущую матрицу. Выбранная точка обзора задается аргументами <i>eyex</i>,
<i>eyey</i> и <i>eyez</i>. Аргументы <i>centerx</i>, <i>centery</i>и <i>centerz</i>задают
любую точку на линии обзора, но обычно они задают точку где-то в середине
обозреваемой сцены. Аргументы <i>upz</i>, <i>upy</i>и <i>upz</i> определяют,
какое направление считается верхним (то есть направление от дна до вершины
объема видимости).</p>

<p class=text align=left style='text-align:left'>По умолчанию камера находится
в начале координат, направлена вдоль отрицательного направления оси <i>z</i>, а
вектор верхнего направления совпадает с положительным направлением оси <i>y</i>.
Таким образом, следующий вызов восстанавливает ситуацию по умолчанию:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <div style='border:solid #D1D7DC 1.0pt;mso-border-alt:solid #D1D7DC .75pt;
  padding:0cm 0cm 0cm 0cm;background:#FAFAFA'>
  <p class=code>gluLookAt(0.0,0.0,0.0,0.0,0.0,-100.0,0.0,1.0,0.0);</p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Величина <i>z</i>-координаты
прицельной точки здесь равна <i>-100.0</i>, но на самом деле она может быть
любой отрицательной величиной, поскольку в этом случае направление обзора
останется неизменным. Для описанного случая нет необходимости вызывать <b>gluLookAt()</b>,
поскольку это – установка по умолчанию (рисунок 3-10). (Линии из точки
наблюдения представляют собой объем видимости, задающий видимое пространство.)</p>

<p class=text align=left style='text-align:left'>Рисунок 3-10. Позиция точки
наблюдения по умолчанию </p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1063" type="#_x0000_t75" alt="" style='width:225pt;height:193.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image039.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов3.mht!http://www.progz.ru/images/opengl/chapter3/3-10.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=300 height=258
src="OpenGL%20Red%20Book.files/image039.jpg" v:shapes="_x0000_i1063"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Заметьте, что <b>gluLookAt()</b>
является частью библиотеки утилит, а не базовой командой OpenGL. Это произошло
не потому, что <b>gluLookAt()</b> бесполезна, а потому, что она инкапсулирует
несколько базовых команд OpenGL, а именно <b>glTranslate*() </b>и <b>glRotate*()</b>.
Чтобы понять это представьте, что камера находится в выбранной точке обзора и
направлена в соответствии с желаемым направлением обзора, как задано <b>gluLookAt()
</b>и сцена находится в начале координат. Чтобы отменить действия <b>gluLookAt()
</b>вам требуется поместить камеру в начале координат и установить направление
обзора совпадающим с отрицательным направлением оси <i>z</i> (то есть привести
видовое преобразование к ситуации по умолчанию). Простой перенос передвинет
камеру в начало координат. Вы легко можете представить себе серию поворотов
вокруг осей фиксированной системы координат, которые в итоге ориентируют камеру
в отрицательном направлении оси <i>z</i>. Поскольку OpenGLпозволяет задавать
повороты вокруг любой выбранной оси, вы можете выполнить требуемый поворот с
помощью всего одной команды <b>glRotate*()</b>.</p>

<p class=warning>Замечание: Вы можете иметь только одно активное видовое
преобразование. Вы не можете комбинировать эффекты двух видовых преобразований
(фотокамера не может быть установлена на двух треногах одновременно). Если вы
хотите изменить позицию камеры, убедитесь, что вы вызвали <b>glLoadIdentity() </b>для
стирания эффекта от текущего видового преобразования.</p>

<p class=text align=left style='text-align:left'><b>Дополнительно:</b> Чтобы
трансформировать любой вектор до совпадения (по направлению) с другим вектором
(например, с отрицательным направлением оси <i>z</i>) требуется произвести
некоторые математические расчеты. Ось, вокруг которой следует производить
вращение, получается как векторное произведение двух нормализованных векторов.
Чтобы найти угол вращения нормализуйте оба данных вектора. Косинус нужного угла
между векторами эквивалентен скалярному произведению между нормализованными
векторами. Угол поворота вокруг оси, полученный как векторное произведение
всегда находится между 0 и 180 градусами.</p>

<p class=text align=left style='text-align:left'>Заметьте, что вычисление угла
между двумя нормализованными векторами посредством взятия арккосинуса их
скалярного произведения дает весьма неточные результаты, особенно при малых
углах. Однако этот метод работает.</p>

<h2>3.2.3.3&nbsp;&nbsp;&nbsp; Создание пользовательской функции</h2>

<p class=text align=left style='text-align:left'><b>Дополнительно:</b> Для
некоторых специализированных приложений может понадобиться собственная функция
преобразования. Поскольку это делается достаточно редко и, в любом случае, это
достаточно сложный, не шаблонный процесс, он оставляется читателю в качестве
упражнения. Далее приведены два примера таких функций.</p>

<p class=text align=left style='text-align:left'>Предположим, что вы
разрабатываете симулятор полетов, и вам требуется изображать мир с точки зрения
пилота в кабине самолета. Самолет находится в точке с координатами (<i>x</i>, <i>y</i>,<i>
z</i>). Предположим также, что самолет характеризуется тремя углами своего наклона
относительно центра своей гравитации – <i>roll</i>, <i>pitch </i>и <i>heading</i>.
Для изображения мира глазами пилота может быть использована следующая функция: </p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void
  pilotView(GLdouble planex, GLdouble planey, GLdouble planez, GLdouble roll,
  GLdouble pitch, GLdouble heading)<br>
  {<br>
  &nbsp;&nbsp; glRotated(roll,0.0,0.0,1.0);<br>
  &nbsp;&nbsp; glRotated(pitch,0.0,1.0,0.0);<br>
  &nbsp;&nbsp; glRotated(heading,1.0,0.0,0.0);<br>
  &nbsp;&nbsp; glTranslated(-planex,-planey,-planez);<br>
  } <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Теперь предположим, что вашему
приложению требуется вращать камеру вокруг объекта, находящегося в начале
координат. В этом случае вы, вероятно, захотите задавать видовое преобразование
в терминах полярной системы координат. Допустим, что переменная <i>distance </i>задает
радиус орбиты, то есть расстояние от камеры до начала координат. (Вначале
камера отодвигается на <i>distance </i>единиц вдоль положительного направления
оси <i>z</i>.) Переменная <i>azimuth </i>задает угол вращения камеры вокруг
объекта в плоскости <i>xy</i>, отмеряемый от положительного направления оси <i>y</i>.
Похожим образом, <i>elevation</i> – это угол вращения камеры в плоскости <i>yz</i>,
отмеряемый от положительного направления оси <i>z</i>. Наконец, <i>twist </i>представляет
собой угол вращения объема видимости вокруг линии обзора. В этом случае
подойдет следующая функция.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void
  polarView(GLdouble distance, GLdouble twist, GLdouble elevation, GLdouble
  azimuth)<br>
  {<br>
  &nbsp;&nbsp; glTranslated(0.0,0.0,-distance);<br>
  &nbsp;&nbsp; glRotated(-twist,0.0,0.0,1.0);<br>
  &nbsp;&nbsp; glRotated(-elevation,1.0,0.0,0.0);<br>
  &nbsp;&nbsp; glRotated(azimuth,0.0,0.0,1.0);<br>
  } <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<h2>3.3&nbsp; Проекционные трансформации</h2>

<p class=text align=left style='text-align:left'>В предыдущем разделе
объяснялось, как задать нужную видовую матрицу для применения требующихся
модельных и видовых преобразований. В этом разделе объясняется, как определить
нужную матрицу проекции, которая также используется для преобразования вершин в
вашей сцене. Помните, что до выполнения любых команд преобразований, описанных
в этом разделе, следует вызвать</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>glMatrixMode(GL_PROJECTION);<br>
  glLoadIdentity();<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>чтобы следующие команды
изменяли именно матрицу проекции, а не видовую матрицу и во избежание составных
проекционных преобразований. Поскольку команда проекционного преобразования
полностью описывает отдельную трансформацию, обычно вам не нужно комбинировать
одну трансформацию с другой.</p>

<p class=text align=left style='text-align:left'>Назначение проекционного
преобразования заключается в определении <i>объема видимости</i>, который
используется двумя путями. Объем видимости определяет, как объект проецируется
на экран (с использованием перспективной или параллельной проекции), он также
определяет, какие объекты или части объектов будут отсечены в результирующем
изображении. Точку наблюдения, о которой мы говорили раньше, вы можете
представить себе находящейся на одном из концов объема видимости.</p>

<h2>3.3.1&nbsp; Перспективная проекция</h2>

<p class=text align=left style='text-align:left'>Наиболее узнаваемой
характеристикой перспективной проекции является уменьшение на расстоянии: чем
дальше объект находится от камеры (точки наблюдения), тем меньше он будет в
финальном изображении. Это происходит потому, что объем видимости перспективной
проекции имеет форму усеченной пирамиды (пирамиды, верхушка которой отрезана
плоскостью, параллельной ее основанию). Объекты, попадающие в объем видимости
проецируются из вершины пирамиды, где находится точка наблюдения. Более близкие
к точке наблюдения объекты получаются крупнее, поскольку они занимают
пропорционально большее пространство объема видимости. Более далекие объекты
оказываются меньше, поскольку они находятся в более широкой части усеченной
пирамиды объема видимости. Данный метод проецирования используется для
анимации, визуальной симуляции и в любых других приложениях, претендующих на
некоторую долю реализма, так как перспективное проектирование похоже на то, как
видит человеческий глаз (или камера).</p>

<p class=text align=left style='text-align:left'>Команда определения объема
видимости в форме усеченной пирамиды <b>glFrustum()</b> вычисляет матрицу,
выполняющую перспективное проецирование, и умножает на нее текущую матрицу
проекции (обычно единичную). Вспомните, что объем видимости используется для
отсечения объектов лежащих вне него; четыре стороны пирамиды, ее основание и
вершина (точнее, верхняя сторона) соответствуют шести отсекающим плоскостям
объема видимости, как показано на рисунке 3-11. Объекты или части объектов вне
этих плоскостей отсекаются и не выводятся в финальном изображении. Заметьте,
что <b>glFrustum()</b> не требует от вас указания симметричного объема
видимости. </p>

<p class=text align=left style='text-align:left'>Рисунок 3-11. Объем видимости
перспективной проекции, заданный командой glFrustum() </p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1064" type="#_x0000_t75" alt="" style='width:225pt;height:214.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image040.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов3.mht!http://www.progz.ru/images/opengl/chapter3/3-11.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=300 height=286
src="OpenGL%20Red%20Book.files/image040.jpg" v:shapes="_x0000_i1064"><![endif]></p>

<p class=text align=left style='text-align:left'>&nbsp; </p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glFrustum</b>
  (GLdouble <i>left</i>, GLdouble <i>right</i>, GLdouble <i>bottom</i>,
  GLdouble <i>top</i>, GLdouble <i>near</i>, GLdouble <i>far</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Создает матрицу перспективного
проецирования и умножает на нее текущую матрицу. Объем видимости задается
параметрами (<i>left</i>, <i>bottom</i>,<i>-near</i>) и (<i>right</i>, <i>top</i>,<i>-near</i>)
определяющими координаты (<i>x</i>, <i>y</i>, <i>z</i>) левого нижнего и
правого верхнего углов ближней отсекающей плоскости; <i>near</i>и <i>far </i>задают
дистанцию от точки наблюдения до ближней и дальней отсекающих плоскостей (они
всегда должны быть положительными).&nbsp;&nbsp; </p>

<p class=text align=left style='text-align:left'>Пирамида имеет ориентацию в
пространстве по умолчанию. Вы можете производить повороты или переносы для
управления ее положением, но это весьма сложный процесс, которого почти всегда
можно избежать. </p>

<p class=text align=left style='text-align:left'><b>Дополнительно: </b>Пирамида
не обязана быть симметричной и ее центральная ось не обязательно должна
совпадать с осью <i>z</i>. Например, вы можете использовать <b>glFrustum()</b>
для создания такого изображения, как если бы вы смотрели через прямоугольное
окно, причем это окно находится выше и правее вас. Фотографы используют этот
прием для создания ложной перспективы. Вы можете использовать его, чтобы
аппаратно визуализировать изображения с разрешением значительно выше обычного
(например, для вывода на принтер). Предположим, вам требуется изображение с
разрешением вдвое большим разрешения вашего экрана. Нарисуйте изображение 4
раза, каждый раз используя пирамидальный объем видимости для покрытия всего
экрана одной четвертью изображения. После того, как каждая четверть будет
выведена на экран, вы можете считать пиксели, собрав, таким образом, данные для
изображения высокого разрешения.</p>

<p class=text align=left style='text-align:left'>Рисунок 3-12. Объем видимости
перспективной проекции, заданный командой gluPerspective </p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1065" type="#_x0000_t75" alt="" style='width:225pt;height:208.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image041.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов3.mht!http://www.progz.ru/images/opengl/chapter3/3-12.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=300 height=278
src="OpenGL%20Red%20Book.files/image041.jpg" v:shapes="_x0000_i1065"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Хотя <b>glFrustum()</b>
концептуально ясна, ее использование не является интуитивно понятным. Вместо
нее вы можете попробовать использовать функцию <b>gluPerspective()</b> из
библиотеки утилит. Эта функция создает объем видимости той же формы, что и <b>glFrustum()</b>,
но вы задаете его параметры иным путем. Вместо указания углов ближней
отсекающей плоскости, вы задаете угол визуального охвата (<!--[if gte vml 1]><v:shape
 id="_x0000_i1066" type="#_x0000_t75" alt="" style='width:8.25pt;height:14.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image042.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов3.mht!http://www.progz.ru/images/opengl/chapter3/form3.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=11 height=19
src="OpenGL%20Red%20Book.files/image042.gif" v:shapes="_x0000_i1066"><![endif]>
или тета) в вертикальном направлении <i>y</i> и отношение ширины к высоте (<i>x/y</i>).
(Для квадратной части экрана отношение ширины к высоте равно <i>1.0</i>.) Этих
двух параметров достаточно для определения неусеченной пирамиды вдоль
направления обзора (рисунок 3-12). Вы также задаете дистанцию между точкой
наблюдения и ближней и дальней отсекающими плоскостями, таким образом, отсекая
пирамиду. </p>

<p class=text align=left style='text-align:left'>Заметьте, что <b>gluPerspective()</b>
ограничена созданием только пирамид симметричных вдоль линии обзора по <i>x</i>-
и <i>y</i>-осям, но обычно это именно то, что и требуется.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>gluPerspective</b>
  (GLdouble <i>fovy</i>, GLdouble <i>aspect</i>, GLdouble <i>near</i>, GLdouble
  <i>far</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Создает матрицу для пирамиды
симметричного перспективного вида и умножает на нее текущую матрицу. Параметр <i>fovy
</i>задает угол визуального охвата в плоскости <i>yz</i>, его значение должно
лежать в диапазоне <i>[0.0, 180.0]</i>. Параметр <i>aspect </i>– это отношение
ширины пирамиды к ее высоте. Параметры <i>near </i>и <i>far</i> представляют
дистанции от точки наблюдения до ближней и дальней плоскостей отсечения вдоль
отрицательного направления оси <i>z</i>.</p>

<p class=text align=left style='text-align:left'>При использовании <b>gluPerspective()</b>
вам необходимо выбрать подходящее значение для угла визуального охвата, иначе
изображение будет выглядеть непропорциональным. Для получения наилучшего
результата, заметьте, на каком расстоянии ваш глаз находится от монитора обычно
и насколько велико окно, затем вычислите угол, на который распространяется окно
в вашем поле зрения при данных дистанции и размере. Скорее всего, эта величина
будет меньше, чем вы ожидали. Другой способ задуматься об этом – помнить, что
94-ех градусный охват с 35-миллиметровой камерой требует 20-миллиметровых линз,
которые считаются весьма широкоугольными.</p>

<p class=text align=left style='text-align:left'>В данном разделе встречались
упоминания о миллиметрах и дюймах – имеют ли они значение в OpenGL. Ответ в
одно слово – нет. Проекционные и иные трансформации не имеют единиц измерения.
Если вы предпочитаете думать, что ближняя и дальняя плоскости отсечения
находятся на расстояниях 1.0 и <st1:metricconverter ProductID="20.0 километров">20.0
 километров</st1:metricconverter>, метров, дюймов, миль и так далее – это ваше
право. Единственное правило – используйте одинаковые единицы для всех измерений
в приложении, тогда изображение будет иметь нужные пропорции и масштаб.</p>

<h2>3.3.2&nbsp; Ортографическая проекция</h2>

<p class=text align=left style='text-align:left'>При использовании
ортографической проекции объем видимости представляет собой прямоугольный
параллепипед или коробку (рисунок 3-13). В отличие от перспективной проекции
размер объема видимости не изменяется от одного конца к другому, таким образом,
дальность от камеры не влияет на размер объектов в результирующем изображении.
Этот тип проекции используется для таких приложений, как системы
автоматизированного проектирования, где важны реальные размеры объектов
относительно друг друга и точность отображения углов между ними. </p>

<p class=text align=left style='text-align:left'>Рисунок 3-13. Объем видимости
ортографической проекции</p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1067" type="#_x0000_t75" alt="" style='width:225pt;height:165.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image043.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов3.mht!http://www.progz.ru/images/opengl/chapter3/3-13.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=300 height=221
src="OpenGL%20Red%20Book.files/image043.jpg" v:shapes="_x0000_i1067"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Команда <b>glOrtho()</b>
создает параллельный объем видимости ортографической проекции. Как и в случае <b>glFrustum()</b>
вы задаете углы ближней отсекающей плоскости и расстояния до ближней и дальней
плоскостей.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glOrtho
  </b>(GLdouble <i>left</i>, GLdouble <i>right</i>, GLdouble <i>bottom</i>,
  GLdouble <i>top</i>, GLdouble <i>near</i>, GLdouble <i>far</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Создает матрицу для
параллельного объема видимости ортографической проекции и умножает на нее
текущую матрицу. (<i>left, bottom, -near</i>) и (<i>right, top, -near</i>)
задают точки на ближней плоскости отсечения, которые будут спроецированы
соответственно на нижний левый и верхний правый углы порта просмотра. (<i>left,
bottom, -far</i>) и (<i>right, top, -far</i>) это точки на дальней плоскости
отсечения, которые будут спроецированы на те же углы порта просмотра. Значения
для <i>far</i> и <i>near </i>могут быть положительными, отрицательными или даже
нулевыми, однако они не должны быть равны между собой.</p>

<p class=text align=left style='text-align:left'>Если никакие другие
преобразования не используются, направление проецирования совпадает с осью <i>z</i>,
а направление обзора – с ее отрицательным направлением.</p>

<p class=text align=left style='text-align:left'>Для специального случая, когда
двумерное изображение проецируется на двумерный экран, используйте функцию <b>gluOrtho2D()</b>
из библиотеки утилит. Эта функция идентична команде <b>glOrtho()</b>, но она
предполагает, что все <i>z</i> – координаты объектов лежат в диапазоне от <i>1.0</i>
до <i>-1.0</i>. Если вы рисуете двумерные объекты с применением двумерных
версий вершинных команд, все их <i>z</i> – координаты равны нулю, таким образом,
ни один из объектов не отсекается из-за своих <i>z</i> – координат. </p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>gluOrtho2D</b>
  (GLdouble <i>left</i>, GLdouble <i>right</i>, GLdouble <i>bottom</i>,
  GLdouble <i>top</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Создает матрицу для
проецирования двумерного изображения на экран и умножает на нее текущую
матрицу. Область отсечения представляет собой прямоугольник с нижним левым
углом в (<i>left, bottom</i>) и правым верхним углом в (<i>right, top</i>).</p>

<h2>3.3.3&nbsp; Отсечение по объему видимости</h2>

<p class=text align=left style='text-align:left'>После того, как вершины
объектов сцены преобразованы с помощью видовой и модельной матриц, любые
примитивы, лежащие вне объема видимости отсекаются. В качестве плоскостей
отсечения используются те шесть, которые задают стороны объема видимости. Вы
также можете задавать дополнительные плоскости отсечения и располагать их там,
где вы хотите. Имейте в виду также, что OpenGL реконструирует ребра отсекаемых
полигонов.</p>

<h2>3.4&nbsp; Подробнее о порядке преобразований</h2>

<p class=text align=left style='text-align:left'><b>Дополнительно:</b> Ранее
было отмечено, что все преобразования вершин в OpenGL (за исключением
преобразования порта просмотра) имеют матричную природу. В теории компьютерной
графики (и во многих приложениях) преобразования вершин производятся следующим
образом. Предположим, требуется повернуть вершину с однородными координатами (<i>x</i>,
<i>y</i>, <i>z</i>, <i>1</i>) на угол <!--[if gte vml 1]><v:shape id="_x0000_i1068"
 type="#_x0000_t75" alt="" style='width:10.5pt;height:15pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image044.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов3.mht!http://www.progz.ru/images/opengl/chapter3/form4.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=14 height=20
src="OpenGL%20Red%20Book.files/image044.gif" v:shapes="_x0000_i1068"><![endif]>&nbsp;вокруг
оси аппликат (оси <i>z</i>), причем центр поворота должен совпадать с началом
координат. Соответствующей матрицей поворота будет:</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1069" type="#_x0000_t75" alt="" style='width:172.5pt;height:82.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image045.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов3.mht!http://www.progz.ru/images/opengl/chapter3/form5.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=230 height=110
src="OpenGL%20Red%20Book.files/image045.gif" v:shapes="_x0000_i1069"><![endif]>.</p>

<p class=text align=left style='text-align:left'>Затем требуется ортогонально
спроецировать вершину вдоль оси <i>z </i>на плоскость <i>xy</i>. Матрица этого
преобразования имеет вид:</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1070" type="#_x0000_t75" alt="" style='width:117.75pt;height:84.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image046.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов3.mht!http://www.progz.ru/images/opengl/chapter3/form6.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=157 height=113
src="OpenGL%20Red%20Book.files/image046.gif" v:shapes="_x0000_i1070"><![endif]>.</p>

<p class=text align=left style='text-align:left'>Для выполнения двух указанных
преобразований необходимо, соблюдая их порядок, умножить вектор координат
вершины на матрицу <!--[if gte vml 1]><v:shape id="_x0000_i1071" type="#_x0000_t75"
 alt="" style='width:23.25pt;height:18.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image047.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов3.mht!http://www.progz.ru/images/opengl/chapter3/form8.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=31 height=25
src="OpenGL%20Red%20Book.files/image047.gif" v:shapes="_x0000_i1071"><![endif]>,
а затем результат умножить на матрицу <!--[if gte vml 1]><v:shape id="_x0000_i1072"
 type="#_x0000_t75" alt="" style='width:23.25pt;height:19.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image048.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов3.mht!http://www.progz.ru/images/opengl/chapter3/form7.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=31 height=26
src="OpenGL%20Red%20Book.files/image048.gif" v:shapes="_x0000_i1072"><![endif]>&nbsp;(альтернативно
можно умножить матрицу <!--[if gte vml 1]><v:shape id="_x0000_i1073" type="#_x0000_t75"
 alt="" style='width:23.25pt;height:18.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image047.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов3.mht!http://www.progz.ru/images/opengl/chapter3/form8.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=31 height=25
src="OpenGL%20Red%20Book.files/image047.gif" v:shapes="_x0000_i1073"><![endif]>&nbsp;на
, <!--[if gte vml 1]><v:shape id="_x0000_i1074" type="#_x0000_t75" alt=""
 style='width:23.25pt;height:19.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image048.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов3.mht!http://www.progz.ru/images/opengl/chapter3/form7.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=31 height=26
src="OpenGL%20Red%20Book.files/image048.gif" v:shapes="_x0000_i1074"><![endif]>а
затем умножить вектор координат на результат, но мы для простоты пойдем первым
путем). После первого перемножения имеем: </p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1075" type="#_x0000_t75" alt="" style='width:345.75pt;height:21pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image049.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов3.mht!http://www.progz.ru/images/opengl/chapter3/form9.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=461 height=28
src="OpenGL%20Red%20Book.files/image049.gif" v:shapes="_x0000_i1075"><![endif]>.</p>

<p class=text align=left style='text-align:left'>После второго перемножения
имеем (это очевидно, так как используемая матрица проекции лишь обнуляет <i>z </i>координату
вершины):</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1076" type="#_x0000_t75" alt="" style='width:226.5pt;height:17.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image050.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов3.mht!http://www.progz.ru/images/opengl/chapter3/form10.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=302 height=23
src="OpenGL%20Red%20Book.files/image050.gif" v:shapes="_x0000_i1076"><![endif]>.</p>

<p class=text align=left style='text-align:left'>Вершина, определяемая
результирующим вектором координат, является искомой.</p>

<p class=text align=left style='text-align:left'>Механизм расчета
преобразований идентичен тому, что используется в OpenGL с двумя важными
отличиями:</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l4 level1 lfo10;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>в вычислениях мы использовали прямой порядок
преобразований – OpenGLперемножила бы матрицы в обратном порядке (сначала
проекционную матрицу на матрицу поворота, затем результат – на вектор
координат) – с первого взгляда это не кажется логичным; </p>

<p class=text align=left style='margin-left:54.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l4 level1 lfo10;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>матрицы в OpenGL хранятся (и используются в
вычислениях) в формате по столбцам, а не по строкам. </p>

<p class=text align=left style='text-align:left'>Как вы увидите далее, эти два
отличия связаны между собой, но сначала зададимся вопросом: Почему они вообще
имеют место? В чем корни различия между теорией и практикой? </p>

<p class=text align=left style='text-align:left'>Для начала рассмотрим упрощенно
порядок наших действий при вычислениях:</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l5 level1 lfo11;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>1.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Запомнить координаты вершины или вершин, над
которыми будет производиться определенная группа преобразований. Перейти к шагу
2. </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l5 level1 lfo11;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>2.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Получить матрицу первого преобразования и
умножить на нее имеющиеся в памяти векторы координат вершин. Перейти к шагу 3. </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l5 level1 lfo11;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>3.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Получить матрицу второго преобразования и
умножить на нее результаты шага 2. Перейти к шагу 4... </p>

<p class=text align=left style='text-align:left'>Вспомним, что OpenGL в
обращении с геометрическими данными действует подобно конвейеру. При работе
конвейера по описанной схеме возникали бы следующие проблемы:</p>

<ul type=disc>
 <li class=MsoNormal style='color:black;mso-margin-top-alt:auto;mso-margin-bottom-alt:
     auto;mso-list:l14 level1 lfo12;tab-stops:list 36.0pt'><span
     style='font-size:10.0pt;font-family:Verdana'>Конвейер OpenGL должен был бы
     останавливаться всякий раз, когда в него поступила группа вершин, к
     которым нужно применить определенную группу преобразований. Он простаивал
     бы до тех пор, пока не поступило бы последнее преобразование группы и
     сигнал о том, что оно действительно последнее – только после этого можно
     было бы начать вычисления. <o:p></o:p></span></li>
 <li class=MsoNormal style='color:black;mso-margin-top-alt:auto;mso-margin-bottom-alt:
     auto;mso-list:l14 level1 lfo12;tab-stops:list 36.0pt'><span
     style='font-size:10.0pt;font-family:Verdana'>С простоем связана еще одна
     проблема – все вершины одной группы необходимо было бы хранить в памяти до
     того, как поступит последняя матрица преобразования. Количество же вершин
     в приложении может быть сколь угодно велико (в большинстве приложений
     количество вершин на порядок больше количества преобразований), и, как
     следствие, для их хранения во время простоя потребовался бы сколь угодно
     большой объем памяти. <o:p></o:p></span></li>
 <li class=MsoNormal style='color:black;mso-margin-top-alt:auto;mso-margin-bottom-alt:
     auto;mso-list:l14 level1 lfo12;tab-stops:list 36.0pt'><span
     style='font-size:10.0pt;font-family:Verdana'>Предположим, что к вершинам
     первого четырехугольника требуется применить поворот и перспективное
     проецирование, а к вершинам второго – перенос и то же самое перспективное
     проецирование. При работе по описанной схеме мы должны были бы передать на
     конвейер матрицу проецирования два раза и два раза выполнить полный
     пересчет координат вершин с двумя перемножениями, поскольку вершины двух
     четырехугольников будут находиться в разных группах. <o:p></o:p></span></li>
</ul>

<p class=text align=left style='text-align:left'>Все эти недостатки вели бы к
неэффективности в работе конвейера (если, конечно, его можно было бы назвать
конвейером вообще). Вследствие этого конвейер OpenGL функционирует по-другому. </p>

<p class=text align=left style='text-align:left'>Преобразования задаются до
поступления координат вершин. Матрица первого преобразования становится
текущей. При поступлении матрицы второго преобразования текущая матрица
умножается на нее, и результат становится новой текущей матрицей. Количество
поступающих матриц преобразований в этом случае может быть сколь угодно велико,
но OpenGLхранит только одну – текущую (или точнее две текущие, поскольку
проекционные и видовые/модельные преобразования хранятся в разных матрицах).
Координаты же вершин могут поступать в любой момент между двумя командами
преобразования, и для их трансформации будет использована только одна текущая
матрица. Поскольку вычисления производятся по мере поступления вершин, конвейер
не простаивает.</p>

<p class=text align=left style='text-align:left'>Теперь обратимся к вопросу о
том, почему проекционные и видовые/модельные преобразования хранятся в OpenGLв
двух разных матрицах и не комбинируются заранее. Следуя схеме вычислений,
описанной в начале этого раздела, матрица проекции должна быть последней в
цепочке матриц преобразований, соответствующих группе вершин. Рассмотрим, как
должна была бы выглядеть типичная программа:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>Задать модельное преобразование
  1<br>
  Задать матрицу проекции<br>
  Задать группу вершин 1<br>
  <br>
  Установить текущую матрицу в единичную<br>
  Задать модельное преобразование 2<br>
  Задать модельное преобразование 3<br>
  Задать матрицу проекции<br>
  Задать группу вершин 2<br>
  &nbsp;<br>
  ...<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Иными словами если бы
проекционная матрица в OpenGL не хранилась отдельно, ее нужно было бы
поставлять на конвейер каждый раз до передачи туда группы вершин, а это
неэффективно, так как матрица проекции, как правило, была бы одной и той же.</p>

<p class=text align=left style='text-align:left'>Кроме того, хранение и
упрежденное комбинирование матрицы проекции с матрицами модельных или видовых
преобразований сделало бы невозможным само накопление модельных преобразований.
Рассмотрим следующий фрагмент:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>Перейти к позиции дома<br>
  Нарисовать дом<br>
  Перейти к позиции окна относительно дома<br>
  Нарисовать окно <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Запись является достаточно
логичной: задаем матрицу переноса к точке, где надо нарисовать дом, рисуем его,
еще одним переносом смещаемся относительно него в позицию окна (то есть
перемножаем матрицу первого переноса на матрицу второго), рисуем окно. Есть, однако,
одна проблема: чтобы отобразить вершины дома мы должны не только перенести их,
но и спроецировать, то есть на момент второго переноса текущая матрица будет
испорчена матрицей проекции и двойной комбинированный перенос не получится. От
этой беды, кстати, не спасает и хранение проекционной матрицы отдельно от
видовой.</p>

<p class=text align=left style='text-align:left'>В OpenGLпроблема решается за
счет того, что матрицы множатся в обратном порядке. Для того, чтобы результат
был верен требуется обеспечить транзитивность произведения матриц (которой на
самом деле не существует) – именно поэтому матрицы в OpenGL хранятся по
столбцам. Рассмотрим, как в OpenGL производится расчет координат вершины из
примера в начале раздела.</p>

<p class=text align=left style='text-align:left'>Первой задается матрица
проекции, хранимая по столбцам (в данном случае она идентична хранимой по
строкам): </p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1077" type="#_x0000_t75" alt="" style='width:116.25pt;height:85.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image051.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов3.mht!http://www.progz.ru/images/opengl/chapter3/form11.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=155 height=114
src="OpenGL%20Red%20Book.files/image051.gif" v:shapes="_x0000_i1077"><![endif]>.</p>

<p class=text align=left style='text-align:left'>Затем поступает команда
преобразования (поворота), формирующая матрицу поворота, хранимую по столбцам
(эта матрица становится текущей):</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1078" type="#_x0000_t75" alt="" style='width:164.25pt;height:84pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image052.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов3.mht!http://www.progz.ru/images/opengl/chapter3/form12.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=219 height=112
src="OpenGL%20Red%20Book.files/image052.gif" v:shapes="_x0000_i1078"><![endif]>.</p>

<p class=text align=left style='text-align:left'>Наконец, поступает столбец вершинных
координат, которые требуется преобразовать:</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1079" type="#_x0000_t75" alt="" style='width:326.25pt;height:86.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image053.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов3.mht!http://www.progz.ru/images/opengl/chapter3/form13.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=435 height=115
src="OpenGL%20Red%20Book.files/image053.gif" v:shapes="_x0000_i1079"><![endif]>.</p>

<p class=text align=left style='text-align:left'>Сравните результат с
приведенным в начале раздела, чтобы убедиться в его правильности.</p>

<p class=text align=left style='text-align:left'>Резюмируем все вышесказанное: </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l17 level1 lfo13;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Текущая видовая и текущая проекционная матрицы
хранятся в OpenGL отдельно, причем каждая из них хранится по столбцам. </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l17 level1 lfo13;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Хранение по столбцам необходимо для обеспечения
видимой транзитивности произведения матриц, так как реально они перемножается в
порядке поступления (Проекционная матрица на видовую матрицу, их произведение –
на последовательно поступающие матрицы модельных преобразований и, в итоге,
результат – на вектор координат вершины). </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l17 level1 lfo13;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Все это сделано из соображений эффективности, а
также для обеспечения возможности комбинирования модельных преобразований,
использования дисплейных списков (списков отображения) и так далее.
Разработчики стандарта OpenGL действительно хорошо поработали! </p>

<h2>3.5&nbsp; Трансформация порта просмотра</h2>

<p class=text align=left style='text-align:left'>Вспомните аналогию с камерой –
вы знаете, что трансформация порта просмотра это тот этап, на котором
выбирается размер результирующей фотографии. Поскольку мы работаем с
компьютерной графикой, порт просмотра представляет собой прямоугольную область
окна, где рисуется изображение. На рисунке 3-14 изображен порт просмотра,
занимающий большую часть экрана. Порт просмотра измеряется в оконных
координатах, которые отражают позиции пикселей на экране относительно нижнего
левого угла окна. Имейте в виду, что к текущему моменту все вершины уже
преобразованы с помощью видовой и проекционной матриц, и те из них, которые не
попали в объем видимости, были отсечены.</p>

<p class=text align=left style='text-align:left'>Рисунок 3-14. Прямоугольник
порта просмотра</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1080" type="#_x0000_t75" alt="" style='width:450pt;height:210pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image054.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов3.mht!http://www.progz.ru/images/opengl/chapter3/3-14.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=600 height=280
src="OpenGL%20Red%20Book.files/image054.jpg" v:shapes="_x0000_i1080"><![endif]></p>

<h2>3.5.1&nbsp; Задаем порт просмотра</h2>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glViewport</b>
  (GLint <i>x</i>, GLint <i>y</i>, GLint <i>width</i>, GLint <i>height</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Задает прямоугольник пикселей
в окне, в который будет перенесено финальное изображение. Параметры (<i>x</i>,<i>y</i>)
задают нижний левый угол порта просмотра, а параметры <i>width</i>и <i>height</i>–
размер прямоугольника порта просмотра. По умолчанию левый нижний угол порта
просмотра находится в левом нижнем углу окна, а его размер совпадает с
размерами окна.</p>

<p class=text align=left style='text-align:left'>Отношение ширины порта
просмотра к его высоте обычно должно быть таким же, как и соответствующее
отношение объема видимости используемой проекции. Если эти два отношения не
совпадают, спроецированное изображение при отображении в порте просмотра будет
искажено, как показано на рисунке 3-15. Заметьте, что изменение размеров окна
не влияет на порт просмотра. В своем приложении вы должны отслеживать события
изменения размеров окна и изменять порт просмотра соответствующим образом.</p>

<p class=text align=left style='text-align:left'>Рисунок 3-15. Отображение
объема видимости в порт просмотра</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1081" type="#_x0000_t75" alt="" style='width:450pt;height:384.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image055.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов3.mht!http://www.progz.ru/images/opengl/chapter3/3-15.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=600 height=513
src="OpenGL%20Red%20Book.files/image055.jpg" v:shapes="_x0000_i1081"><![endif]></p>

<p class=text align=left style='text-align:left'>Левая часть рисунка 3-15
демонстрирует проекцию, отображающую квадратное изображение в квадратный порт
просмотра. Для этого необходимо использовать последовательность команд подобную
этой:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>gluPerspective(fovy,
  1.0, near, far);<br>
  glViewport(0,0,400,400); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Однако, в правой части того же
рисунка размеры и форма окна и порта просмотра были изменены, но проекция
осталась той же. В результате изображение выглядит сжатым по оси <i>y</i>:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>gluPerspective(fovy,
  1.0, near, far);<br>
  glViewport(0,0,400,200); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Во избежание искажений измените
отношение ширины проекции к ее высоте, чтобы оно совпадало с аналогичным
отношением порта просмотра:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>gluPerspective(fovy,
  2.0, near, far);<br>
  glViewport(0,0,400,200); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=warning>Замечание: В каждый момент времени вы можете рисовать только в
одном порте просмотра. Однако вы можете задать один порт просмотра (например, в
правой половине окна), нарисовать в нем некоторую сцену, затем задать второй
порт просмотра (в левой половине окна) и нарисовать там ту же или другую сцену.
Таким образом, вы получите две сцены в двух портах просмотра, но при этом в
одном и том же окне.</p>

<h2>3.5.2&nbsp; Преобразованная глубина</h2>

<p class=text align=left style='text-align:left'>Глубинная координата (<i>z</i>)
кодируется во время трансформации порта просмотра (и позже сохраняется в буфере
глубины). С использованием команды <b>glDepthRange()</b> вы можете масштабировать
<i>z</i> – величины для того, чтобы они лежали в определенном диапазоне. В
отличие от <i>x</i> – и <i>y</i> – координат окна, оконные <i>z</i>– координаты
всегда трактуются OpenGLкак лежащие в диапазоне от <i>0.0</i> до <i>1.0</i>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glDepthRange</b>
  (GLclampd <i>near</i>, GLclampd <i>far</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Определяет кодирование,
которое производится для <i>z</i>– координат во время трансформации порта
просмотра. Параметры <i>near </i>и <i>far</i>представляют собой минимальную и
максимальную границы величин, которые могут быть сохранены в буфере глубины. По
умолчанию эти границы равны <i>0.0</i> и <i>1.0</i> соответственно, что
подходит для большинства приложений. Параметры <i>near </i>и <i>far </i>должны
лежать в диапазоне [<i>0.0</i>, <i>1.0</i>].</p>

<p class=text align=left style='text-align:left'>При перспективном
проецировании преобразованная координата глубины (так же как <i>x </i>- и <i>y </i>-
координаты) подвергается перспективному делению на координату <i>w</i>. С
увеличением дистанции между ближней отсекающей плоскостью и <i>z</i> –
координатой, ее местоположение становится все менее и менее точным (рисунок
3-16). </p>

<p class=text align=left style='text-align:left'>Рисунок 3-16. Перспективное
проецирование и преобразованная координата глубины</p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1082" type="#_x0000_t75" alt="" style='width:225pt;height:134.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image056.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов3.mht!http://www.progz.ru/images/opengl/chapter3/3-16.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=300 height=179
src="OpenGL%20Red%20Book.files/image056.jpg" v:shapes="_x0000_i1082"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Таким образом, перспективное
деление влияет на точность операций базирующихся на преобразованных координатах
глубины, особенно на операции с буфером глубины, который используется для
удаления невидимых поверхностей. </p>

<h2>3.6&nbsp; Наиболее частые проблемы, связанные с трансформациями</h2>

<p class=text align=left style='text-align:left'>Достаточно легко нацелить
реальную камеру в правильном направлении, однако при работе с компьютерной
графикой, вы должны задавать позицию и направление с помощью координат и углов.
Как мы все знаем, получить хорошо-известный эффект черного экрана при этом
слишком легко. Можно сделать множество ошибок, в результате которых на экране
не будет нарисовано абсолютно ничего (например, неправильно навести камеру или
попытаться получить изображение сцены, находящейся за наблюдателем).</p>

<p class=text align=left style='text-align:left'>Если вы обнаружили, что
приложили нечеловеческие усилия только для того, чтобы получить черный экран,
попробуйте выполнить следующие диагностические шаги.</p>

<ol start=1 type=1>
 <li class=MsoNormal style='color:black;mso-margin-top-alt:auto;mso-margin-bottom-alt:
     auto;mso-list:l49 level1 lfo14;tab-stops:list 36.0pt'><span
     style='font-size:10.0pt;font-family:Verdana'>Проверьте очевидные факты.
     Убедитесь, что монитор включен. Убедитесь, что вы рисуете свои объекты
     цветом отличным от того, которым вы очищаете порт просмотра. Убедитесь,
     что любые используемые вами механизмы (такие как освещение,
     текстурирование, альфа наложение или антиалиасинг) включены или выключены
     (в зависимости от того, что именно вам требуется). <o:p></o:p></span></li>
 <li class=MsoNormal style='color:black;mso-margin-top-alt:auto;mso-margin-bottom-alt:
     auto;mso-list:l49 level1 lfo14;tab-stops:list 36.0pt'><span
     style='font-size:10.0pt;font-family:Verdana'>Помните, что при
     использовании проекционных команд координаты ближней и дальней отсекающих
     плоскостей представляют собой дистанцию от точки наблюдения и направление
     обзора (по умолчанию) совпадает с отрицательным направлением оси <i>z</i>.
     Таким образом, если ближняя плоскость находится на расстоянии <i>1.0</i>,
     а дальняя – на расстоянии <i>3.0</i>, <i>z</i> – координаты объектов
     должны лежать в диапазоне <i>[-1.0, -3.0]</i> для того, чтобы объекты были
     видимыми. Если вы хотите убедиться, что не отсекли все объекты сцены,
     временно установите параметры nearи farпроекционных команд в абсолютно
     абсурдные значения вроде <i>0.001</i> и <i>1000000.0</i> соответственно.
     Это полностью сведет на нет действие таких механизмов, как буфер глубины и
     туман, но зато позволит обнаружить ошибочно отсекаемые объекты. <o:p></o:p></span></li>
 <li class=MsoNormal style='color:black;mso-margin-top-alt:auto;mso-margin-bottom-alt:
     auto;mso-list:l49 level1 lfo14;tab-stops:list 36.0pt'><span
     style='font-size:10.0pt;font-family:Verdana'>Определите, где находится
     точка наблюдения, в каком направлении вы смотрите, и где находятся
     объекты. Возможно, в этом случае вам поможет построение реальной
     трехмерной модели (например, с помощью рук). <o:p></o:p></span></li>
 <li class=MsoNormal style='color:black;mso-margin-top-alt:auto;mso-margin-bottom-alt:
     auto;mso-list:l49 level1 lfo14;tab-stops:list 36.0pt'><span
     style='font-size:10.0pt;font-family:Verdana'>Убедитесь в том, что вы
     знаете, вокруг какой точки вы производите вращение объектов. Нет ничего
     страшного во вращении вокруг любой точки, если только вам не требуется
     вращение именно вокруг начала координат. <o:p></o:p></span></li>
 <li class=MsoNormal style='color:black;mso-margin-top-alt:auto;mso-margin-bottom-alt:
     auto;mso-list:l49 level1 lfo14;tab-stops:list 36.0pt'><span
     style='font-size:10.0pt;font-family:Verdana'>Проверьте ваш прицел.
     Используйте <b>gluLookAt()</b>, чтобы навести объем видимости на ваши
     объекты. Или нарисуйте объекты вблизи начала координат, а затем
     используйте <b>glTranslate*()</b> в качестве видовой трансформации, чтобы
     отодвинуть камеру от модели несколько дальше по оси <i>z</i> и объекты
     попадали в объем видимости. После того, как вам удалось сделать объекты
     видимыми, попробуйте инкрементально изменять объем видимости до получения
     именно тех результатов, каких вы хотите. <o:p></o:p></span></li>
 <li class=MsoNormal style='color:black;mso-margin-top-alt:auto;mso-margin-bottom-alt:
     auto;mso-list:l49 level1 lfo14;tab-stops:list 36.0pt'><span
     style='font-size:10.0pt;font-family:Verdana'>При использовании
     перспективных преобразований убедитесь, что ближняя отсекающая плоскость
     находится не слишком близко к наблюдателю (камере), так как это может
     сильно повлиять на точность глубинной буферизации. <o:p></o:p></span></li>
</ol>

<p class=text align=left style='text-align:left'>Даже после того, как вы навели
камеру в правильном направлении и увидели ваши объекты, они могут выглядеть
слишком маленькими или слишком большими. Если вы используете <b>gluPerspective()</b>,
возможно вам придется изменить угол, задающий визуальный охват, изменив
значение первого параметра этой команды. С помощью тригонометрии вы можете
вычислить нужный вам угол, опираясь на размер объекта и его дистанцию от точки
наблюдения: тангенс половины нужного угла равен отношению половины размера
объекта к его дистанции от точки наблюдения (рисунок 3-17). Таким образом, вы
можете использовать функцию вычисления арктангенса для получения значения
половины нужного вам угла. В примере 3-3 предполагается наличие функции <b>atan2()</b>,
которая вычисляет арктангенс угла между противолежащим и прилежащим катетами
прямоугольного треугольника, длины которых передаются в качестве параметров.
Затем результат, полученный в радианах, преобразуется в градусы. </p>

<p class=text align=left style='text-align:left'>Рисунок&nbsp; 3-17.
Использование тригонометрии для вычисления угла визуального охвата</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1083" type="#_x0000_t75" alt="" style='width:232.5pt;height:157.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image057.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов3.mht!http://www.progz.ru/images/opengl/chapter3/3-17.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=310 height=210
src="OpenGL%20Red%20Book.files/image057.jpg" v:shapes="_x0000_i1083"><![endif]></p>

<p class=text align=left style='text-align:left'>Пример 3-3. Вычисление угла
визуального охвата</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>#definePI
  3.1415926535&gt;<br>
  <br>
  double calculateAngle(double size, double distance)<br>
  {<br>
  &nbsp;&nbsp; double radtheta, degtheta;<br>
  &nbsp;&nbsp; radtheta = 2.0 * atan2(size/2.0,distance);<br>
  &nbsp;&nbsp; degtheta=(180.0*radtheta)/PI;<br>
  &nbsp;&nbsp; return degtheta;<br>
  } <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Конечно, в большинстве случаев
вы не знаете точного размера объекта, может быть выяснена только дистанция
между точкой наблюдения и одной из точек вашей сцены. Чтобы получить размер
объекта с достаточно точным приближением, постройте прямоугольный параллепипед,
содержащий в себе всю вашу сцену. Для этого определите максимальные и
минимальные значения <i>x -</i>, <i>y -</i> и <i>z –</i> координат всех
объектов вашей сцены. Затем вычислите радиус сферы, описывающей получившийся
параллепипед. Наконец, используйте центр сферы в качестве дистанции до объекта
и радиус этой сферы в качестве половины размера объекта. </p>

<p class=text align=left style='text-align:left'>Предположим, например, что все
координаты вашего объекта (или объектов) удовлетворяют следующим уравнениям: <!--[if gte vml 1]><v:shape
 id="_x0000_i1084" type="#_x0000_t75" alt="" style='width:57.75pt;height:12pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image058.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов3.mht!http://www.progz.ru/images/opengl/chapter3/form14.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=77 height=16
src="OpenGL%20Red%20Book.files/image058.gif" v:shapes="_x0000_i1084"><![endif]>,
<!--[if gte vml 1]><v:shape id="_x0000_i1085" type="#_x0000_t75" alt=""
 style='width:49.5pt;height:11.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image059.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов3.mht!http://www.progz.ru/images/opengl/chapter3/form15.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=66 height=15
src="OpenGL%20Red%20Book.files/image059.gif" v:shapes="_x0000_i1085"><![endif]>&nbsp;и
<!--[if gte vml 1]><v:shape id="_x0000_i1086" type="#_x0000_t75" alt=""
 style='width:57.75pt;height:10.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image060.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов3.mht!http://www.progz.ru/images/opengl/chapter3/form16.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=77 height=14
src="OpenGL%20Red%20Book.files/image060.gif" v:shapes="_x0000_i1086"><![endif]>.
Тогда центр параллепипеда будет находиться в точке (1, 6, 0), а радиус
описывающей его сферы будет равен расстоянию из центра параллепипеда до любого
из его углов, скажем до (3, 7, 5), а именно он будет равен: </p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1087" type="#_x0000_t75" alt="" style='width:253.5pt;height:24.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image061.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов3.mht!http://www.progz.ru/images/opengl/chapter3/form17.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=338 height=33
src="OpenGL%20Red%20Book.files/image061.gif" v:shapes="_x0000_i1087"><![endif]>.
</p>

<p class=text align=left style='text-align:left'>Если точка наблюдения имеет
координаты (8, 9, 10), дистанция между ней и центром будет равна:</p>

<p class=text align=left style='text-align:left'>&nbsp;<!--[if gte vml 1]><v:shape
 id="_x0000_i1088" type="#_x0000_t75" alt="" style='width:262.5pt;height:24pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image062.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов3.mht!http://www.progz.ru/images/opengl/chapter3/form18.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=350 height=32
src="OpenGL%20Red%20Book.files/image062.gif" v:shapes="_x0000_i1088"><![endif]>.</p>

<p class=text align=left style='text-align:left'>Тангенс половины нужного угла
равен отношению 5.477 к 12.570, которое составляет 0.4357, то есть половина
нужного угла равна 23.54 градусам.</p>

<p class=text align=left style='text-align:left'>Угол визуального охвата влияет
на оптимальное положение точки наблюдения. Это следует помнить, если вы
пытаетесь создать реалистичное изображение. Например, если ваши расчеты
показывают, что вам требуется угол визуального охвата равный 179 градусам,
точка наблюдения должна находиться на расстоянии доли дюйма от экрана для
достижения реализма. Если вычисленный вами визуальный охват слишком велик,
возможно, потребуется передвинуть точку наблюдения дальше от объекта. </p>

<h2>3.7&nbsp; Манипулирование матричными стеками</h2>

<p class=text align=left style='text-align:left'>Видовая и проекционная
матрицы, которые вы создавали, загружали и перемножали были на самом деле лишь
вершиной айсберга. На самом деле каждая из этих матриц является верхним
элементом матричного стека (рисунок 3-18).</p>

<p class=text align=left style='text-align:left'>Рисунок 3-18. Видовый и
проекционный матричные стеки </p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1089" type="#_x0000_t75" alt="" style='width:450pt;height:89.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image063.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов3.mht!http://www.progz.ru/images/opengl/chapter3/3-18.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=600 height=119
src="OpenGL%20Red%20Book.files/image063.jpg" v:shapes="_x0000_i1089"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Матричный стек полезен для
построения иерархических моделей, в которых сложные объекты конструируются при
помощи простых. Предположим, например, что вы рисуете автомобиль, у которого 4
колеса и каждое колесо прикреплено к автомобилю пятью болтами. У вас имеется
функция, рисующая колесо и функция, рисующая болт, так как все колеса и болты
выглядят одинаково. каждая из этих функций рисует колесо или болт в четко
определенном месте, скажем в начале координат, и с определенной ориентацией,
например, с центральной осью объекта, совпадающей с отрицательным направлением
оси z. Когда вы рисуете машину, включая колеса и болты, вы захотите вызвать
функцию, рисующую колесо 4 раза с применением различных трансформаций для
правильного позиционирования каждого колеса. При рисовании каждого колеса вы
захотите нарисовать болт пять раз, каждый раз перенося болт в нужное место
относительно колеса.</p>

<p class=text align=left style='text-align:left'>На секунду предположим, что
все, что вы хотите сделать – это нарисовать корпус машины и колеса. В этом
случае алгоритм процесса может быть описан следующим образом:</p>

<ul type=disc>
 <li class=MsoNormal style='color:black;mso-margin-top-alt:auto;mso-margin-bottom-alt:
     auto;mso-list:l18 level1 lfo15;tab-stops:list 36.0pt'><span
     style='font-size:10.0pt;font-family:Verdana'>Нарисовать корпус машины. <o:p></o:p></span></li>
 <li class=MsoNormal style='color:black;mso-margin-top-alt:auto;mso-margin-bottom-alt:
     auto;mso-list:l18 level1 lfo15;tab-stops:list 36.0pt'><span
     style='font-size:10.0pt;font-family:Verdana'>Запомнить, где мы находимся,
     и выполнить перенос к переднему левому колесу. <o:p></o:p></span></li>
 <li class=MsoNormal style='color:black;mso-margin-top-alt:auto;mso-margin-bottom-alt:
     auto;mso-list:l18 level1 lfo15;tab-stops:list 36.0pt'><span
     style='font-size:10.0pt;font-family:Verdana'>Нарисовать колесо и отбросить
     последний перенос, чтобы вернуться в начало координат относительно корпуса
     машины. <o:p></o:p></span></li>
 <li class=MsoNormal style='color:black;mso-margin-top-alt:auto;mso-margin-bottom-alt:
     auto;mso-list:l18 level1 lfo15;tab-stops:list 36.0pt'><span
     style='font-size:10.0pt;font-family:Verdana'>Запомнить, где мы находимся,
     и выполнить перенос к левому заднему колесу... <o:p></o:p></span></li>
</ul>

<p class=text align=left style='text-align:left'>Похожим образом для каждого
колеса, нам следует нарисовать его, запомнить, где мы, и последовательно
выполнять переносы к позиции каждого болта, отбрасывая преобразования после
того, как каждый болт нарисован.</p>

<p class=text align=left style='text-align:left'>Поскольку преобразования
сохраняются в матрицах, матричный стек предоставляет идеальный механизм для
подобного рода запоминаний, переносов и отбрасываний. Все ранее описанные
матричные операции (<b>glLoadMatrix()</b>, <b>glMultMatrix()</b>, <b>glLoadIdentity()</b>
и команды, создающие специфические матрицы) работают с текущей матрицей, то
есть с верхней матрицей стека. С помощью команд управления стеком вы можете
управлять тем, какая матрица находится на вершине стека: <b>glPushMatrix()</b>
копирует текущую матрицу и добавляет копию на вершину матричного стека, <b>glPopMatrix()</b>
уничтожает верхнюю матрицу в стеке (рисунок 3-19). (Помните, что текущей
матрицей всегда является матрица на вершине). Говоря проще, <b>glPushMatrix()</b>
означает «запомнить, где мы находимся», а <b>glPopMatrix()</b> – «вернуться
туда, где мы были».</p>

<p class=text align=left style='text-align:left'>Рисунок 3-19. Помещение в
матричный стек и извлечение из матричного стека </p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1090" type="#_x0000_t75" alt="" style='width:465pt;height:131.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image064.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов3.mht!http://www.progz.ru/images/opengl/chapter3/3-19.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=620 height=175
src="OpenGL%20Red%20Book.files/image064.jpg" v:shapes="_x0000_i1090"><![endif]><o:p></o:p></span></p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>glPushMatrix</b>
  (void);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Опускает все имеющиеся в
текущем стеке матрицы на один уровень. То, какой стек является текущим,
задается с помощью вызова <b>glMatrixMode()</b>. Верхняя матрица при этом
копируется, таким образом, ее содержимое продублировано в верхней и второй сверху
матрице стека. Если добавлено слишком много матриц, будет сгенерирована ошибка.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>glPopMatrix</b>
  (void);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Выкидывает верхнюю матрицу из
стека, тем самым, уничтожая ее содержимое. Верхней (и, как следствие, текущей)
становится матрица, которая занимала второе сверху место в стеке. Текущий стек
задается командой <b>glMatrixMode()</b>. Если стек содержит только одну
матрицу, вызов <b>glPopMatrix()</b> сгенерирует ошибку.</p>

<p class=text align=left style='text-align:left'>Пример 3-4 рисует автомобиль в
предположении о наличие функций, рисующих корпус машины, колесо и болт.</p>

<p class=text align=left style='text-align:left'>Пример 3-4. Помещение и
извлечение матриц</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>нарисовать_колесо_и_болты()<br>
  {<br>
  &nbsp;&nbsp; long i;<br>
  <br>
  &nbsp;&nbsp; нарисовать_колесо();<br>
  &nbsp;&nbsp; for(i=0;i&lt;5;i++)<br>
  &nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glPushMatrix();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  glRotatef(72.0*i,0.0,0.0,1.0);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glTranslatef(3.0,0.0,0.0);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; нарисовать_болт();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glPopMatrix();<br>
  &nbsp;&nbsp; }<br>
  }<br>
  <br>
  нарисовать_корпус_колеса_и_болты()<br>
  {<br>
  &nbsp;&nbsp; нарисовать_корпус_машины();<br>
  &nbsp;&nbsp; glPushMatrix();<br>
  <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //передвинуться к позиции первого колеса<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glTranslatef(40,0,30);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; нарисовать_колесо_и_болты();<br>
  &nbsp;&nbsp; glPopMatrix();<br>
  <br>
  &nbsp;&nbsp; glPushMatrix();<br>
  <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //передвинуться к позиции второго колеса<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glTranslatef(40,0,-30);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; нарисовать_колесо_и_болты();<br>
  &nbsp;&nbsp; glPopMatrix();<br>
  <br>
  &nbsp;&nbsp; //похожим образом нарисовать еще два колеса<br>
  &nbsp;&nbsp; ...<br>
  } <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>В данном коде предполагается,
что ось колеса и болта совпадает с осью z, что болты располагаются на колесе
каждые 72 градуса и находятся на расстоянии 3 единицы от центра колеса. Также
предполагается, что передние колеса находятся на 40 единиц впереди и на 30
влево и вправо от центра корпуса.</p>

<p class=text align=left style='text-align:left'>Стек более эффективен, чем
индивидуальная матрица, особенно в том случае, если он реализован аппаратно.
Когда вы проталкиваете матрицу в стек, вам не нужно предварительно извлекать из
нее данные и запоминать их в главном процессе, кроме того, аппаратура может
обладать способностью одновременно копировать несколько элементов матрицы.
Иногда стоит держать&nbsp; на дне стека единичную матрицу во избежание
многократных вызовов <b>glLoadIdentity()</b>.</p>

<h2>3.7.1&nbsp; Стек видовых матриц</h2>

<p class=text align=left style='text-align:left'>Как вы видели раньше, видовая
матрица содержит кумулятивное произведение от перемножения матриц,
представляющих отдельные видовые и модельные преобразования. Каждая видовая или
модельная трансформация создает новую матрицу, на которую умножается текущая
видовая матрица. Результат, который становится новой текущей видовой матрицей,
представляет композитное преобразование. Стек видовых матриц может содержать
как минимум 32 матрицы размерностью 4x4. В самом начале верхней (и
единственной) матрицей является единичная. Некоторые реализации OpenGLмогут
поддерживать больше чем 32 матрицы в видовом стеке. Чтобы выяснить максимально
допустимое число матриц, используйте команду <b>glGetIntegerv</b>
(GL_MAX_MODELVIEW_STACK_DEPTH, GLint *<i>params</i>).</p>

<h2>3.7.2&nbsp; Стек проекционных матриц</h2>

<p class=text align=left style='text-align:left'>Матрица проекции содержит
матрицу для проекционного преобразования, описывающую объем видимости. В общем
случае вам не нужно объединять проекционные матрицы, поэтому вы вызываете <b>glLoadIdentity()</b>
перед выполнением проекционного преобразования. По этой же причине стек
проекционных матриц должен быть всего два уровня в глубину. Некоторые
реализации OpenGLмогут позволять хранить больше двух матриц размерностью 4x4.
Для выяснения максимальной глубины проекционного стека вызовите<b>
glGetIntegerv</b> (GL_MAX_PROJECTION_STACK_DEPTH, GLint *<i>params</i>).</p>

<p class=text align=left style='text-align:left'>Одним из применений второго
уровня стека может быть приложение, которому наряду со своим основным окном,
содержащим трехмерную модель, требуется отображать окно помощи с текстом внутри
него. Поскольку текст наиболее легко позиционируется с применением
ортографической проекции, вы можете временно переключиться на ортографическую
проекцию, отобразить помощь и затем вернуться к предыдущей проекции:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>glMatrixMode(GL_PROJECTION);<br>
  glPushMatrix();//сохранить текущую проекцию<br>
  &nbsp;&nbsp; glLoadIdentity();<br>
  &nbsp;&nbsp; glOrtho(...);//настроиться на отображение текста<br>
  &nbsp;&nbsp; отобразить_помощь();<br>
  glPopMatrix(); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Обратите внимание на то, что,
вероятно, вам потребуется также изменить должным образом и видовую матрицу.</p>

<p class=text align=left style='text-align:left'><b>Дополнительно:</b> Если вы
достаточно понимаете в математике, вы можете создавать свои собственные проекционные
матрицы, выполняющие более сложные проекционные преобразования. Например,
OpenGL и ее библиотека утилит не содержит встроенных механизмов для выполнения
двухточечной перспективной проекции. Тем не менее, если вы хотите эмулировать,
скажем, рисунки в виде набросков, вам может понадобиться такая проекционная
матрица.</p>

<h2><span style='font-size:10.0pt'>3.8&nbsp; Дополнительные плоскости отсечения<o:p></o:p></span></h2>

<p class=text align=left style='text-align:left'>Помимо шести плоскостей
отсечения объема видимости (девой, правой, верхней, нижней, ближней и дальней)
вы можете задавать до шести дополнительных плоскостей отсечения, дополнительно
ограничивающих объем видимости. Эта техника удобна, например, для отображения
«отрезанной» части некоторого объекта.</p>

<p class=text align=left style='text-align:left'>Каждая плоскость определяется
коэффициентами своего уравнения: A<i>x</i>+B<i>y</i>+C<i>z</i>+D=0. Отсекающие
плоскости автоматически трансформируются в соответствии с модельными и видовыми
преобразованиями. Видимым усеченным объемом становится пересечение объема
видимости и всех <i>полупространств</i> заданных дополнительными плоскостями
отсечения. Помните, что OpenGL автоматически реконструирует ребра отсеченных
полигонов.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>&nbsp;void
  <b>glClipPlane</b> (GLenum <i>plane</i>, const GLdouble *<i>equation</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Задает плоскость отсечения.
Аргумент <i>equation </i>указывает на 4 коэффициента уравнения плоскости, A<i>x</i>+B<i>y</i>+C<i>z</i>+D=0.
Все точки с видовыми координатами <!--[if gte vml 1]><v:shape id="_x0000_i1091"
 type="#_x0000_t75" alt="" style='width:81.75pt;height:15.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image065.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов3.mht!http://www.progz.ru/images/opengl/chapter3/form19.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=109 height=21
src="OpenGL%20Red%20Book.files/image065.gif" v:shapes="_x0000_i1091"><![endif]>,
удовлетворяющими условию:</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1092" type="#_x0000_t75" alt="" style='width:230.25pt;height:23.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image066.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов3.mht!http://www.progz.ru/images/opengl/chapter3/form20.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=307 height=31
src="OpenGL%20Red%20Book.files/image066.gif" v:shapes="_x0000_i1092"><![endif]>,
</p>

<p class=text align=left style='text-align:left'>где <b>M</b> – видовая матрица
являющаяся текущей на момент вызова <b>glClipPlane()</b> лежат в
полупространстве определенном плоскостью. Все точки вне этого полупространства
отсекаются. Аргумент <i>plane</i>должен быть равен GL_CLIP_PLANE<i>i</i>, где <i>i</i>–
целое, показывающее, какую из имеющихся плоскостей мы определяем. <i>i</i>должно
лежать в диапазоне от 0 до числа на единицу меньшего, чем максимально
допустимое количество дополнительных плоскостей отсечения.</p>

<p class=text align=left style='text-align:left'>Каждая из дополнительных
плоскостей отсечения, кроме того, должна быть включена или выключена
(соответственно) командами:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>glEnable(GL_CLIP_PLANE<i>i</i>);
  <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>&nbsp;или </p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>glDisable(GL_CLIP_PLANE<i>i</i>);
  <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Все реализации OpenGL должны
поддерживать как минимум 6 дополнительных плоскостей отсечения, хотя некоторые
могут позволять и больше. Вы можете выяснить максимально допустимое количество
дополнительных плоскостей отсечения в вашей реализации OpenGL, вызвав <b>glGetIntegerv()</b>
с аргументом GL_MAX_CLIP_PLANES.</p>

<p class=warning>Замечание: Отсечение, производимое как результат вызова <b>glClipPlane()</b>,
совершается в видовых, а не в усеченных координатах. Эта разница заметна в том
случае, если матрица проекции является вырожденной (то есть, реальной
проекционной матрицей, отображающей трехмерные координаты на двумерные).
Отсечение, производимое в видовых координатах, продолжает происходить в трех
измерениях, даже когда матрица проекции вырождена.</p>

<h2>3.8.1&nbsp; Пример кода с дополнительными плоскостями отсечения</h2>

<p class=text align=left style='text-align:left'>Пример 3-5 визуализирует
проволочную сферу с двумя отсекающими плоскостями, которые отрезают три
четверти этой сферы (рисунок 3-20).</p>

<p class=text align=left style='text-align:left'>Рисунок 3-20. Отсеченная
проволочная сфера </p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1093" type="#_x0000_t75" alt="" style='width:126.75pt;height:135.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image067.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов3.mht!http://www.progz.ru/images/opengl/chapter3/3-20.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=169 height=181
src="OpenGL%20Red%20Book.files/image067.jpg" v:shapes="_x0000_i1093"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Пример 3-5. Проволочная сфера
с двумя отсекающими плоскостями: файл clip.cpp</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>#include &lt;glut.h&gt;<br>
  <br>
  //Инициализация<br>
  void init(void)<br>
  {<br>
  &nbsp;&nbsp; glClearColor(0.0,0.0,0.0,0.0);<br>
  &nbsp;&nbsp; glShadeModel(GL_FLAT);<br>
  }<br>
  <br>
  //Изменение размеров окна<br>
  void reshape(int w, int h)<br>
  {<br>
  &nbsp;&nbsp; glViewport(0,0,(GLsizei) w, (GLsizei) h); <br>
  &nbsp;&nbsp; glMatrixMode(GL_PROJECTION);<br>
  &nbsp;&nbsp; glLoadIdentity();<br>
  &nbsp;&nbsp; gluPerspective(60.0,(GLfloat) w/(GLfloat) h,1.0,20.0);
  glMatrixMode(GL_MODELVIEW);<br>
  }<br>
  <br>
  //Отображение <br>
  void display(void)<br>
  {<br>
  &nbsp;&nbsp; GLdouble eqn[4]={0.0,1.0,0.0,0.0};<br>
  &nbsp;&nbsp; GLdouble eqn2[4]={1.0,0.0,0.0,0.0};<br>
  <br>
  &nbsp;&nbsp; glClear(GL_COLOR_BUFFER_BIT);<br>
  &nbsp;&nbsp; glColor3f(1.0,1.0,1.0);<br>
  &nbsp;&nbsp; glPushMatrix();<br>
  &nbsp;&nbsp; glTranslatef(0.0,0.0,-5.0);<br>
  <br>
  &nbsp;&nbsp; //Отсечь нижнюю половину (y&lt;0) <br>
  &nbsp;&nbsp; glClipPlane(GL_CLIP_PLANE0,eqn);<br>
  &nbsp;&nbsp; glEnable(GL_CLIP_PLANE0);<br>
  <br>
  &nbsp;&nbsp; //Отсечь левую половину (x&lt;0) <br>
  &nbsp;&nbsp; glClipPlane(GL_CLIP_PLANE1,eqn2);<br>
  &nbsp;&nbsp; glEnable(GL_CLIP_PLANE1);<br>
  &nbsp;&nbsp; glRotatef(90.0,1.0,0.0,0.0);<br>
  &nbsp;&nbsp; glutWireSphere(2.0,20,16);<br>
  &nbsp;&nbsp; glPopMatrix();<br>
  &nbsp;&nbsp; glFlush();<br>
  }<br>
  <br>
  int main(int argc, char **argv)<br>
  {<br>
  &nbsp;&nbsp; glutInit(&amp;argc,argv);<br>
  &nbsp;&nbsp; glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB); <br>
  &nbsp;&nbsp; glutInitWindowSize(500,500);<br>
  &nbsp;&nbsp; glutInitWindowPosition(100,100);<br>
  &nbsp;&nbsp; glutCreateWindow(&quot;Wireframe Sphere with Two Clipping
  Planes&quot;); <br>
  &nbsp;&nbsp; init();<br>
  &nbsp;&nbsp; glutDisplayFunc(display);<br>
  &nbsp;&nbsp; glutReshapeFunc(reshape);<br>
  &nbsp;&nbsp; glutMainLoop();<br>
  &nbsp;&nbsp; return 0;<br>
  } <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<h2>3.9&nbsp; Примеры комбинирования нескольких преобразований</h2>

<p class=text align=left style='text-align:left'>В этом разделе
демонстрируется, как комбинировать несколько преобразований для достижения
определенных результатов. Приводятся два примера: солнечная система, в которой
объекты должны вращаться относительно своих осей, а также по орбитам вокруг
друг-друга и рука робота, в которой присутствует несколько сочленений,
изменяющих координатную систему и двигающихся относительно друг-друга.</p>

<h2>3.9.1&nbsp; Строим солнечную систему</h2>

<p class=text align=left style='text-align:left'>Программа, описанная в данном
разделе, рисует упрощенную модель солнечной системы, состоящую из солнца и
одной планеты. Оба объекта рисуются в виде сфер. В ходе написания этой
программы потребуется команда <b>glRotate*()</b> для вращения планеты вокруг
солнца и вокруг своей оси. Также потребуется <b>glTranslate*()</b> для
перемещения планеты из начала координат на ее орбиту. Помните, что вы можете
задавать нужные размеры сфер, передавая соответствующие аргументы функции <b>glutWireSphere()</b>.</p>

<p class=text align=left style='text-align:left'>Чтобы нарисовать солнечную
системы, сначала требуется настроить проекцию и видовое преобразование. Для
данного примера были использованы <b>gluPerspective() </b>и <b>gluLookAt()</b>.</p>

<p class=text align=left style='text-align:left'>Рисование солнца достаточно
прямолинейно, поскольку оно должно находиться в начале координат фиксированной
координатной системы, то есть там, где ее помещает рисующая ее функция. Таким
образом, рисование сферы не требует никаких переносов. Вы можете использовать <b>glRotate*()</b>,
чтобы заставить солнце вращаться вокруг своей оси. Чтобы нарисовать планету,
вращающуюся вокруг солнца, как показано на рисунке 3-21, требуется выполнить
несколько модельных преобразований. Планета должна вращаться вокруг своей оси
раз в день, кроме того, раз в год планета должна совершать виток вокруг солнца.</p>

<p class=text align=left style='text-align:left'>Рисунок 3-21. Планета и солнце
</p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1094" type="#_x0000_t75" alt="" style='width:465pt;height:172.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image068.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов3.mht!http://www.progz.ru/images/opengl/chapter3/3-21.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=620 height=230
src="OpenGL%20Red%20Book.files/image068.jpg" v:shapes="_x0000_i1094"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Для определения порядка
модельных преобразований представьте себе, что происходит с локальной
координатной системой. Первый вызов <b>glRotate*()</b> поворачивает локальную
координатную систему (изначально совпадающую с фиксированной). Затем <b>glTranslate*()</b>
переносит локальную координатную систему в позицию на орбите планеты.
Расстояние, на которое выполняется перенос, должно совпадать с радиусом орбиты
планеты. Таким образом, начальный вызов <b>glRotate*()</b> на самом деле
определяет, где именно на орбите находится планета (то есть определяет время
года).</p>

<p class=text align=left style='text-align:left'>Второй вызов <b>glRotate*()</b>
поворачивает локальную координатную системы вокруг одной из ее осей, таким
образом, задавая для планеты время суток. После того, как выполнены все
описанные преобразования, можно рисовать планету.</p>

<p class=text align=left style='text-align:left'>Обобщая вышесказанное,
следующая последовательность команд OpenGL рисует солнце и планету, а полный
текст программы приведен в примере 3-6.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>glPushMatrix();<br>
  glutWireSphere(1.0,20,16);&nbsp;&nbsp; //Рисуем солнце <br>
  glRotatef((GLfloat) year,0.0,1.0,0.0);<br>
  glTranslatef(2.0,0.0,0.0);<br>
  glRotatef((GLfloat) day,0.0,1.0,0.0);<br>
  glutWireSphere(0.2,10,8);&nbsp;&nbsp; //Рисуем планету<br>
  glPopMatrix(); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Пример 3-6. Планетарная
система: файл planet.cpp</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>#include &lt;glut.h&gt;<br>
  <br>
  int year=0, day=0;<br>
  <br>
  //Инициализация<br>
  void init(void)<br>
  {<br>
  &nbsp;&nbsp; glClearColor(0.0,0.0,0.0,0.0);<br>
  &nbsp;&nbsp; glShadeModel(GL_FLAT);<br>
  }<br>
  <br>
  //Изменение размеров окна<br>
  void reshape(int w, int h)<br>
  {<br>
  &nbsp;&nbsp; glViewport(0,0,(GLsizei) w, (GLsizei) h);<br>
  &nbsp;&nbsp; glMatrixMode(GL_PROJECTION);<br>
  &nbsp;&nbsp; glLoadIdentity();<br>
  &nbsp;&nbsp; gluPerspective(60.0,(GLfloat) w/ (GLfloat) h,1.0,20.0);<br>
  &nbsp;&nbsp; glMatrixMode(GL_MODELVIEW);<br>
  &nbsp;&nbsp; glLoadIdentity();<br>
  &nbsp;&nbsp; gluLookAt(0.0,0.0,5.0,0.0,0.0,0.0,0.0,1.0,0.0);<br>
  }<br>
  <br>
  //Отображение <br>
  void display(void)<br>
  {<br>
  &nbsp;&nbsp; glClear(GL_COLOR_BUFFER_BIT);<br>
  &nbsp;&nbsp; glColor3f(1.0,1.0,1.0);<br>
  &nbsp;&nbsp; glPushMatrix();<br>
  <br>
  &nbsp;&nbsp; //Рисуем солнце <br>
  &nbsp;&nbsp; glutWireSphere(1.0,20,16);<br>
  &nbsp;&nbsp; glRotatef((GLfloat)year,0.0,1.0,0.0);<br>
  &nbsp;&nbsp; glTranslatef(2.0,0.0,0.0);<br>
  &nbsp;&nbsp; glRotatef((GLfloat)day,0.0,1.0,0.0);<br>
  <br>
  &nbsp;&nbsp; //Рисуем планету <br>
  &nbsp;&nbsp; glutWireSphere(0.2,10,8);<br>
  &nbsp;&nbsp; glPopMatrix();<br>
  &nbsp;&nbsp; glutSwapBuffers();<br>
  }<br>
  <br>
  //Реакция на клавиатуру <br>
  void keyboard(unsigned char key,int x, int y)<br>
  {<br>
  &nbsp;&nbsp; switch(key)<br>
  &nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'd':<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; day=(day+10)%360;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glutPostRedisplay();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'D':<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; day=(day-10)%360;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glutPostRedisplay();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'y':<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; year=(year+5)%360;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glutPostRedisplay();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'Y':<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; year=(year-5)%360;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glutPostRedisplay();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>
  &nbsp;&nbsp; }<br>
  }<br>
  <br>
  int main(int argc, char **argv)<br>
  {<br>
  &nbsp;&nbsp; glutInit(&amp;argc,argv);<br>
  &nbsp;&nbsp; glutInitDisplayMode(GLUT_DOUBLE|GLUT_RGB);<br>
  &nbsp;&nbsp; glutInitWindowSize(500,500);<br>
  &nbsp;&nbsp; glutInitWindowPosition(100,100);<br>
  &nbsp;&nbsp; glutCreateWindow(&quot;Planetary System&quot;);<br>
  &nbsp;&nbsp; init();<br>
  &nbsp;&nbsp; glutDisplayFunc(display);<br>
  &nbsp;&nbsp; glutReshapeFunc(reshape);<br>
  &nbsp;&nbsp; glutKeyboardFunc(keyboard);<br>
  &nbsp;&nbsp; glutMainLoop();<br>
  &nbsp;&nbsp; return 0;<br>
  } <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<h2>3.9.2&nbsp; Строим руку робота</h2>

<p class=text align=left style='text-align:left'>В этом разделе обсуждается
программа, создающая искусственную руку робота с двумя или более сегментами.
Эти фрагменты соединены в точках плеча, локтя и так далее. На рисунке 3-22
показана одна такая точка соединения.</p>

<p class=text align=left style='text-align:left'>Рисунок 3-22. Рука робота </p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1095" type="#_x0000_t75" alt="" style='width:465pt;height:204.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image069.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов3.mht!http://www.progz.ru/images/opengl/chapter3/3-22.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=620 height=273
src="OpenGL%20Red%20Book.files/image069.jpg" v:shapes="_x0000_i1095"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>В качестве сегментов руки вы
можете использовать масштабированные кубы, но сначала следует применить нужные
модельные преобразования, чтобы ориентировать каждый сегмент. Поскольку
изначально начало локальной координатной системы совпадает с центром куба,
требуется передвинуть ее к ребру куба, иначе он будет поворачиваться вокруг
своего центра, а не вокруг точки соединения.</p>

<p class=text align=left style='text-align:left'>После вызова <b>glTranslate*()</b>
для установки точки соединения и <b>glRotate*()</b> для поворота и
присоединения куба, выполним перенос обратно к центру куба. До его рисования
изменим его масштаб по осям. Вызовы <b>glPushMatrix()</b> и <b>glPopMatrix()</b>
ограничат действие <b>glScale*()</b>. Для первого сегмента руки код будет
выглядеть следующим образом (полный текст программы приводится в примере 3-7):</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>glTranslatef(-1.0,0.0,0.0);<br>
  glRotatef((GLfloat) shoulder, 0.0,0.0,1.0);<br>
  glTranslatef(1.0,0.0,0.0);<br>
  glPushMatrix();<br>
  glScalef(2.0,0.4,1.0);<br>
  glutWireCube(1.0);<br>
  glPopMatrix(); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Чтобы построить второй
сегмент, требуется передвинуть локальную координатную систему к следующей точке
соединения. Поскольку координатная система была предварительно повернута, ее
ось xуже ориентирована вдоль повернутой руки. Таким образом, перенос вдоль оси
x передвигает локальную координатную систему к следующей точке соединения.
После перемещения к ней, вы можете использовать уже приводившийся выше код для
рисования второго сегмента руки, так же как вы использовали его для рисования
первого. Этот процесс может быть повторен для бесконечного числа сегментов
(плечо, локоть, запястье, пальцы).</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>glTranslatef(1.0,0.0,0.0);<br>
  glRotatef((GLfloat) elbow,0.0,0.0,1.0);<br>
  glTranslatef(1.0,0.0,0.0);<br>
  glPushMatrix();<br>
  glScalef(2.0,0.4,1.0);<br>
  glutWireCube(1.0);<br>
  glPopMatrix(); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Пример 3-7. Рука робота: файл
robot.cpp</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>#include &lt;glut.h&gt;<br>
  <br>
  static intshoulder=0,elbow=0;<br>
  <br>
  //Инициализация <br>
  void init(void)<br>
  {<br>
  &nbsp;&nbsp; glClearColor(0.0,0.0,0.0,0.0);<br>
  &nbsp;&nbsp; glShadeModel(GL_FLAT);<br>
  }<br>
  <br>
  //Изменение размеров окна<br>
  void reshape(int w, int h)<br>
  {<br>
  &nbsp;&nbsp; glViewport(0,0,(GLsizei) w, (GLsizei) h);<br>
  &nbsp;&nbsp; glMatrixMode(GL_PROJECTION);<br>
  &nbsp;&nbsp; glLoadIdentity();<br>
  &nbsp;&nbsp; gluPerspective(65.0,(GLfloat) w/ (GLfloat) h,6.0,25.0);<br>
  &nbsp;&nbsp; glMatrixMode(GL_MODELVIEW);<br>
  &nbsp;&nbsp; glLoadIdentity();<br>
  &nbsp;&nbsp; glTranslatef(0.0,0.0,-10.0);<br>
  }<br>
  <br>
  //Отображение <br>
  void display(void)<br>
  {<br>
  &nbsp;&nbsp; glClear(GL_COLOR_BUFFER_BIT);<br>
  &nbsp;&nbsp; glPushMatrix();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glTranslatef(-1.0,0.0,0.0);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glRotatef((GLfloat)shoulder,0.0,0.0,1.0);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glTranslatef(1.0,0.0,0.0);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glPushMatrix();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glScalef(2.0,0.4,1.0);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glutWireCube(1.0);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glPopMatrix();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glTranslatef(1.0,0.0,0.0);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glRotatef((GLfloat)elbow,0.0,0.0,1.0);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glTranslatef(1.0,0.0,0.0);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glPushMatrix();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glScalef(2.0,0.4,1.0);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glutWireCube(1.0);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glPopMatrix();<br>
  &nbsp;&nbsp; glPopMatrix();<br>
  &nbsp;&nbsp; glutSwapBuffers();<br>
  }<br>
  <br>
  //Реакция на клавиатуру <br>
  void keyboard(unsigned char key,int x, int y)<br>
  {<br>
  &nbsp;&nbsp; switch(key)<br>
  &nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 's':<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; shoulder=(shoulder+5)%360;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glutPostRedisplay();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'S':<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; shoulder=(shoulder-5)%360;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glutPostRedisplay();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'e':<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elbow=(elbow+5)%360;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glutPostRedisplay();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'E':<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elbow=(elbow-5)%360;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glutPostRedisplay();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>
  &nbsp;&nbsp; }<br>
  }<br>
  <br>
  int main(int argc, char **argv)<br>
  {<br>
  &nbsp;&nbsp; glutInit(&amp;argc,argv);<br>
  &nbsp;&nbsp; glutInitDisplayMode(GLUT_DOUBLE|GLUT_RGB);<br>
  &nbsp;&nbsp; glutInitWindowSize(500,500);<br>
  &nbsp;&nbsp; glutInitWindowPosition(100,100);<br>
  &nbsp;&nbsp; glutCreateWindow(&quot;Robot Arm&quot;);<br>
  &nbsp;&nbsp; init();<br>
  &nbsp;&nbsp; glutDisplayFunc(display);<br>
  &nbsp;&nbsp; glutReshapeFunc(reshape);<br>
  &nbsp;&nbsp; glutKeyboardFunc(keyboard);<br>
  &nbsp;&nbsp; glutMainLoop();<br>
  &nbsp;&nbsp; return 0;<br>
  } <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<h2>3.10 Трансформационный реверс</h2>

<p class=text align=left style='text-align:left'>Конвейер геометрической
визуализации весьма удобен для преобразования вершин объектов в оконные
координаты, благодаря видовой и проекционной матрицам, а также порту просмотра.
Однако бывают ситуации, когда вам требуется обратить этот процесс. Достаточно
типичен случай, когда пользователь вашей программы использует мышь для выбора
точки в трехмерном пространстве. Мышь возвращает двумерные координаты,
соответствующие положению курсора на экране. В этом случае приложению нужно
обратить трансформационный процесс, чтобы выяснить, какой точке в трехмерном
пространстве соответствует это текущее положение курсора.</p>

<p class=text align=left style='text-align:left'>Такой трансформационный реверс
выполняется функциями <b>gluUnProject()</b> и <b>gluUnProject4()</b> из
библиотеки утилит. Получая трехмерные оконные координаты преобразованной
вершины и данные обо всех преобразованиях, которые влияли на нее, <b>gluUnProject()</b>
возвращает объектные координаты вершины в пространстве. (Если диапазон глубины
в вашем приложении иной нежели <i>[0, 1]</i>, используйте функцию <b>gluUnProject4()</b>.)</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>int <b>gluUnProject</b>
  (GLdouble <i>winx</i>, GLdouble <i>winy</i>, GLdouble <i>winz</i>, const
  GLdouble <i>modelMatrix[16]</i>,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  const GLdouble projMatrix[16], const GLint viewport[4],<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  GLdouble *<i>objx</i>, GLdouble *<i>objy</i>, GLdouble *<i>objz</i>); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Отображает заданные оконные
координаты (<i>winx</i>, <i>winy</i>, <i>winz</i>) в объектные координаты,
используя преобразования, заданные видовой матрицей (<i>modelMatrix</i>),
проекционной матрицей (<i>projMatrix</i>) и портом просмотра (<i>viewport</i>).
Результирующие объектные координаты возвращаются в параметрах <i>objx</i>, <i>objy</i>
и <i>objz</i>. Функция возвращает значение GL_TRUE, индицируя успех операции,
или GL_FALSEв случае неудачи (например, при наличии необратимой матрицы). Эта
операция не пытается отсечь координаты по границе порта просмотра или
уничтожить значения глубины, не заданные командой <b>glDepthRange()</b>.</p>

<p class=text align=left style='text-align:left'>В трансформационном реверсе
существуют специфические сложности. Двумерная точка на экране реально может
находиться где угодно на линии глубины в пространстве. Для возможности
однозначного результата, <b>gluUnProject()</b> требует в качестве одного из
своих параметров значение глубины в оконных координатах (<i>winz</i>), кроме
того, это значение должно быть указано в терминах <b>glDepthRange()</b>. Для
диапазона глубин по умолчанию вызов <b>gluUnProject()</b> с параметром <i>winz</i>=0.0
вернет координаты соответствующей точки на ближней плоскости отсечения объема
видимости, а при <i>winz</i>=1.0 будет вычислена точка на дальней плоскости
отсечения.</p>

<p class=text align=left style='text-align:left'>Пример 3-8 демонстрирует
использование <b>gluUnProject()</b> для чтения позиции курсора в оконных
координатах и распечатки на стандартном устройстве вывода соответствующих этой
позиции трехмерных точек на ближней и дальней плоскостях отсечения. В самом
окне приложения ничего не отображается. </p>

<p class=text align=left style='text-align:left'>Пример 3-8. Обращение
конвейера геометрической визуализации: файл unproject.cpp</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>#include &lt;glut.h&gt;<br>
  #include &lt;stdlib.h&gt;<br>
  #include &lt;stdio.h&gt;<br>
  <br>
  //Изменение размеров окна<br>
  void reshape(int w, int h)<br>
  {<br>
  &nbsp;&nbsp; glViewport(0,0,(GLsizei) w, (GLsizei) h); <br>
  &nbsp;&nbsp; glMatrixMode(GL_PROJECTION);<br>
  &nbsp;&nbsp; glLoadIdentity();<br>
  &nbsp;&nbsp; gluPerspective(45.0,(GLfloat) w/ (GLfloat) h,1.0,100.0);<br>
  &nbsp;&nbsp; glMatrixMode(GL_MODELVIEW);<br>
  &nbsp;&nbsp; glLoadIdentity();<br>
  }<br>
  <br>
  //Отображение <br>
  void display(void)<br>
  {<br>
  &nbsp;&nbsp; glClear(GL_COLOR_BUFFER_BIT);<br>
  &nbsp;&nbsp; glFlush();<br>
  }<br>
  <br>
  //Реакция на мышь <br>
  void mouse(int button,int state,int x, int y)<br>
  {<br>
  &nbsp;&nbsp; GLint viewport[4];<br>
  &nbsp;&nbsp; GLdouble mvmatrix[16], projmatrix[16];<br>
  <br>
  &nbsp;&nbsp; //y – координата в OpenGL<br>
  &nbsp;&nbsp; GLint realy;<br>
  <br>
  &nbsp;&nbsp; //Возвращаемые объектные x, y, z координаты<br>
  &nbsp;&nbsp; GLdouble wx,wy,wz;<br>
  <br>
  &nbsp;&nbsp; switch(button)<br>
  &nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case GLUT_LEFT_BUTTON:<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (state==GLUT_DOWN)<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  glGetIntegerv(GL_VIEWPORT,viewport);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  glGetDoublev(GL_MODELVIEW_MATRIX,mvmatrix);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  glGetDoublev(GL_PROJECTION_MATRIX,projmatrix);<br>
  <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  //viewport[3] - высоте окна в пикселях <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  realy=viewport[3]-(GLint)y-1;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  printf(&quot;Координаты в позиции курсора (%4d,%4d)\n&quot;,x,realy); <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  gluUnProject((GLdouble)x,(GLdouble)realy,0.0,mvmatrix,projmatrix,viewport,&amp;wx,&amp;wy,&amp;wz);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  printf(&quot;Объектные координаты при z=0 (%f,%f,%f)\n&quot;,wx,wy,wz); <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  gluUnProject((GLdouble)x,(GLdouble)realy,1.0,mvmatrix,projmatrix,viewport,&amp;wx,&amp;wy,&amp;wz);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  printf(&quot;Объектные координатыпри z=1 (%f,%f,%f)\n&quot;,wx,wy,wz); <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case GLUT_RIGHT_BUTTON:<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (state==GLUT_DOWN)<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(0);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>
  &nbsp;&nbsp; }<br>
  }<br>
  <br>
  int main(int argc, char **argv)<br>
  {<br>
  &nbsp;&nbsp; glutInit(&amp;argc,argv); <br>
  &nbsp;&nbsp; glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB); <br>
  &nbsp;&nbsp; glutInitWindowSize(500,500);<br>
  &nbsp;&nbsp; glutInitWindowPosition(100,100);<br>
  &nbsp;&nbsp; glutCreateWindow(&quot;Reversing the Geometric Processing
  Pipeline&quot;);<br>
  &nbsp;&nbsp; glutDisplayFunc(display);<br>
  &nbsp;&nbsp; glutReshapeFunc(reshape);<br>
  &nbsp;&nbsp; glutMouseFunc(mouse);<br>
  &nbsp;&nbsp; glutMainLoop();<br>
  &nbsp;&nbsp; return 0;<br>
  }<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>В GLU версии 1.3 появилась
модифицированная версия <b>gluUnProject()</b>. <b>gluUnProject4()</b> может
обрабатывать нестандартные величины диапазона глубин и <i>w</i>– координаты не
равные <i>1</i>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>int <b>gluUnProject4
  </b>(GLdouble <i>winx</i>, GLdouble <i>winy</i>, GLdouble <i>winz</i>, <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  GLdouble <i>clipw</i>, const GLdouble <i>modelMatrix[16]</i>, const GLdouble <i>projMatrix[16]</i>,
  const GLint <i>viewport[4]</i>, <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  GLclampd <i>znear</i>, GLclampd <i>zfar</i>, GLdouble *<i>objx</i>, GLdouble
  *<i>objy</i>, GLdouble *<i>objz</i>, GLdouble *<i>objw</i>); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>В общем, эта команда выполняет
операцию аналогичную <b>glUnProject()</b>. Отображает заданные оконные
координаты (<i>winx</i>, <i>winy</i>, <i>winz</i>) в объектные координаты,
используя преобразования, заданные видовой матрицей (<i>modelMatrix</i>),
проекционной матрицей (<i>projMatrix</i>), портом просмотра (<i>viewport</i>) и
диапазоном глубин <i>znear </i>и <i>zfar</i>. Результирующие объектные
координаты возвращаются в параметрах <i>objx</i>, <i>objy</i>, <i>objz </i>и <i>objw</i>.&nbsp;</p>

<p class=text align=left style='text-align:left'>Еще одной функцией из
библиотеки утилит, связанной с <b>gluUnProject()</b> и <b>gluUnProject4()</b>
является функция <b>gluProject()</b>. <b>gluProject()</b> имитирует действие
конвейера визуализации. Получая трехмерные объектные координаты и все
преобразования, которые влияют на них, <b>gluProject()</b> возвращает
преобразованные оконные координаты.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>int <b>gluProject</b>
  (GLdouble <i>objx</i>, GLdouble <i>objy</i>, GLdouble <i>objz</i>, <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  const GLdouble <i>modelMatrix[16]</i>, const GLdouble <i>projMatrix[16]</i>,
  const GLint <i>viewport[4]</i>, <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  GLdouble *<i>winx</i>, GLdouble *<i>winy</i>, GLdouble *<i>winz</i>); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Отображает заданные объектные
координаты (<i>objx</i>, <i>objy</i>, <i>objz</i>) в оконные координаты с
использованием преобразований, заданных видовой матрицей (<i>modelMatrix</i>),
проекционной матрицей (<i>projMatrix</i>) и портом просмотра (<i>viewport</i>).
Результирующие оконные координаты возвращаются в параметрах <i>winx</i>, <i>winy</i>и
<i>winz</i>. Функция возвращает GL_TRUE&nbsp;в случае успеха и GL_FALSE в
противном случае.</p>

<p class=warning>Замечание: Матрицы, передаваемые <b>gluUnProject()</b>, <b>gluUnProject4()</b>
и <b>gluProject()</b> задаются в формате стандартном для OpenGL, то есть по
столбцам. Вы можете использовать <b>glGetDoublev()</b> и <b>glGetIntegerv()</b>
с параметрами GL_MODELVIEW_MATRIX, GL_PROJECTION_MATRIX и GL_VIEWPORT для
получения текущей видовой матрицы, матрицы проекции и порта просмотра
соответственно, а затем использовать полученные величины при вызове <b>gluUnProject()</b>,
<b>gluUnProject4()</b> или <b>gluProject()</b>.</p>

<p class=MsoNormal><a name=Глава4><span style='display:none;mso-hide:all'><o:p>&nbsp;</o:p></span></a></p>

<h1 align=left style='text-align:left'><span style='mso-bookmark:Глава4'>Глава
4. Цвет</span></h1>

<span style='mso-bookmark:Глава4'></span>

<p class=MsoNormal><a href="mailto:ahinar@list.ru"></a><span style='font-size:
10.0pt;font-family:Verdana'>Целью практически всех приложений OpenGLявляется
отображение цветного изображения в окне на экране. Окно – это прямоугольный
массив пикселей, каждый из которых содержит и отображает свой собственный цвет.
Таким образом, интуитивно, смысл всех вычислений, производимых реализацией
OpenGL – вычислений, принимающих в расчет команды OpenGL, информацию о
состоянии и значения параметров – определить результирующий цвет каждого
пикселя, который должен быть нарисован в окне.<o:p></o:p></span></p>

<h2>4.1&nbsp; Цветовое восприятие</h2>

<p class=text align=left style='text-align:left'>Физически, свет состоит из
протонов – микроскопических световых частиц, каждая из которых движется по
собственному маршруту и вибрирует со своей частотой (или длиной волны, или
энергией – каждая из трех характеристик: частота, длина волны или энергия однозначно
определяет две другие). Протон полностью характеризуется своим положением,
направлением и частотой/длиной волны/энергией. Протоны с длиной волны
приблизительно от 390 нанометров (nm) (фиолетовый) до 720 nm (красный)
покрывают все цвета видимого спектра, формируя цвета радуги (фиолетовый, синий,
голубой, зеленый, желтый, оранжевый и красный). Однако наши глаза воспринимают
множество цветов, которых нет в радуге – например, белый, черный, коричневый,
розовый и так далее. Каким образом это происходит?</p>

<p class=text align=left style='text-align:left'>В действительности наш глаз
видит смесь протонов с различными частотами. Реальные источники света
характеризуются распределением частот излучаемых ими протонов. Идеально белый
свет состоит из равного количества света всех частот. Лазерный луч обычно очень
плотный, и все его протоны практически идентичны по частоте (а также по
направлению и фазе). В обычной лампочке больше света на желтой частоте. Свет от
большинства звезд во вселенной имеет распределение, сильно зависящее от их
температуры. Частота распределения света от большинства обыденных источников
более сложна.</p>

<p class=text align=left style='text-align:left'>Человеческий глаз воспринимает
цвет, когда несколько ячеек в сетчатке (называемых колбочками) возбуждаются
вследствие того, что по ним бьют протоны. Три различных типа колбочек лучше
реагируют на три различных длины световой волны: первый тип лучше реагирует на
красный свет, второй – на зеленый, и третий – на синий. (У человека, не
способного различать цвета, как правило, отсутствует один из типов колбочек.)
Когда смесь протонов попадает в глаз, колбочки сетчатки&nbsp; регистрируют
различные уровни возмущения в соответствии со своим типом. Если после этого в
глаз попадает иная смесь протонов, возмущающая его с уровнем идентичным первой
смеси, то цвет этих двух смесей неразличим.</p>

<p class=text align=left style='text-align:left'>Поскольку каждый цвет фиксируется
глазом в виде уровней возмущения колбочек входящими протонами, глаз может
воспринимать цвета, не являющиеся частью спектра, создаваемого призмой или
радугой. Например, если направить смесь красных и синих протонов на сетчатку
так, чтобы возмущение было зафиксировано красными и синими колбочками, ваш глаз
определит это как лиловый цвет, которого нет в спектре. Другие комбинации могут
дать коричневый цвет, цвет морской волны и другие, отсутствующие в спектре.</p>

<p class=text align=left style='text-align:left'>Графический монитор эмулирует
видимые цвета, подсвечивая пиксели на экране комбинацией красного, зеленого и
синего света в пропорциях, возбуждающих колбочки чувствительные к красному,
зеленому и синему свету, таким образом, чтобы уровень их возмущения совпадал с
уровнем, создаваемым естественной смесью протонов. Если бы у людей было больше
типов колбочек, например, если были бы колбочки чувствительные к желтому свету,
цветные мониторы имели бы, вероятно, еще и желтую пушку, и мы использовали бы
четверку RGBY (красный, зеленый, синий, желтый) для указания цвета. И, наконец,
если бы все люди не различали цветов, эта глава была бы намного проще.</p>

<p class=text align=left style='text-align:left'>Для отображения конкретного
цвета, монитор посылает точное количество красного, зеленого и синего света
(red, green, blue – RGB) должным образом стимулирующее различные типы колбочек
в глазу. Цветной монитор может посылать свет с разными пропорциями красного,
зеленого и синего в каждую точку экрана, и глаз видит миллионы световых точек,
каждая из которых имеет свой собственный цвет.</p>

<p class=warning>Замечание: Помимо RGB существует множество других
представлений цвета или цветовых моделей, обозначаемых как HLS, HSV, CMYK и так
далее. Если вам требуется, чтобы цветовые данные были записаны в одном из этих
форматов, вы всегда можете конвертировать их из RGB – формата или в RGB – формат.</p>

<p class=text align=left style='text-align:left'>В этой главе рассматривается
только восприятие глазом комбинации входящих в него протонов. Ситуация, когда
свет входит в глаз, отразившись от каких-либо материалов еще более сложна –
например, белый цвет, отразившись от красного мяча, выглядит красным, а желтый
свет, проходя через синее стекло, становится почти черным.</p>

<h2>4.2&nbsp; Цвет в компьютере</h2>

<p class=text align=left style='text-align:left'>Аппаратура заставляет каждый
пиксель экрана излучать различные количественные соотношения красного, зеленого
и синего света. Эти количества называются R (красный), G (зеленый) и B (синий)
– величинами. Они часто хранятся и упаковываются вместе (иногда вместе с
четвертой – альфа – величиной или альфа – компонентой, называемой A), и
упакованное значение называется RGB (или RGBA) величиной. Цветовая информация
для каждого пикселя может храниться как в <i>RGBA – режиме</i> (при котором для
каждого пикселя хранятся значения R, G, B и, возможно A), так и в <i>режиме
цветовых индексов</i> (в этом случае для каждого пикселя хранится всего одно
число, называемое <i>цветовым индексом </i>или<i> индексом в палитре</i>).
Каждый цветовой индекс идентифицирует одно вхождение в таблицу, содержащую в
каждом элементе набор из одной R, одной G и одной B – величины. Такая таблица
называется <i>цветовой таблицей</i> (или <i>цветовой картой</i>, или просто <i>палитрой</i>).</p>

<p class=text align=left style='text-align:left'>В индексном режиме вам может
понадобиться изменить величины в цветовой таблице. Поскольку цветовые таблицы
управляются оконной системой, для этого не существует команд OpenGL. Все
примеры в данном пособии инициализируют цветовой режим при открытии окна,
применяя функции из библиотеки GLUT.</p>

<p class=text align=left style='text-align:left'>Между разными аппаратными
графическими платформами существует множество различий, касающихся как размера
пиксельного массива, так и количества цветов, которые могут быть отображены в
каждом пикселе. В любой графической системе каждый пиксель имеет одинаковое
количество памяти для хранения своего цвета, а вся эта память для всех пикселей
вместе называется <i>цветовым буфером</i>. Размер буфера обычно измеряется в
битах, таким образом, 8-битовый буфер может содержать 8 бит данных (то есть одну
из 256 возможных комбинаций, задающих конкретный цвет) для каждого пикселя.
Размер возможных буферов меняется от компьютера к компьютеру.</p>

<p class=text align=left style='text-align:left'>Каждое из R, G и B – значений
может изменяться от 0.0 (отсутствие интенсивности) до 1.0 (полная
интенсивность). Например, комбинация R=0.0, G=0.0 и B=1.0 задает максимально
возможный по яркости синий цвет. Если R, G и B равны 0.0, цвет пикселя –
черный; если все компоненты равны 1.0, пиксель будет нарисован самым ярким
белым цветом, который возможно отобразить на экране. Смешивание синего и
зеленого цветов дает оттенки голубого. Комбинация синего и красного цветов дает
лиловый. Красный и зеленый образуют желтый. Чтобы облегчить себе задачу по
созданию желаемых цветов из R, G и B – компонент, взгляните на рисунок 4.1. Оси
куба на рисунке представляют интенсивности красного, зеленого и синего.</p>

<p class=text align=left style='text-align:left'>Рисунок 4-1. Цветовой куб</p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1096" type="#_x0000_t75" alt="" style='width:465pt;height:236.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image070.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов4.mht!http://www.progz.ru/images/opengl/chapter4/4-1.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=620 height=315
src="OpenGL%20Red%20Book.files/image070.jpg" v:shapes="_x0000_i1096"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Команды, используемые для
указания цвета объекта (в данном случае точки), могут быть достаточно просты:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>glColor3f(1.0,0.0,0.0);&nbsp;&nbsp;
  //Текущий цвет – красный, без зеленого и без синего<br>
  glBegin(GL_POINTS);<br>
  &nbsp;&nbsp; glVertex3fv(point_array);<br>
  glEnd();<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>В некоторых режимах (например,
если производятся вычисления, связанные с освещением или текстурированием),
назначенный цвет может преобразовываться другими операциями до того, как
попадет в буфер кадра, представляя цвет пикселя на экране. Вообще говоря, цвет
пикселя определяется посредством длинной последовательности операций.</p>

<p class=text align=left style='text-align:left'>Вначале исполнения программы
цветовой режим устанавливается в RGBA или индексный. Как только цветовой режим
установлен, он уже не может быть изменен. Во время выполнения программы цвет (и
в индексном, и в RGBA - режиме) определяется на повершинном базисе для каждого
геометрического примитива. Этот цвет может быть тем, который вы задали для
вершины непосредственно, или, если включено освещение, тем, который
определяется под влиянием взаимодействия трансформационных матриц с нормалями к
поверхности и других свойств материала. Иными словами, красный мяч, освещенный
синим светом, выглядит иначе, чем тот же мяч, но без освещения. После
выполнения расчетов, связанных с освещением, применяется выбранная модель
закраски. Вы можете выбрать плоскую или плавную закраску, каждая из которых
оказывает специфическое влияние на цвет пикселя.</p>

<p class=text align=left style='text-align:left'>Далее, примитивы <i>растеризуются</i>
(или преобразуются в двумерное изображение). Растеризация требует определения
того, какие квадраты целочисленной решетки оконных координат заняты примитивом.
Этим квадратам присваивается определенный цвет и другие величины. Квадрат
решетки вместе с присвоенным ему значением цвета, <i>z</i> (глубиной) и
координатами текстуры называется <i>фрагментом</i>. Пиксели являются элементами
буфера кадра; фрагмент поступает из примитива и комбинируется с соответствующим
ему пикселем для получения нового пикселя.&nbsp; После того, как фрагменты
примитива построены, к ним применяются (если включены) текстурирование, туман и
антиалиасинг. Затем над фрагментами и пикселями, уже находящимися в буфере
кадра, выполняются альфа наложение, <i>микширование</i> (<i>dithering</i>–
техника симуляции недостающих цветов) и побитовые логические операции (если
какие-либо или все эти механизмы включены). Наконец, цветовая величина
фрагмента (и в индексном, и в RGBA - режиме) записывается в пиксель и
отображается в окне с использованием цветового режима окна. </p>

<h2>4.3&nbsp; RGBA – режим против Индексного режима</h2>

<p class=text align=left style='text-align:left'>В обоих режимах (индексном и
RGBA) в каждом пикселе хранится определенное количество информации о цвете. Это
количество определяется числом битовых плоскостей в буфере кадра. <i>Битовая
плоскость</i> содержит 1 бит данных для каждого пикселя. Если присутствует 8
битовых плоскостей, в них суммарно хранится 8 бит на цвет и, следовательно,
может существовать <!--[if gte vml 1]><v:shape id="_x0000_i1097" type="#_x0000_t75"
 alt="" style='width:50.25pt;height:17.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image071.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов4.mht!http://www.progz.ru/images/opengl/chapter4/form1.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=67 height=23
src="OpenGL%20Red%20Book.files/image071.gif" v:shapes="_x0000_i1097"><![endif]>&nbsp;
их различных комбинаций или цветов, которые могут быть сохранены в пикселе.</p>

<p class=text align=left style='text-align:left'>Битовые плоскости часто
поровну разделяют на хранилища R, G и B компонент (то есть, система с 24
битовыми плоскостями содержит по 8 бит для красного, зеленого и синего), но это
не всегда соответствует действительности. Для выяснения числа битовых
плоскостей, присутствующих в вашей системе для величин красного, зеленого,
синего цвета, альфа величин и величин цветовых индексов вызовите <b>glGetIntegerv()</b>
c аргументами GL_RED_BITS, GL_GREEN_BITS, GL_BLUE_BITS, GL_ALPHA_BITS и
GL_INDEX_BITS соответственно.</p>

<p class=warning>Замечание: Цветовые интенсивности на большинстве компьютерных
экранов не воспринимаются человеческим глазом, как непрерывные. Предположим,
что цвета состоят только из красного компонента с зеленым и синим,
установленными в нуль. С увеличением интенсивности от 0.0 (полное отсутствие
интенсивности) до 1.0 (полная интенсивность) увеличивается число электронов,
ударяющихся в пиксель экрана. Однако возникает вопрос: будет ли цвет с
интенсивностью 0.5 находится (по внешнему виду) ровно посередине между 0.0 и
1.0? Чтобы выяснить это, напишите программу, заполняющую прямоугольную область
в шахматном порядке пикселями с интенсивностями красного равной 0.0 и 1.0, а
рядом – прямоугольный регион, целиком заполненный пикселями с интенсивностью
красного равной 0.5. На некоторой разумной дистанции от экрана должно казаться,
что оба региона имеют одинаковую интенсивность. Если они выглядят сильно
различающимися, вам следует использовать любой механизм коррекции, имеющийся в
вашей конкретной системе. Например, во многих системах присутствует таблица
настройки интенсивностей, позволяющая настроить внешний вид 0.5, таким образом,
чтобы оно действительно выглядело серединой между 0.0 и 1.0. Обычно применяемый
для этого механизм коррекции имеет экспоненциальный характер, а на экспоненту
ссылаются как на гамму (отсюда термин гамма-коррекция). Использование
одинаковой гаммы для красного, зеленого и синего компонент дает обычно неплохой
результат, но три разные гаммы могут дать лучший.</p>

<h2>4.3.1&nbsp; RGBA – режим</h2>

<p class=text align=left style='text-align:left'>В RGBA – режиме аппаратура
выделяет некоторое число битовых плоскостей для каждого из R, G, B и A
компонента (это число не обязательно является одинаковым для каждого
компонента), как показано на рисунке 4-2. R, G и B – величины чаще хранятся в
виде целых чисел, чем в виде чисел с плавающей точкой и, следовательно,
масштабируются согласно выделенному количеству битовых плоскостей. Например,
если в системе имеется 8 бит для красного компонента, в них могут быть
сохранены целые от 0 до 255. Таким образом, 0, 1, 2, ..., 255 в битовых
плоскостях будут соответствовать R – величинам 0/255=0.0, 1/255, 2/255, ...,
255/255=1.0. Независимо от числа битовых плоскостей 0.0 задает минимальную
интенсивность, а 1.0 – максимальную.</p>

<p class=text align=left style='text-align:left'>Рисунок 4-2. RGB – величины из
битовых плоскостей </p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1098" type="#_x0000_t75" alt="" style='width:465pt;height:314.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image072.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов4.mht!http://www.progz.ru/images/opengl/chapter4/4-2.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=620 height=419
src="OpenGL%20Red%20Book.files/image072.jpg" v:shapes="_x0000_i1098"><![endif]></p>

<p class=warning>Замечание: Значение альфа (A в RGBA) не имеет прямого действия
на цвет, отображаемый на экране. Оно может быть использовано для множества
вещей, включая цветовое наложение и прозрачность, а также для воздействия на
записываемые в буфер величины R, G и B.</p>

<p class=text align=left style='text-align:left'>&nbsp;Количество различных
цветов, которые могут быть отображены на месте одного пикселя, зависит от
количества битовых плоскостей и возможностей аппаратуры по интерпретации этих
плоскостей. Количество одновременно отображаемых цветов не может превышать <!--[if gte vml 1]><v:shape
 id="_x0000_i1099" type="#_x0000_t75" alt="" style='width:15pt;height:13.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image073.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов4.mht!http://www.progz.ru/images/opengl/chapter4/form2.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=20 height=18
src="OpenGL%20Red%20Book.files/image073.gif" v:shapes="_x0000_i1099"><![endif]>,
где <i>n</i> – количество битовых плоскостей. Таким образом, система с 24-мя
битовыми плоскостями может одновременно отображать до 16.77 миллионов различных
цветов.</p>

<h2>4.3.1.1&nbsp;&nbsp;&nbsp; Цветовое микширование</h2>

<p class=text align=left style='text-align:left'><b>Дополнительно: </b>Некоторые
аппаратные средства используют микширование для увеличения числа видимых
цветов. Микширование – это техника, заключающаяся в использовании комбинации
нескольких цветов для создания видимости других цветов. Для иллюстрации того,
как работает микширование, представим, что в вашей системе имеется всего по 1
биту для R, G и B, и она, таким образом, может отображать только 8 цветов:
черный, белый, красный, синий, зеленый, желтый, голубой и фиолетовый. Чтобы
отобразить область, закрашенную розовым цветом, аппаратура может заполнить ее
красными и белыми пикселями по принципу шахматной доски (пиксели через один по
вертикали и горизонтали имеют один и тот же цвет, а соседние пиксели – разные
цвета). Если ваш глаз находится на достаточном расстоянии от экрана, на котором
он не может различить отдельные пиксели – область будет казаться розовой, то
есть средним цветом между белым и красным. Для увеличения «красноты» розового
цвета можно изменить соотношение между цветами, увеличив количество красных
пикселей и уменьшив количество белых. Для более «бледного» розового следует
поступить наоборот – увеличить число белых пикселей и уменьшить количество
красных.</p>

<p class=text align=left style='text-align:left'>При использовании этой техники
на экране нет розовых пикселей вообще. Единственный способ увидеть розовый цвет
– покрыть область, состоящую из множества пикселей, в этом случае вы не сможете
зрительно выделить отдельный пиксель. Если вы задаете RGB-величину
отсутствующего, недоступного цвета и заполняете им полигон, аппаратура заполнит
пиксели внутри полигона смесью доступных цветов, среднее между которыми
наиболее близко к желаемому вами цвету. (Помните, однако, что если вы считаете
пиксельную информацию из буфера кадра, вы получите именно красные и белые
пиксели, так как розовых там нет.)</p>

<p class=text align=left style='text-align:left'>Рисунок 4-3 иллюстрирует несколько
примеров микширования черного и белого цветов для получения трех оттенков
серого. Слева направо в верхнем ряду фрагменты размером 4x4 пикселя
представляют шаблоны микширования для 50 процентного, 19 процентного и 69
процентного серого цвета. Под каждым шаблоном вы можете видеть его уменьшенную
и многократно повторенную копию, однако черные и белые квадраты на них все же
больше, чем большинство пикселей. Если вы посмотрите на эти шаблоны с
достаточно большого расстояния, вы обратите внимание, что отдельные квадратики
на них сливаются и, таким образом, образуют три оттенка серого цвета.</p>

<p class=text align=left style='text-align:left'>Рисунок 4-3. Микширование
черного и белого для создания видимости серого</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1100" type="#_x0000_t75" alt="" style='width:465pt;height:219pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image074.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов4.mht!http://www.progz.ru/images/opengl/chapter4/4-3.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=620 height=292
src="OpenGL%20Red%20Book.files/image074.jpg" v:shapes="_x0000_i1100"><![endif]></p>

<p class=text align=left style='text-align:left'>При наличии 8 бит на каждый из
R, G и B компонентов вы можете получить достаточно высококачественное
изображение и без микширования. Однако то, что на вашей машине имеется 24
битовых плоскости, еще не говорит о том, что микширование вам совсем не нужно.
Например, если вы работаете в режиме двойной буферизации, битовые плоскости
могут быть разделены на 2 набора по 12 плоскостей каждый, то есть на самом деле
имеется только 4 бита для каждого из R, G и B компонент. Без микширования цвет
с 4-мя битами на компонент во многих ситуация может давать менее
удовлетворительные результаты.</p>

<p class=text align=left style='text-align:left'>Вы включаете и выключаете
микширование, передавая аргумент GL_DITHER командам <b>glEnable()</b> и <b>glDisable()</b>.
Имейте в виду, что микширование, в отличие от большинства возможностей OpenGL,
по умолчанию включено.</p>

<h2>4.3.2&nbsp; Индексный режим</h2>

<p class=text align=left style='text-align:left'>При работе в индексном
цветовом режиме OpenGL использует цветовую таблицу, похожую на палитру, на
которой заранее смешивают краски для того, чтобы потом нарисовать картинку
определенным количеством цветов. В палитре художника имеются участки для
смешивания красок, похожим образом компьютерная цветовая таблица предоставляет
индексы ячеек, в которых хранятся цвета, заранее смешиваемые из красного, зеленого
и синего компонентов (рисунок 4-4).</p>

<p class=text align=left style='text-align:left'>Рисунок 4-4. Цветовая таблица </p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1101" type="#_x0000_t75" alt="" style='width:465pt;height:195.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image075.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов4.mht!http://www.progz.ru/images/opengl/chapter4/4-4.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=620 height=261
src="OpenGL%20Red%20Book.files/image075.jpg" v:shapes="_x0000_i1101"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Художник при рисовании ограниченным
количеством цветов выбирает один из них на палитре и заполняет им область на
картине. Компьютер сохраняет в битовых плоскостях цветовой индекс для каждого
пикселя. Затем величины в битовых плоскостях разрешаются: каждый пиксель
рисуется комбинацией красного, зеленого и синего цветов, извлеченной из ячейки
цветовой таблицы, соответствующей хранимому индексу (рисунок 4-5).</p>

<p class=text align=left style='text-align:left'>Рисунок 4-5. Рисование
картинки с использованием цветовой таблицы</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1102" type="#_x0000_t75" alt="" style='width:232.5pt;height:189pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image076.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов4.mht!http://www.progz.ru/images/opengl/chapter4/4-5.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=310 height=252
src="OpenGL%20Red%20Book.files/image076.jpg" v:shapes="_x0000_i1102"><![endif]></p>

<p class=text align=left style='text-align:left'>При использовании индексного
цветового режима количество одновременно доступных цветов ограничено размером
цветовой таблицы и количеством имеющихся битовых плоскостей. Размер цветовой
таблицы зависит от объема аппаратной поддержки. Размер цветовой таблицы всегда
является степенью двойки и обычно варьируется от <!--[if gte vml 1]><v:shape
 id="_x0000_i1103" type="#_x0000_t75" alt="" style='width:43.5pt;height:18pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image077.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов4.mht!http://www.progz.ru/images/opengl/chapter4/form3.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=58 height=24
src="OpenGL%20Red%20Book.files/image077.gif" v:shapes="_x0000_i1103"><![endif]>&nbsp;до
<!--[if gte vml 1]><v:shape id="_x0000_i1104" type="#_x0000_t75" alt=""
 style='width:57.75pt;height:18.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image078.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов4.mht!http://www.progz.ru/images/opengl/chapter4/form4.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=77 height=25
src="OpenGL%20Red%20Book.files/image078.gif" v:shapes="_x0000_i1104"><![endif]>,
где показатель представляет собой количество используемых битовых плоскостей.
Если <!--[if gte vml 1]><v:shape id="_x0000_i1105" type="#_x0000_t75" alt=""
 style='width:15pt;height:13.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image073.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов4.mht!http://www.progz.ru/images/opengl/chapter4/form2.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=20 height=18
src="OpenGL%20Red%20Book.files/image073.gif" v:shapes="_x0000_i1105"><![endif]>&nbsp;
– количество индексов в цветовой таблице, а <i>m</i> – число доступных битовых
плоскостей, то количество возможных к использованию элементов или вхождений в
таблицу равно меньшему из <!--[if gte vml 1]><v:shape id="_x0000_i1106" type="#_x0000_t75"
 alt="" style='width:15pt;height:13.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image073.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов4.mht!http://www.progz.ru/images/opengl/chapter4/form2.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=20 height=18
src="OpenGL%20Red%20Book.files/image073.gif" v:shapes="_x0000_i1106"><![endif]>&nbsp;и
<!--[if gte vml 1]><v:shape id="_x0000_i1107" type="#_x0000_t75" alt=""
 style='width:18.75pt;height:15.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image079.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов4.mht!http://www.progz.ru/images/opengl/chapter4/form5.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=25 height=21
src="OpenGL%20Red%20Book.files/image079.gif" v:shapes="_x0000_i1107"><![endif]>.</p>

<p class=text align=left style='text-align:left'>В RGBA– режиме цвет каждого
пикселя не зависит от других пикселей. Однако в индексном режиме все пиксели с
одинаковым индексом (хранящимся в битовых плоскостях) разделяют один и тот же
элемент в цветовой таблице. Если изменяется содержимое одного из элементов в
таблице, то все пиксели, индексы которых ссылаются на этот элемент, изменяют
свой цвет.</p>

<h2>4.3.3&nbsp; Выбор между RGBA – режимом и индексным режимом</h2>

<p class=text align=left style='text-align:left'>В своем выборе между RGBA -
режимом и индексным режимом вы должны основываться на том, какая имеется
аппаратура, а также на том, что именно требуется вашему приложению. Большинство
систем в RGBA – режиме позволяют одновременно отображать большее число цветов,
чем в индексном. Кроме того, при использовании некоторых эффектов, таких как
заливка, освещение, текстурирование и туман, RGBA предоставляет большую гибкость,
чем индексный режим.</p>

<p class=text align=left style='text-align:left'>Индексный цветовой режим может
быть предпочтительнее в следующих случаях:</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l64 level1 lfo16;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Если вы переносите (портируете) приложение,
интенсивно использующее индексный режим, вероятно, будет проще не переделывать
его под режим RGBA.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l64 level1 lfo16;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Если у вас имеется в наличии небольшое
количество битовых плоскостей, RGBA режим может создавать достаточно резкие
оттенки цвета. Например, если у вас всего 8 битовых плоскостей, в RGBA режиме
будет всего 3 бита для красного цвета, 3 для зеленого и 2 для синего (так как человеческий
глаз наименее чувствителен именно к синему цвету). Таким образом, вы сможете
отображать только 8 (<!--[if gte vml 1]><v:shape id="_x0000_i1108" type="#_x0000_t75"
 alt="" style='width:12.75pt;height:16.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image080.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов4.mht!http://www.progz.ru/images/opengl/chapter4/form6.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=17 height=22
src="OpenGL%20Red%20Book.files/image080.gif" v:shapes="_x0000_i1108"><![endif]>)
оттенков красного, 8 оттенков зеленого и 4 оттенка синего цвета. Разрывы между
цветовыми оттенками будут весьма заметными. В подобной ситуации, если у вас
ограниченные требования, вы можете использовать цветовую таблицу, чтобы
загрузить большее число цветовых оттенков. Например, если вам требуются только
оттенки синего, вы можете использовать индексный режим и сохранить в цветовой
таблице до 256 (<!--[if gte vml 1]><v:shape id="_x0000_i1109" type="#_x0000_t75"
 alt="" style='width:15.75pt;height:17.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image081.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов4.mht!http://www.progz.ru/images/opengl/chapter4/form7.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=21 height=23
src="OpenGL%20Red%20Book.files/image081.gif" v:shapes="_x0000_i1109"><![endif]>)
оттенков синего цвета, что будет намного лучше 4-ех оттенков в RGBA режиме.
Естественно, в этом примере вы задействуете под оттенки синего всю цветовую
таблицу, поэтому у вас не будет оттенков ни красного, ни зеленого цвета, ни
каких-либо их комбинаций.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l64 level1 lfo16;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Индексный режим может быть использован для
различных специфических трюков, например, для анимации цветовой таблицы и
рисования в слоях. </p>

<p class=text align=left style='text-align:left'>Вообще, используйте RGBA режим
везде, где это возможно. Только он работает с текстурированием, а такие
механизмы, как освещение, заливка, туман, антиалиасинг и цветовое наложение
работают в RGBA режиме намного лучше. (Кроме того, индексный режим может быть
недоступен на некоторых платформах, например, приложения GLUT, использующие
индексный режим могут не запускаться в операционной системе Microsoft Windows
XP.)</p>

<h2>4.3.4&nbsp; Изменение режима</h2>

<p class=text align=left style='text-align:left'>В лучшем из всех возможных
миров вам не пришлось бы делать выбор между RGBA и индексным режимами.
Например, вы могли бы использовать индексный режим для эффектов, связанных с
анимацией цветовой таблицы, а затем по необходимости мгновенно переключить
сцену в RGBA режим для текстурирования.</p>

<p class=text align=left style='text-align:left'>Или, похожим образом, вы могли
бы переключаться между режимами одинарной и двойной буферизации. Например, у
вас всего несколько битовых поверхностей, скажем 8. Вы можете использовать 256
(<!--[if gte vml 1]><v:shape id="_x0000_i1110" type="#_x0000_t75" alt=""
 style='width:15.75pt;height:17.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image081.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов4.mht!http://www.progz.ru/images/opengl/chapter4/form7.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=21 height=23
src="OpenGL%20Red%20Book.files/image081.gif" v:shapes="_x0000_i1110"><![endif]>)
цветов в режиме одинарной буферизации, но если вы работаете в режиме двойной
буферизации, чтобы устранить мигание в своей программе анимации, у вас может
быть только 16 (<!--[if gte vml 1]><v:shape id="_x0000_i1111" type="#_x0000_t75"
 alt="" style='width:15pt;height:15.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image082.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов4.mht!http://www.progz.ru/images/opengl/chapter4/form8.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=20 height=21
src="OpenGL%20Red%20Book.files/image082.gif" v:shapes="_x0000_i1111"><![endif]>)&nbsp;
цветов. Возможно, вы хотели бы нарисовать движущийся объект без мигания, то
есть принести цвета в жертву возможности двойной буферизации (может быть,
объект движется настолько быстро, что наблюдатель не заметит деталей). Однако,
когда объект приходит в стационарное состояние, вам захочется рисовать его в
режиме одинарной буферизации, чтобы использовать большее количество цветов.</p>

<p class=text align=left style='text-align:left'>К сожалению, большинство
оконных систем не предусматривает легкого переключения между режимами.
Например, в X Windows System цветовой режим является атрибутом X Visual. X
Visual, в свою очередь должен быть задан до того, как создано окно. Как только
он задан, он не может быть изменен на протяжении времени существования окна. То
есть если вы создали окно с двойной буферизацией и цветовым режимом RGBA – вы
так с ними и останетесь до закрытия окна вашего приложения.</p>

<p class=text align=left style='text-align:left'>Достаточно хитрое решение этой
проблемы заключается в создании более чем одного окна с различными режимами. Вы
должны контролировать видимость каждого окна и рисовать объект в нужном –
видимом окне. </p>

<h2>4.4 Указание цвета и модели закраски</h2>

<p class=text align=left style='text-align:left'>OpenGL управляет цветом через
переменные состояния: текущий цвет (в RGBA режиме) и текущий цветовой индекс (в
индексном режиме). Если только вы не используете более сложную модель закраски,
например, применяя освещение или текстурирование, каждый объект рисуется с
использованием текущего цвета (или текущего цветового индекса). Посмотрите на
следующий псевдокод:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>установить_цвет(красный);<br>
  нарисовать_объект (A);<br>
  нарисовать_ объект (B);<br>
  установить_цвет(зеленый);<br>
  установить_цвет(синий);<br>
  нарисовать_ объект (C);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Объекты A и B будут нарисованы
красным цветом, а C – синим. Четвертая линия, устанавливающая текущий цвет в
зеленый, не дает никакого результата (кроме задержки по времени). Если
выключено освещение и текстурирование, то после того, как установлен текущий
цвет, все объекты, рисуемые далее, рисуются именно этим цветом, и так
происходит до того, как текущий цвет изменяется.</p>

<h2>4.4.1&nbsp; Указание цвета в RGBA режиме</h2>

<p class=text align=left style='text-align:left'>В режиме RGBA для выбора
текущего цвета используйте команды <b>glColor*()</b>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glColor3</b>{b
  s i f d ub us ui} (TYPE <i>r</i>, TYPE <i>g</i>, TYPE <i>b</i>);<br>
  void <b>glColor4</b>{b s i f d ub us ui} (TYPE <i>r</i>, TYPE <i>g</i>, TYPE <i>b</i>,
  TYPE <i>a</i>);<br>
  void <b>glColor3</b>{b s i f d ub us ui}<b>v</b> (const TYPE *<i>v</i>);<br>
  void <b>glColor4</b>{b s i f d ub us ui}<b>v</b> (const TYPE *<i>v</i>); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Устанавливает текущие красную,
зеленую, синюю и альфа величины. Эта команда может иметь до трех суффиксов,
которые разделяют команды по вариациям принимаемых параметров. Первый суффикс (<b>3</b>
или <b>4</b>) является индикатором того, передаете ли вы кроме красной, зеленой
и синей величин еще и величину альфа. Если вы не задаете альфа величину, ей
автоматически присваивается значение <i>1.0</i>. Второй суффикс определяет тип
данных для параметров: байт (byte – <b>b</b>), короткое целое (short – <b>s</b>),
целое (integer – <b>i</b>), число с плавающей точкой (float – <b>f</b>), число
с плавающей точкой двойной точности (double – <b>d</b>), беззнаковый байт
(unsigned byte – <b>ub</b>), беззнаковое короткое целое (unsigned short – <b>us</b>)
или беззнаковое целое (unsigned integer – <b>ui</b>). Третий суффикс (<b>v</b>)
является опциональным и индицирует, что аргументы передаются в виде указателя
на массив величин указанного типа.</p>

<p class=text align=left style='text-align:left'>Для версий <b>glColor*()</b>,
работающих с числами с плавающей точкой, значения параметров обычно должны
принадлежать диапазону от <i>0.0</i> до <i>1.0</i> – диапазону от минимума до
максимума величин, которые могут быть сохранены в буфере кадра. Компоненты,
указываемые в виде беззнаковых целых, линейно интерполируются в числа с
плавающей точкой таким образом, чтобы максимально допустимая для этого типа
величина была представлена числом <i>1.0</i> (полная интенсивность), а <i>0</i>
– числом <i>0.0</i> (нулевая интенсивность). Компоненты задаваемые в виде
знаковых целых линейно интерполируются до величин с плавающей точкой таким
образом, чтобы максимально допустимое положительное значение для данного типа
величина была представлена числом <i>1.0</i>, а минимально допустимая – числом <i>-1.0</i>
(таблица 4-1).</p>

<p class=text align=left style='text-align:left'>Ни величины с плавающей
точкой, ни целые не усекаются до диапазона [<i>0, 1</i>] до обновления текущего
цвета или параметров материала. Результирующие значения цвета, выпадающие за
границы диапазона [<i>0, 1</i>], усекаются до него после проведения расчетов,
связанных с освещением, до интерполяции или записи в буфер кадра. Даже если
механизм освещения выключен, цветовые компоненты усекаются перед растеризацией.</p>

<p class=text align=left style='text-align:left'>Таблица 4-1. Конверсия величин
цветовых компонентов в числа с плавающей точкой</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Суффикс</span></strong><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Тип данных</span></strong><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Минимально допустимая величина</span></strong><span
  style='font-size:8.0pt;font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Значение соответствующее минимальной величине</span></strong><span
  style='font-size:8.0pt;font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Максимально допустимая величина</span></strong><span
  style='font-size:8.0pt;font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Значение соответствующее максимальной величине</span></strong><span
  style='font-size:8.0pt;font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>b<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1-byte integer<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-128<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-1.0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>127<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1.0<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>s<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>2-byte integer<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-32,768<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-1.0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>32,768<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1.0<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>i<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>4-byte integer<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-2,147,483,648<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-1.0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>2,147,483,648<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1.0<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>ub<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>unsigned 1-byte integer<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0.0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>255<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1.0<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:5'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>us<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>unsigned 2-byte integer<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0.0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>65,535<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1.0<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:6;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>ui<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>unsigned 4-byte integer<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0.0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>4,294,967,295<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1.0<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<h2>4.4.2&nbsp; Указание цветов в индексном режиме</h2>

<p class=text align=left style='text-align:left'>В индексном режиме используйте
команду <b>glIndex*()</b> для выбора одной величины индекса в качестве текущей.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glIndex</b>{s
  i f d ub} (TYPE <i>c</i>);<br>
  void <b>glIndex</b>{s i f d ub}<b>v</b> (const TYPE *<i>c</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Устанавливает индекс текущего
цвета равным <i>c</i>. Первый суффикс этой команды индицирует тип данных для
параметров: короткое целое (short – <b>s</b>), целое (integer – <b>i</b>),
число с плавающей точкой (float – <b>f</b>), число с плавающей точкой двойной
точности (double – <b>d</b>), беззнаковый байт (unsigned byte – <b>ub</b>).
Второй опциональный суффикс (<b>v</b>) показывает, что аргумент является
массивом указанного типа (массив в данном случае содержит только одну
величину).</p>

<p class=text align=left style='text-align:left'>В разделе «Очистка окна» главы
2 вы видели спецификацию команды <b>glClearColor()</b>. Для индексного режима
также имеется соответствующая команда <b>glClearIndex()</b>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>glShadeModel</b>
  (GLenum <i>mode</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Устанавливает модель заливки.
Параметр <i>mode</i>может принимать значения GL_SMOOTH (плавная заливка – режим
по умолчанию) или GL_FLAT (плоская заливка).</p>

<p class=text align=left style='text-align:left'>При использовании плоской
заливки цвет одной отдельной вершины независимого примитива дублируется для
всех остальных вершин при визуализации этого примитива. При плавной заливке
цвет каждой вершины считается индивидуальным. Для линии цвет на протяжении
отрезка интерполируется на основании цветов на его концах. Для полигона цвета
его внутренней области интерполируются между цветами его вершин. В примере 4-1
рисуется плавно залитый треугольник, показанный на рисунке 4-6.</p>

<p class=text align=left style='text-align:left'>Рисунок 4-6. Плавно залитый
треугольник</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1112" type="#_x0000_t75" alt="" style='width:198.75pt;height:183.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image083.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов4.mht!http://www.progz.ru/images/opengl/chapter4/4-6.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=265 height=245
src="OpenGL%20Red%20Book.files/image083.jpg" v:shapes="_x0000_i1112"><![endif]></p>

<p class=text align=left style='text-align:left'>Пример 4-1. Рисование плавно
залитого треугольника: файл smooth.cpp</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>#include &lt;glut.h&gt;<br>
  <br>
  //Инициализация<br>
  void init(void)<br>
  {<br>
  &nbsp;&nbsp; glClearColor(0.0,0.0,0.0,0.0);<br>
  &nbsp;&nbsp; glShadeModel(GL_SMOOTH);<br>
  }<br>
  <br>
  //Изменение размеров окна<br>
  void reshape(int w, int h)<br>
  {<br>
  &nbsp;&nbsp; glViewport(0,0,(GLsizei) w, (GLsizei) h); <br>
  &nbsp;&nbsp; glMatrixMode(GL_PROJECTION);<br>
  &nbsp;&nbsp; glLoadIdentity();<br>
  &nbsp;&nbsp; if (w&lt;=h)<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  gluOrtho2D(0.0,30.0,0.0,30.0*(GLfloat)h/(GLfloat)w);<br>
  &nbsp;&nbsp; else<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  gluOrtho2D(0.0,30.0*(GLfloat)w/(GLfloat)h,0.0,30.0); <br>
  &nbsp;&nbsp; glMatrixMode(GL_MODELVIEW);<br>
  }<br>
  <br>
  //Рисуем треугольник <br>
  void triangle(void)<br>
  {<br>
  &nbsp;&nbsp; glBegin(GL_TRIANGLES);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glColor3f(1.0,0.0,0.0);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glVertex2f(5.0,5.0);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glColor3f(0.0,1.0,0.0);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glVertex2f(25.0,5.0);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glColor3f(0.0,0.0,1.0);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glVertex2f(5.0,25.0);<br>
  &nbsp;&nbsp; glEnd();<br>
  }<br>
  <br>
  //Отображение <br>
  void display(void)<br>
  {<br>
  &nbsp;&nbsp; glClear(GL_COLOR_BUFFER_BIT);<br>
  &nbsp;&nbsp; triangle();<br>
  &nbsp;&nbsp; glFlush();<br>
  }<br>
  <br>
  int main(int argc, char** argv)<br>
  {<br>
  &nbsp;&nbsp; glutInit(&amp;argc,argv);<br>
  &nbsp;&nbsp; glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB); <br>
  &nbsp;&nbsp; glutInitWindowSize(500,500); <br>
  &nbsp;&nbsp; glutInitWindowPosition(100,100);<br>
  &nbsp;&nbsp; glutCreateWindow(&quot;Drawing a Smooth-Shaded Triangle&quot;);<br>
  &nbsp;&nbsp; init();<br>
  &nbsp;&nbsp; glutDisplayFunc(display);<br>
  &nbsp;&nbsp; glutReshapeFunc(reshape);<br>
  &nbsp;&nbsp; glutMainLoop();<br>
  &nbsp;&nbsp; return 0;<br>
  } <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>При использовании плавной
заливки соседние пиксели имеют немного различающиеся цвета. В RGBA режиме
соседние пиксели с немного различающимся цветом выглядят одинаково, таким
образом, цвет плавно меняется по всей плоскости полигона. В индексном режиме
соседние пиксели могут ссылаться на различные элементы в цветовой таблице, в
результате они могут иметь совсем разные цвета. Соседние вхождения в цветовую
таблицу могут содержать сильно отличающиеся цвета, и плавно-закрашенный в
индексном режиме примитив может выглядеть психоделически.</p>

<p class=text align=left style='text-align:left'>Во избежание этой проблемы
следует создавать цветовую таблицу с плавно-меняющимися на протяжении всей
области индексов (или ее частей) цветами. Помните, что загрузка цветов в
цветовую таблицу осуществляется функциями вашей оконной системы, а не командами
OpenGL. Если вы используете GLUT, вы можете применять функцию <b>glutSetColor()</b>
для загрузки одного индекса в цветовой таблице указанными значениями красного,
зеленого и синего цветовых компонентов. Первым аргументов <b>glutSetColor() </b>является
индекс, а остальными – значения красного, зеленого и синего. Чтобы загрузить 32
индекса, следующих один за другим (с 16 по 47) немного отличающимися оттенками
желтого, можете использовать следующий фрагмент:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>for(i=0;i&lt;32;i++)<br>
  {<br>
  &nbsp;&nbsp; glutSetColor(16+i,1.0*(i/32.0), 1.0*(i/32.0),0.0);<br>
  }<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Теперь, если вы визуализируете
плавно-залитые полигоны, которые используют только цвета по индексам от 16 до
47, эти полигоны действительно будут залиты плавно-меняющимися оттенками
желтого цвета.</p>

<p class=text align=left style='text-align:left'>При использовании плоской
заливки цвет одной вершины определяет цвет всего примитива. Цветом для линии в
таком случае является цвет, являвшийся текущим на момент указания второй
(конечной) вершины. Для полигона цвет определяется текущим цветом на момент
указания определенной вершины в соответствии с таблицей 4-2. В таблице
предполагается, что вершины и полигоны нумеруются с 1. OpenGL строго следует
этим правилам, однако лучший способ избежать неопределенности относительно
того, как будет выглядеть примитива с плоской заливкой – это задавать один цвет
для всего примитива (для всех его вершин).</p>

<p class=text align=left style='text-align:left'>Таблица 4-2. Как OpenGL
выбирает цвет для i-ого полигона с плоской заливкой</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Тип полигона</span></strong><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Вершина, используемая для выбора цвета <i>i</i>-го полигона</span></strong><span
  style='font-size:8.0pt;font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>единичный полигон<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>triangle strip<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><i><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>i</span></i><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>+2<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>triangle fan<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><i><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>i</span></i><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>+2<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>независимый треугольник<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>3<i>i</i><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:5'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>quad strip<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>2<i>i</i>+2<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:6;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>независимый прямоугольник<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>4<i>i</i><o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:Verdana;
mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><a name=Глава5><span style='display:none;mso-hide:all'><o:p>&nbsp;</o:p></span></a></p>

<h1 align=left style='text-align:left'><span style='mso-bookmark:Глава5'>Глава
5. Освещение</span></h1>

<span style='mso-bookmark:Глава5'></span>

<p class=text align=left style='text-align:left'>Как вы могли видеть в
предыдущей главе, OpenGL вычисляет цвет каждого пикселя в результирующей,
отображаемой сцене, содержащейся в буфере кадра. Часть этого расчета зависит от
того, какое освещение используется в сцене, и как объекты сцены отражают и
поглощают свет. В качестве примера этому вспомните, что океан (или море, или
река – вообще говоря, любой водоем) имеет различный цвет в солнечный или в облачный
день. Присутствие света или облаков определяет, будет ли вода выглядеть ярко
синей или грязно зеленой. По правде говоря, большинство объектов вообще не
выглядят трехмерными, если они не освещены. На рисунке 5-1 изображено два
варианта одной и той же сферы, однако слева она изображена с применением
освещения, а справа – без.</p>

<p class=text align=left style='text-align:left'>Рисунок 5-1. Освещенная и
неосвещенная сферы</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1113" type="#_x0000_t75" alt="" style='width:459.75pt;height:183.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image084.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов5.mht!http://www.progz.ru/images/opengl/chapter5/5-1.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=613 height=245
src="OpenGL%20Red%20Book.files/image084.jpg" v:shapes="_x0000_i1113"><![endif]></p>

<p class=text align=left style='text-align:left'>Как вы можете видеть,
неосвещенная сфера ничем не отличается от двумерного круга. Это прекрасная
демонстрация того, насколько важным является взаимодействие объектов и
источников света при создании трехмерной сцены.</p>

<p class=text align=left style='text-align:left'>При использовании OpenGL вы
можете манипулировать освещением и объектами сцены для создания различных
эффектов.</p>

<h2>5.1&nbsp; Минимальные сведения об удалении невидимых граней</h2>

<p class=text align=left style='text-align:left'>Предположим, что вы рисуете
закрашенные трехмерные объекты. При использовании закрашенных полигонов задача
рисования более близких к наблюдателю объектов и отбрасывания объектов,
загороженных другими, становится очень важной.</p>

<p class=text align=left style='text-align:left'>Когда вы рисуете сцену,
состоящую из трехмерных объектов, некоторые из них могут полностью или частично
закрывать другие. Изменение точки наблюдения может изменить эти загораживающие
связи между объектами. Например, если вы посмотрите на сцену с противоположного
направления, все объекты, которые раньше были впереди других, окажутся позади
них. Для создания реалистичных сцен следует управлять подобными зависимостями.
Предположим, что ваш код выглядит следующим образом:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>while(1)<br>
  {<br>
  &nbsp;&nbsp; получить_точку_наблюдения_через_позицию_мыши();<br>
  &nbsp;&nbsp; glClear(GL_COLOR_BUFFER_BIT);<br>
  &nbsp;&nbsp; нарисовать_трехмерный_объект_A();<br>
  &nbsp;&nbsp; нарисовать_трехмерный_объект_B();<br>
  } <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>При определенных положениях
мыши, объект A может закрывать объект B. При других положениях ситуация может
быть обратной. Если не производить никаких специальных операций, предшествующий
код всегда рисует объект Bвторым (то есть поверх объекта A) вне зависимости от
точки наблюдения. В худшем случае, если объекты Aи B пересекаются друг с другом
(то есть часть объекта A закрыта объектом B, и часть объекта Bзакрыта объектом
A) изменение порядка рисования не решит проблему.</p>

<p class=text align=left style='text-align:left'>Уничтожение частей закрашенных
объектов, загороженных другими, носит название <i>удаления невидимых
поверхностей</i>. (Удаление невидимых линий, выполняющее ту же работу для
объектов, представленных в виде каркаса, несколько сложнее и здесь не
рассматривается.) Простейший способ добиться удаления невидимых поверхностей
заключается в использовании буфера глубины (иногда называемого z-буфером).</p>

<p class=text align=left style='text-align:left'>Буфер глубины ассоциирует с
каждым пикселем значение глубины (или дистанции) от плоскости наблюдения
(обычно от ближней отсекающей плоскости). Изначально, командой <b>glClear()</b>
&nbsp;с параметром GL_DEPTH_BUFFER_BIT глубина для всех пикселей
устанавливается в значение наибольшей возможной дистанции (обычно дальней
отсекающей плоскости). Затем объекты сцены могут рисоваться в любом порядке.</p>

<p class=text align=left style='text-align:left'>Графические вычисления,
производимые аппаратурой или программно, конвертируют каждую рисуемую
поверхность в набор тех пикселей окна, на которых поверхность должна появиться
в случае, если она не загорожена чем-либо другим. Кроме того, вычисляется
дистанция от плоскости наблюдения. При включенном механизме глубинной
буферизации, до того как рисуется каждый пиксель, производится сравнение его
глубины с той, которая уже хранится для данного пикселя в буфере глубины. Если
новый пиксель находится ближе (то есть перед старым), его цвет и значение
глубины заменяют имеющиеся. Если глубина нового пикселя больше, чем имеющаяся –
он загорожен и его данные (цвет и глубина) отбрасываются.</p>

<p class=text align=left style='text-align:left'>Для того, чтобы использовать
глубинную буферизацию, вы должны ее активизировать (включить). Это должно быть
сделано только единожды. Каждый раз при отрисовке сцены, до начала фактического
рисования, вы должны очистить буфер глубины, затем вы можете рисовать объекты в
любом порядке.</p>

<p class=text align=left style='text-align:left'>Модификация предыдущего
примера кода для использования в нем буфера глубины и выполнения удаления
невидимых поверхностей должна выглядеть следующим образом:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>glutInitDisplayMode(GLUT_DEPTH|...);<br>
  glEnable(GL_DEPTH_TEST);<br>
  <br>
  ...<br>
  <br>
  while(1)<br>
  {<br>
  &nbsp;&nbsp; glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);<br>
  &nbsp;&nbsp; </span><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>получить</span><span
  lang=EN-US style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:
  "Courier New";color:black;mso-ansi-language:EN-US'>_</span><span
  style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:"Courier New";
  color:black'>точку</span><span lang=EN-US style='font-size:8.5pt;font-family:
  Courier;mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:
  EN-US'>_</span><span style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:
  "Courier New";color:black'>наблюдения</span><span lang=EN-US
  style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:"Courier New";
  color:black;mso-ansi-language:EN-US'>_</span><span style='font-size:8.5pt;
  font-family:Courier;mso-bidi-font-family:"Courier New";color:black'>через</span><span
  lang=EN-US style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:
  "Courier New";color:black;mso-ansi-language:EN-US'>_</span><span
  style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:"Courier New";
  color:black'>позицию</span><span lang=EN-US style='font-size:8.5pt;
  font-family:Courier;mso-bidi-font-family:"Courier New";color:black;
  mso-ansi-language:EN-US'>_</span><span style='font-size:8.5pt;font-family:
  Courier;mso-bidi-font-family:"Courier New";color:black'>мыши</span><span
  lang=EN-US style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:
  "Courier New";color:black;mso-ansi-language:EN-US'>();<br>
  &nbsp;&nbsp; </span><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>нарисовать</span><span
  lang=EN-US style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:
  "Courier New";color:black;mso-ansi-language:EN-US'>_</span><span
  style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:"Courier New";
  color:black'>трехмерный</span><span lang=EN-US style='font-size:8.5pt;
  font-family:Courier;mso-bidi-font-family:"Courier New";color:black;
  mso-ansi-language:EN-US'>_</span><span style='font-size:8.5pt;font-family:
  Courier;mso-bidi-font-family:"Courier New";color:black'>объект</span><span
  lang=EN-US style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:
  "Courier New";color:black;mso-ansi-language:EN-US'>_A();<br>
  &nbsp;&nbsp; </span><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>нарисовать</span><span
  lang=EN-US style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:
  "Courier New";color:black;mso-ansi-language:EN-US'>_</span><span
  style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:"Courier New";
  color:black'>трехмерный</span><span lang=EN-US style='font-size:8.5pt;
  font-family:Courier;mso-bidi-font-family:"Courier New";color:black;
  mso-ansi-language:EN-US'>_</span><span style='font-size:8.5pt;font-family:
  Courier;mso-bidi-font-family:"Courier New";color:black'>объект</span><span
  lang=EN-US style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:
  "Courier New";color:black;mso-ansi-language:EN-US'>_B();<br>
  } <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Используемый для <b>glClear()</b>
аргумент очищает и цветовой, и глубинный буферы.</p>

<p class=text align=left style='text-align:left'>Тест буфера глубины может
повлиять на быстродействие вашей программы. Поскольку пиксельная информация
часто отбрасывается, а не используется для рисования, удаление невидимых граней
может несколько увеличить быстродействие. Однако наиболее большое значение для
быстродействия имеет реализация буфера глубины. «Программный» буфер глубины
(реализованный с использованием процессорной памяти) может быть намного
медленнее, чем тот, который реализован с использованием специализированного
аппаратного буфера.</p>

<h2>5.2&nbsp; Освещение в реальном мире и в OpenGL </h2>

<p class=text align=left style='text-align:left'>Когда вы смотрите на
физическую поверхность, ваше восприятие цвета зависит от распределения
протонов, которые поступают в глаз и активизируют колбочки на сетчатке. Эти
протоны исходят от источника света или комбинации источников. Часть этих
протонов поглощается поверхностью, другая часть отражается ей. Вдобавок к этому
разные поверхности могут иметь разные свойства – некоторые выглядят блестящими
и отражают свет преимущественно в определенных направлениях, другие
распределяют поступающий свет одинаково во всех направлениях. Большинство
поверхностей являются чем-то средним между двумя описанными.</p>

<p class=text align=left style='text-align:left'>OpenGL рассчитывает свет и
освещение так, как будто свет может быть разделен на красный, зеленый и синий
компоненты. Таким образом, источник света характеризуется количеством красного,
зеленого и синего света, которое он излучает, а материал поверхности
характеризуется долями красного, зеленого и синего компонентов, которые он
отражает в различных направлениях. Уравнения освещенности в OpenGL являются
всего лишь аппроксимациями, но зато они работают достаточно хорошо и могут быть
вычислены относительно быстро. Если вам требуется более точная (или просто
другая) модель освещения, реализовывать ее самостоятельно. Такие расчеты могут
быть весьма сложны – чтение книг по оптической физике в течение нескольких
часов, возможно, убедит вас в этом.</p>

<p class=text align=left style='text-align:left'>В модели освещения OpenGL свет
исходит от нескольких источников, которые могут включаться и выключаться
индивидуально. Часть света обычно исходит из какого-либо определенного
направления или позиции, часть распределена по всей сцене. Например, если вы включите
лампочку в комнате, большая часть света будет исходить от нее, но часть света
падает на поверхности предметов в комнате после того, как он отразился от
одной, двух, трех или более стен. Считается, что этот многократно отраженный
свет (называемый <i>фоновым</i> светом) распределен настолько сильно, что не
существует никакого способа определить его исходное направление, однако он
исчезает при выключении определенного источника света.</p>

<p class=text align=left style='text-align:left'>Наконец, в сцене может также
присутствовать общий фоновый свет, у которого нет никакого конкретного
источника, как будто он был отражен столько раз и распределен так сильно, что
его оригинальный источник установить невозможно.</p>

<p class=text align=left style='text-align:left'>В модели OpenGL эффект от
источника света присутствует только если есть поверхности поглощающие или отражающие
свет. Считается, что каждая поверхность состоит из материала с несколькими
свойствами. Материал может излучать свой собственный свет (например, фара
автомобиля), он может распределять некоторое количество входящего света во всех
направлениях, также он может отражать часть света в определенном направлении
(например, зеркало или другая блестящая поверхность).</p>

<p class=text align=left style='text-align:left'>В модели освещения OpenGL
предполагается, что освещение может быть разделено на 4 компонента: фоновое (<i>ambient</i>),
диффузное (<i>diffuse</i>), зеркальное (<i>specular</i>) и исходящее
(эмиссионное – <i>emissive</i>). Все 4 компонента рассчитываются независимо и
только затем суммируются.</p>

<h2>5.2.1&nbsp; Фоновый, диффузный, зеркальный и исходящий свет</h2>

<p class=text align=left style='text-align:left'><i>Фоновоее</i> излучение –
это свет, который настолько распределен средой (предметами, стенами и так
далее), что его направление определить невозможно – кажется, что он исходит
отовсюду. Лампа дневного света имеет большой фоновый компонент, поскольку
большая часть света, достигающего вашего глаза, сначала отражается от множества
поверхностей. Уличный фонарь имеет маленький фоновый компонент: большая часть
его света идет в одном направлении, кроме того, поскольку он находится на
улице, очень небольшая часть света попадает вам в глаз после того, как
отразится от других объектов. Когда фоновый свет падает на поверхность, он
одинаково распределяется во всех направлениях.</p>

<p class=text align=left style='text-align:left'><i>Диффузный</i> компонент –
это свет, идущий из одного направления, таким образом, он выглядит ярче, если
падает на поверхность под прямым углом, и выглядит тусклым, если касается ее всего
лишь вскользь. Однако, когда он падает на поверхность, он распределяется
одинаково во всех направлениях, то есть его яркость одинакова вне зависимости
от того, с какой стороны вы смотрите на поверхность. Вероятно, любой свет,
исходящий из определенного направления или позиции, имеет диффузный компонент.</p>

<p class=text align=left style='text-align:left'><i>Зеркальный</i> свет исходит
из определенного направления и отражается от поверхности в определенном
направлении. При отражении хорошо сфокусированного лазерного луча от
качественного зеркала происходит почти 100 процентное зеркальное отражение.
Блестящий метал или пластик имеет высокий зеркальный компонент, а кусок ковра
или плюшевая игрушка – нет. Вы можете думать о зеркальности как о том,
насколько блестящим выглядит материал.</p>

<p class=text align=left style='text-align:left'>Помимо фонового, диффузного и зеркального
цветов, материалы могут также иметь <i>исходящий</i> цвет, имитирующий свет,
исходящий от самого объекта. В модели освещения OpenGLисходящий свет
поверхности добавляет объекту интенсивности, но на него не влияют никакие
источники света, и он не производит дополнительного света для сцены в целом.</p>

<p class=text align=left style='text-align:left'>Хотя источник света излучает
единое распределение частот, фоновый, диффузный и зеркальный компоненты могут
быть различны. Например, если в вашей комнате красные стены и белый свет, то
этот свет, отражаясь от стен будет скорее красным, чем белым (несмотря на то,
что падающий на стену свет -- белый). OpenGL позволяет устанавливать значения
красного, зеленого и синего независимо для каждого компонента света.</p>

<h2>5.2.2&nbsp; Цвета материала</h2>

<p class=text align=left style='text-align:left'>Модель освещения OpenGLделает
допущение о том, что цвет материала зависит от долей падающего красного,
зеленого и синего света, которые он отражает. Например, максимально красный шар
отражает весь красный свет, который на него падает и поглощает весь зеленый и
синий. Если вы посмотрите на такой мяч под белым светом (состоящим из
одинакового количества красного, зеленого и синего), весь красный свет
отразится, и вы увидите красный мяч. Если смотреть на мяч при красном свете, он
также будет выглядеть красным. Если, однако, посмотреть на него под зеленым
светом, он будет выглядеть черным (весь зеленый свет поглотится, а красного
нет, то есть никакой свет отражен не будет).</p>

<p class=text align=left style='text-align:left'>Также как и свет, материалы
имеют разные фоновый, диффузный и зеркальный цвета, которые задают реакцию
материала на фоновый, диффузный и зеркальный компоненты света. Фоновый цвет
материала комбинируется с фоновым компонентом всех источников света, диффузный
цвет с диффузным компонентом, а зеркальный с зеркальным. Фоновый и диффузный
цвета задают видимый цвет материала, они обычно близки, если не эквивалентны.
Зеркальный цвет обычно белый или серый. Он задет цвет блика на объекте (то есть
он может совпадать с зеркальным компонентом источника света).</p>

<h2>5.2.3&nbsp; RGB– величины для света и материалов</h2>

<p class=text align=left style='text-align:left'>Цветовые компоненты,
задаваемые для источников света, означают совсем не то же самое, что для
материалов. Для источника света число представляет собой процент от полной
интенсивности каждого цвета. Если R, G и B – величины цвета источника света все
равны 1.0, свет будет максимально белым. Если величины будут равны 0.5, свет
все равно останется белым, но лишь с половиной интенсивности (он будет казаться
серым). Если R=G=1 и B=0 (полный красный, полный зеленый, отсутствие синего),
свет будет желтым.</p>

<p class=text align=left style='text-align:left'>Для материалов числа
соответствуют отраженным пропорциям этих цветов. Так что, если для материала
R=1, G=0.5 и B=0, этот материал отражает весь красный свет, половину зеленого и
совсем не отражает синего. Другими словами, если обозначить компоненты
источника света как (LR, LG, LB), а компоненты материала как (MR, MG, MB) и
проигнорировать все остальные взаимодействия, то свет, который поступит в глаз
можно определить как (LR–MR, LG–MG, LB–MB).</p>

<p class=text align=left style='text-align:left'>Похожим образом, если два
источника света с характеристиками (R1, G1, B1) и (R2, G2, B2) направлены в
глаз, OpenGLсложит компоненты: (R1+R2, G1+G2, B1+B2). Если какая-либо из сумм
будет больше 1 (соответствуя цвету, который нельзя отобразить), компонент будет
урезан до 1.</p>

<h2>5.3&nbsp; Простой пример: отображение освещенной сферы</h2>

<p class=text align=left style='text-align:left'>Чтобы добавить на вашу сцену
освещение, требуется выполнить несколько шагов:</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l68 level1 lfo17;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>1.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Определить вектор нормали для каждой вершины
каждого объекта. Эти нормали задают ориентацию объекта по отношению к
источникам света. </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l68 level1 lfo17;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>2.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Создать, выбрать и позиционировать один или
более источников света. </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l68 level1 lfo17;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>3.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Создать и выбрать <i>модель освещения</i>,
которая определяет уровень глобального фонового света и эффективное положение
точки наблюдения (для вычислений, связанных с освещением). </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l68 level1 lfo17;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>4.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Задать свойства материала для объектов сцены. </p>

<p class=text align=left style='text-align:left'>Эти шаги выполняются в примере
5-1. Он отображает сферу, освещенную единственным источником света,
отображенным ранее на рисунке 5-1.</p>

<p class=text align=left style='text-align:left'>Пример 5-1. Рисуем освещенную
сферу: файл light. </p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>#include
  &lt;glut.h&gt;<br>
  <br>
  //</span><span style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:
  "Courier New";color:black'>Инициализация</span><span lang=EN-US
  style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:"Courier New";
  color:black;mso-ansi-language:EN-US'><br>
  void init(void)<br>
  {<br>
  &nbsp;&nbsp; GLfloat mat_specular[]={1.0,1.0,1.0,1.0};<br>
  &nbsp;&nbsp; GLfloat mat_shininess[]={50.0};<br>
  &nbsp;&nbsp; GLfloat light_position[]={1.0,1.0,1.0,0.0};<br>
  &nbsp;&nbsp; GLfloat white_light[]={1.0,1.0,1.0,1.0};<br>
  <br>
  &nbsp;&nbsp; glClearColor(0.0,0.0,0.0,0.0); <br>
  &nbsp;&nbsp; glShadeModel(GL_SMOOTH);<br>
  &nbsp;&nbsp; glMaterialfv(GL_FRONT,GL_SPECULAR,mat_specular); <br>
  &nbsp;&nbsp; glMaterialfv(GL_FRONT,GL_SHININESS,mat_shininess); <br>
  &nbsp;&nbsp; glLightfv(GL_LIGHT0,GL_POSITION,light_position); <br>
  &nbsp;&nbsp; glLightfv(GL_LIGHT0,GL_DIFFUSE,white_light); <br>
  &nbsp;&nbsp; glLightfv(GL_LIGHT0,GL_SPECULAR,white_light);<br>
  <br>
  &nbsp;&nbsp; glEnable(GL_LIGHTING);<br>
  &nbsp;&nbsp; glEnable(GL_LIGHT0);<br>
  &nbsp;&nbsp; glEnable(GL_DEPTH_TEST);<br>
  }<br>
  <br>
  //</span><span style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:
  "Courier New";color:black'>Отображение</span><span lang=EN-US
  style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:"Courier New";
  color:black;mso-ansi-language:EN-US'> <br>
  void display(void)<br>
  {<br>
  &nbsp;&nbsp; glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);<br>
  &nbsp;&nbsp; glutSolidSphere(1.0,40,16);<br>
  &nbsp;&nbsp; glFlush();<br>
  }<br>
  <br>
  //</span><span style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:
  "Courier New";color:black'>Изменение</span><span style='font-size:8.5pt;
  font-family:Courier;mso-bidi-font-family:"Courier New";color:black;
  mso-ansi-language:EN-US'> </span><span style='font-size:8.5pt;font-family:
  Courier;mso-bidi-font-family:"Courier New";color:black'>размеров</span><span
  style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:"Courier New";
  color:black;mso-ansi-language:EN-US'> </span><span style='font-size:8.5pt;
  font-family:Courier;mso-bidi-font-family:"Courier New";color:black'>окна</span><span
  lang=EN-US style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:
  "Courier New";color:black;mso-ansi-language:EN-US'> <br>
  void reshape(int w, int h)<br>
  {<br>
  &nbsp;&nbsp; glViewport(0,0,(GLsizei) w, (GLsizei) h); <br>
  &nbsp;&nbsp; glMatrixMode(GL_PROJECTION);<br>
  &nbsp;&nbsp; glLoadIdentity();<br>
  &nbsp;&nbsp; if (w&lt;=h) <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  glOrtho(-1.5,1.5,-0.5*(GLfloat)h/(GLfloat)w,0.5*(GLfloat)h/(GLfloat)w,-10.0,10.0);<br>
  &nbsp;&nbsp; else<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  glOrtho(-1.5*(GLfloat)w/(GLfloat)h,1.5*(GLfloat)w/(GLfloat)h,-1.5,1.5,-10.0,10.0);
  <br>
  &nbsp;&nbsp; glMatrixMode(GL_MODELVIEW);<br>
  &nbsp;&nbsp; glLoadIdentity();<br>
  }<br>
  <br>
  int main(int argc, char **argv)<br>
  {<br>
  &nbsp;&nbsp; glutInit(&amp;argc,argv);<br>
  &nbsp;&nbsp; glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB|GLUT_DEPTH);<br>
  &nbsp;&nbsp; glutInitWindowSize(500,500);<br>
  &nbsp;&nbsp; glutInitWindowPosition(100,100);<br>
  &nbsp;&nbsp; glutCreateWindow(&quot;Rendering a Lit Sphere&quot;);<br>
  &nbsp;&nbsp; init();<br>
  &nbsp;&nbsp; glutDisplayFunc(display);<br>
  &nbsp;&nbsp; glutReshapeFunc(reshape); <br>
  &nbsp;&nbsp; glutMainLoop();<br>
  &nbsp;&nbsp; return 0;<br>
  } <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Вызовы команд, связанных с
освещением помещены в функцию <b>init()</b>. Эти вызовы коротко обсуждают в
следующих параграфах и более детально позже в этой главе. Один из моментов,
связанных с примером 5-1, который стоит отметить, заключается в том, что
используется цветовой режим RGBA, а не индексный. OpenGL по-разному
рассчитывает освещенность для этих двух режимах, и, вообще говоря, возможности
освещения в индексном режиме весьма ограничены. Таким образом, если вам
необходимо освещение, режим RGBAболее предпочтителен, и во всех примерах этой
главы используется именно он.</p>

<h2>5.3.1&nbsp; Определение вектора нормали для каждой вершины каждого объекта</h2>

<p class=text align=left style='text-align:left'>Нормали объекта задают его
ориентацию относительно источников света. OpenGLиспользует нормаль вершины для
определения того, как много света эта вершина получает от каждого источника. В
приведенном примере процесс определения нормалей происходит внутри функции <b>glutSolidSphere()</b>.</p>

<p class=text align=left style='text-align:left'>Для правильного освещения
нормали поверхности должны иметь единичную длину. Вы должны быть осторожны и
помнить, что матрица модельного преобразования не масштабирует вектора нормалей
автоматически, и результирующие нормали могут уже не иметь единичную длину.
Чтобы убедиться, что нормали имеют единичную длину, возможно, вам придется
вызвать команду <b>glEnable()</b> с аргументами GL_NORMALIZE или
GL_RESCALE_NORMAL.</p>

<p class=text align=left style='text-align:left'>GL_RESCALE_NORMALведет к тому,
что каждый компонент вектора нормали к поверхности будет умножен на одно и то
же число, извлеченное из матрицы модельных преобразований. Таким образом,
операция работает корректно только в случае, если нормали масштабировались
равномерно и изначально имели единичную длину.</p>

<p class=text align=left style='text-align:left'>GL_NORMALIZE– более сложная
операция, чем GL_RESCALE_NORMAL. Когда активизирован механизм нормализации
(GL_NORMALIZE), сначала вычисляется длина вектора нормали, а затем каждый из
компонентов вектора делится на это число. Эта операция гарантирует, что
результирующие нормали будут иметь единичную длину, но она может быть более
затратной в смысле скорости, чем простое масштабирование нормалей.</p>

<p class=warning>Замечание: Некоторые реализации OpenGL могут выполнять
операцию GL_RESCALE_NORMAL не за счет простого масштабирования, а путем все той
же полной нормализации (GL_NORMALIZE). Однако не существует способа выяснить
так ли это в вашей реализации, и, в любом случае, вы не должны полагаться на
это.</p>

<h2>5.3.2&nbsp; Создание, позиционирование и включение одного или более
источников света</h2>

<p class=text align=left style='text-align:left'>В примере 5-1 используется
всего один источник белого света. Его местоположение задается вызовом команды <b>glLightfv()</b>.
В этом примере для нулевого источника света (GL_LIGHT0) задается белый цвет для
диффузного и зеркального отражения. Если вам требуется свет другого цвета,
измените параметры <b>glLight*()</b>.</p>

<p class=text align=left style='text-align:left'>Кроме того, вы можете добавить
к вашей сцене как минимум 8 источников света различных цветов. (Конкретная
реализация OpenGL может позволять и больше 8-ми источников.) По умолчанию цвет
всех источников света кроме GL_LIGHT0 – черный. Вы можете располагать источники
света везде, где только захотите, например, близко к сцене (как настольную
лампу) или бесконечно далеко за ней (симулирую солнечный свет). Кроме того, вы
можете управлять тем, испускает ли источник сфокусированный, узкий луч или
более широкий. Помните, что каждый источник света требует дополнительных (и
немалых) расчетов для отображения сцены, так что быстродействие вашего
приложение зависит от количества источников.</p>

<p class=text align=left style='text-align:left'>После настройки параметров
источника света вы должны активизировать его командой <b>glEnable()</b>. Кроме
того, вы должны вызвать команду <b>glEnable()</b> с аргументом GL_LIGHTING,
чтобы подготовить OpenGLк выполнению расчетов, связанных с освещением.</p>

<h2>5.3.3&nbsp; Выбор модели освещения</h2>

<p class=text align=left style='text-align:left'>Как вы можете ожидать,
параметры модели освещения описываются командой <b>glLightModel*()</b>. В
примере 5-1 единственным задаваемым параметром модели освещения является
глобальное фоновое освещение. Модель освещения также позволяет указывать, где
находится предполагаемое местоположение наблюдателя: бесконечно далеко или локально
по отношению к сцене, и должны ли вычисления производиться по-разному для
лицевых и обратных поверхностей объектов. В примере 5-1 используются значения
по умолчанию для двух аспектов модели – наблюдатель находится бесконечно далеко
(режим «бесконечно удаленного наблюдателя») и одностороннее освещение.
Использование режима «локального наблюдателя» заставляет производить намного
больший объем сложных расчетов, так как OpenGL должна вычислить угол между
точкой наблюдения и каждым объектом. В режиме «бесконечно удаленного
наблюдателя», однако, этот угол игнорируется, и результат может быть несколько
менее реалистичным. Далее, поскольку в примере 5-1 обратная поверхность сферы
никогда не видна (она находится внутри сферы), достаточно одностороннего освещения.</p>

<h2>5.3.4&nbsp; Определение свойств материала для объектов сцены</h2>

<p class=text align=left style='text-align:left'>Свойства материала объектов
определяют, как он отражает свет и, таким образом, из какого реального
материала он сделан (в зрительном восприятии). Поскольку взаимодействие между
поверхностью материала и входящим светом достаточно сложное, довольно трудно
задать такие параметры материала, чтобы объект имел определенный, желаемый вид.
Вы можете задавать фоновый, диффузный и зеркальный цвета материала и то,
насколько блестящим он будет выглядеть. В приведенном примере с помощью команды
<b>glMaterialfv()</b> были явно заданы только два свойства материала:
зеркальный цвет материала и исходящий цвет.</p>

<h2>5.3.5&nbsp; Несколько важных замечаний</h2>

<p class=text align=left style='text-align:left'>Когда вы пишете свою
собственную программу с освещением, всегда помните, что для некоторых его
параметров вы можете использовать значения по умолчанию, тогда как другие
должны быть заданы явно. Кроме того, не забудьте включить все описанные вами
источники света, а также сам механизм расчетов, связанных с освещением.
Наконец, помните, что вы можете использовать дисплейные списки (списки
отображения), чтобы максимизировать эффективность при изменении условий
освещения.</p>

<h2>5.4&nbsp; Создание источников света</h2>

<p class=text align=left style='text-align:left'>Источники света имеют
несколько параметров, таких как цвет, позиция и направление. Следующие разделы
объясняют, как контролировать эти свойства, на что будет похож результирующий
источник света. Команда, используемая для указания всех параметров света – это <b>glLight*()</b>.
Она принимает три аргумента: идентификатор источника света, имя свойства и
желаемое для него значение.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glLight</b>{if}
  (GLenum <i>light</i>, GLenum <i>pname</i>, TYPE <i>param</i>);<br>
  void <b>glLight</b>{if}<b>v</b> (GLenum <i>light</i>, GLenum <i>pname</i>,
  TYPE *<i>param</i>); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Создает источник, задаваемый
параметром <i>light</i> (который может принимать значения GL_LIGHT0, GL_LIGHT1,
..., GL_LIGHT7). Задаваемая характеристика света определяется аргументом <i>pname</i>
в виде константы (таблица 5-1). В параметре <i>param</i> задается значение или
значения, в которые следует установить характеристику <i>pname</i>. Если
используется векторная версия команды, <i>param </i>представляет собой вектор
величин, а если невекторная, то <i>param</i> – одно единственное значение.
Невекторная версия команды может использоваться только для указания параметров,
чье значение выражается одним числом.</p>

<p class=text align=left style='text-align:left'>Таблица 5-1. Значения по
умолчанию для свойств источника света</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Имена параметров</span></strong><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Значения по умолчанию</span></strong><span style='font-size:
  8.0pt;font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Смысл</span></strong><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_AMBIENT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>(0.0,0.0,0.0,1.0)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Интенсивность фонового света<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_DIFFUSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>(1.0,1.0,1.0,1.0)<br>
  или<br>
  (0.0,0.0,0.0,1.0)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Интенсивность диффузного света (значение по умолчанию для 0-го
  источника - белый свет, для остальных - черный)<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_SPECULAR<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>(1.0,1.0,1.0,1.0)<br>
  или<br>
  (0.0,0.0,0.0,1.0)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Интенсивность зеркального света (значение по умолчанию для 0-го
  источника - белый свет, для остальных - черный)<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_POSITION<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>(0.0,0.0,1.0,0.0)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Положение источника света (<i>x</i>,<i>y</i>,<i>z</i>,<i>w</i>)<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:5'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_SPOT_DIRECTION<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>(0.0,0.0,-1.0)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Направление света прожектора (<i>x</i>,<i>y</i>,<i>z</i>)<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:6'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_SPOT_EXPONENT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0.0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Концентрация светового луча<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:7'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_SPOT_CUTOFF<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>180.0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Угловая ширина светового луча<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:8'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_CONSTANT_ATTENUATION<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1.0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Постоянный фактор ослабления<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:9'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_LINEAR_ATTENUATION<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0.0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Линейный фактор ослабления<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:10;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_QUADRATIC_ATTENUATION<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0.0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Квадратичный фактор ослабления<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=warning>Замечание: Значения по умолчанию для GL_DIFFUSEи GL_SPECULAR в
таблице 5-1 различаются для GL_LIGHT0 и других источников света (GL_LIGHT1,
GL_LIGHT2, ...). Для параметров GL_DIFFUSEи GL_SPECULAR источника света
GL_LIGHT0 значение по умолчанию – (1.0, 1.0, 1.0, 1.0). Для других источников
света значение тех же параметров по умолчанию – (0.0, 0.0, 0.0, 1.0).</p>

<p class=text align=left style='text-align:left'>В примере 5-2 показано, как
использовать <b>glLight*()</b>:</p>

<p class=text align=left style='text-align:left'>Пример 5-2. Указание цветов и
позиции для источников света</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>GLfloat
  light_ambient[]={0.0,0.0,0.0,1.0};<br>
  GLfloat light_diffuse[]={1.0,1.0,1.0,1.0};<br>
  GLfloat light_specular[]={1.0,1.0,1.0,1.0};<br>
  GLfloat light_position[]={1.0,1.0,1.0,0.0};<br>
  <br>
  glLightfv(GL_LIGHT0,GL_AMBIENT, light_ambient);<br>
  glLightfv(GL_LIGHT0,GL_DIFFUSE, light_diffuse);<br>
  glLightfv(GL_LIGHT0,GL_SPECULAR, light_specular);<br>
  glLightfv(GL_LIGHT0,GL_POSITION, light_position);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Как вы можете видеть, для
величин параметров определены массивы, и для установки этих параметров
несколько раз вызывается команда <b>glLightfv()</b>. В этом примере первые три
вызова <b>glLightfv() </b>являются избыточными, поскольку они используются для
указания таких же значений параметров GL_AMBIENT, GL_DIFFUSE и GL_SPECULAR,
какие установлены по умолчанию.</p>

<p class=warning>&nbsp;Замечание: Помните, что каждый источник света нужно
включить командой <b>glEnable()</b>.</p>

<p class=text align=left style='text-align:left'>Все параметры команды <b>glLight*()</b>
и их возможные значения описываются в следующих разделах. Эти параметры
взаимодействуют с параметрами модели освещения конкретной сцены и параметрами
материала объектов.</p>

<h2>5.4.1&nbsp; Цвет</h2>

<p class=text align=left style='text-align:left'>OpenGL позволяет вам
ассоциировать с каждым источником света три различных параметра, связанных с
цветом: GL_AMBIENT, GL_DIFFUSEи GL_SPECULAR. Параметр GL_AMBIENT задает RGBA
интенсивность фонового света, который каждый отдельный источник света добавляет
к сцене. Как вы можете видеть в таблице 5-1, по умолчанию источник сета не
добавляет к сцене фонового света, так как значение по умолчанию для GL_AMBIENT
равно (0.0, 0.0, 0.0, 1.0). Именно эта величина была использована в примере
5-1. Если бы для того же источника света был задан синий фоновый свет,</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>GLfloat
  light_ambient[]={0.0,0.0,1.0,1.0};<br>
  glLightfv(GL_LIGHT0,GL_AMBIENT,light_ambient); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>то результат был бы таким,
какой показан на рисунке 5-2. </p>

<p class=text align=left style='text-align:left'>Рисунок 5-2. Сфера, освещенная
одним источником, добавляющим синий фоновый свет</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1114" type="#_x0000_t75" alt="" style='width:188.25pt;height:180pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image085.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов5.mht!http://www.progz.ru/images/opengl/chapter5/5-2.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=251 height=240
src="OpenGL%20Red%20Book.files/image085.jpg" v:shapes="_x0000_i1114"><![endif]></p>

<p class=text align=left style='text-align:left'>Параметр GL_DIFFUSE наверное
наиболее точно совпадает с тем, что вы привыкли называть «цветом света». Он
определяет RGBA цвет диффузного света, который отдельный источник света
добавляет к сцене. По умолчанию для GL_LIGHT0 параметр GL_DIFFUSE равен (1.0,
1.0, 1.0, 1.0), что соответствует яркому белому свету. Значение по умолчанию
для всех остальных источников света (GL_LIGHT1, GL_LIGHT2, ..., GL_LIGHT7)
равно (0.0, 0.0, 0.0, 0.0).</p>

<p class=text align=left style='text-align:left'>Параметр GL_AMBIENT влияет на
цвет зеркального блика на объекте. В реальном мире на объектах вроде стеклянной
бутылки имеется зеркальный блик соответствующего освещению цвета (часто
белого). Для создания эффекта реалистичности установите GL_SPECULAR в то же
значение, что и GL_DIFFUSE. По умолчанию GL_SPECULAR равно (1.0, 1.0, 1.0, 1.0)
для GL_LIGHT0 и (0.0, 0.0, 0.0, 0.0) для остальных источников.</p>

<p class=warning>&nbsp;Замечание: Альфа компонент всех этих цветов
используется, только если включено цветовое наложение.</p>

<h2>5.4.2&nbsp; Позиция и ослабление</h2>

<p class=text align=left style='text-align:left'>Как было отмечено ранее, вы
можете выбрать, следует ли считать источник света расположенным бесконечно
далеко от сцены или близко к ней. На источники света первого типа ссылаются как
на <i>направленные </i>(directional): эффект от бесконечно далекого
расположения источника заключается в том, что все лучи его света могут
считаться параллельными к моменту достижения объекта. Примером реального
направленного источника света может служить солнце. Источники второго типа
называются <i>позиционными</i> (positional), поскольку их точное положение на
сцене определяет их эффект и, в частности, направление из которого идут лучи.
Примером позиционного источника света является настольная лампа. Свет,
используемый в примере 5-1, является направленным:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>GLfloat
  light_position[]={1.0,1.0,1.0,0.0};<br>
  glLightfv(GL_LIGHT0, GL_POSITION, light_position); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Как видно, для параметра
GL_POSITION вы задаете вектор из четырех величин (<i>x</i>, <i>y</i>, <i>z</i>,
<i>w</i>). Если последняя величина <i>w </i>равна 0, соответствующий источник
света считается направленным, и величины (<i>x</i>, <i>y</i>, <i>z</i>)
определяют его направление. Это направление преобразуется видовой матрицей. По
умолчанию параметру GL_POSITION соответствуют значения (0, 0, 1, 0), что задает
свет, направленный вдоль отрицательного направления оси <i>z</i>. (Заметьте,
что никто не запрещает вам создать свет, направленный в (0, 0, 0), однако такой
свет не даст должного эффекта).</p>

<p class=text align=left style='text-align:left'>Если значение <i>w </i>не
равно 0, свет является позиционным, и величины (<i>x</i>, <i>y</i>, <i>z</i>)
задают его местоположение источника света в однородных объектных координатах.
Это положение преобразуется видовой матрицей и сохраняется в видовых
координатах. Кроме того, по умолчанию позиционный свет излучается во всех
направлениях, но вы можете ограничить распространение света, создав конус
излучения, определяющий прожектор.</p>

<p class=warning>Замечание: Помните, что цвета по всей плавно залитой грани
полигона определяются цветами, вычисляемыми для его вершин. Возможно, из-за
этого вам следует избегать применения больших полигонов вместе с локальным
источником света. Если вы разместите источник света близко к центру полигона,
вершины могут быть слишком далеки от него и не получат достаточно света. В
результате весь полигон будет выглядеть темнее, чем вы ожидали. Во избежание
подобной ситуации разбивайте крупные полигоны на более мелкие составляющие.</p>

<p class=text align=left style='text-align:left'>В реальном мире интенсивность
света уменьшается с увеличением дистанции от его источника. Поскольку источник
направленного света считается бесконечно удаленным, нет смысла ослаблять его
интенсивность с увеличением дистанции, так что ослабление для направленных
источников света не рассчитывается. Однако вам может понадобиться задать
ослабление света от позиционного источника. OpenGL выполняет ослабление
источника света, умножая его интенсивность на фактор ослабления: </p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1115" type="#_x0000_t75" alt="" style='width:128.25pt;height:40.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image086.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов5.mht!http://www.progz.ru/images/opengl/chapter5/form1.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=171 height=54
src="OpenGL%20Red%20Book.files/image086.gif" v:shapes="_x0000_i1115"><![endif]>,</p>

<p class=text align=left style='text-align:left'>где <i>d</i> - расстояние
между позицией источника света и вершиной,<br>
<!--[if gte vml 1]><v:shape id="_x0000_i1116" type="#_x0000_t75" alt=""
 style='width:15pt;height:16.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image087.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов5.mht!http://www.progz.ru/images/opengl/chapter5/form2.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=20 height=22
src="OpenGL%20Red%20Book.files/image087.gif" v:shapes="_x0000_i1116"><![endif]>-
GL_CONSTANT_ATTENUATION (постоянный фактор ослабления),<br>
<!--[if gte vml 1]><v:shape id="_x0000_i1117" type="#_x0000_t75" alt=""
 style='width:12.75pt;height:17.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image088.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов5.mht!http://www.progz.ru/images/opengl/chapter5/form3.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=17 height=23
src="OpenGL%20Red%20Book.files/image088.gif" v:shapes="_x0000_i1117"><![endif]>-
GL_LINEAR_ATTENUATION (линейный фактор ослабления),<br>
<!--[if gte vml 1]><v:shape id="_x0000_i1118" type="#_x0000_t75" alt=""
 style='width:14.25pt;height:18pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image089.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов5.mht!http://www.progz.ru/images/opengl/chapter5/form4.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=19 height=24
src="OpenGL%20Red%20Book.files/image089.gif" v:shapes="_x0000_i1118"><![endif]>-
GL_QUADRATIC_ATTENUATION (квадратичный фактор ослабления).</p>

<p class=text align=left style='text-align:left'>По умолчанию <!--[if gte vml 1]><v:shape
 id="_x0000_i1119" type="#_x0000_t75" alt="" style='width:15pt;height:16.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image087.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов5.mht!http://www.progz.ru/images/opengl/chapter5/form2.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=20 height=22
src="OpenGL%20Red%20Book.files/image087.gif" v:shapes="_x0000_i1119"><![endif]>&nbsp;равно
1.0, а <!--[if gte vml 1]><v:shape id="_x0000_i1120" type="#_x0000_t75" alt=""
 style='width:12.75pt;height:17.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image088.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов5.mht!http://www.progz.ru/images/opengl/chapter5/form3.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=17 height=23
src="OpenGL%20Red%20Book.files/image088.gif" v:shapes="_x0000_i1120"><![endif]>&nbsp;и
<!--[if gte vml 1]><v:shape id="_x0000_i1121" type="#_x0000_t75" alt=""
 style='width:14.25pt;height:18pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image089.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов5.mht!http://www.progz.ru/images/opengl/chapter5/form4.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=19 height=24
src="OpenGL%20Red%20Book.files/image089.gif" v:shapes="_x0000_i1121"><![endif]>&nbsp;-
0.0, но вы можете задавать для этих коэффициентов другие значения:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>glLightf(GL_LIGHT0,
  GL_CONSTANT_ATTENUATION, 2.0);<br>
  glLightf(GL_LIGHT0, GL_LINEAR_ATTENUATION, 1.0);<br>
  glLightf(GL_LIGHT0, GL_QUADRATIC_ATTENUATION, 0.5); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Заметьте, что ослабляются и
фоновая, и диффузная, и зеркальная интенсивности. Только исходящие от объектов
интенсивности и глобальная фоновая интенсивность не подлежат ослаблению. Также
отметьте, что поскольку расчет ослабления требует дополнительной операции
деления (и возможно других операций) для каждого вычисляемого цвета,
использование ослабляемых источников света может замедлить работу приложения.</p>

<h2>5.4.3&nbsp; Прожектора</h2>

<p class=text align=left style='text-align:left'>Как было отмечено ранее, вы
можете заставить позиционный источник света действовать в качестве прожектора,
ограничив распространение света конусом излучения. Чтобы создать прожектор, вам
требуется определить желаемую ширину светового конуса. (Помните, что поскольку
прожектор является позиционным источником света, вам необходимо расположить его
в желаемом месте. Также заметьте, что никто не запрещает вам создавать
прожекторы из направленных источников света, но в этом случае вы наверняка не
получите желаемый результат.) Чтобы задать угол между осью конуса и лучом,
идущим вдоль, ребра конуса, используйте параметр GL_SPOT_CUTOFF. Тогда угол
между ребрами конуса, образованными вершиной и концами диаметра основания,
будет равен заданному вами углу, умноженному на 2.</p>

<p class=text align=left style='text-align:left'>Рисунок 5-3. Параметр
GL_SPOT_CUTOFF </p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1122" type="#_x0000_t75" alt="" style='width:465pt;height:352.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image090.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов5.mht!http://www.progz.ru/images/opengl/chapter5/5-3.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=620 height=470
src="OpenGL%20Red%20Book.files/image090.jpg" v:shapes="_x0000_i1122"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Заметьте, что свет не
излучается за ребрами конуса. По умолчанию, работа с прожекторами
заблокирована, так как параметр GL_SPOT_CUTOFF равен 180.0. Эта величина
означает, что свет излучается во всех направлениях (угол при вершине равен 360
градусам, что вообще не определяет конус). Значения для GL_SPOT_CUTOFF должны
попадать в диапазон [0.0, 90.0] (значение также может быть равно специальной
величине 180.0). Следующая строка устанавливает параметр GL_SPOT_CUTOFF равным
45 градусам:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>glLightf(GL_LIGHT0,
  GL_SPOT_CUTOFF, 45.0);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Вам также требуется задать
направление прожектора, которое определяет центральную ось светового конуса:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=ccode><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>GLfloat
  spot_direction[] = {-1.0, -1.0, 0.0};<br>
  glLightfv(GL_LIGHT0, GL_SPOT_DIRECTION, spot_direction);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Направление указывается в
объектных координатах. По умолчанию направление – (0.0, 0.0, -1.0), так что
если вы явно не изменяете параметр GL_SPOT_DIRECTION, источник света направлен
вдоль отрицательного направления оси <i>z</i>. Также имейте в виду, что
направление прожектора преобразуется видовой матрицей также, как если бы это
был вектор нормали, и результат сохраняется в видовых координатах.</p>

<p class=text align=left style='text-align:left'>В дополнение к углу светового
конуса и направлению прожектора, существует два способа управления распределением
интенсивности света внутри конуса. Во-первых, вы можете задать фактор
ослабления света, который перемножается с интенсивностью. Вы также можете
установить параметр GL_SPOT_EXPONENT (который по умолчанию равен 0), чтобы
управлять концентрацией света. Свет имеет самую высокую интенсивность в центре
конуса. При движении от центра к ребрам он ослабляется с коэффициентом равным
косинусу угла между направлением света и направлением от источника света к
освещаемой вершине, возведенному в степень GL_SPOT_EXPONENT. Таким образом,
больший экспоненциальный коэффициент разброса света (GL_SPOT_EXPONENT) ведет к
более фокусированному свету.</p>

<h2>5.4.4&nbsp; Несколько источников света</h2>

<p class=text align=left style='text-align:left'>Как было отмечено, у вас на
сцене может быть как минимум восемь источников света (возможно больше, но это
зависит от реализации OpenGL). Поскольку OpenGL проводит вычисления для того,
чтобы определить, сколько света получает каждая вершина от каждого источника,
увеличение источников слета весомо влияет на быстродействие. Константы, используемые
для ссылки на 8 источников света – это GL_LIGHT0, GL_LIGHT1, GL_LIGHT2,
GL_LIGHT3 и так далее. В предыдущих обсуждениях параметры устанавливались для
источника GL_LIGHT0. Если вам требуются дополнительные источники света, вы
должны задать и их параметры. Также помните, что значения параметров по
умолчанию не совпадают для GL_LIGHT0 и других источников. В примере 5-3
определяется белый ослабевающий прожектор:</p>

<p class=text align=left style='text-align:left'>Пример 5-3. Второй источник
света</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>GLfloatlight_ambient[]={0.2,0.2,0.2,1.0};<br>
  GLfloat light_diffuse[]={1.0,1.0,1.0,1.0};<br>
  GLfloat light_specular[]={1.0,1.0,1.0,1.0};<br>
  GLfloat light_position[]={-2.0,2.0,1.0,1.0};<br>
  GLfloat spot_direction[]={-1.0,-1.0,0.0};<br>
  <br>
  glLightfv(GL_LIGHT1,GL_AMBIENT, light_ambient);<br>
  glLightfv(GL_LIGHT1,GL_DIFFUSE, light_diffuse);<br>
  glLightfv(GL_LIGHT1,GL_SPECULAR, light_specular);<br>
  glLightfv(GL_LIGHT1,GL_POSITION, light_position);<br>
  glLightf(GL_LIGHT1,GL_CONSTANT_ATTENUATION, 1.5);<br>
  glLightf(GL_LIGHT1,GL_LINEAR_ATTENUATION, 0.5);<br>
  glLightf(GL_LIGHT1,GL_QUADRATIC_ATTENUATION, 0.2);<br>
  glLightf(GL_LIGHT1,GL_SPOT_CUTOFF, 45.0);<br>
  glLightfv(GL_LIGHT1,GL_SPOT_DIRECTION, spot_direction);<br>
  glLightf(GL_LIGHT1,GL_SPOT_EXPONENT, 2.0);<br>
  <br>
  glEnable(GL_LIGHT1); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Если эти строки добавить в
пример 5-1, сфера будет освещена двумя источниками: одним направленным и одним
прожектором.</p>

<h2>5.4.5&nbsp; Управление позицией и направлением источников света</h2>

<p class=text align=left style='text-align:left'>OpenGL обращается с позицией и
направлением источника света так же, как с позицией геометрического примитива.
Другими словами, источник света является субъектом тех же матричных преобразований,
что и примитив. Говоря более определенно, когда команда <b>glLight*()</b>
вызывается для указания позиции или направления источника света, эта позиция
или направление преобразуются текущей видовой матрицей и сохраняется в видовых
координатах. Это означает, что вы можете манипулировать позицией и направлением
источников света, изменяя содержимое видовой матрицы. (Проекционная матрица не
оказывает воздействия на позицию или направление источника света.) В этом
разделе объясняется, как добиться трех перечисленных далее эффектов, изменяя
место в программе (относительно видовых и модельных преобразований), где
задаются источники света:</p>

<p class=text align=left style='margin-left:54.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l19 level1 lfo18;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Позиция источника света остается фиксированной </p>

<p class=text align=left style='margin-left:54.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l19 level1 lfo18;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Источник света движется вокруг неподвижного
объекта </p>

<p class=text align=left style='margin-left:54.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l19 level1 lfo18;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Источник света движется вместе с точкой
наблюдения </p>

<h2>5.4.5.1&nbsp;&nbsp;&nbsp; Стационарный источник света</h2>

<p class=text align=left style='text-align:left'>В простейшем случае, как в
примере 5-1, положение источника света не изменяется. Чтобы добиться этого
эффекта, вам следует устанавливать позицию источника света после всех
используемых видовых и/или модельных преобразований. Пример 5-4 демонстрирует,
как может выглядеть соответствующий объединенный код из <b>init()</b> и <b>reshape()</b>.</p>

<p class=text align=left style='text-align:left'>Пример 5-4. Стационарный
источник света</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>glViewport(0,0,(GLsizei) w,
  (GLsizei) h); <br>
  glMatrixMode(GL_PROJECTION); <br>
  glLoadIdentity(); <br>
  if (w&lt;=h) <br>
  &nbsp;&nbsp;
  glOrtho(-1.5,1.5,-0.5*(GLfloat)h/(GLfloat)w,0.5*(GLfloat)h/(GLfloat)w,-10.0,10.0);
  <br>
  else <br>
  &nbsp;&nbsp;
  glOrtho(-1.5*(GLfloat)w/(GLfloat)h,1.5*(GLfloat)w/(GLfloat)h,-1.5,1.5,-10.0,10.0);<br>
  glMatrixMode(GL_MODELVIEW);<br>
  glLoadIdentity();<br>
  <br>
  //далее функции init()<br>
  GLfloat light_position[]={1.0,1.0,1.0,0.0};<br>
  glLightfv(GL_LIGHT0,GL_POSITION,light_position); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Как вы видите, сначала
устанавливается порт просмотра и проекционная матрица. Затем в видовую матрицу
загружается единичная, и только после этого задается положение источника света.
Поскольку используется единичная матрица, явно установленное положение
источника света – (1.0, 1.0, 1.0) не изменяется умножением на него видовой
матрицы. После этого, поскольку на тот момент ни позиция источника, ни видовая
матрица не изменены, направление света остается прежним – (1.0, 1.0, 1.0). </p>

<h2>5.4.5.2&nbsp;&nbsp;&nbsp; Независимо движущийся источник света</h2>

<p class=text align=left style='text-align:left'>Теперь предположим, что вам
нужно вращать источник света вокруг стационарного объекта или перемещать
источник света вокруг него. Один из способов сделать это заключается в
определении источника света после специфического модельного преобразования,
которое изменяет позицию источника. Вы можете начать с вызовов тех же команд в <b>init()
</b>как и в предыдущем разделе. Затем вам следует выполнить требуемое модельное
преобразование (на стеке видовых матриц) и сбросить позицию источника
(вероятно, в функции <b>display()</b>). Пример 5-5 демонстрирует возможный код
функции <b>display()</b>.</p>

<p class=text align=left style='text-align:left'>Пример 5-5. Независимое
движение источника света</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>GLdouble
  spin;<br>
  void display()<br>
  {<br>
  &nbsp;&nbsp; GLfloat light_position[]={0.0,0.0,1.5,1.0};<br>
  &nbsp;&nbsp; glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);<br>
  &nbsp;&nbsp; glPushMatrix();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  gluLookAt(0.0,0.0,5.0,0.0,0.0,0.0,0.0,1.0,0.0);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glPushMatrix();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glRotated(spin,1.0,0.0,0.0);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  glLightfv(GL_LIGHT0,GL_POSITION,light_position);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glPopMatrix();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glutSolidTorus(0.275,0.85,8,15);<br>
  &nbsp;&nbsp; glPopMatrix();<br>
  glFlush();<br>
  } <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'><i>spin</i> – это глобальная
переменная, значение которой, вероятнее всего, определяется устройством ввода.
Функция <b>display()</b> вызывает перерисовку сцены с источником света
обращенным вокруг неподвижного торуса на <i>spin</i>градусов. Заметьте, что две
пары команд <b>glPushMatrix()</b> и <b>glPopMatrix()</b> изолируют видовые и
модельные преобразования. Поскольку в примере 5-5 точка наблюдения остается
неизменной, текущая матрица проталкивается в стек и далее требуемое видовое
преобразование задается командой <b>gluLookAt()</b>. Далее получившаяся матрица
снова проталкивается в стек перед указанием преобразования поворота командой <b>glRotate()</b>.
Затем задается положение источника света в новой повернутой системе координат,
таким образом, источник света оказывается повернутым относительно своего первоначального
положения. (Помните, что позиция источника света сохраняется в видовых
координатах, получающихся после преобразования видовой матрицей.) Торус
рисуется после того, как матрица выталкивается из стека. Пример 5-6
представляет собой листинг программы, поворачивающей источник света вокруг
неподвижного объекта. При нажатии левой кнопки мыши угол поворота источника
света увеличивается на 30 градусов. Позиция источника света представлена
маленьким неосвещенным проволочным кубом.</p>

<p class=text align=left style='text-align:left'>Пример 5-6. Перемещение источника
света с помощью модельных преобразований: файл movelight.cpp</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>#include
  &lt;glut.h&gt;<br>
  int spin=0;<br>
  <br>
  //</span><span style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:
  "Courier New";color:black'>Инициализация</span><span lang=EN-US
  style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:"Courier New";
  color:black;mso-ansi-language:EN-US'><br>
  void init(void)<br>
  {<br>
  &nbsp;&nbsp; glClearColor(0.0,0.0,0.0,0.0);<br>
  &nbsp;&nbsp; glShadeModel(GL_SMOOTH);<br>
  &nbsp;&nbsp; glEnable(GL_LIGHTING);<br>
  &nbsp;&nbsp; glEnable(GL_LIGHT0);<br>
  &nbsp;&nbsp; glEnable(GL_DEPTH_TEST);<br>
  }<br>
  <br>
  void display(void)<br>
  {<br>
  &nbsp;&nbsp; GLfloat position[]={0.0,0.0,1.5,1.0};<br>
  &nbsp;&nbsp; <br>
  &nbsp;&nbsp; glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT); <br>
  &nbsp;&nbsp; glPushMatrix();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glTranslatef(0.0,0.0,-5.0);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glPushMatrix(); <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glRotated((GLdouble)spin,1.0,0.0,0.0);
  <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  glLightfv(GL_LIGHT0,GL_POSITION,position);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glTranslated(0.0,0.0,1.5);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glDisable(GL_LIGHTING);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glColor3f(0.0,1.0,1.0);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glutWireCube(0.1);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glEnable(GL_LIGHTING);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glPopMatrix();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glutSolidTorus(0.275,0.85,40,40);<br>
  &nbsp;&nbsp; glPopMatrix();<br>
  &nbsp;&nbsp; glutSwapBuffers();<br>
  }<br>
  <br>
  //</span><span style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:
  "Courier New";color:black'>Изменение</span><span style='font-size:8.5pt;
  font-family:Courier;mso-bidi-font-family:"Courier New";color:black;
  mso-ansi-language:EN-US'> </span><span style='font-size:8.5pt;font-family:
  Courier;mso-bidi-font-family:"Courier New";color:black'>размеров</span><span
  style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:"Courier New";
  color:black;mso-ansi-language:EN-US'> </span><span style='font-size:8.5pt;
  font-family:Courier;mso-bidi-font-family:"Courier New";color:black'>окна</span><span
  lang=EN-US style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:
  "Courier New";color:black;mso-ansi-language:EN-US'> <br>
  void reshape(int w, int h)<br>
  {<br>
  &nbsp;&nbsp; glViewport(0,0,(GLsizei) w, (GLsizei) h); <br>
  &nbsp;&nbsp; glMatrixMode(GL_PROJECTION);<br>
  &nbsp;&nbsp; glLoadIdentity(); <br>
  &nbsp;&nbsp; gluPerspective(40.0,(GLfloat)w/(GLfloat)h,1.0,20.0); <br>
  &nbsp;&nbsp; glMatrixMode(GL_MODELVIEW);<br>
  &nbsp;&nbsp; glLoadIdentity();<br>
  }<br>
  <br>
  void light_moving(void)<br>
  {<br>
  &nbsp;&nbsp; spin=(spin+1)%360;<br>
  &nbsp;&nbsp; glutPostRedisplay();<br>
  }<br>
  <br>
  void mouse(int button,int state,int x, int y)<br>
  {<br>
  &nbsp;&nbsp; switch(button)<br>
  &nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case GLUT_LEFT_BUTTON:<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(state==GLUT_DOWN)<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  glutIdleFunc(light_moving);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  glutIdleFunc(NULL);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>
  &nbsp;&nbsp; }<br>
  }<br>
  <br>
  int main(int argc, char **argv)<br>
  {<br>
  &nbsp;&nbsp; glutInit(&amp;argc,argv);<br>
  &nbsp;&nbsp; glutInitDisplayMode(GLUT_DOUBLE|GLUT_RGB|GLUT_DEPTH);<br>
  &nbsp;&nbsp; glutInitWindowSize(500,500);<br>
  &nbsp;&nbsp; glutInitWindowPosition(100,100);<br>
  &nbsp;&nbsp; glutCreateWindow(&quot;Moving a Light with Modeling
  Transformations&quot;);<br>
  &nbsp;&nbsp; init();<br>
  &nbsp;&nbsp; glutDisplayFunc(display);<br>
  &nbsp;&nbsp; glutReshapeFunc(reshape);<br>
  &nbsp;&nbsp; glutMouseFunc(mouse);<br>
  &nbsp;&nbsp; glutMainLoop();<br>
  &nbsp;&nbsp; return 0;<br>
  } <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<h2>5.4.5.3&nbsp;&nbsp;&nbsp; Перемещение источника света вместе с точкой
наблюдения</h2>

<p class=text align=left style='text-align:left'>Чтобы создать источник света,
который передвигается вместе с точкой наблюдения, вам следует задать его
позицию до видового преобразования. Тогда видовое преобразование будет
одинаковым образом воздействовать и на источник света и на точку наблюдения.
Помните, что положение источника света сохраняется в видовых координатах – это
один из небольшого числа случаев, в которых видовые координаты весьма важны. В
примере 5-7 позиция источника света задается в функции <b>init()</b> и
сохраняется в видовых координатах (<i>0</i>, <i>0</i>, <i>0</i>). Другими
словами, свет излучается из линзы камеры.</p>

<p class=text align=left style='text-align:left'>Пример 5-7. Источник света,
перемещающийся вместе с точкой наблюдения</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>GLfloat
  light_position[]={0.0, 0.0, 0.0, 1.0};<br>
  <br>
  glViewport(0,0,(GLsizei) w, (GLsizei) h);<br>
  glMatrixMode(GL_PROJECTION);<br>
  glLoadIdentity();<br>
  gluPerspective(40.0, (GLfloat)w/(GLfloat)h,1.0,100.0); <br>
  glMatrixMode(GL_MODELVIEW);<br>
  glLoadIdentity();<br>
  glLightfv(GL_LIGHT0,GL_POSITION,light_position);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Теперь, если точка наблюдения
переместится, источник света переместится вместе с ней, сохраняя дистанцию (<i>0</i>,
<i>0</i>, <i>0</i>) относительно глаза. В продолжении примера 5-7, следующим
далее, глобальные переменные (<i>ex</i>, <i>ey</i>, <i>ez</i>) управляют
положением точки наблюдения, а (<i>upx</i>, <i>upy</i>, <i>upz</i>) определяют
вектор верхнего направления. Функция <b>display()</b>, вызываемая из цикла
обработки сообщений для перерисовки сцены, может выглядеть следующим образом:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>GLdlouble ex, ey, ez, upx,
  upy, upz;<br>
  <br>
  void display()<br>
  {<br>
  &nbsp;&nbsp; glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);<br>
  &nbsp;&nbsp; glPushMatrix();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gluLookAt(ex, ey, ez, 0.0, 0.0, 0.0, upx, upy,
  upz);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glutSolidTorus(0.275, 0.85, 8, 15);<br>
  &nbsp;&nbsp; glPopMatrix();<br>
  &nbsp;&nbsp; glFlush();<br>
  } <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Когда перерисовывается
освещенный торус, и источник света, и точка наблюдения перемещаются в одно и то
же место. С изменением величин, передаваемых в <b>gluLookAt()</b> (и
перемещением наблюдателя), объект никогда не будет темным, поскольку он всегда
освещается с позиции наблюдателя. Даже если вы не измените координаты позиции
источника света явно, он все равно будет перемещаться, поскольку изменяется
видовая координатная система.</p>

<p class=text align=left style='text-align:left'>Этот метод может быть весьма
полезен при эмуляции фонаря на каске шахтера. Другим примером может быть свеча
или лампа, которую несут в руке. Позиция источника света, задаваемая вызовом <b>glLightfv</b>(GL_LIGHTi,
GL_POSITION, <i>position</i>), по смыслу будет соответствовать указанию
расстояний источника от наблюдателя по <i>x</i>, <i>y </i>и <i>z</i>. Затем при
изменении положения наблюдателя, источник света будет оставаться на том же
относительном расстоянии. </p>

<h2>5.5&nbsp; Выбор модели освещения</h2>

<p class=text align=left style='text-align:left'>В OpenGL понятие модели
освещения разделяется на 4 компонента:</p>

<p class=text align=left style='margin-left:54.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l66 level1 lfo19;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Интенсивность глобального фонового света. </p>

<p class=text align=left style='margin-left:54.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l66 level1 lfo19;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Считается ли положение точки наблюдения
локальным к сцене или бесконечно удаленным. </p>

<p class=text align=left style='margin-left:54.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l66 level1 lfo19;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Должен ли расчет освещенности производиться
по-разному для лицевых и обратных граней объектов. </p>

<p class=text align=left style='margin-left:54.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l66 level1 lfo19;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Должен ли зеркальный цвет отделяться от фонового
и диффузного и накладываться на объект после операций текстурирования. </p>

<p class=text align=left style='text-align:left'>Этот раздел объясняет, как
задавать модель освещения. Здесь также обсуждается, как включать освещение – то
есть, как сказать OpenGL, что она должна производить расчет освещенности.</p>

<p class=text align=left style='text-align:left'><b>glLightModel*()</b> – это
команда, используемая для задания всех параметров модели освещения. <b>glLightModel*()</b>
принимает два аргумента: имя параметра модели освещения в виде константы и
значение для этого параметра.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glLightModel</b>{if}
  (GLenum <i>pname</i>, TYPE <i>param</i>);<br>
  void <b>glLightModel</b>{if}<b>v</b> (GLenum <i>pname</i>, TYPE *<i>param</i>);
  <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Устанавливает свойства модели
освещения. Устанавливаемая характеристика модели освещения определяется аргументом
<i>pname</i> (таблица 5-2). <i>param </i>задает величину, в которую
устанавливается <i>pname</i>; если используется векторная версия команды, то
это указатель на группу величин, если применяется невекторная версия – в <i>param
</i>содержится сама величина. Невекторная версия команды может использоваться
только для установки параметров, определяемых одной величиной (и не может
применяться для GL_LIGHT_MODEL_AMBIENT).</p>

<p class=text align=left style='text-align:left'>Таблица 5-2. Значения по
умолчанию для параметра <i>pname</i> модели освещения</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Имена параметров</span></strong><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Значения по умолчанию</span></strong><span style='font-size:
  8.0pt;font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Смысл</span></strong><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_LIGHT_MODEL_AMBIENT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>(0.2,0.2,0.2,1.0)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>RGBA интенсивность всей сцены<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_LIGHT_MODEL_LOCAL_VIEWER<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0.0 или GL_FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>способ вычисления углов зеркального отражения<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_LIGHT_MODEL_TWO_SIDE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0.0 или GL_FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>выбор между односторонним и двухсторонним освещением<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_LIGHT_MODEL_COLOR_CONTROL<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_SINGLE_COLOR<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>вычисляется ли зеркальный цвет отдельно от фонового и диффузного<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<h2>5.5.1&nbsp; Глобальный фоновый свет</h2>

<p class=text align=left style='text-align:left'>Как обсуждалось ранее, каждый
источник света может добавлять к сцене фоновый свет. Кроме того, может присутствовать
другой фоновый свет, не принадлежащий никакому конкретному источнику. Чтобы
задать RGBA интенсивность такого глобального фонового света, используйте
параметр GL_LIGHT_MODEL_AMBIENT следующим образом:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>GLfloat
  lmodel_ambient[]={0.2,0.2,0.2,1.0};<br>
  glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmodel_ambient);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>В этом примере значения для <i>lmodel_ambient
</i>совпадают со значениями по умолчанию для GL_LIGHT_MODEL_AMBIENT. Поскольку
эти числа задают небольшое количество белого фонового света, вы можете видеть
объекты сцены даже в том случае, если отсутствуют какие-либо дополнительные
источники света. На рисунке 5-4 изображены три чайника, нарисованные на сцене с
разным количеством глобального фонового света (его интенсивность увеличивается
слева направо).</p>

<p class=text align=left style='text-align:left'>Рисунок 5-4. Чайники,
освещенные разным количеством глобального фонового света</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1123" type="#_x0000_t75" alt="" style='width:464.25pt;height:131.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image091.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов5.mht!http://www.progz.ru/images/opengl/chapter5/5-4.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=619 height=175
src="OpenGL%20Red%20Book.files/image091.jpg" v:shapes="_x0000_i1123"><![endif]></p>

<h2>5.5.2&nbsp; Локальная или бесконечно удаленная точка наблюдения</h2>

<p class=text align=left style='text-align:left'>Положение точки наблюдения
влияет на расчет блика, создаваемого зеркальным отражением. Более определенно,
интенсивность блика в конкретной вершине зависит от вектора нормали в этой
вершине, направления из вершины к источнику света и направления из вершины к
точке наблюдения. Имейте в виду, что на самом деле точка наблюдения не
перемещается никакими командами, связанными с освещением, однако расчеты могут
быть различными на основании предположения о ее мнимом местонахождении.</p>

<p class=text align=left style='text-align:left'>Если предполагается, что точка
наблюдения бесконечно удалена, то направления из нее ко всем вершинам считаются
одинаковыми. Локальная точка наблюдения позволяет получать более реалистичный
результат, но, поскольку должны быть рассчитаны направления между ней и каждой
вершиной, среднее быстродействие приложения может значительно снизиться. По
умолчанию используется бесконечно удаленная точка наблюдения. Вы можете сменить
ее на локальную следующим вызовом:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>glLightModeli(GL_LIGHT_MODEL_LOCAL_VIEWER,
  GL_TRUE);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Этот вызов помещает точку
наблюдения в (0, 0, 0) в видовых координатах. Для переключения обратно к
бесконечно удаленной точке наблюдения в предыдущей строке кода замените
GL_TRUEна GL_FALSE.</p>

<h2>5.5.3&nbsp; Двухстороннее освещение</h2>

<p class=text align=left style='text-align:left'>Расчет освещенности
производится для всех полигонов, являются ли они лицевыми или обратными.
Поскольку вы обычно настраиваете источники света, размышляя о лицевых
полигонах, обратные могут быть неверно освещены. В примере 5-1, где в качестве
объекта используется сфера, всегда видны только лицевые грани, поскольку именно
они находятся снаружи сферы. Таким образом, в данном случае неважно, как
выглядят обратные. Однако, если часть сферы будет отсечена и ее внутренняя
поверхность станет видимой, вам возможно захочется, чтобы эта поверхность была
освещена в соответствии с заданными вами условиями освещения; возможно вам
также потребуется задать для обратной поверхности иные свойства материала, чем
для лицевой. Когда вы включаете двухстороннее освещение вызовом:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>glLightModeli(GL_LIGHT_MODEL_TWO_SIDE,
  GL_TRUE);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>OpenGL считает нормалями к
обратным поверхностям нормали к лицевым, направленные в противоположном
направлении. Обычно это означает, что вектора нормалей для видимых обратных
полигонов (как и для лицевых) направлены на, а не от наблюдателя. В результате
все полигоны освещаются правильно. Однако дополнительные операции по
обеспечению двухстороннего освещения делают его более медленным, чем принятое
по умолчанию одностороннее освещение.</p>

<p class=text align=left style='text-align:left'>Чтобы выключить двухстороннее
освещение, измените GL_TRUE в предыдущей строке кода на GL_FALSE. Вы также
можете управлять тем, какие грани OpenGL считает лицевыми с помощью команды <b>glFrontFace()</b>.</p>

<h2>5.5.4&nbsp; Отделение зеркального цвета</h2>

<p class=text align=left style='text-align:left'>При обычном расчете
освещенности, фоновый, диффузный, зеркальный вклады источника света в общую
освещенность и интенсивность исходящего света вычисляются и просто складываются
вместе. По умолчанию наложение текстуры производится после расчета
освещенности, в результате зеркальный блик может выглядеть мутным, а текстура
может быть искажена. Если же вы произведете следующий вызов:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>glLightModeli(GL_LIGHT_MODEL_COLOR_CONTROL,
  GL_SEPARATE_SPECULAR_COLOR);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>OpenGL отделит расчет
зеркального освещения от его применения. После этого вызова при расчете
освещенности производится два цвета на каждую вершину: первичный, состоящий из
суммы всех незеркальных вкладов всех источников света, и вторичный, состоящий
из суммы всех зеркальных вкладов всех источников света. Во время
текстурирования с цветами текстуры комбинируется только первичный цвет. Вторичный
свет добавляется к комбинации первичного и текстурных цветов после операции
текстурирования. Объекты, освещенные и текстурированные с применением
отдельного зеркального цвета, как правило, имеют более четкий выделяющийся
зеркальный блик.</p>

<p class=text align=left style='text-align:left'>Чтобы восстановить метод
расчета освещенности по умолчанию, вызовите:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>glLightModeli(GL_LIGHT_MODEL_COLOR_CONTROL,
  GL_SINGLE_COLOR);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>После этого вызова первичный
цвет будет состоять из всех вкладов источника света в освещенность
вершины:&nbsp; фонового, диффузного и зеркального, а также из исходящего цвета
материала самого объекта. Никакие дополнительные вклады в освещенность не
добавляются после текстурирования.</p>

<p class=text align=left style='text-align:left'>Если вы не производите
наложение текстуры на объект, отделение зеркального цвета от остальных не имеет
никакого смысла.</p>

<h2>5.5.5&nbsp; Включение расчета освещенности</h2>

<p class=text align=left style='text-align:left'>При использовании OpenGL вам
необходимо включать (или выключать) механизм расчета освещенности. Если данный
механизм не включен, текущий цвет просто ассоциируется с текущей вершиной, и не
производится никаких вычислений, касающихся нормалей, источников света, модели
освещения и свойств материала. Расчет освещенности включается командой:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>glEnable(GL_LIGHTING);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>и выключается командой:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>glDisable(GL_LIGHTING);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Кроме того, вам требуется
включать каждый источник света, после того, как вы определили его параметры. В
примере 5-1 используется только один источник света – GL_LIGHT0:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>glEnable(GL_LIGHT0);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<h2>5.6&nbsp; Указание свойств материала</h2>

<p class=text align=left style='text-align:left'>Вы видели, как создать
источник света с определенными характеристиками и как задать нужную модель
освещения. В этом разделе описано, как задать свойства материала для объектов
на сцене: фоновый, диффузный и зеркальный цвета, степень сияния (насколько
блестящим выглядит объект) и цвет исходящего от объекта света. Большинство
свойств материала концептуально похожи на те, которые использовались при
создании источников света. Механизм из указания также аналогичен установке
параметров источника света за исключением того, что здесь используется команда <b>glMaterial*()</b>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glMaterial</b>{if}(GLenum
  <i>face</i>, GLenum <i>pname</i>, TYPE <i>param</i>);<br>
  void <b>glMaterial</b>{if}<b>v</b>(GLenum <i>face</i>, GLenum <i>pname</i>,
  TYPE *<i>param</i>); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Задает свойство материала для
использования при расчете освещенности. Аргумент <i>face </i>может принимать
значения GL_FRONT, GL_BACKили GL_FRONT_AND_BACK, указывая для каких граней
объекта задается свойство материала. Устанавливаемое свойство материала
определяется значением аргумента <i>pname</i>, а его значение содержится в <i>param
</i>(в виде указателя на вектор величин в случае векторной версии команды или в
виде самой величины при использовании невекторного варианта). Невекторная
версия команды работает только для параметра GL_SHININESS. Возможные значения
для аргумента <i>pname </i>перечислены в таблице 5-3. Заметьте, что константа
GL_AMBIENT_AND_DIFFUSE позволяет вам одновременно установить фоновый и
диффузный цвета материала в одно и то же RGBAзначение.</p>

<p class=text align=left style='text-align:left'>Таблица 5-3. Значения по
умолчанию для параметра материала <i>pname</i></p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Имена параметров</span></strong><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Значения по умолчанию</span></strong><span style='font-size:
  8.0pt;font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Смысл</span></strong><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_AMBIENT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>(0.2,0.2,0.2,1.0)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>фоновый цвет материала<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_DIFFUSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>(0.8,0.8,0.8,1.0)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>диффузный цвет материала<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_AMBIENT_AND_DIFFUSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>&nbsp;<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>фоновый и диффузный цвет материала<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_SPECULAR<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>(0.0,0.0,0.0,1.0)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>зеркальный цвет материала<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:5'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_SHININESS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0.0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>показатель зеркального отражения<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:6'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_EMISSION<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>(0.0,0.0,0.0,1.0)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>исходящий цвет материала<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:7;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_COLOR_INDEXES<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>(0,1,1)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>индексы фонового, диффузного и зеркального цветов<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Как обсуждалось ранее, вы
можете задать расчет освещенности для лицевых и обратных полигонов объекта.
Если в вашем приложении обратные грани могут быть видимыми, вы можете по-разному
задать параметры материала для лицевых и обратных граней объекта, используя
аргумент <i>face </i>команды <b>glMaterial*()</b>. На рисунке 5-5 изображен
объект, нарисованный с применением разных свойств материала для его лицевых и
обратных граней.</p>

<p class=text align=left style='text-align:left'><b>&nbsp; </b>Рисунок 5-5.
Разный материал для лицевых и обратных граней </p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1124" type="#_x0000_t75" alt="" style='width:231pt;height:230.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image092.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов5.mht!http://www.progz.ru/images/opengl/chapter5/5-5.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=308 height=307
src="OpenGL%20Red%20Book.files/image092.jpg" v:shapes="_x0000_i1124"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>В примере 5-8 приведен код,
используемый для рисования чайника на рисунке 5-5.</p>

<p class=text align=left style='text-align:left'>Пример 5-8. Отсеченный чайник
с разными материалами для лицевых и обратных граней: файл two_side_lighting.cpp</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>#include &lt;glut.h&gt;<br>
  <br>
  //Инициализация<br>
  void init(void)<br>
  {<br>
  &nbsp;&nbsp; glClearColor(0.0,0.0,0.0,0.0);<br>
  &nbsp;&nbsp; glShadeModel(GL_SMOOTH);<br>
  <br>
  &nbsp;&nbsp; //Настраиваем источник света<br>
  &nbsp;&nbsp; GLfloat light_position[]={1.0,1.0,1.0,0.0};<br>
  &nbsp;&nbsp; GLfloat white_light[]={1.0,1.0,1.0,1.0};<br>
  &nbsp;&nbsp; glLightfv(GL_LIGHT0,GL_POSITION,light_position);<br>
  &nbsp;&nbsp; glLightfv(GL_LIGHT0,GL_DIFFUSE,white_light);<br>
  &nbsp;&nbsp; glLightfv(GL_LIGHT0,GL_SPECULAR,white_light);<br>
  <br>
  &nbsp;&nbsp; //...и модель двухстороннего освещения<br>
  &nbsp;&nbsp; GLfloat lmodel_ambient[]={1.0,1.0,1.0,1.0};<br>
  &nbsp;&nbsp; glLightModelfv(GL_LIGHT_MODEL_AMBIENT,lmodel_ambient);<br>
  &nbsp;&nbsp; glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, GL_TRUE);<br>
  <br>
  &nbsp;&nbsp; //Включаем нужные механизмы <br>
  &nbsp;&nbsp; glEnable(GL_LIGHTING);<br>
  &nbsp;&nbsp; glEnable(GL_LIGHT0);<br>
  &nbsp;&nbsp; glEnable(GL_DEPTH_TEST);<br>
  <br>
  &nbsp;&nbsp; //Задаем параметры материала для лицевых граней<br>
  &nbsp;&nbsp; GLfloat mat_specular_front[]={0.0,0.3,0.9,1.0};<br>
  &nbsp;&nbsp; GLfloat mat_ambient_front[]={0.0,0.1,0.3,1.0};<br>
  &nbsp;&nbsp; glMaterialfv(GL_FRONT,GL_SPECULAR,mat_specular_front);<br>
  &nbsp;&nbsp; glMaterialfv(GL_FRONT,GL_AMBIENT,mat_ambient_front);<br>
  <br>
  &nbsp;&nbsp; //... и для обратных<br>
  &nbsp;&nbsp; GLfloat mat_specular_back[]={1.0,0.0,0.0,1.0};<br>
  &nbsp;&nbsp; GLfloat mat_ambient_back[]={0.5,0.1,0.1,1.0};<br>
  &nbsp;&nbsp; glMaterialfv(GL_BACK,GL_SPECULAR,mat_specular_back);<br>
  &nbsp;&nbsp; glMaterialfv(GL_BACK,GL_AMBIENT,mat_ambient_back);<br>
  <br>
  &nbsp;&nbsp; //GL_SHININESS в данном случае одинаково для всех граней<br>
  &nbsp;&nbsp; GLfloat mat_shininess[]={50.0};<br>
  &nbsp;&nbsp; glMaterialfv(GL_FRONT_AND_BACK,GL_SHININESS,mat_shininess);<br>
  <br>
  &nbsp;&nbsp; //Задаем дополнительную плоскость отсечения<br>
  &nbsp;&nbsp; GLdouble equation[]={0.4,0.5,-0.5,0.6};<br>
  &nbsp;&nbsp; glClipPlane(GL_CLIP_PLANE1, equation);<br>
  &nbsp;&nbsp; glEnable(GL_CLIP_PLANE1);<br>
  <br>
  &nbsp;&nbsp; //Задаем какие грани считать лицевыми<br>
  &nbsp;&nbsp; glFrontFace(GL_CW);<br>
  }<br>
  <br>
  //Отображение <br>
  void display(void)<br>
  {<br>
  &nbsp;&nbsp; glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);<br>
  &nbsp;&nbsp; glutSolidTeapot(0.9);<br>
  &nbsp;&nbsp; glFlush();<br>
  }<br>
  <br>
  //Изменение размеров окна<br>
  void reshape(int w, int h)<br>
  {<br>
  &nbsp;&nbsp; glViewport(0,0,(GLsizei) w, (GLsizei) h);<br>
  &nbsp;&nbsp; glMatrixMode(GL_PROJECTION);<br>
  &nbsp;&nbsp; glLoadIdentity();<br>
  &nbsp;&nbsp; if (w&lt;=h)<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glOrtho(-1.5,1.5,-1.5*(GLfloat)h/(GLfloat)w,
  1.5*(GLfloat)h/(GLfloat)w,-10.0,10.0);<br>
  &nbsp;&nbsp; else<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glOrtho(-1.5*(GLfloat)w/(GLfloat)h,
  1.5*(GLfloat)w/(GLfloat)h,-1.5,1.5,-10.0,10.0);<br>
  &nbsp;&nbsp; glMatrixMode(GL_MODELVIEW);<br>
  &nbsp;&nbsp; glLoadIdentity();<br>
  }<br>
  <br>
  //Точка входа<br>
  int main(int argc, char **argv)<br>
  {<br>
  &nbsp;&nbsp; glutInit(&amp;argc,argv);<br>
  &nbsp;&nbsp; glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB|GLUT_DEPTH);<br>
  &nbsp;&nbsp; glutInitWindowSize(310,310);<br>
  &nbsp;&nbsp; glutInitWindowPosition(100,100);<br>
  &nbsp;&nbsp; glutCreateWindow(&quot;Two-sided lighting&quot;);<br>
  &nbsp;&nbsp; init();<br>
  &nbsp;&nbsp; glutDisplayFunc(display);<br>
  &nbsp;&nbsp; glutReshapeFunc(reshape);<br>
  &nbsp;&nbsp; glutMainLoop();<br>
  &nbsp;&nbsp; return 0;<br>
  } <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Чтобы получить представление о
том, каких эффектов можно достигнуть с помощью различных свойств материала,
взгляните на рисунок 5-6. На этом рисунке изображено несколько экземпляров
одного и того же объекта, нарисованных с применением разных свойств материала.
Каждый раз был использован один и тот же источник света и одинаковая модель
освещения. В разделах следующих далее, обсуждаются отдельные свойства
материалов.</p>

<p class=text align=left style='text-align:left'>Рисунок 5-6. Чайники из разных
материалов </p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1125" type="#_x0000_t75" alt="" style='width:416.25pt;height:402.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image093.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов5.mht!http://www.progz.ru/images/opengl/chapter5/5-6.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=555 height=537
src="OpenGL%20Red%20Book.files/image093.jpg" v:shapes="_x0000_i1125"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Заметьте, что большинство
параметров материала, устанавливаемых с помощью команды <b>glMaterial*()</b>
являются RGBA величинами. Независимо от величины альфа, задаваемой в других
параметрах, величиной альфа для конкретной вершины принимается та, которая была
задана для диффузного цвета, то есть для параметра GL_DIFFUSE. Также заметьте,
что в индексном цветовом режиме RGBA значения для свойств материала не используются.</p>

<h2>5.6.1&nbsp; Диффузное и фоновое отражение</h2>

<p class=text align=left style='text-align:left'>Параметры GL_DIFFUSEи
GL_AMBIENT, устанавливаемые командой <b>glMaterial*()</b> влияют на цвета
диффузного и фонового света, отражаемого объектом. Диффузное отражение играет
наиболее важную роль в определении того, что вы воспринимаете как цвет объекта.
На ваше восприятие оказывает влияние цвет падающего диффузного света и угол
между этим светом и вектором нормали к поверхности. (Диффузное отражение
наиболее заметно, если диффузный свет падает перпендикулярно к поверхности.)
Положение точки наблюдения вообще не влияет на диффузное отражение.</p>

<p class=text align=left style='text-align:left'>Фоновое отражение одинаково
влияет на все цвета объекта. Поскольку диффузное отражение наиболее заметно на
непосредственно освещаемых частях объекта, фоновое отражение наиболее заметно
на частях объекта, которые непосредственно не освещаются. Суммарное фоновое
отражение объекта складывается из глобального фонового освещения и фонового
света, излучаемого индивидуальными источниками. Также как и диффузное, фоновое
отражение не зависит от точки наблюдения.</p>

<p class=text align=left style='text-align:left'>В реальном мире, диффузное и
фоновое отражение от одного и того же объекта, как правило, имеет одинаковый
цвет. По этой причине OpenGL предоставляет упрощенный путь для задания обоих
параметров материала в команде <b>glMaterial*()</b>:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=ccode><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>GLfloat
  mat_amb_diff[]={0.1,0.5,0.8,1.0};<br>
  glMaterialfv(GL_FRONT_AND_BACK,GL_AMBIENT_AND_DIFFUSE);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>В этом примере RGBA цвет (0.1,
0.5, 0.8, 1.0) – глубокий синий цвет – задается в качестве текущих цветов
фонового и диффузного отражения для лицевых и обратных граней полигонов.</p>

<h2>5.6.2&nbsp; Зеркальное отражение</h2>

<p class=text align=left style='text-align:left'>Зеркальное отражение от
объекта создает блик. В отличие от фонового и диффузного отражения, количество
зеркального отражения, видимого наблюдателем, зависит от положения точки
наблюдения. Чтобы это понять, представьте, что вы смотрите на металлический
шарик под солнечным светом. При движении вашей головы, блик, создаваемый
солнечным светом на шарике до некоторой степени будет передвигаться вместе с
вами. Однако, если вы слишком далеко переместите голову, вы вообще перестанете
видеть блик.</p>

<p class=text align=left style='text-align:left'>OpenGL позволяет вам задавать
эффект, производимый материалом на отраженный свет (с помощью параметра
GL_SPECULAR), и контролировать размер и яркость блика (с помощью параметра
GL_SHININESS). GL_SHININESS может принимать значения в диапазоне [0.0, 128.0]:
чем больше значение, тем меньше и ярче зеркальный блик (то есть при увеличении
значения GL_SHININESS блик будет все более и более сфокусирован).</p>

<h2>5.6.3&nbsp; Исходящий (эмиссионный) цвет</h2>

<p class=text align=left style='text-align:left'>Задавая RGBA цвет для
параметра GL_EMISSION, вы можете изобразить объект так, как будто он излучает
свет этого цвета. Поскольку большинство реальных объектов (помимо источников
света) сами не излучают свет, вы, вероятно, будете использовать этот эффект для
симуляции ламп и других источников света.</p>

<p class=text align=left style='text-align:left'>Имейте в виду, что хотя
объекты с высокой интенсивностью исходящего света выглядят светящимися, на
самом деле они не работают в качестве источников света, то есть не оказывают
никакого воздействия на другие объекты сцены. Для того, чтобы имитировать лампу
или фонарь, вам нужно создать дополнительный источник света и поместить его в
ту же позицию, что и светящийся объект.</p>

<h2>5.6.4&nbsp; Изменение свойств материала</h2>

<p class=text align=left style='text-align:left'>В примере 5-1 один и тот же
материал использовался для всех вершин единственного объекта сцены (сферы). В иных
ситуациях вам может потребоваться ассоциировать различные свойства материала с
различными вершинами одного и того же объекта. Более вероятно, что на сцене
будет больше одного объекта. Например, посмотрите на выдержку кода в примере
5-9.</p>

<p class=text align=left style='text-align:left'>Пример 5-9. Разные свойства
материала</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>GLfloat
  no_mat[]={0.0,0.0,0.0,1.0};<br>
  GLfloat mat_ambient[]={0.7,0.7,0.7,1.0};<br>
  GLfloat mat_ambient_color[]={0.8,0.8,0.2,1.0};<br>
  GLfloat mat_diffuse[]={0.1,0.5,0.8,1.0};<br>
  GLfloat mat_specular[]={1.0,1.0,1.0,1.0};<br>
  GLfloat no_shininess[]={0.0};<br>
  GLfloat low_shininess[]={5.0};<br>
  GLfloat high_shininess[]={100.0};<br>
  GLfloat mat_emission[]={0.3,0.2,0.2,0.0};<br>
  glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);<br>
  <br>
  //</span><span style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:
  "Courier New";color:black'>Нарисовать</span><span style='font-size:8.5pt;
  font-family:Courier;mso-bidi-font-family:"Courier New";color:black;
  mso-ansi-language:EN-US'> </span><span style='font-size:8.5pt;font-family:
  Courier;mso-bidi-font-family:"Courier New";color:black'>первую</span><span
  style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:"Courier New";
  color:black;mso-ansi-language:EN-US'> </span><span style='font-size:8.5pt;
  font-family:Courier;mso-bidi-font-family:"Courier New";color:black'>сферу</span><span
  style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:"Courier New";
  color:black;mso-ansi-language:EN-US'> </span><span style='font-size:8.5pt;
  font-family:Courier;mso-bidi-font-family:"Courier New";color:black'>слева</span><span
  lang=EN-US style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:
  "Courier New";color:black;mso-ansi-language:EN-US'><br>
  glPushMatrix();<br>
  glTranslate(-3.75,0.0,0.0);<br>
  glMaterialfv(GL_FRONT, GL_AMBIENT, no_mat);<br>
  glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);<br>
  glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);<br>
  glMaterialfv(GL_FRONT, GL_SHININESS, no_shininess);<br>
  glMaterialfv(GL_FRONT, GL_EMISSION, no_mat);<br>
  glutSolidSphere(1.0,16,16);<br>
  glPopMatrix();<br>
  <br>
  //</span><span style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:
  "Courier New";color:black'>Нарисовать</span><span style='font-size:8.5pt;
  font-family:Courier;mso-bidi-font-family:"Courier New";color:black;
  mso-ansi-language:EN-US'> </span><span style='font-size:8.5pt;font-family:
  Courier;mso-bidi-font-family:"Courier New";color:black'>вторую</span><span
  style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:"Courier New";
  color:black;mso-ansi-language:EN-US'> </span><span style='font-size:8.5pt;
  font-family:Courier;mso-bidi-font-family:"Courier New";color:black'>сферу</span><span
  style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:"Courier New";
  color:black;mso-ansi-language:EN-US'> </span><span style='font-size:8.5pt;
  font-family:Courier;mso-bidi-font-family:"Courier New";color:black'>правее</span><span
  style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:"Courier New";
  color:black;mso-ansi-language:EN-US'> </span><span style='font-size:8.5pt;
  font-family:Courier;mso-bidi-font-family:"Courier New";color:black'>первой</span><span
  lang=EN-US style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:
  "Courier New";color:black;mso-ansi-language:EN-US'> <br>
  glPushMatrix();<br>
  glTranslate(-1.25,0.0,0.0);<br>
  glMaterialfv(GL_FRONT, GL_AMBIENT, no_mat);<br>
  glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);<br>
  glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);<br>
  glMaterialfv(GL_FRONT, GL_SHININESS, low_shininess);<br>
  glMaterialfv(GL_FRONT, GL_EMISSION, no_mat);<br>
  glutSolidSphere(1.0,16,16);<br>
  glPopMatrix();<br>
  <br>
  //</span><span style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:
  "Courier New";color:black'>Нарисовать</span><span style='font-size:8.5pt;
  font-family:Courier;mso-bidi-font-family:"Courier New";color:black;
  mso-ansi-language:EN-US'> </span><span style='font-size:8.5pt;font-family:
  Courier;mso-bidi-font-family:"Courier New";color:black'>третью</span><span
  style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:"Courier New";
  color:black;mso-ansi-language:EN-US'> </span><span style='font-size:8.5pt;
  font-family:Courier;mso-bidi-font-family:"Courier New";color:black'>сферу</span><span
  style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:"Courier New";
  color:black;mso-ansi-language:EN-US'> </span><span style='font-size:8.5pt;
  font-family:Courier;mso-bidi-font-family:"Courier New";color:black'>правее</span><span
  style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:"Courier New";
  color:black;mso-ansi-language:EN-US'> </span><span style='font-size:8.5pt;
  font-family:Courier;mso-bidi-font-family:"Courier New";color:black'>первых</span><span
  style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:"Courier New";
  color:black;mso-ansi-language:EN-US'> </span><span style='font-size:8.5pt;
  font-family:Courier;mso-bidi-font-family:"Courier New";color:black'>двух</span><span
  lang=EN-US style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:
  "Courier New";color:black;mso-ansi-language:EN-US'><br>
  glPushMatrix();<br>
  glTranslate(1.25,0.0,0.0);<br>
  glMaterialfv(GL_FRONT, GL_AMBIENT, no_mat);<br>
  glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);<br>
  glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);<br>
  glMaterialfv(GL_FRONT, GL_SHININESS, high_shininess);<br>
  glMaterialfv(GL_FRONT, GL_EMISSION, no_mat);<br>
  glutSolidSphere(1.0,16,16);<br>
  glPopMatrix();<br>
  <br>
  //</span><span style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:
  "Courier New";color:black'>Нарисовать</span><span style='font-size:8.5pt;
  font-family:Courier;mso-bidi-font-family:"Courier New";color:black;
  mso-ansi-language:EN-US'> </span><span style='font-size:8.5pt;font-family:
  Courier;mso-bidi-font-family:"Courier New";color:black'>последнюю</span><span
  style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:"Courier New";
  color:black;mso-ansi-language:EN-US'> </span><span style='font-size:8.5pt;
  font-family:Courier;mso-bidi-font-family:"Courier New";color:black'>сферу</span><span
  style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:"Courier New";
  color:black;mso-ansi-language:EN-US'> </span><span style='font-size:8.5pt;
  font-family:Courier;mso-bidi-font-family:"Courier New";color:black'>справа</span><span
  lang=EN-US style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:
  "Courier New";color:black;mso-ansi-language:EN-US'><br>
  glPushMatrix();<br>
  glTranslate(3.75,0.0,0.0);<br>
  glMaterialfv(GL_FRONT, GL_AMBIENT, no_mat);<br>
  glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);<br>
  glMaterialfv(GL_FRONT, GL_SPECULAR, no_mat);<br>
  glMaterialfv(GL_FRONT, GL_SHININESS, no_shininess);<br>
  glMaterialfv(GL_FRONT, GL_EMISSION, no_mat);<br>
  glutSolidSphere(1.0,16,16);<br>
  glPopMatrix(); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Как вы видите, <b>glMaterial*()</b>
вызывается несколько раз для установки требуемого свойства материала для каждой
сферы. Заметьте, что эту команду необходимо вызывать только для тех параметров,
которые действительно изменяются. Вторая, третья и четвертая сферы используют
одинаковые фоновое и диффузное свойство материала, так что на самом деле нет
смысла задавать их каждый раз. Поскольку существуют некоторые временные затраты
на выполнение <b>glMaterial*()</b>, пример 5-9 может быть переписан более
эффективным образом (на самом деле из него нужно просто удалить некоторые
строки).</p>

<h2>5.6.5&nbsp; Режим цвета материала</h2>

<p class=text align=left style='text-align:left'>Другая техника снижения затрат
производительности заключается в использовании команды <b>glColorMaterial()</b>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glColorMaterial</b>
  (GLenum <i>face</i>, GLenum <i>mode</i>); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Для граней, заданных
аргументом <i>face</i>, заставляет свойство (или свойства) материала, заданное
аргументом mode, все время принимать значение текущего цвета. При изменении
текущего цвета (командой <b>glColor*()</b>) указанные свойства материала также
незамедлительно меняются. Аргумент <i>face </i>может принимать значения
GL_FRONT, GL_BACKили GL_FRONT_AND_BACK (такое значение аргумент имеет по
умолчанию). Аргумент <i>mode </i>может принимать значения GL_AMBIENT, GL_DIFFUSE,
GL_SPECULAR, GL_AMBIENT_AND_DIFFUSE (значение по умолчанию) или GL_EMISSION. В
каждый момент времени активным является только один из режимов. <b>glColorMaterial()</b>
не работает при использовании освещения в индексном режиме.</p>

<p class=text align=left style='text-align:left'>Отметьте, что <b>glColorMaterial()</b>
задает две независимые величины: первая определяет, свойства материала какого
типа или типов граней изменяются с изменением текущего цвета, а вторая – какие
именно свойства материала изменяются. Однако OpenGL не следит за разными
значениями аргумента <i>mode </i>для разных типов граней!</p>

<p class=text align=left style='text-align:left'>Помимо вызова <b>glColorMaterial()</b>
вам требуется вызвать <b>glEnable()</b> с аргументом GL_COLOR_MATERIAL. После
этого во время рисования вы можете изменять текущий цвет командой <b>glColor*()</b>
(а также по необходимости другие свойства материала командой <b>glMaterial*()</b>).</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>glEnable(GL_COLOR_MATERIAL);<br>
  glColorMaterial(GL_FRONT, GL_DIFFUSE);<br>
  <br>
  //Теперь glColor*() будет изменять диффузное отражение<br>
  glColor3f(0.2,0.5,0.8);<br>
  <br>
  //Здесь мы рисуем несколько объектов<br>
  glColorMaterial(GL_FRONT, GL_SPECULAR);<br>
  <br>
  //Теперь glColor*() изменяет не диффузное, <br>
  //а зеркальное отражение<br>
  glColor3f(0.9,0.0,0.2);<br>
  <br>
  //Рисуем еще несколько объектов<br>
  glDisable(GL_COLOR_MATERIAL); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Используйте <b>glColorMaterial()</b>
в тех случаях, когда для множества вершин на сцене вам требуется изменять
значение единственного параметра материала. Если вам нужно постоянно изменять
более одного свойства – используйте <b>glMaterial*()</b>. Когда
функциональность команды <b>glColorMaterial()</b> вам не требуется, обязательно
убедитесь, что вы выключили данный механизм командой <b>glDisable()</b>. Это
позволит вам избежать свойств материала, изменяющихся «по неизвестным
причинам», а также снизит затраты производительности. Быстродействие приложения
при работе с механизмом <b>glColorMaterial()</b> зависит от реализации OpenGL. Некоторые
реализации могут оптимизировать обработку вершин для ускоренного изменения
свойств материала на базе текущего цвета.</p>

<p class=text align=left style='text-align:left'>Пример 5-10 представляет собой
интерактивную программу, использующую команду <b>glColorMaterial()</b> для
изменения свойств материала. Нажатие на любую из трех кнопок мыши изменяет цвет
диффузного отражения.</p>

<p class=text align=left style='text-align:left'>Пример 5-10. Использование
glColorMaterial(): файл colormat.cpp</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>#include
  &lt;glut.h&gt;<br>
  GLfloat diffuseMaterial[4]={0.0,0.0,0.0,1.0};<br>
  <br>
  //</span><span style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:
  "Courier New";color:black'>Инициализация</span><span lang=EN-US
  style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:"Courier New";
  color:black;mso-ansi-language:EN-US'> <br>
  void init(void)<br>
  {<br>
  &nbsp;&nbsp; GLfloat mat_specular[4]={1.0,1.0,1.0,1.0};<br>
  &nbsp;&nbsp; GLfloat light_position[4]={1.0,1.0,1.0,0.0};<br>
  <br>
  &nbsp;&nbsp; glClearColor(0.0,0.0,0.0,0.0); <br>
  &nbsp;&nbsp; glShadeModel(GL_SMOOTH);<br>
  &nbsp;&nbsp; glEnable(GL_DEPTH_TEST); <br>
  &nbsp;&nbsp; glMaterialfv(GL_FRONT,GL_DIFFUSE,diffuseMaterial); <br>
  &nbsp;&nbsp; glMaterialfv(GL_FRONT,GL_SPECULAR,mat_specular); <br>
  &nbsp;&nbsp; glMaterialf(GL_FRONT,GL_SHININESS,25.0); <br>
  &nbsp;&nbsp; glLightfv(GL_LIGHT0,GL_POSITION,light_position); <br>
  &nbsp;&nbsp; glEnable(GL_LIGHTING);<br>
  &nbsp;&nbsp; glEnable(GL_LIGHT0);<br>
  &nbsp;&nbsp; glColorMaterial(GL_FRONT,GL_DIFFUSE); <br>
  &nbsp;&nbsp; glEnable(GL_COLOR_MATERIAL);<br>
  }<br>
  <br>
  //</span><span style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:
  "Courier New";color:black'>Отображение</span><span lang=EN-US
  style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:"Courier New";
  color:black;mso-ansi-language:EN-US'> <br>
  void display(void)<br>
  {<br>
  &nbsp;&nbsp; glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);<br>
  &nbsp;&nbsp; glutSolidSphere(1.0,20,16);<br>
  &nbsp;&nbsp; glutWireCube(1.0);<br>
  &nbsp;&nbsp; glFlush();<br>
  }<br>
  <br>
  //</span><span style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:
  "Courier New";color:black'>Изменение</span><span style='font-size:8.5pt;
  font-family:Courier;mso-bidi-font-family:"Courier New";color:black;
  mso-ansi-language:EN-US'> </span><span style='font-size:8.5pt;font-family:
  Courier;mso-bidi-font-family:"Courier New";color:black'>размеров</span><span
  style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:"Courier New";
  color:black;mso-ansi-language:EN-US'> </span><span style='font-size:8.5pt;
  font-family:Courier;mso-bidi-font-family:"Courier New";color:black'>окна</span><span
  lang=EN-US style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:
  "Courier New";color:black;mso-ansi-language:EN-US'> <br>
  void reshape(int w, int h)<br>
  {<br>
  &nbsp;&nbsp; glViewport(0,0,(GLsizei) w, (GLsizei) h); <br>
  &nbsp;&nbsp; glMatrixMode(GL_PROJECTION);<br>
  &nbsp;&nbsp; glLoadIdentity();<br>
  &nbsp;&nbsp; if (w&lt;=h) <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  glOrtho(-1.5,1.5,-1.5*(GLfloat)h/(GLfloat)w,1.5*(GLfloat)h/(GLfloat)w,-10.0,10.0);<br>
  &nbsp;&nbsp; else<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  glOrtho(-1.5*(GLfloat)w/(GLfloat)h,1.5*(GLfloat)w/(GLfloat)h,-1.5,1.5,-10.0,10.0);<br>
  &nbsp;&nbsp; glMatrixMode(GL_MODELVIEW);<br>
  &nbsp;&nbsp; glLoadIdentity();<br>
  }<br>
  <br>
  //</span><span style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:
  "Courier New";color:black'>Реакция</span><span style='font-size:8.5pt;
  font-family:Courier;mso-bidi-font-family:"Courier New";color:black;
  mso-ansi-language:EN-US'> </span><span style='font-size:8.5pt;font-family:
  Courier;mso-bidi-font-family:"Courier New";color:black'>на</span><span
  style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:"Courier New";
  color:black;mso-ansi-language:EN-US'> </span><span style='font-size:8.5pt;
  font-family:Courier;mso-bidi-font-family:"Courier New";color:black'>мышь</span><span
  lang=EN-US style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:
  "Courier New";color:black;mso-ansi-language:EN-US'> <br>
  void mouse(int button,int state, int x, int y)<br>
  {<br>
  &nbsp;&nbsp; switch(button)<br>
  &nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case GLUT_LEFT_BUTTON:<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (state==GLUT_DOWN) // </span><span
  style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:"Courier New";
  color:black'>Изменяем</span><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'> </span><span
  style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:"Courier New";
  color:black'>красный</span><span lang=EN-US style='font-size:8.5pt;
  font-family:Courier;mso-bidi-font-family:"Courier New";color:black;
  mso-ansi-language:EN-US'> <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  diffuseMaterial[0]+=0.1;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if
  (diffuseMaterial[0] &gt; 1.0)<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  diffuseMaterial[0]=0.0; <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  glColor4fv(diffuseMaterial); <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  glutPostRedisplay();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case GLUT_MIDDLE_BUTTON:<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (state==GLUT_DOWN) // </span><span
  style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:"Courier New";
  color:black'>Изменяем</span><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'> </span><span
  style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:"Courier New";
  color:black'>зеленый</span><span lang=EN-US style='font-size:8.5pt;
  font-family:Courier;mso-bidi-font-family:"Courier New";color:black;
  mso-ansi-language:EN-US'><br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; diffuseMaterial[1]+=0.1;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if
  (diffuseMaterial[1] &gt; 1.0) <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  diffuseMaterial[1]=0.0;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  glColor4fv(diffuseMaterial); <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  glutPostRedisplay();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case GLUT_RIGHT_BUTTON:<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (state==GLUT_DOWN) // </span><span
  style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:"Courier New";
  color:black'>Изменяем</span><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'> </span><span
  style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:"Courier New";
  color:black'>синий</span><span lang=EN-US style='font-size:8.5pt;font-family:
  Courier;mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:
  EN-US'> <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  diffuseMaterial[2]+=0.1;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if
  (diffuseMaterial[2] &gt; 1.0) <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  diffuseMaterial[2]=0.0;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  glColor4fv(diffuseMaterial); <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  glutPostRedisplay();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>
  &nbsp;&nbsp; }<br>
  }<br>
  <br>
  int main(int argc, char **argv)<br>
  {<br>
  &nbsp;&nbsp; glutInit(&amp;argc,argv); <br>
  &nbsp;&nbsp; glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB|GLUT_DEPTH); <br>
  &nbsp;&nbsp; glutInitWindowSize(500,500); <br>
  &nbsp;&nbsp; glutInitWindowPosition(100,100);<br>
  &nbsp;&nbsp; glutCreateWindow(&quot;Using glColorMaterial()&quot;);<br>
  &nbsp;&nbsp; init();<br>
  &nbsp;&nbsp; glutDisplayFunc(display);<br>
  &nbsp;&nbsp; glutReshapeFunc(reshape);<br>
  &nbsp;&nbsp; glutMouseFunc(mouse);<br>
  &nbsp;&nbsp; glutMainLoop();<br>
  &nbsp;&nbsp; return 0;<br>
  } <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<h2>5.7&nbsp; Математика освещения </h2>

<p class=text align=left style='text-align:left'><b>Дополнительно:</b> В этом
разделе представлены уравнения, используемые OpenGL в расчетах освещенности,
для определения цветов в RGBA режиме. Вам не требуется читать этот раздел, если
вы хотите добиться определенного освещения путем экспериментов. Даже после
чтения этого раздела, вам наверняка придется экспериментировать, но вы будете
иметь лучшее представление о том, как значения определенных параметров влияют
на цвет вершины. Помните, что если освещение выключено, цвет вершины просто
принимает значение текущего цвета, если же освещение включено, расчеты,
связанные с ним, производятся в видовых координатах.</p>

<p class=text align=left style='text-align:left'>В следующих уравнениях
математические расчеты производятся отдельно для R, G и B компонент цвета.
Таким образом, если в уравнении складываются три величины, следует понимать,
что R величины, G величины и B величины складываются отдельно, формируя
результирующий RGB цвет <!--[if gte vml 1]><v:shape id="_x0000_i1126" type="#_x0000_t75"
 alt="" style='width:243.75pt;height:14.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image094.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов5.mht!http://www.progz.ru/images/opengl/chapter5/form5.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=325 height=19
src="OpenGL%20Red%20Book.files/image094.gif" v:shapes="_x0000_i1126"><![endif]>.
Когда же три величины перемножаются – результатом будет <!--[if gte vml 1]><v:shape
 id="_x0000_i1127" type="#_x0000_t75" alt="" style='width:154.5pt;height:14.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image095.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов5.mht!http://www.progz.ru/images/opengl/chapter5/form6.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=206 height=19
src="OpenGL%20Red%20Book.files/image095.gif" v:shapes="_x0000_i1127"><![endif]>.
(Помните, что значение компонента A или альфа компонента цвета вершины равно
значению диффузного альфа компонента материала этой вершины.)</p>

<p class=text align=left style='text-align:left'>Цвет освещенной вершины
вычисляется следующим образом:</p>

<p class=text align=left style='text-align:left'>цвет вершины =&nbsp; исходящий
цвет материала вершины +<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
глобальный фоновый цвет, умноженный на значение фонового свойства материала
вершины + <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
фоновые, диффузные и зеркальные вклады всех источников света, ослабленные
должным образом.</p>

<p class=text align=left style='text-align:left'>После расчета освещенности
цветовые величины масштабируются в диапазон [0, 1] (в режиме RGBA).</p>

<p class=text align=left style='text-align:left'>Имейте в виду, что при расчете
освещенности OpenGL не принимает в расчет возможность того, что один объект
может загораживать свет для другого, как следствие автоматически не
отбрасываются тени. Также имейте в виду, что объекты, обладающие исходящим
излучением, не добавляют света другим объектам. </p>

<h2>5.7.1&nbsp; Исходящий свет материала</h2>

<p class=text align=left style='text-align:left'>Исходящий свет является
простейшим для расчета. Его значение равно параметру GL_EMISSION материала
вершины.</p>

<h2>5.7.2&nbsp; Масштабированный глобальный фоновый свет</h2>

<p class=text align=left style='text-align:left'>Числовая величина этого света
вычисляется путем перемножения глобального фонового света (определенного
параметром GL_LIGHT_MODEL_AMBIENT) на значение фонового свойства материала
GL_AMBIENT, определенного командой <b>glMaterial*()</b>:</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1128" type="#_x0000_t75" alt="" style='width:211.5pt;height:18.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image096.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов5.mht!http://www.progz.ru/images/opengl/chapter5/form7.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=282 height=25
src="OpenGL%20Red%20Book.files/image096.gif" v:shapes="_x0000_i1128"><![endif]></p>

<p class=text align=left style='text-align:left'>Каждая пара R, G и B величин
для этих двух параметров перемножается независимо, формируя результирующий RGB
цвет <!--[if gte vml 1]><v:shape id="_x0000_i1129" type="#_x0000_t75" alt=""
 style='width:112.5pt;height:15.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image097.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов5.mht!http://www.progz.ru/images/opengl/chapter5/form8.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=150 height=21
src="OpenGL%20Red%20Book.files/image097.gif" v:shapes="_x0000_i1129"><![endif]>.</p>

<h2>5.7.3&nbsp; Вклады источников света</h2>

<p class=text align=left style='text-align:left'>Каждый источник света может
вносить свой вклад в освещенность вершины, и все эти вклады от всех источников
суммируются. Далее приведено уравнение, используемое для вычисления вклада
каждого источника света:</p>

<p class=text align=left style='text-align:left'>вклад =фактор ослабления *
прожекторный эффект * (фоновый вклад + диффузный вклад + зеркальный вклад)</p>

<h2>5.7.3.1&nbsp;&nbsp;&nbsp; Фактор ослабления</h2>

<p class=text align=left style='text-align:left'>Фактор ослабления был описан
ранее в этой главе.</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1130" type="#_x0000_t75" alt="" style='width:128.25pt;height:40.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image086.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов5.mht!http://www.progz.ru/images/opengl/chapter5/form1.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=171 height=54
src="OpenGL%20Red%20Book.files/image086.gif" v:shapes="_x0000_i1130"><![endif]>,</p>

<p class=text align=left style='text-align:left'>где <i>d</i> - расстояние
между позицией источника света и вершиной,<br>
<!--[if gte vml 1]><v:shape id="_x0000_i1131" type="#_x0000_t75" alt=""
 style='width:15pt;height:16.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image087.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов5.mht!http://www.progz.ru/images/opengl/chapter5/form2.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=20 height=22
src="OpenGL%20Red%20Book.files/image087.gif" v:shapes="_x0000_i1131"><![endif]>-
GL_CONSTANT_ATTENUATION (постоянный фактор ослабления),<br>
<!--[if gte vml 1]><v:shape id="_x0000_i1132" type="#_x0000_t75" alt=""
 style='width:12.75pt;height:17.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image088.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов5.mht!http://www.progz.ru/images/opengl/chapter5/form3.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=17 height=23
src="OpenGL%20Red%20Book.files/image088.gif" v:shapes="_x0000_i1132"><![endif]>-
GL_LINEAR_ATTENUATION (линейный фактор ослабления),<br>
<!--[if gte vml 1]><v:shape id="_x0000_i1133" type="#_x0000_t75" alt=""
 style='width:14.25pt;height:18pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image089.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов5.mht!http://www.progz.ru/images/opengl/chapter5/form4.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=19 height=24
src="OpenGL%20Red%20Book.files/image089.gif" v:shapes="_x0000_i1133"><![endif]>-
GL_QUADRATIC_ATTENUATION (квадратичный фактор ослабления).</p>

<p class=text align=left style='text-align:left'>Если источник света является
направленным, фактор ослабления равен 1.</p>

<h2>5.7.3.2&nbsp;&nbsp;&nbsp; Прожекторный эффект</h2>

<p class=text align=left style='text-align:left'>Прожекторный эффект может
вычисляться тремя разными способами в зависимости от того, является ли в
действительности источник света прожектором и от того, находится ли вершина
внутри или снаружи конуса излучения прожектора:</p>

<p class=text align=left style='margin-left:54.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l42 level1 lfo20;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>1, если источник не является прожектором
(параметр GL_SPOT_CUTOFFравен 180.0);</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l42 level1 lfo20;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>0, если источник света является прожектором, но
вершина лежит вне его конуса излучения;</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l42 level1 lfo20;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>&nbsp;<!--[if gte vml 1]><v:shape id="_x0000_i1134"
 type="#_x0000_t75" alt="" style='width:212.25pt;height:21.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image098.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов5.mht!http://www.progz.ru/images/opengl/chapter5/form9.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=283 height=29
src="OpenGL%20Red%20Book.files/image098.gif" v:shapes="_x0000_i1134"><![endif]>,
где <!--[if gte vml 1]><v:shape id="_x0000_i1135" type="#_x0000_t75" alt=""
 style='width:82.5pt;height:12.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image099.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов5.mht!http://www.progz.ru/images/opengl/chapter5/form10.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=110 height=17
src="OpenGL%20Red%20Book.files/image099.gif" v:shapes="_x0000_i1135"><![endif]>&nbsp;--
единичный вектор из прожектора в вершину; <!--[if gte vml 1]><v:shape id="_x0000_i1136"
 type="#_x0000_t75" alt="" style='width:90.75pt;height:17.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image100.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов5.mht!http://www.progz.ru/images/opengl/chapter5/form11.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=121 height=23
src="OpenGL%20Red%20Book.files/image100.gif" v:shapes="_x0000_i1136"><![endif]>&nbsp;--
направление прожектора (GL_SPOT_DIRECTION), предполагается, что источник света
является прожектором и вершина лежит внутри его конуса излучения. Скалярное
произведение векторов <i>v</i> и &nbsp;<i>d</i> меняется в соответствии с
косинусом угла между ними; таким образом, объекты на линии освещения получают
максимум освещенности, объекты вне этой линии получают меньше света в
соответствии с косинусом угла.</p>

<p class=text align=left style='text-align:left'>Для определения того, лежит ли
вершина внутри конуса излучения прожектора OpenGL вычисляет величину <!--[if gte vml 1]><v:shape
 id="_x0000_i1137" type="#_x0000_t75" alt="" style='width:84pt;height:14.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image101.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов5.mht!http://www.progz.ru/images/opengl/chapter5/form12.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=112 height=19
src="OpenGL%20Red%20Book.files/image101.gif" v:shapes="_x0000_i1137"><![endif]>.
Если эта величина меньше косинуса угла при вершине конуса излучения прожектора
(GLL_SPOT_CUTOFF) – вершина находится вне конуса излучения, иначе вершина
находится внутри конуса.</p>

<h2>5.7.3.3&nbsp;&nbsp;&nbsp; Фоновый вклад</h2>

<p class=text align=left style='text-align:left'>Фоновый вклад представляет
собой фоновый цвет источника, умноженный на фоновое свойство материала вершины:
</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1138" type="#_x0000_t75" alt="" style='width:168pt;height:18pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image102.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов5.mht!http://www.progz.ru/images/opengl/chapter5/form19.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=224 height=24
src="OpenGL%20Red%20Book.files/image102.gif" v:shapes="_x0000_i1138"><![endif]></p>

<h2>5.7.3.4&nbsp;&nbsp;&nbsp; Диффузный вклад</h2>

<p class=text align=left style='text-align:left'>Необходимо принимать в расчет
диффузный вклад источника света независимо от того, падает ли свет
непосредственно на вершину или нет. Он вычисляется как:</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1139" type="#_x0000_t75" alt="" style='width:246.75pt;height:20.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image103.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов5.mht!http://www.progz.ru/images/opengl/chapter5/form13.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=329 height=27
src="OpenGL%20Red%20Book.files/image103.gif" v:shapes="_x0000_i1139"><![endif]>,
где</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1140" type="#_x0000_t75" alt="" style='width:87.75pt;height:18.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image104.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов5.mht!http://www.progz.ru/images/opengl/chapter5/form14.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=117 height=25
src="OpenGL%20Red%20Book.files/image104.gif" v:shapes="_x0000_i1140"><![endif]>&nbsp;--
единичные вектор, указывающий из вершины в направлении положения источника
света (GL_POSITION).</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1141" type="#_x0000_t75" alt="" style='width:87pt;height:16.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image105.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов5.mht!http://www.progz.ru/images/opengl/chapter5/form15.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=116 height=22
src="OpenGL%20Red%20Book.files/image105.gif" v:shapes="_x0000_i1141"><![endif]>&nbsp;--
вектор нормали единичной длины в вершине.</p>

<h2>5.7.3.5&nbsp;&nbsp;&nbsp; Зеркальный вклад</h2>

<p class=text align=left style='text-align:left'>Зеркальный вклад зависит от
того, падает ли свет непосредственно на вершину. Если <!--[if gte vml 1]><v:shape
 id="_x0000_i1142" type="#_x0000_t75" alt="" style='width:27pt;height:14.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image106.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов5.mht!http://www.progz.ru/images/opengl/chapter5/form16.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=36 height=19
src="OpenGL%20Red%20Book.files/image106.gif" v:shapes="_x0000_i1142"><![endif]>&nbsp;меньше
или равно 0, то в вершине не присутствует зеркального компонента. (Если эта
величина меньше 0, источник света находится с другой стороны поверхности.) Если
же зеркальный вклад присутствует, он зависит от следующего:</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l23 level1 lfo21;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Вершинная нормаль единичной длины <!--[if gte vml 1]><v:shape
 id="_x0000_i1143" type="#_x0000_t75" alt="" style='width:63pt;height:15pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image107.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов5.mht!http://www.progz.ru/images/opengl/chapter5/form17.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=84 height=20
src="OpenGL%20Red%20Book.files/image107.gif" v:shapes="_x0000_i1143"><![endif]>.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l23 level1 lfo21;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Сумма двух векторов единичной длины: вектора
между вершиной и положением источника света (или направлением источника света)
и вектора между вершиной и точкой наблюдения (в случае если выбран режим
GL_LIGHT_MODEL_LOCAL_VIEWER, если это не так, то в качестве второго вектора
суммы берется (0, 0, 1)). Эта векторная сумма нормализуется (путем деления
каждого компонента на размер получившегося вектора). В результате получаем <!--[if gte vml 1]><v:shape
 id="_x0000_i1144" type="#_x0000_t75" alt="" style='width:82.5pt;height:18pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image108.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов5.mht!http://www.progz.ru/images/opengl/chapter5/form18.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=110 height=24
src="OpenGL%20Red%20Book.files/image108.gif" v:shapes="_x0000_i1144"><![endif]>.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l23 level1 lfo21;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Зеркальный показатель (GL_SHININESS).</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l23 level1 lfo21;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Зеркальный цвет источника света (<!--[if gte vml 1]><v:shape
 id="_x0000_i1145" type="#_x0000_t75" alt="" style='width:120pt;height:17.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image109.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов5.mht!http://www.progz.ru/images/opengl/chapter5/form20.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=160 height=23
src="OpenGL%20Red%20Book.files/image109.gif" v:shapes="_x0000_i1145"><![endif]>).</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l23 level1 lfo21;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Зеркальное свойство материала (<!--[if gte vml 1]><v:shape
 id="_x0000_i1146" type="#_x0000_t75" alt="" style='width:138.75pt;height:18pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image110.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов5.mht!http://www.progz.ru/images/opengl/chapter5/form21.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=185 height=24
src="OpenGL%20Red%20Book.files/image110.gif" v:shapes="_x0000_i1146"><![endif]>).</p>

<p class=text align=left style='text-align:left'>OpenGL использует следующее
уравнение для расчета зеркального вклада источника света (с учетом приведенного
выше описания):</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1147" type="#_x0000_t75" alt="" style='width:306pt;height:21.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image111.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов5.mht!http://www.progz.ru/images/opengl/chapter5/form22.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=408 height=29
src="OpenGL%20Red%20Book.files/image111.gif" v:shapes="_x0000_i1147"><![endif]>.</p>

<p class=text align=left style='text-align:left'>Однако, если <!--[if gte vml 1]><v:shape
 id="_x0000_i1148" type="#_x0000_t75" alt="" style='width:48pt;height:13.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image112.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов5.mht!http://www.progz.ru/images/opengl/chapter5/form26.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=64 height=18
src="OpenGL%20Red%20Book.files/image112.gif" v:shapes="_x0000_i1148"><![endif]>,
зеркальный вклад равен 0.</p>

<h2>5.7.4&nbsp; Суммирование всех элементов</h2>

<p class=text align=left style='text-align:left'>Ссылаясь на определения,
данные в предыдущих разделах, мы можем записать полное уравнение освещенности,
используемое OpenGL в следующем виде:</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1149" type="#_x0000_t75" alt="" style='width:429pt;height:141.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image113.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов5.mht!http://www.progz.ru/images/opengl/chapter5/form23.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=572 height=189
src="OpenGL%20Red%20Book.files/image113.gif" v:shapes="_x0000_i1149"><![endif]></p>

<h2>5.7.5&nbsp; Отделение зеркального цвета</h2>

<p class=text align=left style='text-align:left'>Если для модели освещения
цветовой контроль установлен в значение GL_SEPARATE_SPECULAR_COLOR, то для
каждой вершины вычисляется два цвета (первичный и вторичный) в соответствии со
следующими формулами:</p>

<p class=text align=left style='text-align:left'>первичный цвет =&nbsp;
исходящий свет материала вершины +<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
глобальное фоновое освещение, умноженное на<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
фоновое свойство материала вершины +<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
фоновые и диффузные вклады всех источников света, <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ослабленные соответствующим образом.</p>

<p class=text align=left style='text-align:left'>вторичный цвет =&nbsp;
зеркальные вклады всех источников света,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ослабленные соответствующим образом.</p>

<p class=text align=left style='text-align:left'>Следующие два уравнения
применяются OpenGL для расчета первичного и вторичного цветов:</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1150" type="#_x0000_t75" alt="" style='width:441.75pt;height:113.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image114.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов5.mht!http://www.progz.ru/images/opengl/chapter5/form24.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=589 height=151
src="OpenGL%20Red%20Book.files/image114.gif" v:shapes="_x0000_i1150"><![endif]></p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1151" type="#_x0000_t75" alt="" style='width:411.75pt;height:70.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image115.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов5.mht!http://www.progz.ru/images/opengl/chapter5/form25.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=549 height=94
src="OpenGL%20Red%20Book.files/image115.gif" v:shapes="_x0000_i1151"><![endif]></p>

<p class=text align=left style='text-align:left'>В процессе текстурирования, с
цветами текстуры комбинируется только первичный цвет. После текстурирования
вторичный цвет добавляется к комбинации первичного и текстурных цветов.</p>

<h2>5.8&nbsp; Освещение в индексном цветовом режиме</h2>

<p class=text align=left style='text-align:left'>В индексном режиме параметры,
задаваемые RGBAвеличинами, либо не имеют эффекта, либо интерпретируются особым
образом. Поскольку в индексном режиме намного сложнее достигнуть определенных
эффектов, связанных с освещением, следует использовать RGBAрежим везде, где это
возможно. Вообще говоря, в индексном режиме используется всего три параметра в
форме RGBA. Более конкретно, используются параметры источника света GL_DIFFUSEи
GL_SPECULAR, а также параметр материала GL_SHININESS. GL_DIFFUSEи GL_SPECULAR (<!--[if gte vml 1]><v:shape
 id="_x0000_i1152" type="#_x0000_t75" alt="" style='width:14.25pt;height:15pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image116.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов5.mht!http://www.progz.ru/images/opengl/chapter5/form27.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=19 height=20
src="OpenGL%20Red%20Book.files/image116.gif" v:shapes="_x0000_i1152"><![endif]>
и <!--[if gte vml 1]><v:shape id="_x0000_i1153" type="#_x0000_t75" alt=""
 style='width:10.5pt;height:13.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image117.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов5.mht!http://www.progz.ru/images/opengl/chapter5/form28.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=14 height=18
src="OpenGL%20Red%20Book.files/image117.gif" v:shapes="_x0000_i1153"><![endif]>,
соответственно) используются для вычисления цветовых индексов диффузной и
зеркальной световых интенсивностей (<!--[if gte vml 1]><v:shape id="_x0000_i1154"
 type="#_x0000_t75" alt="" style='width:17.25pt;height:16.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image118.png" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов5.mht!http://www.progz.ru/images/opengl/chapter5/form29.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=23 height=22
src="OpenGL%20Red%20Book.files/image119.gif" v:shapes="_x0000_i1154"><![endif]>и
<!--[if gte vml 1]><v:shape id="_x0000_i1155" type="#_x0000_t75" alt=""
 style='width:17.25pt;height:15.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image120.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов5.mht!http://www.progz.ru/images/opengl/chapter5/form30.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=23 height=21
src="OpenGL%20Red%20Book.files/image120.gif" v:shapes="_x0000_i1155"><![endif]>)
следующим образом:</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1156" type="#_x0000_t75" alt="" style='width:231.75pt;height:37.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image121.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов5.mht!http://www.progz.ru/images/opengl/chapter5/form31.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=309 height=50
src="OpenGL%20Red%20Book.files/image121.gif" v:shapes="_x0000_i1156"><![endif]>,
где</p>

<p class=text align=left style='text-align:left'>R(x), G(x) и B(x) представляют
соответственно красный, зеленый и синий компоненты цвета x. Весовые
коэффициенты 0.30, 0.59 и 0.11 отражают степень восприятия компонентов цвета
человеческим глазом – ваши глаза наиболее чувствительных зеленому и наименее
чувствительны к синему цвету.</p>

<p class=text align=left style='text-align:left'>Чтобы задать цвета материала в
индексном режиме, используйте <b>glMaterial*()</b> со специальным параметром
GL_COLOR_INDEXES:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>GLufloat
  mat_colormap[]={16.0,47.0,79.0};<br>
  glMaterialfv(GL_FRONT, GL_COLOR_INDEXES, mat_colormap); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Три числа заданные для
GL_COLOR_INDEXES задают соответственно цветовые индексы фонового, диффузного и
зеркального цветов материала. Другими словами OpenGL считает цвет с индексом,
заданным в первом числе (в данном случае 16.0) чистым фоновым цветом, цвет с
индексом, заданным во втором числе (47.0) чистым диффузным цветом, а цвет с
индексом, заданным в третьем числе (79.0) – чистым зеркальным цветом. (По
умолчанию фоновый цвет имеет индекс 0.0, а диффузный и зеркальный цвета –
индекс 1.0. Отметьте, что команда <b>glColorMaterial() </b>не работает в
индексном режиме.)</p>

<p class=text align=left style='text-align:left'>Во время рисования сцены
OpenGL использует цвета, ассоциированные с индексами между этими числами для
закраски объектов сцены. Таким образом, вы должны верно построить цветовую
таблицу между этими индексами (в данном примере между 16 и 47 и затем между 47
и 79). Часто цветовая карта строится плавной, но вы можете создавать ее из
других соображений для достижения определенных эффектов. Далее приведен пример
плавной цветовой карты, начинающейся с черного фонового цвета, проходящей через
фиолетовый диффузный цвет к белому зеркальному цвету:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>for
  (i=0;i&lt;32;i++)<br>
  {<br>
  &nbsp;&nbsp; glutSetColor(16+i,1.0*(i/32.0),0.0,1.0*(i/32.0));<br>
  &nbsp;&nbsp; glutSetColor(48+i,1.0,1.0*(i/32.0),1.0);<br>
  } <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Команда <b>glutSetColor()</b>
библиотеки GLUT принимает 4 аргумента. Она ассоциирует индекс, задаваемый
первым аргументом с тройкой RGB, задаваемой вторым, третьим и четвертым
аргументами. При i=0 цветовой индекс 16 ассоциируется с черным RGBцветом (0, 0,
0). Цветовая карта плавно строится до диффузного цвета материала с индексом 47
(при i=31), которому соответствует фиолетовый RGB цвет (1.0, 0.0, 1.0). Вторая
команда внутри цикла строит карту между фиолетовым диффузным цветом и белым
зеркальным цветом (1.0, 1.0, 1.0) в индексе 79.</p>

<h2>5.8.1&nbsp; Математика освещения в индексном режиме</h2>

<p class=text align=left style='text-align:left'><b>Дополнительно:</b> Как вы
можете ожидать, поскольку в индексном режиме доступно другое подмножество
параметром освещения, нежели в RGBAрежиме, расчеты также производятся иначе.
Поскольку в индексном режиме исходящий от материала свет, а также фоновое
освещение не задаются, здесь представляют интерес только диффузный и зеркальный
вклады источников света. Даже эти элементы рассчитываются иначе. </p>

<p class=text align=left style='text-align:left'>Начнем с диффузного и
зеркального элементов из RGBAуравнений. В диффузном элементе заменим <!--[if gte vml 1]><v:shape
 id="_x0000_i1157" type="#_x0000_t75" alt="" style='width:154.5pt;height:18pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image122.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов5.mht!http://www.progz.ru/images/opengl/chapter5/form39.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=206 height=24
src="OpenGL%20Red%20Book.files/image122.gif" v:shapes="_x0000_i1157"><![endif]>&nbsp;на
<!--[if gte vml 1]><v:shape id="_x0000_i1158" type="#_x0000_t75" alt=""
 style='width:17.25pt;height:16.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image118.png" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов5.mht!http://www.progz.ru/images/opengl/chapter5/form29.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=23 height=22
src="OpenGL%20Red%20Book.files/image119.gif" v:shapes="_x0000_i1158"><![endif]>,
вычисленное в предыдущем разделе для индексного режима. Аналогично, для
зеркального элемента, вместо <!--[if gte vml 1]><v:shape id="_x0000_i1159"
 type="#_x0000_t75" alt="" style='width:171pt;height:18.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image123.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов5.mht!http://www.progz.ru/images/opengl/chapter5/form40.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=228 height=25
src="OpenGL%20Red%20Book.files/image123.gif" v:shapes="_x0000_i1159"><![endif]>&nbsp;подставим
<!--[if gte vml 1]><v:shape id="_x0000_i1160" type="#_x0000_t75" alt=""
 style='width:17.25pt;height:15.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image120.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов5.mht!http://www.progz.ru/images/opengl/chapter5/form30.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=23 height=21
src="OpenGL%20Red%20Book.files/image120.gif" v:shapes="_x0000_i1160"><![endif]>&nbsp;из
предыдущего раздела. (Ослабление, прожекторный эффект и другие компоненты этих
элементов вычисляются также как в RGBAрежиме.) Назовем эти модифицированные
элементы <i>d</i> и <i>s</i> соответственно. Теперь, пусть <!--[if gte vml 1]><v:shape
 id="_x0000_i1161" type="#_x0000_t75" alt="" style='width:66pt;height:15pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image124.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов5.mht!http://www.progz.ru/images/opengl/chapter5/form32.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=88 height=20
src="OpenGL%20Red%20Book.files/image124.gif" v:shapes="_x0000_i1161"><![endif]>.
Вычислим <!--[if gte vml 1]><v:shape id="_x0000_i1162" type="#_x0000_t75"
 alt="" style='width:180.75pt;height:15.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image125.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов5.mht!http://www.progz.ru/images/opengl/chapter5/form33.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=241 height=21
src="OpenGL%20Red%20Book.files/image125.gif" v:shapes="_x0000_i1162"><![endif]>,
где <!--[if gte vml 1]><v:shape id="_x0000_i1163" type="#_x0000_t75" alt=""
 style='width:17.25pt;height:12pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image126.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов5.mht!http://www.progz.ru/images/opengl/chapter5/form34.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=23 height=16
src="OpenGL%20Red%20Book.files/image126.gif" v:shapes="_x0000_i1163"><![endif]>,
<!--[if gte vml 1]><v:shape id="_x0000_i1164" type="#_x0000_t75" alt=""
 style='width:20.25pt;height:18pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image127.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов5.mht!http://www.progz.ru/images/opengl/chapter5/form35.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=27 height=24
src="OpenGL%20Red%20Book.files/image127.gif" v:shapes="_x0000_i1164"><![endif]>&nbsp;и
<!--[if gte vml 1]><v:shape id="_x0000_i1165" type="#_x0000_t75" alt=""
 style='width:14.25pt;height:14.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image128.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов5.mht!http://www.progz.ru/images/opengl/chapter5/form36.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=19 height=19
src="OpenGL%20Red%20Book.files/image128.gif" v:shapes="_x0000_i1165"><![endif]>&nbsp;представляют
собой индексы фонового, диффузного и зеркального цветов материала, заданные
командой <b>glMaterial*()</b> с аргументом GL_COLOR_INDEXES. Индекс
результирующего цвета будет равен<sub> <!--[if gte vml 1]><v:shape id="_x0000_i1166"
 type="#_x0000_t75" alt="" style='width:81.75pt;height:15pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image129.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов5.mht!http://www.progz.ru/images/opengl/chapter5/form37.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=109 height=20
src="OpenGL%20Red%20Book.files/image129.gif" v:shapes="_x0000_i1166"><![endif]></sub>.</p>

<p class=text align=left style='text-align:left'>После того, как расчет
освещенности произведен, индексные величины конвертируются в формат с
фиксированной точкой (с неопределенным количеством битов справа от двоичной
точки). Далее целая часть индекса маскируется (с помощью побитового И) с числом
<!--[if gte vml 1]><v:shape id="_x0000_i1167" type="#_x0000_t75" alt=""
 style='width:33.75pt;height:16.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image130.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов5.mht!http://www.progz.ru/images/opengl/chapter5/form38.GIF"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=45 height=22
src="OpenGL%20Red%20Book.files/image130.gif" v:shapes="_x0000_i1167"><![endif]>,
где <i>n</i>– количество битов на цвет в индексном буфере.</p>

<p class=MsoNormal><a name=Глава6><span style='display:none;mso-hide:all'><o:p>&nbsp;</o:p></span></a></p>

<h1 align=left style='text-align:left'><span style='mso-bookmark:Глава6'>Глава
6. Цветовое наложение, сглаживание, туман и смещение полигонов</span></h1>

<span style='mso-bookmark:Глава6'></span>

<p class=MsoNormal><a href="mailto:ahinar@list.ru"></a><span style='font-size:
10.0pt;font-family:Verdana'><span style='mso-spacerun:yes'> </span>В данной
главе обсуждаются 4 техники, которые позволят вам «отполировать» ваши
трехмерные сцены и внести в них дополнительные детали. Каждую из этих техник
достаточно легко использовать – по правде говоря, их значительно тяжелее
объяснить, чем использовать.<o:p></o:p></span></p>

<h2>6.1&nbsp; Цветовое наложение</h2>

<p class=text align=left style='text-align:left'>Вы уже видели значения альфа –
компонента в четверке RGBA, но до этого момента они игнорировались. Альфа –
значения задаются при использовании команды <b>glColor*()</b>, при указании
очищающего цвета командой <b>glClearColor()</b>, а также при определении
некоторых параметров освещения, например, свойств материала или интенсивности
освещения. Пиксели на мониторе излучают красный, зеленый и синий свет, а его
количество контролируется соответствующими значениями красного, зеленого и
синего. Так каким же образом значение альфа влияет на то, что будет нарисовано
в окне на экране?</p>

<p class=text align=left style='text-align:left'>При включенном механизме
цветового наложения, значение альфа часто используется для комбинирования цвета
обрабатываемого фрагмента с цветом соответствующего ему пикселя, уже
сохраненного в буфере кадра. Цветовое наложение происходит после того, как ваша
сцена была растеризована и преобразована во фрагменты, но до того, как пиксели
записываются в буфер кадра. Значения альфа, кроме того, могут быть использованы
при альфа – тестировании для принятия или отбрасывания отдельных фрагментов на
основании их альфа – значения.</p>

<p class=text align=left style='text-align:left'>Без цветового наложения каждый
новый фрагмент заменяет любые цветовые значения в буфере кадра, как будто этот
фрагмент является непрозрачным. С использованием цветового наложения вы можете
управлять тем как (и в какой степени) существующие цветовые величины должны
комбинироваться с цветами новых поступающих фрагментов. Таким образом, вы
можете использовать цветовое наложение для создания полупрозрачных фрагментов,
сквозь которые вида часть ранее сохраненного в буфере кадра цвета. Цветовое наложение
необходимо для таких техник как прозрачность и цифровая композиция.</p>

<h2>6.1&nbsp; Цветовое наложение</h2>

<p class=text align=left style='text-align:left'>Вы уже видели значения альфа –
компонента в четверке RGBA, но до этого момента они игнорировались. Альфа –
значения задаются при использовании команды <b>glColor*()</b>, при указании
очищающего цвета командой <b>glClearColor()</b>, а также при определении
некоторых параметров освещения, например, свойств материала или интенсивности
освещения. Пиксели на мониторе излучают красный, зеленый и синий свет, а его
количество контролируется соответствующими значениями красного, зеленого и
синего. Так каким же образом значение альфа влияет на то, что будет нарисовано
в окне на экране?</p>

<p class=text align=left style='text-align:left'>При включенном механизме
цветового наложения, значение альфа часто используется для комбинирования цвета
обрабатываемого фрагмента с цветом соответствующего ему пикселя, уже
сохраненного в буфере кадра. Цветовое наложение происходит после того, как ваша
сцена была растеризована и преобразована во фрагменты, но до того, как пиксели
записываются в буфер кадра. Значения альфа, кроме того, могут быть использованы
при альфа – тестировании для принятия или отбрасывания отдельных фрагментов на
основании их альфа – значения.</p>

<p class=text align=left style='text-align:left'>Без цветового наложения каждый
новый фрагмент заменяет любые цветовые значения в буфере кадра, как будто этот
фрагмент является непрозрачным. С использованием цветового наложения вы можете
управлять тем как (и в какой степени) существующие цветовые величины должны
комбинироваться с цветами новых поступающих фрагментов. Таким образом, вы можете
использовать цветовое наложение для создания полупрозрачных фрагментов, сквозь
которые вида часть ранее сохраненного в буфере кадра цвета. Цветовое наложение
необходимо для таких техник как прозрачность и цифровая композиция. </p>

<p class=warning>Замечание: Альфа – величины не задаются в индексном цветовом
режиме, как следствие, цветовое наложение в этом режиме недоступно. </p>

<p class=text align=left style='text-align:left'>Наиболее близкий к реальности
способ осознания операций с цветовым наложением заключается в том, чтобы думать
о RGB– тройке, как о цвете фрагмента, а об альфа – величине как о степени его
непрозрачности (цветовой плотности). Прозрачные и полупрозрачные поверхности
имеют плотность ниже, чем непрозрачные и, таким образом, обладают меньшем
значением альфа. Например, если вы рассматриваете объект через зеленое стекло,
его цвет будет частично зеленым (от стекла) и частично цветом самого объекта.
Процентное соотношение этих цветов зависит от того, насколько хорошо стекло
пропускает свет. Если оно пропускает 80% поступающего на него света (то есть
стекло цветовую имеет плотность равную 20%), то цвет, который вы увидите, будет
состоять на 20% из цвета стекла и на 80% из цвета объекта за ним. Вы легко
можете представить себе ситуации с множеством полупрозрачных поверхностей.
Например, при рассматривании автомобиля снаружи, его интерьер виден вам через
одно стекло, тогда как некоторые объекты за автомобилем могут быть видны через
два стекла.</p>

<h2>6.1.1&nbsp; Факторы источника и приемника</h2>

<p class=text align=left style='text-align:left'>Во время цветового наложения
цветовые величины входящего фрагмента (<i>источника</i>) комбинируются с
цветовыми величинами соответствующего, сохраненного к текущему моменту пикселя
(<i>приемника</i>) в два этапа. Сначала вы задаете, каким образом следует
вычислять факторы источника и приемника. Эти факторы представляют собой
четверки RGBA, которые умножаются на R, G, B и A величины источника и приемника
соответственно. Затем соответствующие компоненты в двух наборах RGBA четверок
комбинируются между собой. Чтобы показать этот процесс с математической точки
зрения, обозначим факторы источника и приемника соответственно <!--[if gte vml 1]><v:shape
 id="_x0000_i1168" type="#_x0000_t75" alt="" style='width:85.5pt;height:17.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image131.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов6.mht!http://www.progz.ru/images/opengl/chapter6/form1.JPG"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=114 height=23
src="OpenGL%20Red%20Book.files/image131.jpg" v:shapes="_x0000_i1168"><![endif]>&nbsp;и
<!--[if gte vml 1]><v:shape id="_x0000_i1169" type="#_x0000_t75" alt=""
 style='width:97.5pt;height:17.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image132.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов6.mht!http://www.progz.ru/images/opengl/chapter6/form2.JPG"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=130 height=23
src="OpenGL%20Red%20Book.files/image132.jpg" v:shapes="_x0000_i1169"><![endif]>,
а цветовые компоненты источника и приемника обозначим нижним индексом <i>s</i>
или <i>d</i> соответственно. Тогда результирующие цветовые величины после
цветового наложения могут быть получены из следующего уравнения:</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1170" type="#_x0000_t75" alt="" style='width:345.75pt;height:17.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image133.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов6.mht!http://www.progz.ru/images/opengl/chapter6/form3.JPG"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=461 height=23
src="OpenGL%20Red%20Book.files/image133.jpg" v:shapes="_x0000_i1170"><![endif]>.</p>

<p class=text align=left style='text-align:left'>Каждый компонент этой четверки
приводится к диапазону [0,1].</p>

<p class=text align=left style='text-align:left'>По умолчанию фрагменты
приемника и источника комбинируются путем суммирования их величин. Однако, если
ваша реализация OpenGL поддерживает подмножество функций работы с
изображениями, вы можете использовать другие математические операции для
комбинирования фрагментов.</p>

<p class=text align=left style='text-align:left'>Теперь разберемся с тем, как
генерируются факторы наложения. Вы используете команду <b>glBlendFunc()</b>,
чтобы задать две константы: одна из них задает метод вычисления фактора
источника, вторая – метод расчета фактора приемника. Чтобы производить цветовое
наложение, вам также следует включить соответствующий механизм:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>glEnable(GL_BLEND);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Для выключения наложения
следует использовать команду <b>glDisable()</b> с аргументом GL_BLEND. Также
обратите внимание, что использование констант GL_ONE (для источника) и GL_ZERO
(для приемника) дает те же результаты, что и при выключенном цветовом наложении
(именно эти значения установлены для факторов по умолчанию).</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glBlendFunc</b>
  (GLenum <i>sfactor</i>, GLenum <i>dfactor</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Управляет тем, как цветовые
величины обрабатываемого фрагмента (источника) комбинируются с теми, которые
уже сохранены в буфере кадра (приемника). Аргумент <i>sfactor </i>задает метод
вычисления фактора наложения источника; аргумент <i>dfactor</i> -- метод
вычисления фактора наложения приемника. Возможные значения этих параметров
перечислены в таблице 6-1. Вычисляемые факторы наложения лежат в диапазоне
[0,1]; после того, как цветовые величины источника и приемника комбинируются,
они также приводятся к диапазону [0,1].</p>

<p class=warning>Замечание: В таблице 6-1 RGBA величины источника, приемника и
константных цветов индицируются нижним индексом <i>s</i>, <i>d</i> или <i>c</i>
соответственно. Вычитание четверок, означает покомпонентное вычитание одного их
набора из другого. Колонка «Принадлежность» показывает, к чему может быть
применена константа: к источнику или к приемнику.</p>

<p class=text align=left style='text-align:left'>Таблица 6-1. Факторы наложения
источника и приемника</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Константа</span></strong><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Принадлежность</span></strong><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Вычисляемый фактор</span></strong><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_ZERO<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>источник или приемник<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>(0,0,0,0)<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_ONE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>источник или приемник<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>(1,1,1,1)<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_DST_COLOR<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>источник<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1171" type="#_x0000_t75"
   alt="" style='width:95.25pt;height:17.25pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image134.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов6.mht!http://www.progz.ru/images/opengl/chapter6/form4.JPG"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=127 height=23
  src="OpenGL%20Red%20Book.files/image134.jpg" v:shapes="_x0000_i1171"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_SRC_COLOR<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>приемник<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1172" type="#_x0000_t75"
   alt="" style='width:85.5pt;height:17.25pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image135.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов6.mht!http://www.progz.ru/images/opengl/chapter6/form5.JPG"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=114 height=23
  src="OpenGL%20Red%20Book.files/image135.jpg" v:shapes="_x0000_i1172"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:5'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_ONE_MINUS_DST_COLOR<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>источник<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1173" type="#_x0000_t75"
   alt="" style='width:149.25pt;height:17.25pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image136.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов6.mht!http://www.progz.ru/images/opengl/chapter6/form6.JPG"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=199 height=23
  src="OpenGL%20Red%20Book.files/image136.jpg" v:shapes="_x0000_i1173"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:6'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_ONE_MINUS_SRC_COLOR<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>приемник<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1174" type="#_x0000_t75"
   alt="" style='width:138pt;height:16.5pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image137.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов6.mht!http://www.progz.ru/images/opengl/chapter6/form7.JPG"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=184 height=22
  src="OpenGL%20Red%20Book.files/image137.jpg" v:shapes="_x0000_i1174"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:7'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_SRC_ALPHA<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>источник или приемник<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1175" type="#_x0000_t75"
   alt="" style='width:87.75pt;height:17.25pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image138.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов6.mht!http://www.progz.ru/images/opengl/chapter6/form8.JPG"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=117 height=23
  src="OpenGL%20Red%20Book.files/image138.jpg" v:shapes="_x0000_i1175"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:8'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_ONE_MINUS_SRC_ALPHA<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>источник или приемник<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1176" type="#_x0000_t75"
   alt="" style='width:139.5pt;height:17.25pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image139.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов6.mht!http://www.progz.ru/images/opengl/chapter6/form9.JPG"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=186 height=23
  src="OpenGL%20Red%20Book.files/image139.jpg" v:shapes="_x0000_i1176"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:9'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_DST_ALPHA<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>источник или приемник<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1177" type="#_x0000_t75"
   alt="" style='width:93.75pt;height:19.5pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image140.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов6.mht!http://www.progz.ru/images/opengl/chapter6/form10.JPG"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=125 height=26
  src="OpenGL%20Red%20Book.files/image140.jpg" v:shapes="_x0000_i1177"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:10'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_ONE_MINUS_DSR_ALPHA<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>источник или приемник<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1178" type="#_x0000_t75"
   alt="" style='width:147.75pt;height:15.75pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image141.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов6.mht!http://www.progz.ru/images/opengl/chapter6/form11.JPG"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=197 height=21
  src="OpenGL%20Red%20Book.files/image141.jpg" v:shapes="_x0000_i1178"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:11'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_SRC_ALPHA_SATURATE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>источник<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1179" type="#_x0000_t75"
   alt="" style='width:174pt;height:18.75pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image142.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов6.mht!http://www.progz.ru/images/opengl/chapter6/form12.JPG"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=232 height=25
  src="OpenGL%20Red%20Book.files/image142.jpg" v:shapes="_x0000_i1179"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:12'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_CONSTANT_COLOR<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>источник или приемник<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1180" type="#_x0000_t75"
   alt="" style='width:89.25pt;height:15.75pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image143.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов6.mht!http://www.progz.ru/images/opengl/chapter6/form13.JPG"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=119 height=21
  src="OpenGL%20Red%20Book.files/image143.jpg" v:shapes="_x0000_i1180"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:13'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_ONE_MINUS_CONSTANT_COLOR<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>источник или приемник<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1181" type="#_x0000_t75"
   alt="" style='width:138pt;height:15pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image144.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов6.mht!http://www.progz.ru/images/opengl/chapter6/form14.JPG"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=184 height=20
  src="OpenGL%20Red%20Book.files/image144.jpg" v:shapes="_x0000_i1181"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:14'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_CONSTANT_ALPHA<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>источник или приемник<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1182" type="#_x0000_t75"
   alt="" style='width:86.25pt;height:15pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image145.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов6.mht!http://www.progz.ru/images/opengl/chapter6/form15.JPG"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=115 height=20
  src="OpenGL%20Red%20Book.files/image145.jpg" v:shapes="_x0000_i1182"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:15;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_ONE_MINUS_CONSTANT_ALPHA<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>источник или приемник<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1183" type="#_x0000_t75"
   alt="" style='width:138pt;height:16.5pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image146.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов6.mht!http://www.progz.ru/images/opengl/chapter6/form16.JPG"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=184 height=22
  src="OpenGL%20Red%20Book.files/image146.jpg" v:shapes="_x0000_i1183"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=warning>Замечание: GL_CONSTANT_COLOR, GL_ONE_MINUS_CONSTANT_COLOR,
GL_CONSTANT_ALPHA и GL_ONE_MINUS_CONSTANT_ALPHA поддерживаются только в том
случае, если ваша реализация OpenGL поддерживает подмножество функций работы с
изображениями. </p>

<h2>6.1.2&nbsp; Примеры использования цветового наложения</h2>

<p class=text align=left style='text-align:left'>Не все комбинации факторов
источника и приемника имеют смысл. Большинство приложений использует небольшое
число этих комбинаций. Следующие параграфы описывают типичное использование
конкретных комбинаций факторов источника и приемника. Некоторые из этих
примеров используют только альфа – значение входящего фрагмента и, таким
образом, могут работать даже в том случае, когда значения альфа не сохраняются
в буфере кадра. Также имейте в виду, что часто существует более одного способа
достичь определенного эффекта.</p>

<ul type=disc>
 <li class=MsoNormal style='color:black;mso-margin-top-alt:auto;mso-margin-bottom-alt:
     auto;mso-list:l53 level1 lfo22;tab-stops:list 36.0pt'><span
     style='font-size:10.0pt;font-family:Verdana'>Одним из способов нарисовать
     картинку, состоящую из половины одного изображения и половины второго,
     равномерно смешанных, является установка фактора источника в GL_ONE, а
     фактора приемника в GL_ZERO и отображение первого изображения. Затем
     следует установить фактор источника в GL_SRC_ALPHA, фактор приемника в
     GL_MINUS_SRC_ALPHA и нарисовать второе изображение с альфа равным 0.5.
     Данная пара факторов, вероятно, представляет собой наиболее часто
     используемую операцию наложения. Если картинка должна быть смешана из 75% первого
     изображения и 25% второго, нарисуйте первое изображение как и раньше,
     затем нарисуйте второе с альфа равным 0.25. <o:p></o:p></span></li>
 <li class=MsoNormal style='color:black;mso-margin-top-alt:auto;mso-margin-bottom-alt:
     auto;mso-list:l53 level1 lfo22;tab-stops:list 36.0pt'><span
     style='font-size:10.0pt;font-family:Verdana'>Чтобы равномерно смешать три
     различных изображения, установите фактор приемника в GL_ONE, а фактор
     источника в GL_SRC_ALPHA. Нарисуйте каждое изображение с альфа равным
     0.3333333. При подобной технике каждое изображение имеет только треть
     своей исходной яркости, что заметно в тех областях, где изображения не
     пересекаются. <o:p></o:p></span></li>
 <li class=MsoNormal style='color:black;mso-margin-top-alt:auto;mso-margin-bottom-alt:
     auto;mso-list:l53 level1 lfo22;tab-stops:list 36.0pt'><span
     style='font-size:10.0pt;font-family:Verdana'>Предположим, что вы пишете
     программу рисования, и вам требуется создать кисть, постепенно добавляющую
     цвет таким образом, чтобы каждый росчерк кисти добавлял немного больше
     своего цвета к тому, что в данный момент находится на экране (например,
     каждый росчерк состоит из 10% цвета и 90% исходного изображения). Чтобы это
     сделать, нарисуйте изображение росчерка кисти с 10-ти процентным альфа,
     используя GL_SRC_ALPHA для источника и GL_ONE_MINUS_SRC_ALPHA для
     приемника. Заметьте, что вы можете изменять альфа для разных частей
     росчерка кисти (например, чтобы цвет в центре росчерка был более ярким,
     чем по его границе). Похожим образом, ластик может быть реализован путем
     установки его цвета в цвет фона. <o:p></o:p></span></li>
 <li class=MsoNormal style='color:black;mso-margin-top-alt:auto;mso-margin-bottom-alt:
     auto;mso-list:l53 level1 lfo22;tab-stops:list 36.0pt'><span
     style='font-size:10.0pt;font-family:Verdana'>Функции наложения,
     использующие цвета источника или приемника – GL_DST_COLOR или
     GL_ONE_MINUS_DST_COLOR для источника и GL_SRC_COLOR или
     GL_ONE_MINUS_SRC_COLOR для приемника – позволяют вам эффективно выделять
     отдельные цветовые компоненты. Данная операция эквивалентна наложению
     простого фильтра, например, умножение красного компонента на 0.80,
     зеленого на 0.40, а синего на 0.72 имитирует просмотр сцены через
     фотографический фильтр, блокирующий 20% красного света, 60% зеленого и 28%
     синего. <o:p></o:p></span></li>
 <li class=MsoNormal style='color:black;mso-margin-top-alt:auto;mso-margin-bottom-alt:
     auto;mso-list:l53 level1 lfo22;tab-stops:list 36.0pt'><span
     style='font-size:10.0pt;font-family:Verdana'>Предположим, что вам
     требуется отобразить три полупрозрачные поверхности на непрозрачном фоне.
     Части одних поверхностей закрывают другие. Предположим, что самая дальняя
     поверхность пропускает 80% цвета, средняя – 40% цвета, а ближняя – 90%.
     Чтобы составить картинку, вначале нарисуйте задний фон с факторами
     источника и приемника по умолчанию, затем измените факторы на GL_SRC_ALPHA
     (для источника) и GL_ONE_MINUS_SRC_ALPHA (для приемника). Далее, нарисуйте
     самую дальнюю поверхность с альфа равным 0.2, среднюю с альфа равным 0.6,
     а самую ближнюю с альфа равным 0.1. <o:p></o:p></span></li>
 <li class=MsoNormal style='color:black;mso-margin-top-alt:auto;mso-margin-bottom-alt:
     auto;mso-list:l53 level1 lfo22;tab-stops:list 36.0pt'><span
     style='font-size:10.0pt;font-family:Verdana'>Если в вашей системе имеются
     альфа – плоскости, вы можете визуализировать объекты (включая их альфа -
     величины), считывать их обратно и затем производить интересные операции по
     их композиции с полностью визуализированными объектами. Обратите внимание,
     что объекты, используемые для композиции, могут приходить из любого
     источника – они могут быть построены с помощью команд OpenGL, получены с
     помощью других техник, например, трассировки лучей, реализованных в других
     графических библиотеках, или получены с помощью сканирования. <o:p></o:p></span></li>
 <li class=MsoNormal style='color:black;mso-margin-top-alt:auto;mso-margin-bottom-alt:
     auto;mso-list:l53 level1 lfo22;tab-stops:list 36.0pt'><span
     style='font-size:10.0pt;font-family:Verdana'>Вы можете создать видимость
     непрямоугольного растрового изображения, назначив разные альфа – величины
     индивидуальным фрагментам изображения. В большинстве случаев вы назначаете
     альфа равную 0 каждому невидимому фрагменту и альфа равную 1.0 каждому
     непрозрачному фрагменту. Например, вы можете нарисовать полигон в форме дерева
     и наложить на него текстуру с изображением кроны; наблюдатель сможет
     видеть через части прямоугольной текстуры, не являющиеся частями дерева,
     если вы назначите им альфа равные 0. Этот метод, иногда называемый <i>billboarding</i>
     (billboard – большая подсвечиваемая вывеска на здании), намного быстрее,
     чем создание дерева из трехмерных полигонов. Например, на рисунке 6-1
     дерево создано из двух одинаковых полигонов повернутых под углом 90
     градусов друг к другу. Буфер глубины выключен, при рисовании обоих полигонов
     использовались методы вычисления факторов GL_SRC_ALPHA (для источника) и
     GL_ONE_MINUS_SRC_ALPHA (для приемника). <o:p></o:p></span></li>
 <li class=MsoNormal style='color:black;mso-margin-top-alt:auto;mso-margin-bottom-alt:
     auto;mso-list:l53 level1 lfo22;tab-stops:list 36.0pt'><span
     style='font-size:10.0pt;font-family:Verdana'>Цветовое наложение также
     используется для <i>антиалиасинга</i> – техники сокращения видимого
     лестничного эффекта в примитивах, рисуемых на растровом экране. <o:p></o:p></span></li>
</ul>

<p class=text align=left style='text-align:left'>Рисунок 6-1. Создание
трехмерного дерева с помощью техники billboarding: файл billboarding.cpp</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1184" type="#_x0000_t75" alt="" style='width:354pt;height:354pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image147.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов6.mht!http://www.progz.ru/images/opengl/chapter6/6-1.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=472 height=472
src="OpenGL%20Red%20Book.files/image147.jpg" v:shapes="_x0000_i1184"><![endif]></p>

<h2>6.1.3&nbsp; Пример цветового наложения</h2>

<p class=text align=left style='text-align:left'>В примере 6-1 рисуются два
перекрывающихся цветных треугольника, каждый из которых имеет альфа, равное
0.75. Механизм цветового наложения включен, а факторы источника и приемника
установлены в GL_SRC_ALPHAи GL_ONE_MINUS_SRC_ALPHA соответственно.</p>

<p class=text align=left style='text-align:left'>Когда программа стартует,
слева отображается желтый треугольник, а справа – голубой. Таким образом, в
центре окна, где треугольники пересекаются, голубой накладывается на желтый
(рисунок 6-2). Вы можете изменить порядок, в котором отображаются треугольники
с помощью клавиши ‘t’.</p>

<p class=text align=left style='text-align:left'>Рисунок 6-2. Цветовое
наложение двух треугольников</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1185" type="#_x0000_t75" alt="" style='width:265.5pt;height:131.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image148.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов6.mht!http://www.progz.ru/images/opengl/chapter6/6-2.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=354 height=175
src="OpenGL%20Red%20Book.files/image148.jpg" v:shapes="_x0000_i1185"><![endif]></p>

<p class=text align=left style='text-align:left'>Пример 6-1. Пример цветового
наложения: файл alpha.cpp</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>#include &lt;GL/glut.h&gt;<br>
  <br>
  int leftFirst=GL_TRUE;<br>
  <br>
  //Инициализация<br>
  void init(void)<br>
  {<br>
  &nbsp;&nbsp; glEnable(GL_BLEND); <br>
  &nbsp;&nbsp; glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA); <br>
  &nbsp;&nbsp; glShadeModel(GL_FLAT);<br>
  &nbsp;&nbsp; glClearColor(0.0,0.0,0.0,0.0);<br>
  }<br>
  <br>
  void drawLeftTriangle(void)<br>
  {<br>
  &nbsp;&nbsp; //Нарисовать желтый треугольник на левой половине экрана <br>
  &nbsp;&nbsp; glBegin(GL_TRIANGLES);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glColor4f(1.0,1.0,0.0,0.75); <br>
  &nbsp;&nbsp; &nbsp;&nbsp; glVertex3f(0.1,0.9,0.0);<br>
  &nbsp;&nbsp; &nbsp;&nbsp; glVertex3f(0.1,0.1,0.0);<br>
  &nbsp;&nbsp; &nbsp;&nbsp; glVertex3f(0.7,0.5,0.0);<br>
  &nbsp;&nbsp; glEnd();<br>
  }<br>
  <br>
  void drawRightTriangle(void)<br>
  {<br>
  &nbsp;&nbsp; //Нарисовать голубой треугольник на правой половине экрана <br>
  &nbsp;&nbsp; glBegin(GL_TRIANGLES);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glColor4f(0.0,1.0,1.0,0.75); <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glVertex3f(0.9,0.9,0.0);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glVertex3f(0.3,0.5,0.0);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glVertex3f(0.9,0.1,0.0);<br>
  &nbsp;&nbsp; glEnd();<br>
  }<br>
  <br>
  void display(void)<br>
  {<br>
  &nbsp;&nbsp; glClear(GL_COLOR_BUFFER_BIT);<br>
  &nbsp;&nbsp; if(leftFirst)<br>
  &nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; drawLeftTriangle();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; drawRightTriangle();<br>
  &nbsp;&nbsp; }<br>
  &nbsp;&nbsp; else<br>
  &nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; drawRightTriangle();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; drawLeftTriangle();<br>
  &nbsp;&nbsp; }<br>
  &nbsp;&nbsp; glFlush();<br>
  }<br>
  <br>
  void reshape(int w, int h)<br>
  {<br>
  &nbsp;&nbsp; glViewport(0,0,(GLsizei) w, (GLsizei) h); <br>
  &nbsp;&nbsp; glMatrixMode(GL_PROJECTION);<br>
  &nbsp;&nbsp; glLoadIdentity();<br>
  &nbsp;&nbsp; if (w&lt;=h) <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  gluOrtho2D(0.0,1.0,0.0,1.0*(GLfloat)h/(GLfloat)w);<br>
  &nbsp;&nbsp; else<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gluOrtho2D(0.0,1.0*(GLfloat)w/(GLfloat)h,0.0,1.0);
  <br>
  }<br>
  <br>
  void keyboard(unsigned char key,int x,int y)<br>
  {<br>
  &nbsp;&nbsp; switch(key)<br>
  &nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 't':<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'T':<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; leftFirst=!leftFirst; <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glutPostRedisplay(); <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 27:<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(0);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>
  &nbsp;&nbsp; }<br>
  }<br>
  <br>
  int main(int argc, char** argv)<br>
  {<br>
  &nbsp;&nbsp; glutInit(&amp;argc,argv); <br>
  &nbsp;&nbsp; glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB); <br>
  &nbsp;&nbsp; glutInitWindowSize(200,200); <br>
  &nbsp;&nbsp; glutCreateWindow(&quot;Blending Example&quot;); <br>
  &nbsp;&nbsp; init();<br>
  &nbsp;&nbsp; glutDisplayFunc(display); <br>
  &nbsp;&nbsp; glutReshapeFunc(reshape); <br>
  &nbsp;&nbsp; glutKeyboardFunc(keyboard); <br>
  &nbsp;&nbsp; glutMainLoop();<br>
  &nbsp;&nbsp; return 0;<br>
  } <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Порядок, в котором рисуются
треугольники, влияет на цвет региона их перекрытия. Когда первым рисуется левый
треугольник, голубые фрагменты (источник) смешиваются с желтыми фрагментами,
которые уже находятся в буфере кадра (приемник). Когда первым рисуется правый
треугольник, желтые фрагменты накладываются на голубые. Поскольку все альфа
величины равны 0.75, факторами наложения становятся значения 0.75 для источника
и 1-0.75=0.25 для приемника. Другими словами фрагменты источника в некотором
смысле прозрачны, но они оказывают больший эффект на результирующий цвет, чем
фрагменты приемника.</p>

<h2>6.1.4&nbsp; Трехмерное цветовое наложение и буфер глубины</h2>

<p class=text align=left style='text-align:left'>Как вы видели в предыдущем
примере, порядок, в котором выводятся полигоны, значительно влияет на результат
наложения. При рисовании трехмерных полупрозрачных объектов вы можете получить
различный результат в зависимости от того, рисуете ли вы их от дальних к
ближним или от ближних к дальним. Также при определении правильного порядка
следует учитывать влияние буфера глубины. Буфер глубины отслеживает дистанцию
между точкой наблюдения и частью объекта, занимающей определенный пиксель окна
на экране; когда поступает следующий кандидат на тот же пиксель, он рисуется
только если его объект ближе к точке наблюдения – в этом случае его величина
глубины сохраняется в буфере глубины. При использовании этого метода
загороженные (или скрытые) части поверхностей не обязательно будут нарисованы
и, таким образом, не обязательно используются при наложении.</p>

<p class=text align=left style='text-align:left'>Если вам требуются и
полупрозрачные и непрозрачные объекты в одной сцене, вам стоит использовать
буфер глубины для удаления невидимых поверхностей любых объектов, лежащих за
непрозрачными объектами. Если непрозрачный объект закрывает полупрозрачный
объект или другой непрозрачный объект, стоит использовать буфер глубины для
удаления более дальнего объекта. Однако, если полупрозрачный объект ближе, вам
нужно выполнить цветовое наложение между ним и непрозрачным объектом. Довольно
легко выяснить требуемый правильный порядок рисования полигонов в случае, когда
объекты сцены стационарны, но проблема может быстро стать очень сложной, если
точка наблюдения или объект перемещается.</p>

<p class=text align=left style='text-align:left'>Решение заключается в том,
чтобы включить глубинную буферизацию, но в период рисования полупрозрачных
объектов сделать буфер глубины доступным только для чтения. Сначала вы рисуете
все непрозрачные объекты (в это время буфер глубины находится в нормальном
состоянии). Затем вы делаете величины глубины неизменяемыми, переводя буфер
глубины в состояние «только для чтения». Во время рисования полупрозрачных
объектов их величины глубины по-прежнему сравниваются с&nbsp; величинами,
установленными непрозрачными объектами, таким образом, полупрозрачные объекты
не рисуются, если они находятся за непрозрачными. Если же они находятся ближе к
точке наблюдения, они не удаляют непрозрачные объекты, поскольку величины
буфера глубины не могут быть изменены. Вместо этого выполняется их цветовое
наложение на непрозрачные объекты. Для управления тем, можно ли изменять
величины буфера глубины, используйте команду <b>glDepthMask()</b>; если вы
передадите в качестве аргумента GL_FALSE, буфер станет доступным только для
чтения, в то время как аргумент GL_TRUE восстанавливает возможность записи в
него.</p>

<p class=text align=left style='text-align:left'>Пример 6-2 демонстрирует
использование данного метода для рисования непрозрачных и прозрачных объектов в
трехмерном пространстве. Внутри программы, клавиша ‘a’ запускает анимационную
последовательность, в процессе которой полупрозрачный куб проходит через
непрозрачную сферу (рисунок 6-3). Нажатие клавиши ‘r’ приводит объекты в
начальное состояние. Когда полупрозрачные объекты пересекаются, для получения
наилучших результатов рисуйте объекты от дальних к ближним.</p>

<p class=text align=left style='text-align:left'>Рисунок 6-3. Полупрозрачный
куб и непрозрачная сфера </p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1186" type="#_x0000_t75" alt="" style='width:180.75pt;height:186.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image149.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов6.mht!http://www.progz.ru/images/opengl/chapter6/6-3.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=241 height=249
src="OpenGL%20Red%20Book.files/image149.jpg" v:shapes="_x0000_i1186"><![endif]></p>

<p class=text align=left style='text-align:left'>Пример 6-2. Трехмерное
цветовое наложение: файл alpha3D.cpp</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>#include
  &lt;GL/glut.h&gt;<br>
  <br>
  #define MAXZ 8.0<br>
  #define MINZ -8.0<br>
  #define ZINC 0.02<br>
  <br>
  float solidZ=MAXZ;<br>
  float transparentZ=MINZ;<br>
  GLuint sphereList,cubeList;<br>
  <br>
  void init(void)<br>
  {<br>
  &nbsp;&nbsp; GLfloat mat_specular[]={1.0,1.0,1.0,0.15};<br>
  &nbsp;&nbsp; GLfloat mat_shininess[]={100.0};<br>
  &nbsp;&nbsp; GLfloat position[]={0.5,0.5,1.0,0.0};<br>
  <br>
  &nbsp;&nbsp; glMaterialfv(GL_FRONT,GL_SPECULAR,mat_specular);<br>
  &nbsp;&nbsp; glMaterialfv(GL_FRONT,GL_SHININESS,mat_shininess);<br>
  &nbsp;&nbsp; glLightfv(GL_LIGHT0,GL_POSITION,position);<br>
  &nbsp;&nbsp; glEnable(GL_LIGHTING);<br>
  &nbsp;&nbsp; glEnable(GL_LIGHT0);<br>
  &nbsp;&nbsp; glEnable(GL_DEPTH_TEST);<br>
  &nbsp;&nbsp; sphereList=glGenLists(1);<br>
  &nbsp;&nbsp; glNewList(sphereList,GL_COMPILE);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glutSolidSphere(0.4,16,16);<br>
  &nbsp;&nbsp; glEndList();<br>
  &nbsp;&nbsp; cubeList=glGenLists(1);<br>
  &nbsp;&nbsp; glNewList(cubeList,GL_COMPILE);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glutSolidCube(0.6);<br>
  &nbsp;&nbsp; glEndList();<br>
  }<br>
  <br>
  void display(void)<br>
  {<br>
  &nbsp;&nbsp; GLfloat mat_solid[]={0.75,0.75,0.0,1.0};<br>
  &nbsp;&nbsp; GLfloat mat_zero[]={0.0,0.0,0.0,1.0};<br>
  &nbsp;&nbsp; GLfloat mat_transparent[]={0.0,0.8,0.8,0.6};<br>
  &nbsp;&nbsp; GLfloat mat_emission[]={0.0,0.3,0.3,0.6};<br>
  <br>
  &nbsp;&nbsp; glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);<br>
  &nbsp;&nbsp; glPushMatrix();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glTranslatef(-0.15,-0.15,solidZ);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glMaterialfv(GL_FRONT,GL_EMISSION,mat_zero);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glMaterialfv(GL_FRONT,GL_DIFFUSE,mat_solid);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glCallList(sphereList);<br>
  &nbsp;&nbsp; glPopMatrix();<br>
  &nbsp;&nbsp; glPushMatrix();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glTranslatef(0.15,0.15,transparentZ);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glRotatef(15.0,1.0,1.0,0.0);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glRotatef(30.0,0.0,1.0,0.0);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  glMaterialfv(GL_FRONT,GL_EMISSION,mat_emission);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  glMaterialfv(GL_FRONT,GL_DIFFUSE,mat_transparent);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glEnable(GL_BLEND);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glDepthMask(GL_FALSE);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glBlendFunc(GL_SRC_ALPHA,GL_ONE);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glCallList(cubeList);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glDepthMask(GL_TRUE);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glDisable(GL_BLEND);<br>
  &nbsp;&nbsp; glPopMatrix();<br>
  &nbsp;&nbsp; glutSwapBuffers();<br>
  }<br>
  <br>
  void reshape(int w, int h)<br>
  {<br>
  &nbsp;&nbsp; glViewport(0,0,(GLsizei) w, (GLsizei) h);<br>
  &nbsp;&nbsp; glMatrixMode(GL_PROJECTION);<br>
  &nbsp;&nbsp; glLoadIdentity();<br>
  &nbsp;&nbsp; if (w&lt;=h)<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  glOrtho(-1.5,1.5,-0.5*(GLfloat)h/(GLfloat)w,1.5*(GLfloat)h/(GLfloat)w,-10.0,10.0);<br>
  &nbsp;&nbsp; else<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  glOrtho(-1.5*(GLfloat)w/(GLfloat)h,1.5*(GLfloat)w/(GLfloat)h,-1.5,1.5,-10.0,10.0);<br>
  &nbsp;&nbsp; glMatrixMode(GL_MODELVIEW);<br>
  &nbsp;&nbsp; glLoadIdentity();<br>
  }<br>
  <br>
  void animate()<br>
  {<br>
  &nbsp;&nbsp; if(solidZ&lt;=MINZ || transparentZ &gt;=MAXZ)<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glutIdleFunc(NULL);<br>
  &nbsp;&nbsp; else<br>
  &nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; solidZ-=ZINC;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; transparentZ+=ZINC;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glutPostRedisplay();<br>
  &nbsp;&nbsp; }<br>
  }<br>
  <br>
  void keyboard(unsigned char key,int x, int y)<br>
  {<br>
  &nbsp;&nbsp; switch (key)<br>
  &nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'a':<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'A':<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; solidZ=MAXZ;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; transparentZ=MINZ;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glutIdleFunc(animate);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'r':<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'R':<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; solidZ=MAXZ;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; transparentZ=MINZ;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glutPostRedisplay();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 27:<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(0);<br>
  &nbsp;&nbsp; }<br>
  }<br>
  <br>
  int main(int argc, char** argv)<br>
  {<br>
  &nbsp;&nbsp; glutInit(&amp;argc,argv); <br>
  &nbsp;&nbsp; glutInitDisplayMode(GLUT_DOUBLE|GLUT_RGB|GLUT_DEPTH);<br>
  &nbsp;&nbsp; glutInitWindowSize(500,500);<br>
  &nbsp;&nbsp; glutCreateWindow(&quot;Three-Dimensional Blending&quot;);<br>
  &nbsp;&nbsp; init();<br>
  &nbsp;&nbsp; glutDisplayFunc(display);<br>
  &nbsp;&nbsp; glutReshapeFunc(reshape);<br>
  &nbsp;&nbsp; glutKeyboardFunc(keyboard);<br>
  &nbsp;&nbsp; glutMainLoop();<br>
  &nbsp;&nbsp; return 0; <br>
  } <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<h2>6.2&nbsp; Антиалиасинг</h2>

<p class=text align=left style='text-align:left'>На некоторых изображениях,
созданных с помощью OpenGL вы могли заметить, что линии выглядят
«ступенчатыми», особенно если они близки к горизонтальным или вертикальным. Эти
ступеньки появляются потому, что идеальная линия аппроксимируется сериями
пикселей из пиксельной решетки экрана. «Ступенчатость» называется <i>алиасинг</i>
(<i>aliasing</i>), и в данном разделе описывается техника антиалиасинга,
позволяющая ее устранить. На рисунке 6-4 показаны две пары пересекающихся
линий: слева пара несглаженных, а справа пара сглаженных путем антиалиасинга.
Для демонстрации эффекта изображение было увеличено.</p>

<p class=text align=left style='text-align:left'>Рисунок 6-4. Сглаженные и
несглаженные линии </p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1187" type="#_x0000_t75" alt="" style='width:342.75pt;height:192.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image150.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов6.mht!http://www.progz.ru/images/opengl/chapter6/6-4.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=457 height=257
src="OpenGL%20Red%20Book.files/image150.jpg" v:shapes="_x0000_i1187"><![endif]></p>

<p class=text align=left style='text-align:left'>На рисунке 6-5 показано, что
диагональная линия в 1 пиксель толщиной покрывает площадь некоторых пикселей в
большей степени, чем других. Вообще говоря, когда производится антиалиасинг,
OpenGL рассчитывает <i>величину покрытия</i> для каждого фрагмента, базируясь
на доле покрываемой им площади пикселя на экране. Рисунок 6-5 демонстрирует эти
величины для линии. В RGBA режиме OpenGL умножает эту величину на альфа
величину фрагмента. Затем вы можете использовать получившееся альфа для
цветового наложения фрагмента на соответствующий пиксель, уже находящийся в
буфере кадра. В индексном цветовом режиме, OpenGL устанавливает 4 младших бита
цветового индекса в зависимости от величины покрытия фрагмента (0000 – если
фрагмент не попадает на пиксель и 1111 – при полном покрытии фрагментом
пикселя). Загрузка цветовой таблицы и ее верное применение для получения выгоды
от этих величин покрытия лежит на вас.</p>

<p class=text align=left style='text-align:left'>Рисунок 6-5. Определение
величин покрытия </p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1188" type="#_x0000_t75" alt="" style='width:326.25pt;height:205.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image151.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов6.mht!http://www.progz.ru/images/opengl/chapter6/6-5.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=435 height=274
src="OpenGL%20Red%20Book.files/image151.jpg" v:shapes="_x0000_i1188"><![endif]></p>

<p class=text align=left style='text-align:left'>Подробности расчета величины
покрытия довольно сложны, трудны для объяснения и вообще говоря, могут быть
несколько различными в зависимости от вашей конкретной реализации OpenGL. Вы
можете использовать команду <b>glHint()</b> для некоторого контроля над
соотношением между качеством изображения и скоростью, однако не все реализации
OpenGL реагируют на нее.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glHint</b>
  (GLenum <i>target</i>, GLenum <i>hint</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Управляет определенными
аспектами поведения OpenGL. Параметр <i>target </i>задает, какой именно аспект
поведения контролируется, его возможные значения показаны в таблице 6-2.
Значениями для параметра <i>hint </i>может быть GL_FASTEST (для самого
эффективного по скорости метода действий), GL_NICEST(для самого
высококачественного метода) или GL_DONT_CARE(для метода по выбору библиотеки).
Интерпретация этих установок зависит от реализации, конкретная реализация
OpenGL может вообще игнорировать эти установки.</p>

<p class=text align=left style='text-align:left'>Целевая установка
GL_PERSPECTIVE_CORRECTION_HINT относится к тому, как цветовые величины и
координаты текстуры интерполируются внутри примитива: линейно в экранном
пространстве (относительно простой метод вычислений) или путем перспективной
коррекции (которая требует больших вычислений). Часто системы производят
линейную цветовую интерполяцию, поскольку результаты хотя и не являются
технически верными, но визуально приемлемы; однако текстуры в большинстве
случаев требуют интерполяции с коррекцией перспективы для того, чтобы быть
визуально приемлемыми. Следовательно, реализация OpenGL может интерпретировать
этот параметр для управления тем, какой метод интерполяции использовать.</p>

<p class=text align=left style='text-align:left'>Таблица 6-2. Значения,
используемые в команде glHint() </p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Параметр</span></strong><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><strong><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Смысл</span></strong><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_POINT_SMOOTH_HINT<br>
  GL_LINE_SMOOTH_HINT<br>
  GL_POLYGON_SMOOTH_HINT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>задают желаемое количество сэмплов и следовательно качество
  сглаживания точек, линий и полигонов соответственно <o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FOG_SMOOTH_HINT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>задает, должен ли расчет тумана производиться для каждого
  пикселя (GL_NICEST) или для каждой вершины (GL_FASTEST) <o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_PERSPECTIVE_CORRECTION_HINT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>задает желаемое качество интерполяции цветов и координат
  текстуры <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<h2>6.2.1&nbsp; Сглаживание точек и линий</h2>

<p class=text align=left style='text-align:left'>Для сглаживания точек или
линий вам нужно включить антиалиасинг командой <b>glEnable()</b>, передав ей в
качестве аргумента GL_POINT_SMOOTHили GL_LINE_SMOOTH соответственно. Вы также
можете задать параметр качества с помощью <b>glHint()</b>. (Помните, что вы
можете задавать размер точек и толщину линий.) Далее следуйте процедурам,
описанным в одном из следующих разделов в зависимости от того, работаете ли вы
в RGBAили индексном цветовом режиме.</p>

<h2>6.2.1.1&nbsp;&nbsp;&nbsp; Антиалиасинг в RGBA режиме</h2>

<p class=text align=left style='text-align:left'>В режиме RGBA вам нужно
включить механизм цветового наложения. Факторы, которые вы, скорее всего,
будете при этом использовать – GL_SRC_ALPHA (для источника) и
GL_ONE_MINUS_SRC_ALPHA (для приемника). в качестве альтернативы вы можете
задать фактор GL_ONE(для приемника), что сделает линии несколько более яркими в
точках пересечения. Теперь вы можете рисовать любые точки или линии – они будут
сглажены. Эффект от сглаживания наиболее заметен в случае использования
достаточно высоких значений альфа. Помните, что поскольку вы используете
цветовое наложение, вам, возможно, понадобится следить за порядком выбора
фигур. Однако, в большинстве случаем, порядок вывода может быть проигнорирован
без значительных визуальных последствий. В примере 6-3 инициализируются все
необходимые режимы, и затем отображаются две пересекающиеся диагональные линии.
Нажатие на клавишу ‘r’ во время работы программы поворачивает линии, чтобы
можно было рассмотреть эффект от сглаживания линии, нарисованных под разными
углами. Заметьте, что в данном примере выключен буфер глубины.</p>

<p class=text align=left style='text-align:left'>Пример 6-3. Сглаженные линии:
файл aargb.cpp</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>#include
  &lt;GL/glut.h&gt;<br>
  <br>
  float rotAngle=0;<br>
  <br>
  void init(void)<br>
  {<br>
  &nbsp;&nbsp; glEnable(GL_LINE_SMOOTH);<br>
  &nbsp;&nbsp; glEnable(GL_BLEND);<br>
  &nbsp;&nbsp; glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);<br>
  &nbsp;&nbsp; glHint(GL_LINE_SMOOTH_HINT,GL_NICEST);<br>
  &nbsp;&nbsp; glLineWidth(1.5);<br>
  &nbsp;&nbsp; glClearColor(0.0,0.0,0.0,0.0);<br>
  }<br>
  <br>
  void display(void)<br>
  {<br>
  &nbsp;&nbsp; glClear(GL_COLOR_BUFFER_BIT);<br>
  &nbsp;&nbsp; glColor3f(0.0,1.0,0.0);<br>
  &nbsp;&nbsp; glPushMatrix();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glRotatef(-rotAngle,0.0,0.0,0.1);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glBegin(GL_LINES);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glVertex2f(-0.5,0.5);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glVertex2f(0.5,-0.5);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glEnd();<br>
  &nbsp;&nbsp; glPopMatrix();<br>
  &nbsp;&nbsp; glColor3f(0.0,0.0,1.0);<br>
  &nbsp;&nbsp; glPushMatrix();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glRotatef(rotAngle,0.0,0.0,0.1);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glBegin(GL_LINES);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glVertex2f(0.5,0.5);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glVertex2f(-0.5,-0.5);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glEnd();<br>
  &nbsp;&nbsp; glPopMatrix();<br>
  glFlush();<br>
  }<br>
  <br>
  void reshape(int w, int h)<br>
  {<br>
  &nbsp;&nbsp; glViewport(0,0,(GLsizei) w, (GLsizei) h);<br>
  &nbsp;&nbsp; glMatrixMode(GL_PROJECTION);<br>
  &nbsp;&nbsp; glLoadIdentity();<br>
  &nbsp;&nbsp; if (w&lt;=h)<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  gluOrtho2D(-1.0,1.0,-1.0*(GLfloat)h/(GLfloat)w,1.0*(GLfloat)h/(GLfloat)w);<br>
  &nbsp;&nbsp; else<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  gluOrtho2D(-1.0*(GLfloat)w/(GLfloat)h,1.0*(GLfloat)w/(GLfloat)h,-1.0,1.0);<br>
  &nbsp;&nbsp; glMatrixMode(GL_MODELVIEW);<br>
  &nbsp;&nbsp; glLoadIdentity();<br>
  }<br>
  <br>
  void keyboard(unsigned char key, int x, int y)<br>
  {<br>
  &nbsp;&nbsp; switch(key)<br>
  &nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'r':<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'R':<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rotAngle+=10;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (rotAngle&gt;=360) <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  rotAngle=0;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glutPostRedisplay();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 27:<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(0);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>
  &nbsp;&nbsp; }<br>
  }<br>
  <br>
  int main(int argc, char** argv)<br>
  {<br>
  &nbsp;&nbsp; glutInit(&amp;argc,argv); <br>
  &nbsp;&nbsp; glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);<br>
  &nbsp;&nbsp; glutInitWindowSize(200,200);<br>
  &nbsp;&nbsp; glutCreateWindow(&quot;Antialiased Lines&quot;);<br>
  &nbsp;&nbsp; init();<br>
  &nbsp;&nbsp; glutDisplayFunc(display);<br>
  &nbsp;&nbsp; glutReshapeFunc(reshape);<br>
  &nbsp;&nbsp; glutKeyboardFunc(keyboard);<br>
  &nbsp;&nbsp; glutMainLoop();<br>
  &nbsp;&nbsp; return 0;<br>
  } <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<h2>6.2.1.2&nbsp;&nbsp;&nbsp; Антиалиасинг в индексном режиме</h2>

<p class=text align=left style='text-align:left'>Самая хитрая часть
антиалиасинга в индексном режиме заключается в загрузке и использовании
цветовой таблицы. Поскольку последние 4 бита цветового индекса индицируют
величину покрытия, вам следует загрузить 16 идущих один за другим индексов
цветами градиентами от цвета фона до цвета объекта. (Каждый из градиентов
должен начинаться с величины индекса кратной 16.) Затем вы очищаете цветовой
буфер с помощью первого индекса в градиенте и рисуете точки и линии с помощью
других его цветов. Пример 6-4 демонстрирует, как конструировать градиент для
рисования сглаженных линий в индексном режиме. В этом примере создается два
цветовых градиента: один содержит оттенки зеленого, другой – оттенки синего.</p>

<p class=text align=left style='text-align:left'>Пример 6-4. Сглаживание в
индексном режиме: файл aaindex.cpp</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>#include
  &lt;GL/glut.h&gt;<br>
  <br>
  #define RAMPSIZE 16<br>
  #define RAMP1START 32<br>
  #define RAMP2START 48<br>
  <br>
  float rotAngle=0;<br>
  <br>
  void init(void)<br>
  {<br>
  &nbsp;&nbsp; int i;<br>
  <br>
  &nbsp;&nbsp; for (i=0;i&lt;RAMPSIZE;i++)<br>
  &nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GLfloat shade;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; shade=(GLfloat)i/(GLfloat)RAMPSIZE;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glutSetColor(RAMP1START+(GLint)i,0.,shade,0.);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glutSetColor(RAMP2START+(GLint)i,0.,0.,shade);<br>
  &nbsp;&nbsp; }<br>
  &nbsp;&nbsp; glEnable(GL_LINE_SMOOTH);<br>
  &nbsp;&nbsp; glHint(GL_LINE_SMOOTH_HINT,GL_NICEST);<br>
  &nbsp;&nbsp; glLineWidth(1.5);<br>
  &nbsp;&nbsp; glClearIndex((GLfloat)RAMP1START);<br>
  }<br>
  <br>
  void display(void)<br>
  {<br>
  &nbsp;&nbsp; glClear(GL_COLOR_BUFFER_BIT);<br>
  &nbsp;&nbsp; glIndexi(RAMP1START);<br>
  &nbsp;&nbsp; glPushMatrix();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glRotatef(-rotAngle,0.0,0.0,0.1);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glBegin(GL_LINES);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glVertex2f(-0.5,0.5);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glVertex2f(0.5,-0.5);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glEnd();<br>
  &nbsp;&nbsp; glPopMatrix();<br>
  &nbsp;&nbsp; glIndexi(RAMP2START);<br>
  &nbsp;&nbsp; glPushMatrix();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glRotatef(rotAngle,0.0,0.0,0.1);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glBegin(GL_LINES);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glVertex2f(0.5,0.5);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glVertex2f(-0.5,-0.5);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glEnd();<br>
  &nbsp;&nbsp; glPopMatrix();<br>
  &nbsp;&nbsp; glFlush();<br>
  }<br>
  <br>
  void reshape(int w, int h)<br>
  {<br>
  &nbsp;&nbsp; glViewport(0,0,(GLsizei) w, (GLsizei) h);<br>
  &nbsp;&nbsp; glMatrixMode(GL_PROJECTION);<br>
  &nbsp;&nbsp; glLoadIdentity();<br>
  &nbsp;&nbsp; if (w&lt;=h)<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gluOrtho2D(-1.0,1.0,-1.0*(GLfloat)h/(GLfloat)w,1.0*(GLfloat)h/(GLfloat)w);<br>
  &nbsp;&nbsp; else<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  gluOrtho2D(-1.0*(GLfloat)w/(GLfloat)h,1.0*(GLfloat)w/(GLfloat)h,-1.0,1.0);<br>
  &nbsp;&nbsp; glMatrixMode(GL_MODELVIEW);<br>
  &nbsp;&nbsp; glLoadIdentity();<br>
  }<br>
  <br>
  void keyboard(unsigned char key,int x,int y)<br>
  {<br>
  &nbsp;&nbsp; switch(key)<br>
  &nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'r':<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'R':<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rotAngle+=10;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (rotAngle&gt;=360)
  rotAngle=0;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  glutPostRedisplay();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 27:<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(0);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>
  &nbsp;&nbsp; }<br>
  }<br>
  <br>
  int main(int argc, char** argv)<br>
  {<br>
  &nbsp;&nbsp; glutInit(&amp;argc,argv); <br>
  &nbsp;&nbsp; glutInitDisplayMode(GLUT_SINGLE|GLUT_INDEX);<br>
  &nbsp;&nbsp; glutInitWindowSize(200,200);<br>
  &nbsp;&nbsp; glutCreateWindow(&quot;Antialiasing in Color-Index mode&quot;);<br>
  &nbsp;&nbsp; init();<br>
  &nbsp;&nbsp; glutDisplayFunc(display);<br>
  &nbsp;&nbsp; glutReshapeFunc(reshape);<br>
  &nbsp;&nbsp; glutKeyboardFunc(keyboard);<br>
  &nbsp;&nbsp; glutMainLoop();<br>
  &nbsp;&nbsp; return 0;<br>
  } <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Поскольку градиент проходит от
цвета фона до цвета объекта, сглаженные линии выглядят верно только в тех
местах, где они рисуются поверх фона. Когда рисуется синяя линия, она затирает
часть зеленой в точке их пересечения. Чтобы это исправить, вам требуется
перерисовать область пересечения линий с помощью градиента, проходящего от
зеленого (цвета в буфере кадра) до синего (цвета рисуемой линии). Однако, это
требует дополнительных расчетов и обычно не стоит усилий, поскольку область
пересечения линий достаточно мала. Заметьте, что это не является проблемой в
RGBAрежиме, поскольку цвета рисуемых линий накладываются на цвета, уже
находящиеся в буфере кадра.</p>

<p class=text align=left style='text-align:left'>Вы также можете захотеть
включить тест глубины при рисовании сглаженных точек и линий в индексном
режиме. В предыдущем примере тест глубины выключен, поскольку обе линии
рисуются в одной плоскости по z. Однако если вы захотите нарисовать трехмерную
сцену, вам следует включить буфер глубины, чтобы итоговые цвета пикселей
соответствовали ближайшим объектам.</p>

<p class=text align=left style='text-align:left'>Трюк, описанный в разделе
«Трехмерное цветовое наложение» может быть также использован для смешивания
сглаженных точек и линий с несглаженными полигонами в режиме с включенным
буфером глубины. Чтобы это сделать, сначала нарисуйте полигоны, затем сделайте
буфер глубины доступным только для чтения и нарисуйте точки и линии. Точку и
линии будут пересекаться между собой, однако будут загораживаться ближайшими
полигонами.</p>

<h2>6.2.2&nbsp; Сглаживание полигонов</h2>

<p class=text align=left style='text-align:left'>Сглаживание ребер залитых
полигонов похоже на сглаживание точек и линий. Когда разные полигоны
накладываются друг на друга, вам нужно накладывать цвета соответствующим
образом. Для сглаживания вы можете использовать метод, описываемый в этом
разделе или буфер аккумулятора (сглаживающий всю сцену). Использование буфера аккумуляции
может показаться более простым, но оно весьма интенсивно по производимым
расчетам и, как следствие, весьма медленно. Однако, как вы увидите далее,
метод, описываемый здесь, более сложен для воспроизведения.</p>

<p class=warning>Замечание: Если вы рисуете ваши полигоны в виде точек в
вершинах или границы – то есть, передавая аргумент GL_POINT или GL_LINE команде
<b>glPolygonMode()</b> – применяется техника сглаживания точек или линий,
описанная ранее (если сглаживание включено). Оставшаяся часть данного раздела
посвящена сглаживанию полигонов в режиме их отображения GL_FILL.</p>

<p class=text align=left style='text-align:left'>В теории, вы можете сглаживать
полигоны и в RGBA, и в индексном цветовых режимах. Однако пересечение объектов
оказывает на сглаживание полигонов значительно большее воздействие, чем оно
влияет на сглаживание точек и линий, и, следовательно, порядок отображения и
точность наложения играют критическую роль. На сомом деле они грают настолько
критическую роль, что если вы сглаживаете более чем один полигон, вам нужно
упорядочивать полигоны от передних к задним и использовать команду <b>glBlendFunc()</b>
с параметрами GL_SRC_ALPHA_SATURATE (для источника) и GL_ONE (для приемника).
Следовательно, сглаживание полигонов в индексном режиме не является практически
применимым.</p>

<p class=text align=left style='text-align:left'>Чтобы сглаживать полигоны в
RGBAрежиме, вы используете альфа величины для представления величины покрытия
ребер полигона. Вам следует включить сглаживание полигонов передачей аргумента
GL_POLYGON_SMOOTH команде <b>glEnable()</b>. Это приведет к тому, что пикселям
на ребрах полигона будут присвоены частичные альфа величины в зависимости от
величины покрытия, так же как при сглаживании точек и линий. Также, если вы
захотите, вы можете задать величину для GL_POLYGON_SMOOTH_HINT. Теперь вам
следует должным образом наложить друг на друга перекрывающиеся ребра. Во-первых,
выключите буфер глубины, чтобы иметь контроль над тем, как накладываются друг
на друга перекрывающиеся пиксели. Затем установите факторы наложения в
GL_SRC_ALPHA_SATURATE (для источника) и GL_ONE (для приемника). С заданной
таким образом функцией наложения результирующий цвет будет представлять собой
сумму цвета приемника и масштабированного цвета источника. Фактор
масштабирования будет одновременно меньше и входящей величины альфа и единицы
минус альфа величины приемника. Это означает, что входящие пиксели имеют
небольшой эффект на результирующий цвет для пикселей с большой величиной альфа,
поскольку единица минус альфа приемника почти равна нулю. При использовании
этого метода пиксель на ребре рисуемого полигона может быть совмещен с цветом
полигона, нарисованного ранее. В итоге, до того чтобы рисовать, вам требуется
упорядочить все полигоны сцены в порядке от более близких к более дальним.</p>

<h2>6.3&nbsp; Туман</h2>

<p class=text align=left style='text-align:left'>Иногда компьютерные
изображения могут казаться нереально четкими и резкими. Антиалиасинг делает
объекты более реалистичными за счет сглаживания их ребер. Кроме того, вы можете
увеличить реалистичность&nbsp; всего изображения, добавив <i>туман</i>, который
постепенно размывает объекты в зависимости от дистанции до наблюдателя. «Туман»
-- это довольно общий термин, описывающий несколько похожих форм атмосферных
явлений (дым от горения, дымка, туман над болотом, смог и так далее). Туман
просто необходим для различных программ визуальной симуляции, которым требуется
имитация ограниченной видимости. Он часто применяется в симуляторах полетов.</p>

<p class=text align=left style='text-align:left'>Когда включен туман, объекты,
находящиеся дальше от наблюдателя как бы таят в цвете тумана. Вы можете
управлять плотностью тумана, которая определяет уровень воздействия дистанции
от наблюдателя на цвет и размытость объекта. Туман может быть использован и в
RGBA, и в индексном режиме, однако расчеты, связанные с ним, в этих режимах
несколько различаются. Поскольку расчет тумана производится после матричных
преобразований, расчета освещенности и текстурирования, он воздействует на
преобразованные, освещенные и текстурированные объекты. Заметьте, что
применение тумана может увеличить быстродействие приложений симуляции,
поскольку вы можете не рисовать объекты, которые находятся слишком далеко и
слишком размыты туманом.</p>

<p class=text align=left style='text-align:left'>Все типы примитивов, включая
точки и линии, могут быть затуманены. Использование тумана для точек и линий
также называется <i>depth – cuing</i> (<i>глубинирование </i>– при
использовании этой техники линии находящиеся дальше от наблюдателя отображаются
более блеклыми) и весьма популярно в программах молекулярного моделирования и
других приложениях.</p>

<h2>6.3.1&nbsp; Использование тумана</h2>

<p class=text align=left style='text-align:left;text-indent:35.4pt'>Использовать
туман очень просто. Вы включаете его, передавая аргумент GL_FOG, команде <b>glEnable()</b>.
Также вы выбираете цвет тумана и уравнение, управляющее его плотностью, с
помощью команды <b>glFog*()</b>. Кроме того, вы можете установить качество
расчета тумана с помощью аргумента GL_FOG_HINTкоманды <b>glHint()</b>. В
примере 6-5 отображаются 5 красных сфер, все на разных дистанциях от
наблюдателя. Клавиша ‘f’ выбирает уравнение плотности тумана. Сами уравнения
объясняются далее.</p>

<p class=text align=left style='text-align:left'>Рисунок 6-6. Пять затуманенных
сфер </p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1189" type="#_x0000_t75" alt="" style='width:464.25pt;height:232.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image152.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов6.mht!http://www.progz.ru/images/opengl/chapter6/6-6.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=619 height=310
src="OpenGL%20Red%20Book.files/image152.jpg" v:shapes="_x0000_i1189"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Пример 6-5. Пять затуманенных
сфер в RGBA режиме: файл fog.cpp</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>#include
  &lt;windows.h&gt;<br>
  #include &lt;GL/glut.h&gt;<br>
  <br>
  GLint fogMode;<br>
  <br>
  void init(void)<br>
  {<br>
  &nbsp;&nbsp; GLfloat position[]={0.5,0.5,3.0,0.0};<br>
  &nbsp;&nbsp; glEnable(GL_DEPTH_TEST);<br>
  &nbsp;&nbsp; glLightfv(GL_LIGHT0,GL_POSITION,position);<br>
  &nbsp;&nbsp; glEnable(GL_LIGHTING);<br>
  &nbsp;&nbsp; glEnable(GL_LIGHT0);<br>
  &nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GLfloat mat[3]={0.1745,0.01175,0.01175};<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glMaterialfv(GL_FRONT,GL_AMBIENT,mat);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat[0]=0.61424;mat[1]=0.04135;mat[2]=0.04136;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glMaterialfv(GL_FRONT,GL_DIFFUSE,mat);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mat[0]=0.727811;mat[1]=0.626959;mat[2]=0.626959;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glMaterialfv(GL_FRONT,GL_SPECULAR,mat);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glMaterialf(GL_FRONT,GL_SHININESS,0.6*128.0);<br>
  &nbsp;&nbsp; }<br>
  &nbsp;&nbsp; glEnable(GL_FOG);<br>
  &nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GLfloat fogColor[4]={0.5,0.5,0.5,1.0};<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fogMode=GL_EXP;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glFogi(GL_FOG_MODE,fogMode);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glFogfv(GL_FOG_COLOR,fogColor);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glFogf(GL_FOG_DENSITY,0.35);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glHint(GL_FOG_HINT,GL_NICEST);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glFogf(GL_FOG_START,1.0);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glFogf(GL_FOG_END,5.0);<br>
  &nbsp;&nbsp; }<br>
  &nbsp;&nbsp; glClearColor(0.5,0.5,0.5,1.0);<br>
  }<br>
  <br>
  void renderSphere(GLfloat x ,GLfloat y, GLfloat z)<br>
  {<br>
  &nbsp;&nbsp; glPushMatrix();<br>
  &nbsp;&nbsp; glTranslatef(x,y,z);<br>
  &nbsp;&nbsp; glutSolidSphere(0.4,16,16);<br>
  &nbsp;&nbsp; glPopMatrix();<br>
  }<br>
  <br>
  void display(void)<br>
  {<br>
  &nbsp;&nbsp; glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);<br>
  &nbsp;&nbsp; renderSphere(-2.,-0.5,-1.0);<br>
  &nbsp;&nbsp; renderSphere(-1.,-0.5,-2.0);<br>
  &nbsp;&nbsp; renderSphere(0.,-0.5,-3.0);<br>
  &nbsp;&nbsp; renderSphere(1.,-0.5,-4.0);<br>
  &nbsp;&nbsp; renderSphere(2.,-0.5,-5.0);<br>
  &nbsp;&nbsp; glFlush();<br>
  }<br>
  <br>
  void reshape(int w, int h)<br>
  {<br>
  &nbsp;&nbsp; glViewport(0,0,(GLsizei) w, (GLsizei) h);<br>
  &nbsp;&nbsp; glMatrixMode(GL_PROJECTION);<br>
  &nbsp;&nbsp; glLoadIdentity();<br>
  &nbsp;&nbsp; if (w&lt;=h)<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glOrtho(-2.5,2.5,-2.5*(GLfloat)h/(GLfloat)w,2.5*(GLfloat)h/(GLfloat)w,-10.0,10.0);<br>
  &nbsp;&nbsp; else<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  glOrtho(-2.5*(GLfloat)w/(GLfloat)h,2.5*(GLfloat)w/(GLfloat)h,-2.5,2.5,-10.0,10.0);<br>
  &nbsp;&nbsp; glMatrixMode(GL_MODELVIEW);<br>
  &nbsp;&nbsp; glLoadIdentity();<br>
  }<br>
  <br>
  void keyboard(unsigned char key,int x, int y)<br>
  {<br>
  &nbsp;&nbsp; switch (key)<br>
  &nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'f':<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'F':<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(fogMode==GL_EXP)<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  fogMode=GL_EXP2;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  MessageBox(NULL,&quot;Fog mode is GL_EXP2&quot;,&quot;Five Fogged Spheres in
  RGBA mode&quot;,MB_OK);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  if(fogMode==GL_EXP2)<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  fogMode=GL_LINEAR;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  MessageBox(NULL,&quot;Fog mode is GL_LINEAR&quot;,&quot;Five Fogged Spheres
  in RGBA mode&quot;,MB_OK);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  if(fogMode==GL_LINEAR)<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  fogMode=GL_EXP;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  MessageBox(NULL,&quot;Fog mode is GL_EXP&quot;,&quot;Five Fogged Spheres in
  RGBA mode&quot;,MB_OK);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  }<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glFogi(GL_FOG_MODE,fogMode);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glutPostRedisplay();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 27:<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(0);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>
  &nbsp;&nbsp; }<br>
  }<br>
  <br>
  int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR
  lpCmdLine, int nCmdShow)<br>
  {<br>
  &nbsp;&nbsp; char* argv=&quot;&quot;;<br>
  &nbsp;&nbsp; int argc=0;<br>
  &nbsp;&nbsp; glutInit(&amp;argc,&amp;argv);<br>
  &nbsp;&nbsp; glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB|GLUT_DEPTH);<br>
  &nbsp;&nbsp; glutInitWindowSize(500,500);<br>
  &nbsp;&nbsp; glutCreateWindow(&quot;Five Fogged Spheres in RGBA mode&quot;);<br>
  &nbsp;&nbsp; init();<br>
  &nbsp;&nbsp; glutDisplayFunc(display);<br>
  &nbsp;&nbsp; glutReshapeFunc(reshape);<br>
  &nbsp;&nbsp; glutKeyboardFunc(keyboard);<br>
  &nbsp;&nbsp; glutMainLoop();<br>
  &nbsp;&nbsp; return 0;<br>
  } <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<h2>6.3.2&nbsp; Уравнения расчета плотности тумана</h2>

<p class=text align=left style='text-align:left'>Туман накладывает свой цвет на
цвет входящего фрагмента с учетом фактора наложения тумана. Этот фактор <i>f</i>,
вычисляется с помощью одного из трех следующих уравнений и затем усекается до
диапазона [0, 1]. </p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1190" type="#_x0000_t75" alt="" style='width:213pt;height:88.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image153.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов6.mht!http://www.progz.ru/images/opengl/chapter6/form17.JPG"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=284 height=118
src="OpenGL%20Red%20Book.files/image153.jpg" v:shapes="_x0000_i1190"><![endif]></p>

<p class=text align=left style='text-align:left'>В этих трех уравнениях <i>z</i>–
дистанция в видовых координатах от точки наблюдения до центра фрагмента.
Величины <i>density</i>, <i>start </i>и <i>end </i>задаются командой <b>glFog*()</b>.
Фактор fиспользуется по-разному в зависимости от того, работаете ли вы в RGBA
или в индексном цветовом режиме.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glFog</b>{if}
  (GLenum <i>pname</i>, TYPE <i>param</i>);<br>
  void <b>glFog</b>{if}<b>v</b> (GLenum <i>pname</i>, TYPE *<i>params</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Задает параметры и функцию для
вычисления тумана. Если <i>pname </i>имеет значение GL_FOG_MODE, то <i>param </i>может
принимать значения GL_EXP (значение по умолчанию), GL_EXP2 или GL_LINEAR и
задает метод вычисления фактора тумана. Если <i>pname </i>равен GL_FOG_DENSITY,
GL_FOG_STARTили GL_FOG_END, то <i>param </i>содержит (или для векторной версии
команды указывает на) величины <i>density</i>, <i>start </i>или <i>end </i>для
использования в уравнениях. (Значения по умолчанию – 1, 0 и 1 соответственно.)
В RGBA режиме <i>pname </i>может также содержать значение GL_FOG_COLOR, в этом
случае <i>params </i>указывает на четверку величин, задающую RGBA цвет тумана.</p>

<p class=text align=left style='text-align:left'>Соответствующее значение <i>pname
</i>для индексного режима – GL_FOG_INDEX, в этом случае <i>param </i>должен
содержать единственную величину, задающую цветовой индекс тумана.</p>

<p class=text align=left style='text-align:left'>На рисунке 6-7 изображены графики
факторов наложения тумана, вычисленных с помощью различных уравнений и разных
значений переменных.</p>

<p class=text align=left style='text-align:left'>Рисунок 6-7. Уравнения
плотности тумана </p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1191" type="#_x0000_t75" alt="" style='width:467.25pt;height:282pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image154.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов6.mht!http://www.progz.ru/images/opengl/chapter6/6-7.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=623 height=376
src="OpenGL%20Red%20Book.files/image154.jpg" v:shapes="_x0000_i1191"><![endif]></p>

<h2>6.3.2.1&nbsp;&nbsp;&nbsp; Туман в RGBA режиме</h2>

<p class=text align=left style='text-align:left'>В RGBA режиме фактор тумана
используется для вычисления финального затуманенного цвета следующим образом: </p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1192" type="#_x0000_t75" alt="" style='width:114.75pt;height:18.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image155.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов6.mht!http://www.progz.ru/images/opengl/chapter6/form18.JPG"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=153 height=25
src="OpenGL%20Red%20Book.files/image155.jpg" v:shapes="_x0000_i1192"><![endif]>,
</p>

<p class=text align=left style='text-align:left'>где <!--[if gte vml 1]><v:shape
 id="_x0000_i1193" type="#_x0000_t75" alt="" style='width:16.5pt;height:14.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image156.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов6.mht!http://www.progz.ru/images/opengl/chapter6/form19.JPG"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=22 height=19
src="OpenGL%20Red%20Book.files/image156.jpg" v:shapes="_x0000_i1193"><![endif]>&nbsp;представляет
RGBA величины входящего фрагмента, а <!--[if gte vml 1]><v:shape id="_x0000_i1194"
 type="#_x0000_t75" alt="" style='width:19.5pt;height:16.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image157.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов6.mht!http://www.progz.ru/images/opengl/chapter6/form20.JPG"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=26 height=22
src="OpenGL%20Red%20Book.files/image157.jpg" v:shapes="_x0000_i1194"><![endif]>&nbsp;--
цвет тумана, заданный аргументом GL_FOG_COLOR.</p>

<h2>6.3.2.2&nbsp;&nbsp;&nbsp; Туман в индексном режиме</h2>

<p class=text align=left style='text-align:left'>В индексном режиме индекс
финального затуманенного цвета вычисляется следующим образом:</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1195" type="#_x0000_t75" alt="" style='width:99pt;height:18pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image158.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов6.mht!http://www.progz.ru/images/opengl/chapter6/form21.JPG"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=132 height=24
src="OpenGL%20Red%20Book.files/image158.jpg" v:shapes="_x0000_i1195"><![endif]>,</p>

<p class=text align=left style='text-align:left'>где <!--[if gte vml 1]><v:shape
 id="_x0000_i1196" type="#_x0000_t75" alt="" style='width:11.25pt;height:18.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image159.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов6.mht!http://www.progz.ru/images/opengl/chapter6/form22.JPG"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=15 height=25
src="OpenGL%20Red%20Book.files/image159.jpg" v:shapes="_x0000_i1196"><![endif]>&nbsp;представляет
собой цветовой индекс входящего фрагмента, а <!--[if gte vml 1]><v:shape id="_x0000_i1197"
 type="#_x0000_t75" alt="" style='width:16.5pt;height:19.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image160.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов6.mht!http://www.progz.ru/images/opengl/chapter6/form23.JPG"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=22 height=26
src="OpenGL%20Red%20Book.files/image160.jpg" v:shapes="_x0000_i1197"><![endif]>&nbsp;--
индекс цвета тумана, заданный аргументом GL_FOG_INDEX.</p>

<p class=text align=left style='text-align:left'>Чтобы использовать туман в индексном
режиме, вам требуется должным образом загрузить величины в цветовую карту.
Первый цвет в карте должен быть цветом объекта без тумана, а последний – цветом
полностью затуманенного объекта. Возможно, вы захотите использовать <b>glClearIndex()</b>,
чтобы инициализировать цвет заднего фона индексом последнего цвета в карте;
таким образом, полностью затуманенные объекты будут совмещены с задним фоном.
Похожим образом, до того, как объекты нарисованы, вам следует вызвать команду <b>glIndex*()</b>
и передать ей индекс первого цвета в карте (цвета незатуманенного объекта).
Кроме того, если вы хотите нарисовать несколько затуманенных объектов разного
цвета, вам следует загрузить соответствующее количество цветовых карт и
вызывать <b>glIndex*()</b> перед рисованием каждого объекта. Пример 6-6
иллюстрирует инициализацию всех нужных аспектов для использования тумана в
индексном режиме.</p>

<p class=text align=left style='text-align:left'>Пример 6-6. Туман в индексном
режиме: файл fogindex.cpp</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>#include
  &lt;windows.h&gt;<br>
  #include &lt;GL/glut.h&gt;<br>
  <br>
  #define NUM_COLORS 32<br>
  #define RAMPSTART 16<br>
  <br>
  void init(void)<br>
  {<br>
  &nbsp;&nbsp; int i;<br>
  <br>
  &nbsp;&nbsp; glEnable(GL_DEPTH_TEST);<br>
  &nbsp;&nbsp; for(i=0;i&lt;NUM_COLORS;i++)<br>
  &nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GLfloat shade;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  shade=(GLfloat)(NUM_COLORS-i)/(GLfloat)NUM_COLORS;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glutSetColor(RAMPSTART+i,shade,shade,shade);<br>
  &nbsp;&nbsp; }<br>
  &nbsp;&nbsp; glEnable(GL_FOG);<br>
  &nbsp;&nbsp; glFogi(GL_FOG_MODE,GL_LINEAR);<br>
  &nbsp;&nbsp; glFogi(GL_FOG_INDEX,NUM_COLORS);<br>
  &nbsp;&nbsp; glFogf(GL_FOG_DENSITY,0.35);<br>
  &nbsp;&nbsp; glFogf(GL_FOG_START,1.0);<br>
  &nbsp;&nbsp; glFogf(GL_FOG_END,6.0);<br>
  &nbsp;&nbsp; glHint(GL_FOG_HINT,GL_NICEST);<br>
  &nbsp;&nbsp; glClearIndex((GLfloat)(NUM_COLORS+RAMPSTART-1));<br>
  }<br>
  <br>
  void renderSphere(GLfloat x ,GLfloat y, GLfloat z)<br>
  {<br>
  &nbsp;&nbsp; glPushMatrix();<br>
  &nbsp;&nbsp; glTranslatef(x,y,z);<br>
  &nbsp;&nbsp; glutWireSphere(0.4,16,16);<br>
  &nbsp;&nbsp; glPopMatrix();<br>
  }<br>
  <br>
  void display(void)<br>
  {<br>
  &nbsp;&nbsp; glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);<br>
  &nbsp;&nbsp; glIndexi(RAMPSTART);<br>
  &nbsp;&nbsp; renderSphere(-2.,-0.5,-1.0);<br>
  &nbsp;&nbsp; renderSphere(-1.,-0.5,-2.0);<br>
  &nbsp;&nbsp; renderSphere(0.,-0.5,-3.0);<br>
  &nbsp;&nbsp; renderSphere(1.,-0.5,-4.0);<br>
  &nbsp;&nbsp; renderSphere(2.,-0.5,-5.0);<br>
  &nbsp;&nbsp; glFlush();<br>
  }<br>
  <br>
  void reshape(int w, int h)<br>
  {<br>
  &nbsp;&nbsp; glViewport(0,0,(GLsizei) w, (GLsizei) h);<br>
  &nbsp;&nbsp; glMatrixMode(GL_PROJECTION);<br>
  &nbsp;&nbsp; glLoadIdentity();<br>
  &nbsp;&nbsp; if (w&lt;=h)<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  glOrtho(-2.5,2.5,-2.5*(GLfloat)h/(GLfloat)w,2.5*(GLfloat)h/(GLfloat)w,-10.0,10.0);<br>
  &nbsp;&nbsp; else<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  glOrtho(-2.5*(GLfloat)w/(GLfloat)h,2.5*(GLfloat)w/(GLfloat)h,-2.5,2.5,-10.0,10.0);<br>
  &nbsp;&nbsp; glMatrixMode(GL_MODELVIEW);<br>
  &nbsp;&nbsp; glLoadIdentity();<br>
  }<br>
  <br>
  int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR
  lpCmdLine, int nCmdShow)<br>
  {<br>
  &nbsp;&nbsp; char* argv=&quot;&quot;;<br>
  &nbsp;&nbsp; int argc=0;<br>
  &nbsp;&nbsp; glutInit(&amp;argc,&amp;argv);<br>
  &nbsp;&nbsp; glutInitDisplayMode(GLUT_SINGLE|GLUT_INDEX|GLUT_DEPTH);<br>
  &nbsp;&nbsp; glutInitWindowSize(500,500);<br>
  &nbsp;&nbsp; glutCreateWindow(&quot;Fog in Color-Index Mode&quot;);<br>
  &nbsp;&nbsp; init();<br>
  &nbsp;&nbsp; glutDisplayFunc(display);<br>
  &nbsp;&nbsp; glutReshapeFunc(reshape);<br>
  &nbsp;&nbsp; glutMainLoop();<br>
  &nbsp;&nbsp; return 0; <br>
  } <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<h2>6.4&nbsp; Смещение полигонов</h2>

<p class=text align=left style='text-align:left'>Если вы хотите выделить ребра
залитого объекта, вы можете попробовать нарисовать его сначала в режиме
GL_FILL, а затем перерисовать его снова, но другим цветом и в режиме GL_LINE.
Однако поскольку линии и залитые полигоны растеризуются не совсем одинаковым
образом, величины глубины, сгенерированные для линий не совсем те же самые, что
сгенерированы для ребер полигона, даже между двумя одинаковыми вершинами.
Выделяемые ребра могут входить и выходить из смежного полигона, который в
результате выглядит недостаточно качественно и часто называется «<i>простроченным</i>»
(«<i>stiching</i>»). </p>

<p class=text align=left style='text-align:left'>Недостатки внешнего вида могут
быть устранены путем использования полигонального смещения, которое вносит
необходимое смещение, форсируя четкое разделение смежных ребер и линий по
глубине. (Для этого также может быть использован буфер трафарета, но
полигональное смещение, как правило, работает быстрее.) Полигональное смещение
также весьма удобно использовать для добавления выделения к поверхностям,
визуализации изображений с удалением невидимых линий. Помимо линий и залитых
полигонов эта техника может быть применена к точкам. На обеих частях рисунка
6-8 сначала был нарисован освещенный торус в режиме заливки, а затем такой же
торус, но другим цветом и в режиме контура, однако слева полигональное смещение
выключено, а справа включено.</p>

<p class=text align=left style='text-align:left'>Рисунок 6-8. Залитые и
проволочные торусы с полигональным смещением (справа) и без него (слева) </p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1198" type="#_x0000_t75" alt="" style='width:440.25pt;height:220.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image161.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов6.mht!http://www.progz.ru/images/opengl/chapter6/6-8.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=587 height=294
src="OpenGL%20Red%20Book.files/image161.jpg" v:shapes="_x0000_i1198"><![endif]></p>

<p class=text align=left style='text-align:left'>Существует три различных
способа включить полигональное смещение, по одному для каждого режима
растеризации полигонов: GL_FILL, GL_LINE, GL_POINT. Вы включаете полигональное
смещение, передавая соответствующий аргумент команде <b>glEnable()</b> –
GL_POLYGON_OFFSET_FILL, GL_POLYGON_OFFSET_LINE или GL_POLYGON_OFFSET_POINT. Вы
также должны вызвать <b>glPolygonMode()</b>, чтобы выбрать текущий режим
растеризации полигонов.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glPolygonOffset</b>
  (GLfloat <i>factor</i>, GLfloat <i>units</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Если полигональное смещение
включено, величина глубины каждого фрагмента добавляется к вычисленной величине
смещения. Смещение добавляется до того, как производится тест глубины и до
того, как величина глубины записывается в буфер глубины. Величина смещения
вычисляется следующим образом:</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1199" type="#_x0000_t75" alt="" style='width:135.75pt;height:14.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image162.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов6.mht!http://www.progz.ru/images/opengl/chapter6/form24.JPG"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=181 height=19
src="OpenGL%20Red%20Book.files/image162.jpg" v:shapes="_x0000_i1199"><![endif]>,</p>

<p class=text align=left style='text-align:left'>где <i>m</i> – максимальное
разброс глубины вершин полигона, а <i>r </i>– минимальная величина,
гарантирующая разумное различие по глубине в оконных координатах. Величина <i>r</i>
– константа, зависимая от реализации.</p>

<p class=text align=left style='text-align:left'>Чтобы достигнуть приемлемых
результатов и избежать визуальных артефактов, вы можете либо добавить
положительное смещение к залитому объекту (отодвинуть его от себя), либо
добавить отрицательное смещение к каркасу (придвинуть его к себе). Самый
сложный вопрос заключается в том, насколько большое смещение стоит выбирать? К
сожалению, нужное смещение зависит от многих факторов, в частности от
максимального разброса в глубине вершин полигона и толщины линий каркаса.</p>

<p class=text align=left style='text-align:left'>OpenGL вычисляет разброс
глубины вершин полигона самостоятельно, но важно, чтобы вы понимали, что есть
этот разброс, поскольку это позволит вам выбирать осмысленные значения для
аргумента <i>factor</i>. Разброс глубины – это изменение в величине глубины,
деленное на изменение в xили y – координатах, пересекающих полигон. Величины
глубины при этом измеряются в оконных координатах, усеченных до диапазона [0,
1]. Чтобы вычислить разброс глубин полигона, используйте формулу </p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1200" type="#_x0000_t75" alt="" style='width:114pt;height:40.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image163.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов6.mht!http://www.progz.ru/images/opengl/chapter6/form25.JPG"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=152 height=54
src="OpenGL%20Red%20Book.files/image163.jpg" v:shapes="_x0000_i1200"><![endif]>.</p>

<p class=text align=left style='text-align:left'>Рисунок 6-9. Полигоны и их
разброс глубин</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1201" type="#_x0000_t75" alt="" style='width:232.5pt;height:122.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image164.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов6.mht!http://www.progz.ru/images/opengl/chapter6/6-9.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=310 height=163
src="OpenGL%20Red%20Book.files/image164.jpg" v:shapes="_x0000_i1201"><![endif]></p>

<p class=text align=left style='text-align:left'>Для полигонов, которые
параллельны ближней или дальней отсекающим плоскостям, разброс глубин равен 0.
Для полигонов в вашей сцене, разброс глубин которых близок к нулю, требуется лишь
небольшая величина смещения. Чтобы создать небольшое, постоянное смещение, вы
можете передать в команду <b>glPolygonOffset()</b> <i>factor</i>=0.0 и <i>units</i>=1.0.</p>

<p class=text align=left style='text-align:left'>Для полигонов с большим углом
к плоскостям отсечения, разброс глубин может быть значительно больше нуля, и
может потребоваться большее смещение. Небольшая, неравная нулю величина для <i>factor</i>,
например 0.75 или 1.0 может быть вполне достаточной для генерации величин
глубины, необходимых для устранения визуальных артефактов.</p>

<p class=text align=left style='text-align:left'>Пример 6-7 демонстрирует часть
кода с применением списка отображения (рисующим залитый объект). Сначала объект
отображается с освещением, режимом полигонов GL_FILL и полигональном смещением
с величинами <i>factor</i>=1.0 и <i>units</i>=1.0. Данные величины гарантируют,
что смещение достаточно для всех полигонов в вашей сцене, независимо от
разброса глубины. (Эти величины могут быть даже больше минимально необходимых,
однако чуть-чуть большее, чем нужно полигональное смещение заметно меньше, чем
чуть-чуть меньшее.) Затем, для выделения ребер первого объекта, объект
отображается еще раз в виде неосвещенного каркаса с выключенным смещением.</p>

<p class=text align=left style='text-align:left'>Пример 6-7. Использование
полигонального смещения для удаления визуальных артефактов</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>glEnable(GL_LIGHTING);
  glEnable(GL_LIGHT0);<br>
  glEnable(GL_POLYGON_OFFSET_FILL);<br>
  glPolygonOffset(1.0,1.0);<br>
  glCallList(list);<br>
  glDisable(GL_POLYGON_OFFSET_FILL);<br>
  glDisable(GL_LIGHTING);<br>
  glDisable(GL_LIGHT0);<br>
  glColor3f(1.0,1.0,1.0);<br>
  glPolygonMode(GL_FRONT_AND_BACK,GL_LINE);<br>
  glCallList(list);<br>
  glPolygonMode(GL_FRONT_AND_BACK,GL_FILL);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>В небольшом числе ситуаций
простейшие значения для величин <i>factor </i>и units (1.0, и 1.0) не являются
решениями проблемы. Например, если длина линий, выделяющих ребра больше 1,
может быть необходимо увеличение значения <i>factor</i>. Также, поскольку
величины глубины неравномерно преобразуются в оконные координаты при
перспективном проецировании, меньшее смещение требуется для полигонов, которые
находятся ближе к ближней отсекающей плоскости и большее для полигонов,
находящихся дальше от нее. Таким образом, требуются эксперименты со значениями <i>factor</i>.</p>

<p class=MsoNormal><a name=Глава7><span style='display:none;mso-hide:all'><o:p>&nbsp;</o:p></span></a></p>

<h1 align=left style='text-align:left'><span style='mso-bookmark:Глава7'>Глава
7. Списки отображения</span></h1>

<span style='mso-bookmark:Глава7'></span>

<p class=MsoNormal><a href="mailto:ahinar@list.ru"></a><i><span
style='font-size:10.0pt;font-family:Verdana'>Список отображения (дисплейные
списки)</span></i><span style='font-size:10.0pt;font-family:Verdana'> – это
группа команд OpenGL, сохраненная для дальнейшего исполнения. Когда исполняется
список отображения, команды, включенные в него, исполняются в том порядке, в
котором они были заданы. Большинство команд OpenGL могут быть как сохранены в
списке отображения, так и выполняться в непосредственном режиме, в котором они
выполняются немедленно. В одной программе вы можете смело смешивать код
непосредственного режима с использованием списков отображения. Во всех примерах
программ до этого момента все команды исполнялись в непосредственном режиме. В
данной главе обсуждаются списки отображения и то, как их лучше использовать.<o:p></o:p></span></p>

<h2>7.1&nbsp; Зачем использовать списки отображения</h2>

<p class=text align=left style='text-align:left'>Списки отображения могут
увеличить быстродействие, поскольку вы можете сохранять в них команды OpenGL
для дальнейшего исполнения. Хорошей идеей является кэширование команд в списке
отображения, если вы планируете рисовать какую-либо геометрию несколько раз или
если несколько раз устанавливаете одно и то же состояние настроек. Используя
списки отображения, вы можете определить геометрические данные или изменения в
состоянии один раз и затем исполнять их столько раз, сколько вам нужно.</p>

<p class=text align=left style='text-align:left'>Чтобы разобраться с
использование списков, представьте себе рисование трехколесного велосипеда. Два
задних колеса имеют одинаковый размер, но смещены относительно друг друга.
Переднее колесо больше по размеру, чем задние и находится в другом месте.
Эффективным способом визуализации колес велосипеда будет сохранение геометрии
для одного колеса в списке отображения, и затем его исполнение три раза. Вам
следует устанавливать видовую матрицу каждый раз перед исполнением списка для
вычисления правильного размера и положения каждого колеса.</p>

<p class=text align=left style='text-align:left'>Особенно важно кэшировать
команды OpenGL в списках отображения, когда приложение исполняется на удаленной
машине. В этом случае, сервер и хост физически являются разными машинами.
Поскольку списки отображения являются частью состояния сервера и, таким
образом, сохраняются на серверной машине, вы можете сократить время на
постоянную передачу этих данных по сети, если сохраните часто используемые
команды в списках отображения. </p>

<p class=text align=left style='text-align:left'>При локальном исполнении, вы
часто также можете увеличить быстродействие путем сохранения часто используемых
команд в списках отображения. Некоторая графическая аппаратура может сохранять
списки отображения в выделенной для этого памяти или хранить данные в
оптимизированной форме, которая более совместима с аппаратным или программным
обеспечением.</p>

<h2>7.2&nbsp; Пример использования списка отображения</h2>

<p class=text align=left style='text-align:left'>Список отображения это удобный
и эффективный путь именования и организации набора команд OpenGL. Предположим,
например, что вы хотите нарисовать торус и смотреть на него под разными углами.
Наиболее эффективный способ сделать это заключается в том, чтобы сохранить
торус в списке отображения. После этого, если вы хотите изменить угол обзора,
все что вам нужно сделать, это изменить видовую матрицу и вызвать список отображения
к исполнению. </p>

<p class=text align=left style='text-align:left'>Пример 7-1. Создание списка
отображения: файл torus.cpp </p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>#include &lt;glut.h&gt;<br>
  #include &lt;math.h&gt;<br>
  <br>
  GLuint theTorus;<br>
  <br>
  //Отрисовка торуса <br>
  void torus(int numc,int numt)<br>
  {<br>
  &nbsp;&nbsp; int i,j,k;<br>
  &nbsp;&nbsp; double s,t,x,y,z,twopi;<br>
  &nbsp;&nbsp; twopi=2*(double) 3.1415;<br>
  &nbsp;&nbsp; for(i=0;i&lt;numc;i++)<br>
  &nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glBegin(GL_QUAD_STRIP);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(j=0;j&lt;=numt;j++)<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  for(k=1;k&gt;=0;k--)<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  s=(i+k)%numc+0.5;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  t=j%numt;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  x=(1+.1*cos(s*twopi/numc))*cos(t*twopi/numt);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  y=(1+.1*cos(s*twopi/numc))*sin(t*twopi/numt);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  z=.1*sin(s*twopi/numc);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  glVertex3f(x,y,z);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glEnd();<br>
  &nbsp;&nbsp; }<br>
  }<br>
  <br>
  void init(void)<br>
  {<br>
  &nbsp;&nbsp; theTorus=glGenLists(1);<br>
  &nbsp;&nbsp; glNewList(theTorus,GL_COMPILE);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; torus(8,25);<br>
  &nbsp;&nbsp; glEndList();<br>
  &nbsp;&nbsp; glShadeModel(GL_FLAT);<br>
  &nbsp;&nbsp; glClearColor(0.0,0.0,0.0,0.0);<br>
  }<br>
  <br>
  void display()<br>
  {<br>
  &nbsp;&nbsp; glClear(GL_COLOR_BUFFER_BIT);<br>
  &nbsp;&nbsp; glColor3f(1.0,1.0,1.0);<br>
  &nbsp;&nbsp; glCallList(theTorus);<br>
  &nbsp;&nbsp; glFlush();<br>
  }<br>
  <br>
  void reshape(int w,int h)<br>
  {<br>
  &nbsp;&nbsp; glViewport(0,0,(GLsizei)w,(GLsizei)h);<br>
  &nbsp;&nbsp; glMatrixMode(GL_PROJECTION);<br>
  &nbsp;&nbsp; glLoadIdentity();<br>
  &nbsp;&nbsp; gluPerspective(30,(GLfloat)w/(GLfloat)h,1.0,100.0);<br>
  &nbsp;&nbsp; glMatrixMode(GL_MODELVIEW);<br>
  &nbsp;&nbsp; glLoadIdentity();<br>
  &nbsp;&nbsp; gluLookAt(0,0,10,0,0,0,0,1,0);<br>
  }<br>
  <br>
  //&quot;x&quot; -- повернуть вокруг x -оси;&quot;y&quot; -- повернуть вокруг
  y -оси;&quot;i&quot;--вернуться в начальное состояние<br>
  void keyboard(unsigned char key,int x,int y)<br>
  {<br>
  &nbsp;&nbsp; switch(key)<br>
  &nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'X':<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'x':<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glRotatef(30.,1.0,0.0,0.0);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glutPostRedisplay();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'Y':<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'y':<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glRotatef(30.,0.0,1.0,0.0);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glutPostRedisplay();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'I':<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'i':<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glLoadIdentity();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  gluLookAt(0,0,10,0,0,0,0,1,0);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glutPostRedisplay();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 27:<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(0);<br>
  &nbsp;&nbsp; }<br>
  }<br>
  <br>
  int main(int argc, char** argv)<br>
  {<br>
  &nbsp;&nbsp; glutInit(&amp;argc,argv); <br>
  &nbsp;&nbsp; glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);<br>
  &nbsp;&nbsp; glutInitWindowSize(200,200);<br>
  &nbsp;&nbsp; glutCreateWindow(&quot;Creating a Display List&quot;);<br>
  &nbsp;&nbsp; init();<br>
  &nbsp;&nbsp; glutDisplayFunc(display);<br>
  &nbsp;&nbsp; glutReshapeFunc(reshape);<br>
  &nbsp;&nbsp; glutKeyboardFunc(keyboard);<br>
  &nbsp;&nbsp; glutMainLoop();<br>
  &nbsp;&nbsp; return 0;<br>
  }<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Начнем с рассмотрения функции <b>init()</b>.
Она создает список отображения для торуса и инициализирует состояние OpenGL.
Заметьте, что вызов функции рисования торуса (<b>torus()</b>) заключена в
командные скобки <b>glNewList()</b> и <b>glEndList()</b>, которые определяют
список отображения. Аргумент <i>listName </i>команды <b>glNewList()</b>
представляет собой целочисленный индекс, сгенерированный командой <b>glGenLists()</b>
и однозначно идентифицирующий конкретный список отображения.</p>

<p class=text align=left style='text-align:left'>Пользователь может
поворачивать торус вокруг осей <i>x</i>и <i>y</i>, нажимая клавиши ‘x’ и ‘y’,
соответственно. Каждый раз, когда это случается, вызывается функция обратного
вызова <b>keyboard()</b>, которая комбинирует текущую видовую матрицу с
матрицей поворота вокруг соответствующей оси. Затем вызывается функция <b>glutPostRedisplay()</b>,
которая заставляет <b>glutMainLoop()</b> вызвать функцию <b>display()</b> и
вывести торус после того, как будут обработаны все остальные события. Когда
нажимается клавиша ‘i’, функция <b>keyboard()</b> восстанавливает начальную
видовую матрицу и возвращает торус к начальному положению.</p>

<p class=text align=left style='text-align:left'>Сама функция <b>display()</b>
крайне проста. Она очищает окно и затем вызывает команду <b>glCallList()</b>
для исполнения команд в списке отображения. Если бы мы не использовали списки
отображения, в функции <b>display()</b> следовало бы вызывать все команды для
отображения торуса.</p>

<p class=text align=left style='text-align:left'>Список отображения содержит
только команды OpenGL. В примере 7-1 в списке отображения сохраняются только
команды <b>glBegin()</b>, <b>glEnd()</b> и <b>glVertex()</b>. Параметры для
этих вызовов <i>вычисляются</i> и после этого копируются в список отображения
при его создании. Все тригонометрические расчеты для создания торуса
выполняются только один раз, что увеличивает быстродействие. Однако величины в
списке отображения не могут быть изменены в дальнейшем, и после того как
команда была сохранена в списке отображения, не существует способа извлечь ее
из него. Также невозможно добавлять новые команды в список отображения, после
того как он был определен. Вы можете удалить список целиком и создать новый, но
не можете изменять его.</p>

<p class=warning>Замечание: Списки отображения также отлично работают с
командами из библиотеки утилит GLU, поскольку эти команды могут быть разбиты на
низкоуровневые команды OpenGL и сохранены в списках отображения. Использование
списков отображения совместно с командами GLU особенно важно для увеличения
быстродействия при работе с тесселяцией и NURBS.</p>

<h2>7.3&nbsp; Философия разработки списков отображения</h2>

<p class=text align=left style='text-align:left'>В целях оптимизации быстродействия,
списки отображения сделаны больше похожими на кэш команд, чем на динамическую
базу данных. Другими словами, как только список создан, он не может быть
изменен. Если бы списки были бы изменяемыми, быстродействие снизилось бы за
счет необходимости затрат на поиск по ним и управление памятью. Из-за изменения
частей списка, пространство в памяти выделялось и освобождалось бы частями, что
вело бы к фрагментации памяти. Кроме того, для модификации частей списка
требовалось бы обратить все изменения, которые реализация OpenGL внесла в него
в целях оптимизации. Помимо прочего, вероятно, что получить доступ к спискам
было бы весьма трудно, так как они могут кэшироваться где-либо в сети или
системной шине.</p>

<p class=text align=left style='text-align:left'>Способ, которым оптимизируются
команды в списке отображения, может меняться от реализации к реализации. За
счет базовых команд вроде <b>glRotate()</b> можно получить достаточно большой
выигрыш по производительности, поместив их в списки отображения, поскольку
вычисления, необходимые для построения матрицы поворота нетривиальны (и могут
включать вычисление квадратных корней и тригонометрические функции). Однако в
списке отображения можно сохранить только результирующую матрицу поворота,
поэтому команда поворота в списке отображения может быть выполнена настолько
быстро, насколько быстро аппаратура может выполнить <b>glMultMatrix*()</b>.
Наиболее продвинутые реализации OpenGL могут даже комбинировать смежные команды
преобразований в одну финальную матрицу.</p>

<p class=text align=left style='text-align:left'>Хотя и не гарантируется, что
ваша конкретная реализация OpenGL оптимизирует списки отображения для
каких-либо конкретных нужд, в любом случае исполнение списка не может быть
медленнее, чем непосредственное индивидуальное исполнение всех&nbsp; команд,
содержащихся в нем. Некоторая потеря быстродействия может, однако, возникнуть
из необходимости переходов от списка к списку. Если конкретный список
достаточно мал, то эта потеря может свести на нет выгоду от его использования.
Далее перечислены наиболее вероятные случаи, в которых можно оптимизировать
быстродействие за счет списков отображения.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l61 level1 lfo23;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Матричные операции. Большинство матричных
операций OpenGL вычисления обратных матриц. Обе матрицы – расчетная и обратная
к ней могут быть сохранены в списке отображения реализацией OpenGL.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l61 level1 lfo23;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Битовые карты и изображения. Формат, в котором
вы задаете растровые данные, наверняка не является тем, который идеален для
аппаратуры. При компиляции списка отображения, OpenGL может преобразовать
данные к представлению, предпочтительному для аппаратуры. Это может значительно
повлиять на скорость рисования растровых символов, строки символов обычно
состоят из серий небольших битовых карт.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l61 level1 lfo23;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Источники света, свойства материалов и модели
освещения. Когда вы рисуете сцену со сложными условиями освещения, вы можете
изменять материалы для каждого элемента сцены. Настройка материалов может быть
достаточно медленной, поскольку требует ряда вычислений. Если вы поместите
определение материала в список отображения, эти вычисления не будут
производиться каждый раз при переключении материала, поскольку необходимо
сохранить только результаты вычислений; в результате визуализация и вывод
освещенных сцен может совершаться значительно быстрее.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l61 level1 lfo23;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Текстуры. Вы можете максимизировать
эффективность при определении текстур скомпилировав их в список отображения,
поскольку список отображения может кэшировать изображение текстуры в выделенной
текстурной памяти. После этого не требуется копировать изображение текстуры
каждый раз, когда оно понадобилось. Кроме того, аппаратный формат текстуры
может отличаться от формата OpenGL, и конверсия может быть выполнена во время
компиляции списка отображения, а не во время отображения сцены. В OpenGL версии
1.0 списки отображения были главным методом управления текстурами. Однако если
вы работаете с OpenGL версии 1.1 или выше, вам следует сохранять текстуры в <i>объекте
текстуры</i>. (Некоторые реализации версии 1.0 имеют специфичные для
производителя расширения для поддержки объектов текстуры. Если ваша реализация
поддерживает объекты текстуры, вам следует использовать их.)</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l61 level1 lfo23;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Рисунки шаблонов полигона.</p>

<p class=text align=left style='text-align:left'>Некоторые из команд,
используемых для задания свойств, перечисленных здесь, являются
контекстно-чувствительными, и это следует принимать в расчет для получения
оптимального быстродействия. Например, когда включен режим цвета материала
(GL_COLOR_MATERIAL), некоторые из параметров материала будут отслеживать
текущий цвет. Любые вызовы <b>glMaterial*()</b> для установки тех же параметров
будут игнорироваться.</p>

<p class=text align=left style='text-align:left'>Сохранение установок
переменных состояния вместе с геометрическими данными может увеличить
быстродействие. Например, предположим, что вы хотите трансформировать некоторые
геометрические объекты и затем вывести результат. Код для этого может быть
таким:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>glNewList(1, GL_COMPILE);<br>
  &nbsp;&nbsp; нарисовать_некоторые_объекты();<br>
  glEndList();<br>
  glLoadMatrix(M);<br>
  glCallList(1);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Однако, если геометрический
объект каждый раз преобразовывается одинаковым образом, лучше сохранить матрицу
преобразования в списке отображения. Например, Если вы напишите код следующим
образом, некоторые реализации OpenGL могут преобразовать объект по время его
определения, а не во время его рисования:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>glNewList(1, GL_COMPILE);<br>
  &nbsp;&nbsp; glLoadMatrix(M);<br>
  &nbsp;&nbsp; нарисовать_некоторые_объекты();<br>
  glEndList();<br>
  glCallList(1);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Более частая ситуация
возникает при визуализации изображений. Вы можете изменять переменные
состояния, управляющие переносом пикселей и управлять тем, как растеризуются
изображения и битовые карты. Если команды, устанавливающие эти переменные,
предшествуют определению изображения или битовой карты, реализация OpenGL может
выполнить некоторые преобразования в момент создания списка и кэшировать
результаты.</p>

<p class=text align=left style='text-align:left'>Помните, что списки
отображения имеют и ряд недостатков. Очень маленькие списки могут работать
недостаточно быстро, так как существует некоторая потеря времени при исполнении
списка. Другим недостатком является неизменяемость данных внутри списка
отображения. Для оптимизации быстродействия содержимое списков отображения
OpenGL не может быть изменено или считано. Если приложению требуется управление
данными отдельно от списков отображения (например, для отображения данных в
реальном времени), может потребоваться много дополнительной памяти.</p>

<h2>7.4&nbsp; Создание и исполнение списка отображения</h2>

<p class=text align=left style='text-align:left'>Как вы уже видели, для начала
и конца описания списка применяются команды <b>glNewList()</b> и <b>glEndList()</b>.
Далее список может быть исполнен передачей его индекса в команду <b>glCallList()</b>.
В примере 7-2 список создается в функции <b>init()</b>. Этот список отображения
содержит команды OpenGL для рисования красного треугольника. Затем в функции <b>display()</b>
список исполняется 10 раз. Кроме того, там же рисуется линия в непосредственном
режиме. Имейте в виду, что для списка отображения выделяется память, в которой
хранятся его команды и все необходимые переменные.</p>

<p class=text align=left style='text-align:left'>Пример 7-2. Использование
списка отображения: файл list.cpp</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>#include &lt;glut.h&gt;<br>
  <br>
  GLuint listName;<br>
  <br>
  void init(void)<br>
  {<br>
  &nbsp;&nbsp; listName=glGenLists(1);<br>
  &nbsp;&nbsp; glNewList(listName,GL_COMPILE);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glColor3f(1.0,0.0,0.0);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glBegin(GL_TRIANGLES);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glVertex2f(0.0,0.0);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glVertex2f(1.0,0.0);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glVertex2f(0.0,1.0);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glEnd();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glTranslatef(1.5,0.0,0.0);<br>
  &nbsp;&nbsp; glEndList();<br>
  &nbsp;&nbsp; glShadeModel(GL_FLAT);<br>
  }<br>
  <br>
  void drawLine()<br>
  {<br>
  &nbsp;&nbsp; glBegin(GL_LINES);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glVertex2f(0.0,0.5);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glVertex2f(15.0,0.5);<br>
  &nbsp;&nbsp; glEnd();<br>
  }<br>
  <br>
  void display(void)<br>
  {<br>
  &nbsp;&nbsp; GLuint i;<br>
  &nbsp;&nbsp; glClear(GL_COLOR_BUFFER_BIT);<br>
  &nbsp;&nbsp; glColor3f(0.0,1.0,0.0);<br>
  &nbsp;&nbsp; for(i=0;i&lt;=10;i++)<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glCallList(listName);<br>
  <br>
  &nbsp;&nbsp; //Эта линия НЕ будет зеленой, так как текущий цвет был изменен
  внутри ЛИСТА<br>
  &nbsp;&nbsp; drawLine();<br>
  &nbsp;&nbsp; glFlush();<br>
  }<br>
  <br>
  void reshape(int w, int h)<br>
  {<br>
  &nbsp;&nbsp; glViewport(0,0,w,h);<br>
  &nbsp;&nbsp; glMatrixMode(GL_PROJECTION);<br>
  &nbsp;&nbsp; glLoadIdentity();<br>
  &nbsp;&nbsp; if (w&lt;=h)<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  gluOrtho2D(0.0,2.0,-0.5*(GLfloat)h/(GLfloat)w,1.5*(GLfloat)h/(GLfloat)w);<br>
  &nbsp;&nbsp; else<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  gluOrtho2D(0.0,2.0*(GLfloat)w/(GLfloat)h,-0.5,1.5);<br>
  &nbsp;&nbsp; glMatrixMode(GL_MODELVIEW);<br>
  &nbsp;&nbsp; glLoadIdentity();<br>
  }<br>
  <br>
  int main(int argc, char** argv)<br>
  {<br>
  &nbsp;&nbsp; glutInit(&amp;argc,argv);<br>
  &nbsp;&nbsp; glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);<br>
  &nbsp;&nbsp; glutInitWindowSize(650,50);<br>
  &nbsp;&nbsp; glutCreateWindow(&quot;Using a Display List&quot;);<br>
  &nbsp;&nbsp; init();<br>
  &nbsp;&nbsp; glutDisplayFunc(display);<br>
  &nbsp;&nbsp; glutReshapeFunc(reshape);<br>
  &nbsp;&nbsp; glutMainLoop();<br>
  &nbsp;&nbsp; return 0; <br>
  } <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Команда <b>glTranslatef()</b>
в списке отображения сдвигает позицию следующего рисуемого объекта. Без нее два
вызова списка к исполнению рисовали бы треугольники в одном и том же месте один
поверх другого. Функция <b>drawLine()</b>, вызываемая в непосредственном режиме
затронута влиянием 10-го вызова <b>glTranslate()</b>. Таким образом, если вы
вызываете команды преобразований внутри списка отображения, не забудьте учесть
эффект от влияния этих команд на более поздние вызовы в вашей программе. </p>

<p class=text align=left style='text-align:left'>В каждый момент времени
создается только один список отображения. Другими словами, за командой <b>glNewList()</b>
должна следовать команда <b>glEndList()</b>, завершающая создание списка, и
только после этого можно начинать создавать новый список. Как вы можете
подозревать, вызов <b>glEndList()</b> без предшествующего вызова <b>glNewList()</b>
сгенерирует ошибку GL_INVALID_OPERATION.</p>

<h2>7.4.1&nbsp; Именование и создание списка отображения</h2>

<p class=text align=left style='text-align:left'>Каждый список отображения
идентифицируется целым индексом. При создании списка следует быть осторожным,
дабы случайно не задействовать уже используемый индекс, поскольку это приведет
к перезаписи имеющегося списка. Во избежание этой проблемы используйте команду <b>glGenLists()</b>
для генерирования одного или более незадействованных индексов.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>GLuint <b>glGenLists</b>
  (GLsizei <i>range</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Выделяет непрерывный диапазон
незадействованных индексов, количеством <i>range</i>. Возвращаемое значение –
это первый индекс в этом блоке пустых индексов. Возвращаемые индексы помечаются
как пустые и используемые, таким образом последующие вызовы <b>glGenLists()</b>
не возвратят именно эти номера до тех пор, пока они не будут стерты. Если <i>range</i>
равен 0 или блок свободных индексов нужного размера отсутствует, <b>glGenLists()</b>
вернет 0.</p>

<p class=text align=left style='text-align:left'>В следующем примере
запрашивается единственный индекс, и, если он получен, создается новый список
отображения.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>listIndex=glGenLists(1);<br>
  if (listIndex!=0)<br>
  {<br>
  &nbsp;&nbsp; glNewList(listIndex, GL_COMPILE);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<br>
  &nbsp;&nbsp; </span><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>glEndList();<br>
  } <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=warning>Замечание: 0 не является допустимым индексом.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glNewList</b>
  (GLuint <i>list</i>, GLenum <i>mode</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Маркирует начало списка
отображения. Вызываемые далее (до вызова <b>glEndList()</b>) команды OpenGL
(кроме нескольких, запрещенных к использованию в списках) сохраняются в списке
отображения. (Эти запрещенные команды, если они встречаются в описании списка,
исполняются немедленно в непосредственном режиме.) Аргумент <i>list </i>– это
ненулевое положительное целое число, уникально идентифицирующее список
отображения. Возможными значениями для <i>mode </i>являются GL_COMPILE и
GL_COMPILE_AND_EXECUTE. Используйте GL_COMPILE, если вы не хотите, чтобы
команды OpenGL исполнялись немедленно при помещении в список. Если вы хотите,
чтобы при создании списка команды, помещаемые в него, выполнились еще и в
непосредственном режиме – используйте GL_COMPILE_AND_EXECUTE.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>glEndList</b> (void);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Маркирует конец списка
отображения.</p>

<p class=text align=left style='text-align:left'>При создании списка
отображения, он сохраняется вместе с текущим контекстом OpenGL. То есть, при
уничтожении контекста список также уничтожается. Некоторые оконные системы
позволяют разделение списков несколькими контекстами. В этом случае, список
уничтожается вместе с последним контекстом из <i>разделяющей группы</i>.</p>

<h2>7.4.2&nbsp; Что сохраняется в списке отображения</h2>

<p class=text align=left style='text-align:left'>Когда вы строите список, в нем
сохраняются только значения выражений. Если впоследствии элементы массива
изменятся – величины в списке останутся нетронутыми. В следующем фрагменте кода
список отображения содержит команды для установки текущего RGBA цвета в черный
(0.0, 0.0, 0.0). последующее изменение элементов массива <i>color_vector </i>на
красный (1.0, 0.0, 0.0) не затрагивает список отображения, поскольку в нем сохранились
величины, действовавшие на момент его создания.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>GLfloat
  color_vector[3]={0.0, 0.0, 0.0};<br>
  <br>
  glNewList(1, GL_COMPILE);<br>
  &nbsp;&nbsp; glColor3f(color_vector);<br>
  glEndList();<br>
  color_vector[0]=1.0; <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Не все команды OpenGL могут
быть сохранены и исполнены из списка отображения. Например, команды,
устанавливающие клиентское состояние, и команды, запрашивающие значения
переменных состояния, в списках отображения не сохраняются. (Многие из
несохраняемых в списках команд могут быть идентифицированы по тому признаку, что
они возвращают значение непосредственно или через аргумент указатель.) Если эти
команды вызываются при создании списка отображения, они выполняются немедленно.</p>

<p class=text align=left style='text-align:left'>Далее перечислены команды
OpenGL, которые не сохраняются в списках отображения. (Заметьте также, что
команда <b>glNewList()</b> сгенерирует ошибку, если будет вызвана во время
создания списка отображения.) </p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glColorPointer()<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glFlush()<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glNormalPointer()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glDeleteLists()<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGenLists()<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glPixelStore()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glDisableClientState()<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGet*()<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glReadPixels()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glEdgeFlagPointer()<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glIndexPointer()<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glRenderMode()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glEnableClientState()<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glInterleavedArrays()<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glSelectBuffer()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:5'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glFeedbackBuffer()<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glIsEnabled()<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glTexCoordPointer()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:6;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glFinish()<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glIsList()<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glVertexPointer()<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Чтобы более ясно понять,
почему эти команды не сохраняются в списках, помните, что при использовании
OpenGL по сети, клиент и сервер могут находиться на разных машинах. После
создания списка отображения, он находится на сервере, и сервер не может
полагаться на клиента в вопросах касающихся любой информации, связанной со
списком. Если бы команды опроса, такие как <b>glGet*()</b> или <b>glIs*()</b>
были допустимы в списках отображения, вызывающая программа была бы крайне
удивлена данным, поступающим по сети в случайные моменты времени. Без разбора
отосланного списка, программа вообще не будет знать, что делать с этими
данными. Таким образом, любые команды, возвращающие значения, не могут быть
сохранены в списке отображения. Кроме того, в списках не сохраняются команды,
изменяющие состояние клиента, такие как <b>glPixelStore()</b> или <b>glSelectBuffer()</b>,
и команды, определяющие вершинные массивы.</p>

<p class=text align=left style='text-align:left'>Действие некоторых команд
OpenGL зависит от состояния клиента. Например, команды описания вершинных
массивов (такие как <b>glVertexPointer()</b>, <b>glColorPointer()</b> и <b>glInterleavedArrays()</b>)
устанавливают указатели в пространстве клиента и не могут сохраняться в списках
отображения. Команды <b>glArrayElement()</b>, <b>glDrawArrays()</b> и <b>glDrawElements()</b>
посылают данные состоянию серверу для построения примитивов из вершинных
массивов, так что эти операции могут быть сохранены в списках отображения.
Данные вершинных массивов, сохраненные в списке отображения извлекаются путем
разрешения указателей, а не сохранением самого указателя. Таким образом,
последующие изменения в данных вершинных массивов не повлияют на описание примитива
в списке отображения.</p>

<p class=text align=left style='text-align:left'>Кроме того, любые команды,
опирающиеся в своей работе на режимы сохранения пикселей, используют те режимы,
которые были в действии на момент помещения этих команд в список. Другие
команды, опирающиеся на состояние клиента – такие как <b>glFinish()</b> и <b>glFlush()</b>
– не могут быть помещены в список отображения, так как они зависят от состояния
клиента в момент их исполнения.</p>

<h2>7.4.3&nbsp; Исполнение списка отображения</h2>

<p class=text align=left style='text-align:left'>После того, как вы создали
список отображения, вы можете исполнять его, вызвав команду <b>glCallList()</b>.
Естественно, вы можете исполнять один и тот же список много раз, и, как вы уже
видели, вы можете смешивать в программе код для исполнения списков отображения
и команды непосредственного режима.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>glCallList</b>
  (GLuint <i>list</i>); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Эта команда исполняет список
отображения, заданный аргументом <i>list</i>. Команды в списке исполняются в
том порядке, в котором они сохранялись, таким же образом, как если бы они
выполнялись вне списка. Если список с индексом <i>list </i>не определен, не
происходит ничего.</p>

<p class=text align=left style='text-align:left'>Вы можете вызывать <b>glCallList()</b>
из любого места программы до тех пор, пока активным является контекст OpenGL,
способный получить доступ к нужному списку отображения (то есть активным должен
быть контекст, в котором список создавался, или контекст, входящий в ту же
разделяющую группу). Список отображения может быть создан в одной функции, а и
вызван к исполнению совершенно из другой, поскольку в любом случае он
идентифицируется по своему индексу. Не существует методов для сохранения
содержимого списка отображения в файл данных, а также методов для загрузки
списков из файла. Таким образом, списки отображения разработаны для временного
использования.</p>

<h2>7.4.4&nbsp; Иерархические списки отображения</h2>

<p class=text align=left style='text-align:left'>Вы можете создать
иерархический список отображения, то есть список отображения, который исполняет
другой список отображения, вызывая <b>glCallList()</b> между парой <b>glNewList()</b>
и <b>glEndList()</b>. Иерархический список отображения полезен для рисования
объектов, состоящих из компонентов, особенно если эти компоненты используются
более одного раза. Например, следующий список отображения для велосипеда
исполняет списки отображения для рисования его частей:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>glNewList(listIndex,
  GL_COMPILE);<br>
  &nbsp;&nbsp; glCallList(handlebars);<br>
  &nbsp;&nbsp; glCallList(frame);<br>
  &nbsp;&nbsp; glTranslatef(1.0,0.0,0.0);<br>
  &nbsp;&nbsp; glCallList(wheel);<br>
  &nbsp;&nbsp; glTranslatef(3.0,0.0,0.0); <br>
  &nbsp;&nbsp; glCallList(wheel);<br>
  glEndList(); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Во избежание бесконечной
рекурсии существует ограничение на уровень вложенности списков отображение;
максимум уровня вложенности не может быть меньше 64, но может быть больше в
зависимости от реализации. Чтобы выяснить максимальный уровень вложенности в
вашей реализации OpenGL, используйте:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>glGetIntegerv(GL_MAX_LIST_NESTING,
  GLint *data); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>OpenGL позволяет вам создавать
списки, исполняющие другие списки, которые еще не созданы. Если один список
пытается исполнить другой, еще не созданный, ничего не происходит.</p>

<p class=text align=left style='text-align:left'>Вы можете использовать
иерархический список отображения для эмуляции редактируемого списка, оборачивая
его вокруг нескольких списков более низкого уровня. Например, чтобы поместить
полигон в список отображения и оставить за собой возможность редактировать его
вершины, можно использовать код из примера 7-3.</p>

<p class=text align=left style='text-align:left'>Пример 7-3. Иерархический
список отображения</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>glNewList(1, GL_COMPILE);<br>
  &nbsp;&nbsp; glVertex3fv(v1);<br>
  glEndList();<br>
  <br>
  glNewList(2, GL_COMPILE);<br>
  &nbsp;&nbsp; glVertex3fv(v2);<br>
  glEndList();<br>
  <br>
  glNewList(3, GL_COMPILE);<br>
  &nbsp;&nbsp; glVertex3fv(v3);<br>
  glEndList();<br>
  <br>
  glNewList(4, GL_COMPILE);<br>
  &nbsp;&nbsp; glBegin(GL_POLYGON);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glCallList(1);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glCallList(2);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glCallList(3);<br>
  &nbsp;&nbsp; glEnd();<br>
  glEndList(); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Чтобы отобразить полигон,
вызовите список отображения номер 4. Для редактирования вершины, вам нужно лишь
заново создать единственный список отображения соответствующий этой вершине.
Поскольку индекс однозначно идентифицирует список, создание нового списка, с
индексом существующего автоматически удалит старый. Имейте в виду, что такая
техника не гарантирует оптимального использования памяти или максимального
быстродействия, но она приемлема и полезна в некоторых случаях.</p>

<h2>7.4.5&nbsp; Управление индексами списков отображения</h2>

<p class=text align=left style='text-align:left'>До сих пор мы рекомендовали
использовать <b>glGenLists()</b> для получения неиспользуемых индексов. Если вы
хотите избежать использования <b>glGenLists()</b>, обязательно используйте <b>glIsList()</b>
для выяснения того, находится ли конкретный индекс в использовании.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>GLboolean <b>glIsList</b> (GLuint
  <i>list</i>); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Возвращает GL_TRUE если <i>list
</i>уже используется в качестве идентификатора существующего списка отображения
и GL_FALSE в противном случае.</p>

<p class=text align=left style='text-align:left'>Вы можете удалить конкретный
список отображения или их непрерывный диапазон командой <b>glDeleteLists()</b>.
После применения <b>glDeleteLists()</b>, индексы удаленных списков становятся
доступны для дальнейшего использования.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glDeleteLists</b>
  (GLuint <i>list</i>, GLsizei <i>range</i>); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Удаляет последовательные (по
индексам) списки отображения количеством <i>range</i>, начиная с индекса <i>list</i>.
Попытки удалить несуществующие списки отображения игнорируются.</p>

<h2>7.5&nbsp; Исполнение нескольких списков отображения</h2>

<p class=text align=left style='text-align:left'>OpenGL предоставляет
эффективный механизм для последовательного исполнения нескольких списков
отображения. Этот механизм требует, чтобы вы поместили индексы нужных списков в
массив и вызвали <b>glCallLists()</b>. Этот механизм обычно используется тогда,
когда индексы списков отображения имеют осмысленные значения. Например, если вы
создаете шрифт, индекс каждого списка может соответствовать ASCII коду символа
в шрифте. Чтобы создать несколько таких шрифтов, вам необходимо заранее
установить разные начальные значения для индексов списков отображения каждого
шрифта. Вы можете задать начальный индекс, вызвав <b>glListBase()</b> до вызова
<b>glCallLists()</b>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>&nbsp;void <b>glListBase</b>
  (GLuint <i>base</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Задает смещение, которое
добавляется к индексам списков в <b>glCallLists()</b> для получения финальных
индексов. По умолчанию базовое смещение равно 0. База не оказывает влияние ни
на команду <b>glNewList()</b>, ни на <b>glCallList()</b>, исполняющую единственный
список отображения.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>&nbsp;</span><span
  lang=EN-US style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:
  "Courier New";color:black;mso-ansi-language:EN-US'>void <b>glCallLists</b>
  (GLsizei <i>n</i>, GLenum <i>type</i>, const GLvoid *<i>lists</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Исполняет nсписков
отображения. Индексы исполняемых списков отображения вычисляются путем сложения
текущей базы списков (заданной с помощью <b>glListBase()</b>) с знаковыми
целыми значениями в массиве, на который указывает <i>lists</i>.</p>

<p class=text align=left style='text-align:left'>Аргумент <i>type</i>
задаеттипвеличинв <i>lists</i> иможет принимать значения GL_BYTE,
GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT или
GL_FLOAT, указывая на то, что массив <i>lists</i> должен интерпретироваться как
массив байт, беззнаковых байт, коротких целых, беззнаковых коротких целых,
целых, беззнаковых целых или чисел с плавающей точкой, соответственно. <i>Type</i>
также может принимать значения GL_2_BYTES, GL_3_BYTESили GL_4_BYTES; в этом случае
из массива считываются по 2, 3 или 4 байта, сдвигаются и складываются вместе,
байт за байтом, для вычисления смещения списка. Используется следующий алгоритм
(<i>byte[0]</i>– это начало последовательности байтов):</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>/* b=2, 3 или 4; байты в
  массиве нумеруются 0, 1, 2, 3 и так далее */<br>
  offset=0;<br>
  for(i=0;i&lt;b;i++)<br>
  {<br>
  &nbsp;&nbsp; offset=offset &lt;&lt; 8;<br>
  &nbsp;&nbsp; offset+=byte[i];<br>
  }<br>
  index=offset+listbase; <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Для многобайтовых данных
первый, извлекаемый из массива байт, становится старшим.</p>

<p class=text align=left style='text-align:left'>В качестве примера
использования нескольких списков отображения, рассмотрите фрагмент программы
7-4, взятый из полной программы-примера 7-5. Эта программа рисует символы
линейным шрифтом (набор букв был создан из сегментов линий). Функция <b>initStrokedFont()</b>
устанавливает индекс для каждого списка, чтобы индексы были равны значениям
ASCII-кодов соответствующих символов.</p>

<p class=text align=left style='text-align:left'>&nbsp;Пример 7-4. Определение
нескольких списков отображения</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void
  initStrokedFont(void)<br>
  {<br>
  &nbsp;&nbsp; GLuint base;<br>
  <br>
  &nbsp;&nbsp; base=glGenLists(128);<br>
  &nbsp;&nbsp; glListBase(base);<br>
  &nbsp;&nbsp; glNewList(base+’A’,GL_COMPILE);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; drawLetter(Adata);<br>
  &nbsp;&nbsp; glEndList();<br>
  <br>
  &nbsp;&nbsp; glNewList(base+’E’,GL_COMPILE);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; drawLetter(Edata);<br>
  &nbsp;&nbsp; glEndList();<br>
  <br>
  &nbsp;&nbsp; glNewList(base+’P’,GL_COMPILE);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; drawLetter(Pdata);<br>
  &nbsp;&nbsp; glEndList();<br>
  <br>
  &nbsp;&nbsp; glNewList(base+’R’,GL_COMPILE);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; drawLetter(Rdata);<br>
  &nbsp;&nbsp; glEndList();<br>
  <br>
  &nbsp;&nbsp; glNewList(base+’S’,GL_COMPILE);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; drawLetter(Sdata);<br>
  &nbsp;&nbsp; glEndList();<br>
  <br>
  &nbsp;&nbsp; //</span><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>Символ</span><span
  style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:"Courier New";
  color:black;mso-ansi-language:EN-US'> </span><span style='font-size:8.5pt;
  font-family:Courier;mso-bidi-font-family:"Courier New";color:black'>пробела</span><span
  lang=EN-US style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:
  "Courier New";color:black;mso-ansi-language:EN-US'><br>
  &nbsp;&nbsp; glNewList(base+’ ’,GL_COMPILE);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glTranslatef(8.0,0.0,0.0);<br>
  &nbsp;&nbsp; glEndList();<br>
  } <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Команда <b>glGenLists()</b>
выделяет 128 непрерывных индексов для списков отображения. Первый из этих
индексов становится базой списков. Для каждой буквы создается свой список;
индекс каждого списка представляет собой сумму базы и ASCII-кода символа. В
этом примере создается только несколько символов и символ пробела.</p>

<p class=text align=left style='text-align:left'>После создания списков, может
быть вызвана команда <b>glCallLists()</b> для их исполнения. Например, вы
можете передать текстовую строку функции <b>printStrokedString()</b>:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void
  printStrokedString(GLbyte *s)<br>
  {<br>
  &nbsp;&nbsp; GLint len=strlen(s);<br>
  &nbsp;&nbsp; glCallLists(len, GL_BYTE, s);<br>
  } <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Значение ASCII для каждого
символа в строке используется в качестве смещения в индексах списков
отображения. Для определения финального индекса исполняемых списков списочная
база складывается с ASCII-кодом каждого символа. Вывод, производимый примером
7-5, показан на рисунке 7-1.</p>

<p class=text align=left style='text-align:left'>Рисунок 7-1. Линейный шрифт с
символами A, E, P, R и S </p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1202" type="#_x0000_t75" alt="" style='width:309.75pt;height:58.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image165.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов7.mht!http://www.progz.ru/images/opengl/chapter7/7-1.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=413 height=78
src="OpenGL%20Red%20Book.files/image165.jpg" v:shapes="_x0000_i1202"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Пример 7-5. Несколько списков
отображения, определяющие линейный шрифт: файл stroke.cpp</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>#include &lt;glut.h&gt;<br>
  #include &lt;string.h&gt;<br>
  <br>
  #define PT 1<br>
  #define STROKE 2<br>
  #define END 3<br>
  <br>
  typedef struct charpoint<br>
  {<br>
  &nbsp;&nbsp; GLfloat x,y;<br>
  &nbsp;&nbsp; int type;<br>
  } CP;<br>
  <br>
  CP
  Adata[]={{0,0,PT},{0,9,PT},{1,10,PT},{4,10,PT},{5,9,PT},{5,0,STROKE},{0,5,PT},{5,5,END}};<br>
  CP Edata[]={{5,0,PT},{0,0,PT},{0,10,PT},{5,10,STROKE},{0,5,PT},{4,5,END}};<br>
  CP
  Pdata[]={{0,0,PT},{0,10,PT},{4,10,PT},{5,9,PT},{5,6,PT},{4,5,PT},{0,5,END}};<br>
  CP
  Rdata[]={{0,0,PT},{0,10,PT},{4,10,PT},{5,9,PT},{5,6,PT},{4,5,PT},{0,5,STROKE},{3,5,PT},
  {5,0,END}};<br>
  CP Sdata[]={{0,1,PT},{1,0,PT},{4,0,PT},{5,1,PT},{5,4,PT},{4,5,PT},{1,5,PT},{0,6,PT},{0,9,PT},{1,10,PT},{4,10,PT},{5,9,END}};<br>
  <br>
  //Интерпретируем инструкции из массива для буквы и <br>
  //визуализируем букву с помощью сегментов линий<br>
  void drawLetter(CP *l)<br>
  {<br>
  &nbsp;&nbsp; glBegin(GL_LINE_STRIP);<br>
  &nbsp;&nbsp; while(1)<br>
  &nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch(l-&gt;type)<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case PT:<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  glVertex2fv(&amp;l-&gt;x);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case STROKE:<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  glVertex2fv(&amp;l-&gt;x);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glEnd();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  glBegin(GL_LINE_STRIP);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case END:<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  glVertex2fv(&amp;l-&gt;x);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glEnd();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  glTranslatef(8.0,0.0,0.0);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l++;<br>
  &nbsp;&nbsp; }<br>
  }<br>
  <br>
  //Создаем список отображения для каждого из 6 символов (5 букв + пробел)<br>
  void init()<br>
  {<br>
  &nbsp;&nbsp; glLineWidth(2.0);<br>
  &nbsp;&nbsp; base=glGenLists(128);<br>
  &nbsp;&nbsp; glListBase(base);<br>
  &nbsp;&nbsp; glNewList(base+'A',GL_COMPILE); drawLetter(Adata); glEndList();<br>
  &nbsp;&nbsp; glNewList(base+'E',GL_COMPILE); drawLetter(Edata); glEndList();<br>
  &nbsp;&nbsp; glNewList(base+'P',GL_COMPILE); drawLetter(Pdata); glEndList();<br>
  &nbsp;&nbsp; glNewList(base+'R',GL_COMPILE); drawLetter(Rdata); glEndList();<br>
  &nbsp;&nbsp; glNewList(base+'S',GL_COMPILE); drawLetter(Sdata); glEndList();<br>
  &nbsp;&nbsp; glNewList(base+' ',GL_COMPILE); glTranslatef(8.0,0.0,0.0);
  glEndList();<br>
  }<br>
  <br>
  char *test1=&quot;A SPARE SERAPE APPEARS AS&quot;;<br>
  char *test2=&quot;APES PREPARE RARE PEPPERS&quot;;<br>
  <br>
  void printStrokedString(char *s)<br>
  {<br>
  &nbsp;&nbsp; GLsizei len=strlen(s);<br>
  &nbsp;&nbsp; glCallLists(len,GL_BYTE,(GLbyte *) s);<br>
  }<br>
  <br>
  void display()<br>
  {<br>
  &nbsp;&nbsp; glClear(GL_COLOR_BUFFER_BIT);<br>
  &nbsp;&nbsp; glColor3f(0.0,1.0,0.0);<br>
  &nbsp;&nbsp; glPushMatrix();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glScalef(2.0,2.0,2.0);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glTranslatef(10.0,30.0,0.0);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printStrokedString(test1);<br>
  &nbsp;&nbsp; glPopMatrix();<br>
  &nbsp;&nbsp; glPushMatrix();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glScalef(2.0,2.0,2.0);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glTranslatef(10.0,13.0,0.0);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printStrokedString(test2);<br>
  &nbsp;&nbsp; glPopMatrix();<br>
  &nbsp;&nbsp; glFlush();<br>
  }<br>
  <br>
  void reshape(int w,int h)<br>
  {<br>
  &nbsp;&nbsp; glViewport(0,0,w,h);<br>
  &nbsp;&nbsp; glMatrixMode(GL_PROJECTION);<br>
  &nbsp;&nbsp; glLoadIdentity();<br>
  &nbsp;&nbsp; gluOrtho2D(0.0,440,0.0,120);<br>
  }<br>
  <br>
  void keyboard(unsigned char key,int x,int y)<br>
  {<br>
  &nbsp;&nbsp; switch(key)<br>
  &nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case ' ':<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glutPostRedisplay();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 27:<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(0);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>
  &nbsp;&nbsp; }<br>
  }<br>
  <br>
  int main(int argc, char** argv)<br>
  {<br>
  &nbsp;&nbsp; glutInit(&amp;argc,argv);<br>
  &nbsp;&nbsp; glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);<br>
  &nbsp;&nbsp; glutInitWindowSize(440,120);<br>
  &nbsp;&nbsp; glutCreateWindow(&quot;Multiple Display Lists to Define a
  Stroked Font&quot;);<br>
  &nbsp;&nbsp; init();<br>
  &nbsp;&nbsp; glutDisplayFunc(display);<br>
  &nbsp;&nbsp; glutReshapeFunc(reshape);<br>
  &nbsp;&nbsp; glutKeyboardFunc(keyboard);<br>
  &nbsp;&nbsp; glutMainLoop();<br>
  &nbsp;&nbsp; return 0; <br>
  } <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<h2>7.6&nbsp; Управление переменными состояния с помощью списков отображения</h2>

<p class=text align=left style='text-align:left'>Список отображения может
содержать команды, изменяющие значения переменных состояния OpenGL. Величины
изменяются при исполнении списка отображения, как если бы команды выполнялись в
непосредственном режиме. Изменения сохраняются и после завершения исполнения
списка. Как было видно в примере 7-2 и будет показано в примере 7-6, изменения
текущего цвета и текущей матрицы, сделанные в процессе исполнения списка
отображения, остаются в действии и после того, как он был выполнен.</p>

<p class=text align=left style='text-align:left'>Пример 7-6. Постоянство
изменения состояния после исполнения списка отображения</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>glNewList(listIndex,
  GL_COMPILE);<br>
  &nbsp;&nbsp; glColor3f(1.0,0.0,0.0);<br>
  &nbsp;&nbsp; glBegin(GL_POLYGON);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glVertex2f(0.0,0.0);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glVertex2f(1.0,0.0);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glVertex2f(0.0,1.0);<br>
  &nbsp;&nbsp; glEnd();<br>
  &nbsp;&nbsp; glTranslatef(1.5,0.0,0.0);<br>
  glEndList(); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Таким образом, если вы
выполните следующую последовательность кода, линию, нарисованная после того,
как список отображения рисовал красным цветом и выполнил смещение на (1.5, 0.0,
0.0), будет красной:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>glCallList(listIndex);<br>
  glBegin(GL_LINES);<br>
  &nbsp;&nbsp; glVertex2f(2.0,-1.0);<br>
  &nbsp;&nbsp; glVertex2f(1.0,0.0);<br>
  glEnd(); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Иногда вам нужно, чтобы
изменения в состоянии сохранялись, но иногда вам необходимо сохранить значения
переменных до исполнения списка отображения и затем восстановить их после него.
Помните, что в списках вы не можете использовать команды <b>glGet*()</b>, так
что понадобится иной способ запроса и сохранения значений переменных состояния.</p>

<p class=text align=left style='text-align:left'>Вы можете использовать <b>glPushAttrib()</b>
для сохранения групп переменных состояния и <b>glPopAttrib()</b> для их
последующего восстановления. Чтобы сохранять и восстанавливать текущую матрицу,
используйте <b>glPushMatrix()</b> и <b>glPopMatrix()</b>. Эти команды могут
быть вполне законно кэшированы в списках отображения. Чтобы восстановить
переменные состояния в примере 7-6, можно использовать код примера 7-7.</p>

<p class=text align=left style='text-align:left'>Пример 7-7. Восстановление
переменных состояния внутри списка отображения</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>glNewList(listIndex,
  GL_COMPILE);<br>
  &nbsp;&nbsp; glPushMatrix();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glPushAttrib(GL_CURRENT_BIT);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glColor3f(1.0,0.0,0.0);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glBegin(GL_POLYGON);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glVertex2f(0.0,0.0);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glVertex2f(1.0,0.0);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glVertex2f(0.0,1.0);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glEnd();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glTranslatef(1.5,0.0,0.0);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glPopAttrib();<br>
  &nbsp;&nbsp; glPopMatrix();<br>
  glEndList(); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Если вы используете список
отображения из примера 7-7, код в примере 7-8 нарисует зеленую, неперенесенную
линию. При использовании списка отображения из примера 7-6 (которые не
сохраняет и не восстанавливает состояние), линия будет нарисована красным
сдвинутой 10 раз на (1.5, 0.0, 0.0).</p>

<p class=text align=left style='text-align:left'>Пример 7-8. Список отображение
может влиять или не влиять на drawLine()</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void display(void)<br>
  {<br>
  &nbsp;&nbsp; GLint i;<br>
  &nbsp;&nbsp; glClear(GL_COLOR_BUFFER_BIT);<br>
  &nbsp;&nbsp; glColor3f(0.0,1.0,0.0);&nbsp;&nbsp; //устанавливаем текущий цвет
  в зеленый<br>
  &nbsp;&nbsp; for(i=0;i&lt;10;i++)<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glCallList(listIndex); //список исполняется 10
  раз<br>
  &nbsp;&nbsp; drawLine();<br>
  &nbsp;&nbsp; glFlush();<br>
  } <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<h2>7.6.1&nbsp; Инкапсуляция изменений режима</h2>

<p class=text align=left style='text-align:left'>Вы можете использовать списки
отображения для организации и сохранения групп команд, изменяющих различные
режимы и устанавливающих различные параметры. Когда вы хотите переключиться от
одной группы установок к другой, использование списков отображения может быть эффективнее
непосредственных вызовов команд, так как команды в списке могут быть кэшированы
в формате, более подходящим для вашей графической системы.</p>

<p class=text align=left style='text-align:left'>Списки могут быть эффективнее,
чем команды непосредственного режима, при переключении различных условий освещения,
моделей освещения и свойств материала. Вы также можете использовать списки для
рисунков шаблонов, параметров тумана и уравнений отсекающих плоскостей. В
общем, исполнение списков отображения, как минимум, не медленнее, чем вызовы
команд в непосредственном режиме, однако помните, что с исполнением списков
также связаны некоторые временные затраты.</p>

<p class=text align=left style='text-align:left'>Пример 7-9 показывает, как
использовать списки отображения для переключения между тремя различными
шаблонами линий. Сначала вызывается <b>glGenLists()</b>, чтобы выделить индекс
для списка каждого рисунка шаблона, и создаются сами списки. Затем для
переключения между разными рисунками шаблона используется <b>glCallList()</b>.</p>

<p class=text align=left style='text-align:left'>Пример 7-9. Списки
отображения, используемые для смены режимов</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>GLuint
  offset;<br>
  <br>
  offset=glGenLists(3);<br>
  glNewList(offset,GL_COMPILE);<br>
  &nbsp;&nbsp; glDisable(GL_LINE_STIPPLE);<br>
  glEndList();<br>
  <br>
  glNewList(offset+1,GL_COMPILE);<br>
  &nbsp;&nbsp; glEnable(GL_LINE_STIPPLE);<br>
  &nbsp;&nbsp; glLineStipple(1,0x0F0F);<br>
  glEndList();<br>
  <br>
  glNewList(offset+2,GL_COMPILE);<br>
  &nbsp;&nbsp; glEnable(GL_LINE_STIPPLE);<br>
  &nbsp;&nbsp; glLineStipple(1,0x1111);<br>
  glEndList();<br>
  <br>
  #define drawOneLine(x1, y1, x2, y2) glBegin(GL_LINES); glVertex2f((x1),(y1));
  glVertex2f((x2),(y2)); glEnd();<br>
  <br>
  glCallList(offset);<br>
  drawOneLine(50.0,125.0,350.0,125.0);<br>
  glCallList(offset+1);<br>
  drawOneLine(50.0,100.0,350.0,100.0);<br>
  glCallList(offset+2);<br>
  drawOneLine(50.0,75.0,350.0,75.0); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:Verdana;
mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><a name=Глава8><span style='display:none;mso-hide:all'><o:p>&nbsp;</o:p></span></a></p>

<h1 align=left style='text-align:left'><span style='mso-bookmark:Глава8'>Глава
8. Отображение пикселей, битовых карт, шрифтов и изображений</span></h1>

<span style='mso-bookmark:Глава8'></span>

<p class=MsoNormal><a href="mailto:ahinar@list.ru"></a><span style='font-size:
10.0pt;font-family:Verdana'>До сих пор большинство дискуссий в данном пособии
касалось визуализации и отображения геометрических данных – точек, линий и
полигонов. Два других важных типов данных, которые могут отображаться OpenGL
это:<o:p></o:p></span></p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l0 level1 lfo24;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Битовые карты, обычно используемые для символов
шрифта </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l0 level1 lfo24;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Изображения, которые могут быть отсканированы
или построены путем вычислений. </p>

<p class=text align=left style='text-align:left'>И битовые карты и изображения
имеют форму прямоугольных массивов пикселей. Одно из различий, существующее
между ними, заключается в том, что битовая карта хранит по одному биту на
каждый, входящий в нее пиксель, а в изображении на каждый пиксель хранится, как
правило, несколько элементов данных (например, полные значения красного,
зеленого, синего и альфа компонентов цвета). Кроме того, битовые карты работают
как маски, если перекрывают изображение, а данные изображения просто
перезаписывают информацию в буфере кадра или накладываются на нее.</p>

<p class=text align=left style='text-align:left'>В этой главе описывается, как
рисовать пиксельные данные (битовые карты и изображения) из памяти в буфер
кадра и как считывать из буфера кадра обратно. Также описывается, как
копировать пиксельные данные из одной позиции в другие, то есть из одного
буфера в другой, или из буфера в него же. </p>

<p class=warning>Замечание: OpenGL не поддерживает ни считывание пикселей из
графических файлов, ни сохранение пикселей в них.</p>

<h2>8.1&nbsp; Битовые карты и шрифты</h2>

<p class=text align=left style='text-align:left'>Битовая карта – это
прямоугольный массив из нулей и единиц, который служит в качестве маски для
прямоугольной части окна. Предположим, что вы рисуете битовую карту и текущий
цвет – красный. Везде, где в битовой карте встречается 1, соответствующий
пиксель в буфере кадра замещается красным (или комбинируется с красным в
зависимости от того, какие пофрагментные операции производятся). Там, где в
битовой карте стоит 0, фрагменты не генерируются и пиксели не изменяются.
Битовые карты наиболее часто используются для рисования символов на экране.</p>

<p class=text align=left style='text-align:left'>OpenGL предоставляет только
низкоуровневую поддержку для рисования строк символов и манипуляций со
шрифтами. Команды <b>glRasterPos*()</b> и <b>glBitmap()</b> позиционируют и
рисуют на экране одну битовую карту. Кроме того, с помощью механизма списков
отображения вы можете использовать последовательности кодов символов для
индексации соответствующих серий битовых карт, представляющих эти символы. Если
для ваших манипуляций с битовыми картами, шрифтами и символами требуется иная
поддержка, вам необходимо написать собственные функции.</p>

<p class=text align=left style='text-align:left'>Рассмотрим пример 8-1, который
трижды рисует на экране символ F. На рисунке 8-1 символ F показан в виде
битовой карты и соответствующих ей данных.</p>

<p class=text align=left style='text-align:left'>Рисунок 8-1. Битовая карта
символа F и ее данные </p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1203" type="#_x0000_t75" alt="" style='width:465pt;height:262.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image166.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/8-1.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=620 height=350
src="OpenGL%20Red%20Book.files/image166.jpg" v:shapes="_x0000_i1203"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Пример 8-1. Рисование битовой
карты символа: файл drawf.cpp</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>#include &lt;glut.h&gt;<br>
  <br>
  GLubyte rasters[24]= { 0xC0,0x00,0xC0,0x00,0xC0,0x00,0xC0,0x00,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  0xC0,0x00,0xFF,0x00,0xFF,0x00,0xC0,0x00,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  0xC0,0x00,0xC0,0x00,0xFF,0xC0,0xFF,0xC0 };<br>
  <br>
  void init(void)<br>
  {<br>
  &nbsp;&nbsp; glPixelStorei(GL_UNPACK_ALIGNMENT,1);<br>
  &nbsp;&nbsp; glClearColor(0.0,0.0,0.0,0.0);<br>
  }<br>
  <br>
  void display(void)<br>
  {<br>
  &nbsp;&nbsp; glClear(GL_COLOR_BUFFER_BIT);<br>
  &nbsp;&nbsp; glColor3f(1.0,1.0,1.0);<br>
  &nbsp;&nbsp; glRasterPos2i(20,20);<br>
  &nbsp;&nbsp; glBitmap(10,12,0.0,0.0,11.0,0.0,rasters);<br>
  &nbsp;&nbsp; glBitmap(10,12,0.0,0.0,11.0,0.0,rasters);<br>
  &nbsp;&nbsp; glBitmap(10,12,0.0,0.0,11.0,0.0,rasters);<br>
  &nbsp;&nbsp; glFlush();<br>
  }<br>
  <br>
  void reshape(int w, int h)<br>
  {<br>
  &nbsp;&nbsp; glViewport(0,0,(GLsizei) w, (GLsizei) h);<br>
  &nbsp;&nbsp; glMatrixMode(GL_PROJECTION);<br>
  &nbsp;&nbsp; glLoadIdentity();<br>
  &nbsp;&nbsp; glOrtho(0,w,0,h,-1.0,1.0);<br>
  &nbsp;&nbsp; glMatrixMode(GL_MODELVIEW);<br>
  }<br>
  <br>
  void keyboard(unsigned char key,int x,int y)<br>
  {<br>
  &nbsp;&nbsp; switch(key)<br>
  &nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 27:<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(0);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>
  &nbsp;&nbsp; }<br>
  }<br>
  <br>
  int main(int argc, char **argv)<br>
  {<br>
  &nbsp;&nbsp; glutInit(&amp;argc,argv);<br>
  &nbsp;&nbsp; glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);<br>
  &nbsp;&nbsp; glutInitWindowSize(300,100);<br>
  &nbsp;&nbsp; glutCreateWindow(&quot;Drawing a Bitmapped Character&quot;);<br>
  &nbsp;&nbsp; init();<br>
  &nbsp;&nbsp; glutDisplayFunc(display);<br>
  &nbsp;&nbsp; glutReshapeFunc(reshape);<br>
  &nbsp;&nbsp; glutKeyboardFunc(keyboard);<br>
  &nbsp;&nbsp; glutMainLoop();<br>
  &nbsp;&nbsp; return 0; <br>
  } <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>На рисунке 8-1 обратите
внимание, что видимая часть символа Fзанимает 10 бит в ширину. Битовые карты
всегда хранятся кусками, ширина которых кратна 8, но реальная ширина битовой
карты не обязана быть кратной 8. Биты, задающие битовую карту, выводятся,
начиная с левого нижнего угла: сначала рисуется нижний ряд, затем ряд над ним и
так далее. Как вы можете видеть в коде, битовая карта хранится в памяти именно
в этом порядке – массив начинается с чисел 0xc0, 0x00, 0xc0, 0x00, задающих два
нижних ряда символа F и заканчивается числами 0xff, 0xc0, 0xff, 0xc0, задающими
два верхних ряда.</p>

<p class=text align=left style='text-align:left'>В приведенном примере особый
интерес представляют команды <b>glRasterPos2i()</b> и <b>glBitmap()</b>; они подробно
рассматриваются в следующих разделах. Пока мы проигнорируем команду <b>glPixelStorei()</b>;
она указывает на то, как данные битовой карты хранятся в памяти компьютера.</p>

<h2>8.1.1&nbsp; Текущая позиция растра</h2>

<p class=text align=left style='text-align:left'>Текущая позиция растра – это
некоторое положение на экране, где будет нарисована следующая битовая карта
(или изображение). В примере с символом F текущая позиция растра была
установлена командой <b>glRasterPos*()</b> с координатами (20, 20) в качестве
параметров. Это то место, где был помещен нижний левый угол символа F:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>glRasterPos2i(20, 20); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Verdana;
color:black;display:none;mso-hide:all'><o:p>&nbsp;</o:p></span></p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glRasterPos</b>[234]{sifd}
  (TYPE <i>x</i>, TYPE <i>y</i>, TYPE <i>z</i>, TYPE <i>w</i>);<br>
  void <b>glRasterPos</b>[234]{sifd}<b>v</b> (TYPE *<i>coords</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Устанавливает текущую позицию
растра. Аргументы <i>x</i>, <i>y</i>, <i>z </i>и <i>w</i>&nbsp;задают
координаты позиции растра. Если используется векторная форма функции, массив <i>coords
</i>содержит координаты позиции растра. Если используется версия <b>glRasterPos2*()</b>,
то <i>z</i>принимается равным 0, а <i>w</i>– 1; похожим же образом, если
используется <b>glRasterPos3*()</b>, то <i>w </i>принимается равным 1.</p>

<p class=text align=left style='text-align:left'>Координаты позиции растра преобразуются
в экранные координаты точно таким же образом, как и координаты, заданные
командой <b>glVertex*()</b> (то есть они преобразуются с помощью видовой и
проекционной матриц). После всех преобразований, текущие координаты растра либо
определяют некоторую видимую на экране точку, либо отсекаются, если находятся
вне объема видимости. Если преобразованная точка отсечена, текущая позиция
растра считается незаконной.</p>

<p class=warning>Замечание: Если вы хотите задать позицию растра в экранных
координатах, вам следует убедиться в том, что вы задали видовую и проекционную
матрицу для простого 2D отображения. Для этого подойдет последовательность
команд вроде следующей (<i>width</i> и <i>height</i> представляют собой размеры
порта просмотра):</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>glMatrixMode(GL_PROJECTION);<br>
  glLoadIdentity();<br>
  gluOrtho2D(0.0, (GLfloat) width, 0.0, (GLfloat) height);<br>
  glMatrixMode(GL_MODELVIEW);<br>
  glLoadIdentity(); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Чтобы получить текущую позицию
растра, вы можете использовать команду <b>glGetFloatv()</b> с
GL_CURRENT_RASTER_POSITION в качестве первого аргумента. Второй аргумент должен
быть указателем на массив, способный сохранить четверку (<i>x</i>, <i>y</i>, <i>z</i>,
<i>w</i>) в виде чисел с плавающей точкой. Если вы хотите выяснить, является ли
текущая позиция растра легальной (допустимой), вызывайте <b>glGetBooleanv()</b>
с константой GL_CURRENT_RASTER_POSITION_VALID в качестве первого аргумента.</p>

<h2>8.1.2&nbsp; Отображение битовой карты</h2>

<p class=text align=left style='text-align:left'>Как только вы установили
желаемую позицию растра, вы можете использовать команду <b>glBitmap()</b>,
чтобы вывести данные.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=prototype><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glBitmap</b>
  (GLsizei <i>width</i>,GLsizei <i>height</i>,GLfloat </span><span
  style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:"Courier New";
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1204" type="#_x0000_t75"
   alt="" style='width:22.5pt;height:12.75pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image167.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form1b.JPG"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=30 height=17
  src="OpenGL%20Red%20Book.files/image167.jpg" v:shapes="_x0000_i1204"><![endif]></span><span
  lang=EN-US style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:
  "Courier New";color:black;mso-ansi-language:EN-US'>,GLfloat </span><span
  style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:"Courier New";
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1205" type="#_x0000_t75"
   alt="" style='width:20.25pt;height:12.75pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image168.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form2b.JPG"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=27 height=17
  src="OpenGL%20Red%20Book.files/image168.jpg" v:shapes="_x0000_i1205"><![endif]></span><span
  lang=EN-US style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:
  "Courier New";color:black;mso-ansi-language:EN-US'>,GLfloat </span><span
  style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:"Courier New";
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1206" type="#_x0000_t75"
   alt="" style='width:18.75pt;height:13.5pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image169.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form3b.JPG"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=25 height=18
  src="OpenGL%20Red%20Book.files/image169.jpg" v:shapes="_x0000_i1206"><![endif]></span><span
  lang=EN-US style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:
  "Courier New";color:black;mso-ansi-language:EN-US'>,GLfloat </span><span
  style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:"Courier New";
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1207" type="#_x0000_t75"
   alt="" style='width:16.5pt;height:13.5pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image170.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form4b.JPG"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=22 height=18
  src="OpenGL%20Red%20Book.files/image170.jpg" v:shapes="_x0000_i1207"><![endif]></span><span
  lang=EN-US style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:
  "Courier New";color:black;mso-ansi-language:EN-US'>,GLubyte *<i>bitmap</i>); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Рисует битовую карту, заданную
аргументом <i>bitmap</i>, который представляет собой указатель на данные карты.
Начальная точка битовой карты помещается в текущую позицию растра. Если текущая
позиция растра недопустима, ничего не рисуется, а позиция растра остается
недопустимой. Аргументы <i>width </i>и <i>height</i> индицируют ширину и высоту
битовой карты в пикселях. Ширина должна быть кратной 8-ми, поскольку данные
хранятся в беззнаковых символах по 8 бит каждый. (В примере с символом F не
имеет значения, присутствует ли в данных за границами реальной карты какой-либо
мусор, поскольку <b>glBitmap()</b> вызывается с аргументом <i>width</i> равным
10 и, как следствие, визуализируются только 10 бит в ряду.) Используйте <!--[if gte vml 1]><v:shape
 id="_x0000_i1208" type="#_x0000_t75" alt="" style='width:21pt;height:12.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image171.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form1.JPG"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=28 height=17
src="OpenGL%20Red%20Book.files/image171.jpg" v:shapes="_x0000_i1208"><![endif]>&nbsp;и
<!--[if gte vml 1]><v:shape id="_x0000_i1209" type="#_x0000_t75" alt=""
 style='width:21pt;height:12.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image172.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form2.JPG"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=28 height=17
src="OpenGL%20Red%20Book.files/image172.jpg" v:shapes="_x0000_i1209"><![endif]>,
чтобы задать начальную точку битовой карты, которая будет помещена в текущую
позицию растра (положительные величины сдвигают начальную точку вверх и вправо
от текущей позиции растра, отрицательные вниз и влево). Аргументы <!--[if gte vml 1]><v:shape
 id="_x0000_i1210" type="#_x0000_t75" alt="" style='width:17.25pt;height:15pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image173.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form3.JPG"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=23 height=20
src="OpenGL%20Red%20Book.files/image173.jpg" v:shapes="_x0000_i1210"><![endif]>&nbsp;и
<!--[if gte vml 1]><v:shape id="_x0000_i1211" type="#_x0000_t75" alt=""
 style='width:18pt;height:13.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image174.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form4.JPG"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=24 height=18
src="OpenGL%20Red%20Book.files/image174.jpg" v:shapes="_x0000_i1211"><![endif]>&nbsp;задают
смещение по <i>x</i> и <i>y</i>, которое добавляется к текущей позиции растра
после растеризации битовой карты (рисунок 8-2).</p>

<p class=text align=left style='text-align:left'>Рисунок 8-2. Битовая карта и
ассоциированные с ней параметры </p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1212" type="#_x0000_t75" alt="" style='width:465pt;height:218.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image175.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/8-2.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=620 height=291
src="OpenGL%20Red%20Book.files/image175.jpg" v:shapes="_x0000_i1212"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Свободное размещение начальной
точки карты позволяет символам спускаться ниже начальной точки (обычно для
символов, частично располагающихся ниже основной линии текста, например, g,
jили y) или левее ее (например, для шрифтов, скошенных влево, и специальных
символов).</p>

<p class=text align=left style='text-align:left'>После того, как битовая карта
нарисована, текущая позиция растра сдвигается на <!--[if gte vml 1]><v:shape
 id="_x0000_i1213" type="#_x0000_t75" alt="" style='width:17.25pt;height:15pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image173.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form3.JPG"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=23 height=20
src="OpenGL%20Red%20Book.files/image173.jpg" v:shapes="_x0000_i1213"><![endif]>&nbsp;и
<!--[if gte vml 1]><v:shape id="_x0000_i1214" type="#_x0000_t75" alt=""
 style='width:18pt;height:13.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image174.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form4.JPG"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=24 height=18
src="OpenGL%20Red%20Book.files/image174.jpg" v:shapes="_x0000_i1214"><![endif]>&nbsp;по
<i>x</i> и &nbsp;<i>y</i> осям соответственно. (Если вы просто хотите сдвинуть
позицию растра, ничего не рисуя, вызовите команду <b>glBitmap()</b> с
аргументом <i>bitmap </i>установленным в NULL и параметрами <i>width </i>и <i>height
</i>равными 0.) &nbsp;Для стандартных латинских шрифтов <!--[if gte vml 1]><v:shape
 id="_x0000_i1215" type="#_x0000_t75" alt="" style='width:18pt;height:13.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image174.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form4.JPG"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=24 height=18
src="OpenGL%20Red%20Book.files/image174.jpg" v:shapes="_x0000_i1215"><![endif]>&nbsp;обычно
равно 0, а <!--[if gte vml 1]><v:shape id="_x0000_i1216" type="#_x0000_t75"
 alt="" style='width:17.25pt;height:15pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image173.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form3.JPG"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=23 height=20
src="OpenGL%20Red%20Book.files/image173.jpg" v:shapes="_x0000_i1216"><![endif]>&nbsp;--
положительное число, так как последующие символы рисуются слева направо. Для
Иврита, символы которого пишутся справа налево, <!--[if gte vml 1]><v:shape
 id="_x0000_i1217" type="#_x0000_t75" alt="" style='width:17.25pt;height:15pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image173.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form3.JPG"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=23 height=20
src="OpenGL%20Red%20Book.files/image173.jpg" v:shapes="_x0000_i1217"><![endif]>&nbsp;обычно
должно быть отрицательным числом. Для шрифта, символы которого выводятся
вертикально в столбик, нужно использовать <!--[if gte vml 1]><v:shape id="_x0000_i1218"
 type="#_x0000_t75" alt="" style='width:17.25pt;height:15pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image173.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form3.JPG"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=23 height=20
src="OpenGL%20Red%20Book.files/image173.jpg" v:shapes="_x0000_i1218"><![endif]>&nbsp;равное
0, а <!--[if gte vml 1]><v:shape id="_x0000_i1219" type="#_x0000_t75" alt=""
 style='width:18pt;height:13.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image174.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form4.JPG"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=24 height=18
src="OpenGL%20Red%20Book.files/image174.jpg" v:shapes="_x0000_i1219"><![endif]>&nbsp;отличное
от 0. На рисунке 8-2, каждый раз при рисовании F текущая позиция растра
сдвигается на 11 пикселей, оставляя между соседними символами пространство в 1
пиксель.</p>

<p class=text align=left style='text-align:left'>Поскольку <!--[if gte vml 1]><v:shape
 id="_x0000_i1220" type="#_x0000_t75" alt="" style='width:21pt;height:12.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image171.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form1.JPG"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=28 height=17
src="OpenGL%20Red%20Book.files/image171.jpg" v:shapes="_x0000_i1220"><![endif]>,
<!--[if gte vml 1]><v:shape id="_x0000_i1221" type="#_x0000_t75" alt=""
 style='width:21pt;height:12.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image172.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form2.JPG"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=28 height=17
src="OpenGL%20Red%20Book.files/image172.jpg" v:shapes="_x0000_i1221"><![endif]>,
<!--[if gte vml 1]><v:shape id="_x0000_i1222" type="#_x0000_t75" alt=""
 style='width:17.25pt;height:15pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image173.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form3.JPG"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=23 height=20
src="OpenGL%20Red%20Book.files/image173.jpg" v:shapes="_x0000_i1222"><![endif]>&nbsp;и
<!--[if gte vml 1]><v:shape id="_x0000_i1223" type="#_x0000_t75" alt=""
 style='width:18pt;height:13.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image174.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form4.JPG"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=24 height=18
src="OpenGL%20Red%20Book.files/image174.jpg" v:shapes="_x0000_i1223"><![endif]>&nbsp;представляют
собой числа с плавающей точкой, символы не должны занимать целое число
пикселей. Реальные символы рисуются четко по пиксельным границам, однако
текущая позиция растра хранится в виде дробного числа, благодаря чему каждый
символ рисуется максимально близко к тому месту, где он должен находиться.
Например, если в примере с символом F сделать <!--[if gte vml 1]><v:shape id="_x0000_i1224"
 type="#_x0000_t75" alt="" style='width:17.25pt;height:15pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image173.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form3.JPG"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=23 height=20
src="OpenGL%20Red%20Book.files/image173.jpg" v:shapes="_x0000_i1224"><![endif]>&nbsp;равным
11.5 вместо 12, и нарисовать больше символов, пространство между буквами было
бы то 1, то 2 пикселя, давая наилучшее к запрошенному пространству в 1.5
пикселя.</p>

<p class=warning>Замечание: Вы не можете поворачивать шрифты, созданные в виде
битовых карт, поскольку битовые карты всегда рисуются выровненными по осям x и
y буфера кадра. Кроме того, битовые карты нельзя масштабировать.</p>

<h2>8.1.3&nbsp; Выбор цвета для битовой карты</h2>

<p class=text align=left style='text-align:left'>Вы уже знакомы с
использованием команд <b>glColor*()</b> и <b>glIndex*()</b>, устанавливающих
текущий цвет и текущий индекса для рисования геометрических примитивов. Те же
самые команды используются для установки других переменных состояния:
GL_CURRENT_RASTER_COLOR и GL_CURRENT_RASTER_INDEX, для рисования битовых карт.
Переменная состояния, отвечающая за цвет растра устанавливается равной текущему
цвету в момент вызова <b>glRasterPos*()</b>. Это может сыграть злую шутку. Как
вы думаете, каков будет цвет битовой карты после выполнения следующего кода?</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>glColor3f(1.0,1.0,1.0);&nbsp;&nbsp;
  /*</span><span style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:
  "Courier New";color:black'>белый</span><span lang=EN-US style='font-size:
  8.5pt;font-family:Courier;mso-bidi-font-family:"Courier New";color:black;
  mso-ansi-language:EN-US'>*/<br>
  glRasterPos3fv(position);<br>
  glColor3f(1.0,0.0,0.0);&nbsp;&nbsp; /*</span><span style='font-size:8.5pt;
  font-family:Courier;mso-bidi-font-family:"Courier New";color:black'>красный</span><span
  lang=EN-US style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:
  "Courier New";color:black;mso-ansi-language:EN-US'>*/<br>
  glBitmap(...); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Вы удивлены, что битовая карта
будет белой? Переменная GL_CURRENT_RASTER_COLOR устанавливается в белый цвет в
момент вызова <b>glRasterPos3fv()</b>. Второй вызов <b>glColor3f()</b> меняет
значение переменной GL_CURRENT_COLOR для визуализации будущих геометрических
примитивов, но цвет, используемый для визуализации битовых карт, остается
неизменным.</p>

<p class=text align=left style='text-align:left'>Чтобы выяснить текущий цвет
или индекс растра, вы можете использовать опросные команды <b>glGetFloatv()</b>
или <b>glGetIntegerv()</b> с аргументами GL_CURRENT_RASTER_COLOR или
GL_CURRENT_RASTER_INDEX в качестве первого аргумента.</p>

<h2>8.1.4&nbsp; Шрифты и списки отображения</h2>

<p class=text align=left style='text-align:left'>Списки отображения обсуждались
ранее. Однако, некоторые из команд управления списками имеют особое отношение к
выводу строк символов. Во время чтения данного раздела имейте в виду, что идеи,
представленные здесь, в равной степени применимы и к символам, рисуемым с
помощью битовых карт, и к символам, сконструированным из геометрических
примитивов (точек, линий и полигонов).</p>

<p class=text align=left style='text-align:left'>Шрифт обычно состоит из набора
символов, где каждый символ имеет идентификационный номер (как правило, свой
ASCII код) и метод начертания. В стандартном наборе символов ASCII заглавная
буква A (в латинице) имеет номер 65, B – 66 и так далее. Строка «DAB» может
быть представлена тремя индексами 68, 65 и 66. В простейшем случае список
отображения номер 65 рисует A, номер 66 – B и так далее. То есть для того,
чтобы вывести строку из символов 68, 65, 66 просто вызовите к исполнению
соответствующие списки отображения.</p>

<p class=text align=left style='text-align:left'>Вы можете использовать команду
<b>glCallLists()</b> следующим образом:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glCallLists</b>(GLsizei
  <i>n</i>, GLenum <i>type</i>, const GLvoid *<i>lists</i>); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Первый аргумент, <i>n</i>,
индицирует количество выводимых символов, <i>type </i>обычно равен GL_BYTE, а <i>lists</i>–
это массив кодов символов.</p>

<p class=text align=left style='text-align:left'>Поскольку многим приложениям
требуется отображать символы разных размеров и из разных шрифтов, простейший
случай нас не устраивает. Было бы неплохо использовать 65 для символа
Aнезависимо от того, какой шрифт является активным на данный момент. Вы могли
бы в шрифте 1 закодировать A, B и Cномерами 1065, 1066 и 1067, а в шрифте 2 –
номерами 2065, 2066 и 2067, но тогда любые номера больше 256 уже не будут
укладываться в 8-ми битовый байт. Лучшее решение заключается в том, чтобы
добавлять некоторое смещение к каждому вхождению в строку до того, как
производится выбор списка отображения. В этом случае символы A, B и C будут
представлены номерами 1065, 1066 и 1067 в шрифте 1, а в шрифте 2 они могут быть
представлены числами 2065, 2066 и 2067. Тогда, чтобы нарисовать символы шрифтом
1, нужно установить смещение равным 1000 и вызвать к исполнению списки
отображения 65, 66 и 67. Чтобы нарисовать ту же строку шрифтом 2, нужно
установить смещение равным 2000 и вызвать к исполнению те же списки.</p>

<p class=text align=left style='text-align:left'>Для того, чтобы установить
смещение, используйте команду <b>glListBase()</b>. Для предыдущих примеров она
должна быть вызвана с 1000 и 2000 в качестве единственного аргумента. Теперь
все, что вам нужно – это непрерывный диапазон неиспользуемых индексов списков
отображения, который может быть получен с помощью команды <b>glGenLists()</b>:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>GLuint <b>glGenLists</b>
  (GLsizei <i>range</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Эта функция возвращает блок,
состоящий из <i>range </i>идентификаторов списков отображения. Возвращенные
списки маркируются как «используемые» даже несмотря на то, что они пусты, так
что последующие вызовы <b>glGenLists()</b> никогда не возвращают те же номера
списков (если только вы не удалили их перед этим). Таким образом, если вы
используете 4 в качестве аргумента и <b>glGenLists()</b> возвращает 81, вы
можете использовать идентификаторы списков отображения 81, 82, 83 и 84 для
ваших символов. Если <b>glGenLists()</b> не может найти блок свободных индексов
нужного размера, она возвращает 0. (Заметьте, что команда <b>glDeleteLists()</b>
позволяет удалить все списки отображения, связанные со шрифтом, за один вызов.)</p>

<p class=text align=left style='text-align:left'>Большинство американских и
европейских шрифтов включают небольшое число символов (менее 256), так что
довольно легко представить каждый символ уникальным кодом, который может быть
сохранен в одном байте. Азиатские шрифты (и некоторые другие) могут содержать
намного большие наборы символов, и однобайтовой кодировки может быть
недостаточно. OpenGL позволяет обрабатывать строки, состоящие из 1-, 2-, 3- и
4-ех байтовых символов с помощью параметра <i>type </i>команды <b>glCallLists()</b>.
Этот параметр может иметь любое из следующих значений:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_BYTE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_UNSIGNED_BYTE<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_SHORT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_UNSIGNED_SHORT<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_INT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_UNSIGNED_INT<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FLOAT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_2_BYTES<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_3_BYTES<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_4_BYTES<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<h2>8.1.5&nbsp; Описание и использование целого шрифта</h2>

<p class=text align=left style='text-align:left'>Команда <b>glBitmap()</b> и
механизм списков отображений, описанный в предыдущем разделе, позволяет легко
определить растровый шрифт. В примере 8-2 задаются символы верхнего регистра
ASCIIшрифта. В этом примере все символы имеют одинаковую длину, но в общем
случае это не всегда так. Как только шрифт определен, программа выводит
сообщение «THEQUICKBROWNFOXJUMPSOVERALAZYDOG.» (рисунок 8-3).</p>

<p class=text align=left style='text-align:left'>Код примера 8-2 похож на
пример с символом F за исключением того, что здесь битовая карта каждого
символа сохраняется в своем собственном списке отображения. Комбинирование идентификатора
списка со смещением, возвращенным командой <b>glGenLists()</b> равно ASCII коду
символа.</p>

<p class=text align=left style='text-align:left'>Рисунок 8-3. Фраза, написанная
растровым шрифтом</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1225" type="#_x0000_t75" alt="" style='width:208.5pt;height:48pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image176.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/8-3.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=278 height=64
src="OpenGL%20Red%20Book.files/image176.jpg" v:shapes="_x0000_i1225"><![endif]></p>

<p class=text align=left style='text-align:left'>Пример 8-2. Отображение
полного шрифта: файл font.cpp</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>#include &lt;glut.h&gt;<br>
  #include &lt;string.h&gt;<br>
  <br>
  GLubyte space[]=
  {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};<br>
  GLubyte letters[][13]={ <br>
  {0x00,0x00,0xc3,0xc3,0xc3,0xc3,0xff,0xc3,0xc3,0xc3,0x66,0x3c,0x18},<br>
  {0x00,0x00,0xfe,0xc7,0xc3,0xc3,0xc7,0xfe,0xc7,0xc3,0xc3,0xc7,0xfe}, <br>
  {0x00,0x00,0x7e,0x7e,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xe7,0x7e},<br>
  {0x00,0x00,0xfc,0xce,0xc7,0xc3,0xc3,0xc3,0xc3,0xc3,0xc7,0xce,0xfc},<br>
  {0x00,0x00,0xff,0xc0,0xc0,0xc0,0xc0,0xfc,0xc0,0xc0,0xc0,0xc0,0xff},<br>
  {0x00,0x00,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xfc,0xc0,0xc0,0xc0,0xff},<br>
  {0x00,0x00,0x7e,0x7e,0xc3,0xc3,0xcf,0xc0,0xc0,0xc0,0xc0,0xe7,0x7e},<br>
  {0x00,0x00,0xc3,0xc3,0xc3,0xc3,0xc3,0xff,0xc3,0xc3,0xc3,0xc3,0xc3},<br>
  {0x00,0x00,0x7e,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x7e},<br>
  {0x00,0x00,0x7c,0xee,0xc6,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06},<br>
  {0x00,0x00,0xc3,0xc6,0xcc,0xd8,0xf0,0xe0,0xf0,0xd8,0xcc,0xc6,0xc3},<br>
  {0x00,0x00,0xff,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0},<br>
  {0x00,0x00,0xc3,0xc3,0xc3,0xc3,0xc3,0xc3,0xdb,0xff,0xff,0xe7,0xc3},<br>
  {0x00,0x00,0xc7,0xc7,0xcf,0xcf,0xdf,0xdb,0xfb,0xf3,0xf3,0xe3,0xe3},<br>
  {0x00,0x00,0x7e,0xe7,0xc3,0xc3,0xc3,0xc3,0xc3,0xc3,0xc3,0xe7,0x7e},<br>
  {0x00,0x00,0xc0,0xc0,0xc0,0xc0,0xc0,0xfe,0xc7,0xc3,0xc3,0xc7,0xfe},<br>
  {0x00,0x00,0x3f,0x6e,0xdf,0xdb,0xc3,0xc3,0xc3,0xc3,0xc3,0x66,0x3c},<br>
  {0x00,0x00,0xc3,0xc6,0xcc,0xd8,0xf0,0xfe,0xc7,0xc3,0xc3,0xc7,0xfe},<br>
  {0x00,0x00,0x7e,0xe7,0x03,0x03,0x07,0x7e,0xe0,0xc0,0xc0,0xe7,0x7e},<br>
  {0x00,0x00,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0xff},<br>
  {0x00,0x00,0x7e,0xe7,0xc3,0xc3,0xc3,0xc3,0xc3,0xc3,0xc3,0xc3,0xc3},<br>
  {0x00,0x00,0x18,0x3c,0x3c,0x66,0x66,0xc3,0xc3,0xc3,0xc3,0xc3,0xc3},<br>
  {0x00,0x00,0xc3,0xe7,0xff,0xff,0xdb,0xdb,0xc3,0xc3,0xc3,0xc3,0xc3},<br>
  {0x00,0x00,0xc3,0x66,0x66,0x3c,0x3c,0x18,0x3c,0x3c,0x66,0x66,0xc3},<br>
  {0x00,0x00,0x18,0x18,0x18,0x18,0x18,0x18,0x3c,0x3c,0x66,0x66,0xc3},<br>
  {0x00,0x00,0xff,0xc0,0xc0,0x60,0x30,0x7e,0x0c,0x06,0x03,0x03,0xff}<br>
  };<br>
  GLuint fontOffset;<br>
  <br>
  void makeRasterFont()<br>
  {<br>
  &nbsp;&nbsp; GLuint i,j;<br>
  <br>
  &nbsp;&nbsp; glPixelStorei(GL_UNPACK_ALIGNMENT,1);<br>
  &nbsp;&nbsp; fontOffset=glGenLists(128);<br>
  &nbsp;&nbsp; for(i=0,j='A';i&lt;26;i++,j++)<br>
  &nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glNewList(fontOffset+j,GL_COMPILE);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  glBitmap(8,13,0.0,2.0,10.0,0.0,letters[i]);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glEndList();<br>
  &nbsp;&nbsp; }<br>
  &nbsp;&nbsp; glNewList(fontOffset+' ',GL_COMPILE);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glBitmap(8,13,0.0,2.0,10.0,0.0,space);<br>
  &nbsp;&nbsp; glEndList();<br>
  }<br>
  <br>
  void init(void)<br>
  {<br>
  &nbsp;&nbsp; glShadeModel(GL_FLAT);<br>
  &nbsp;&nbsp; makeRasterFont();<br>
  }<br>
  <br>
  void printString(char *s)<br>
  {<br>
  &nbsp;&nbsp; glPushAttrib(GL_LIST_BIT);<br>
  &nbsp;&nbsp; glListBase(fontOffset);<br>
  &nbsp;&nbsp; glCallLists(strlen(s),GL_UNSIGNED_BYTE,(GLubyte*)s);<br>
  &nbsp;&nbsp; glPopAttrib();<br>
  }<br>
  <br>
  void display(void)<br>
  {<br>
  &nbsp;&nbsp; GLfloat white[3]={1.0,1.0,1.0};<br>
  <br>
  &nbsp;&nbsp; glClear(GL_COLOR_BUFFER_BIT);<br>
  &nbsp;&nbsp; glColor3fv(white);<br>
  &nbsp;&nbsp; glRasterPos2i(20,60);<br>
  &nbsp;&nbsp; printString(&quot;THE QUICK BROWN FOX JUMPS&quot;);<br>
  &nbsp;&nbsp; glRasterPos2i(20,40);<br>
  &nbsp;&nbsp; printString(&quot;OVER A LAZY DOG&quot;);<br>
  &nbsp;&nbsp; glFlush();<br>
  }<br>
  <br>
  void reshape(int w, int h)<br>
  {<br>
  &nbsp;&nbsp; glViewport(0,0,(GLsizei) 300, (GLsizei) 100);<br>
  &nbsp;&nbsp; glMatrixMode(GL_PROJECTION);<br>
  &nbsp;&nbsp; glLoadIdentity();<br>
  &nbsp;&nbsp; glOrtho(0,w,0,h,-1.0,1.0);<br>
  &nbsp;&nbsp; glMatrixMode(GL_MODELVIEW);<br>
  }<br>
  <br>
  void keyboard(unsigned char key,int x,int y)<br>
  {<br>
  &nbsp;&nbsp; switch(key)<br>
  &nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 27:<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(0);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>
  &nbsp;&nbsp; }<br>
  }<br>
  <br>
  int main(int argc, char **argv)<br>
  {<br>
  &nbsp;&nbsp; glutInit(&amp;argc,argv);<br>
  &nbsp;&nbsp; glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);<br>
  &nbsp;&nbsp; glutInitWindowSize(300,100);<br>
  &nbsp;&nbsp; glutCreateWindow(&quot;Drawing a Complete Font&quot;);<br>
  &nbsp;&nbsp; init();<br>
  &nbsp;&nbsp; glutDisplayFunc(display);<br>
  &nbsp;&nbsp; glutReshapeFunc(reshape);<br>
  &nbsp;&nbsp; glutKeyboardFunc(keyboard);<br>
  &nbsp;&nbsp; glutMainLoop();<br>
  &nbsp;&nbsp; return 0; <br>
  } <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<h2>8.2&nbsp; Изображения</h2>

<p class=text align=left style='text-align:left'>Изображение похоже на битовую
карту, но вместо одного бита на каждый пиксель прямоугольной области экрана,
изображение может содержать значительно больше информации. Например,
изображение может содержать информацию о полном цвете (R, G, B, A) для каждого
пикселя. Изображения могут быть получены из нескольких источников, таких как:</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l41 level1 lfo25;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Оцифрованные сканером фотографии</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l41 level1 lfo25;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Изображение, которое первоначально было
сгенерировано на экране графической программой с использованием графической
аппаратуры, а затем считано в память пиксель за пикселем</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l41 level1 lfo25;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Программа, которая генерирует изображение в
памяти пиксель за пикселем.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l41 level1 lfo25;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Изображения, о которых вы обычно думаете, как о
картинках происходят из цветовых буферов. Однако вы можете считывать или
записывать области пиксельных данных из или в буфер глубины или буфер
трафарета.</p>

<p class=text align=left style='text-align:left'>Помимо того, что изображение
может просто отображаться на экране, оно может быть использовано для
текстурирования. В этом случае изображение накладывается на полигон, который
затем визуализируется обычным образом.</p>

<h2>8.2.1&nbsp; Считывание, запись и копирование пиксельных данных</h2>

<p class=text align=left style='text-align:left'>OpenGL предоставляет три
основные команды для манипуляции данными изображения:</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l3 level1 lfo26;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]><b>glReadPixels()</b> – считывает прямоугольный
массив пикселей из буфера кадра в процессорную память.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l3 level1 lfo26;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]><b>glDrawPixels()</b> – записывает прямоугольный
массив пикселей из данных, хранящихся в процессорной памяти, в буфер кадра в
текущую позицию растра, заданную командой <b>glRasterPos*()</b>.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l3 level1 lfo26;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]><b>glCopyPixels()</b> – копирует прямоугольный
массив пикселей из одной части буфера кадра в другую. Эта команда ведет себя
так же как пара вызовов <b>glReadPixels()</b> и <b>glDrawPixels()</b>, но
данные никогда не попадают в процессорную память.</p>

<p class=text align=left style='text-align:left'>Порядок обработки пиксельных
данных для вышеозначенных команд показан на рисунке 8-4.</p>

<p class=text align=left style='text-align:left'>Рисунок 8-4. Упрощенная
диаграмма потоков пиксельных данных </p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1226" type="#_x0000_t75" alt="" style='width:283.5pt;height:297pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image177.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/8-4.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=378 height=396
src="OpenGL%20Red%20Book.files/image177.jpg" v:shapes="_x0000_i1226"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Рисунок 8-4 отображает
основной поток пикселей в процессе обработки. Координаты <b>glRasterPos*()</b>,
которые задают текущую позицию растра и используются командами <b>glDrawPixels()</b>
и <b>glCopyPixels()</b>, преобразуются геометрическим конвейером. Растеризация
и пофрагментные операции влияют и на <b>glDrawPixels()</b> и на <b>glCopyPixels()</b>.
(Однако, когда рисуется или копируется прямоугольник пикселей, как правило, нет
причин для использования тумана или текстуры.)</p>

<p class=text align=left style='text-align:left'>Сложности возникают из-за
того, что в буфере кадра существует совершенно различная информация, существует
множество способов хранения пиксельной информации в памяти компьютера, а также
различные операции преобразования данных могут производиться во время операций
чтения, записи и копирования. Эти возможности отражаются в большом числе
различных режимов операций. Если все, что делает ваша программа – это
копирование изображений на экран или временное считывание изображений в память
с тем, чтобы они могли быть скопированы позднее, вы можете игнорировать
большинство этих режимов. Однако если вы хотите, чтобы ваша программа
модифицировала данные, пока они находятся в памяти – например, если у вас есть
изображение в одном формате, а окно требует его в другом формате, или вы хотите
сохранить изображение в файл для дальнейшего восстановления в другой сессии или
на другом типе машины с совершенно иными графическими возможностями – вам
следует понимать различные режимы работы.</p>

<p class=text align=left style='text-align:left'>Остальная часть данного
раздела описывает основные команды в деталях. Следующие разделы обсуждают
детали серий операций с изображениями, входящими в состав конвейера
изображений: режимы хранения пикселей, операции переноса пикселей и операции по
преобразованию пикселей.</p>

<h2>8.2.1.1&nbsp;&nbsp;&nbsp; Чтение пикселей из буфера кадра в память
процессора</h2>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glReadPixels</b>
  (GLint <i>x</i>, GLint <i>y</i>, GLsizei <i>width</i>, GLsizei <i>height</i>,
  GLenum <i>format</i>, GLenum <i>type</i>, GLvoid *<i>pixels</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Считывает пиксельные данные из
прямоугольника буфера кадра, чей левый нижний угол находится в точке с оконными
координатами (<i>x</i>, <i>y</i>), а ширина и высота равны <i>width </i>и <i>height</i>,
и сохраняет его в массиве, на который указывает аргумент <i>pixels</i>.
Аргумент <i>format </i>задает характер элементов пиксельных данных, которые
должны быть считаны (величина индекса или величины R, G, B или A в соответствии
с таблицей 8-1), а <i>type </i>задает тип данных для каждого элемента (таблица
8-2).</p>

<p class=text align=left style='text-align:left'>Если вы используете <b>glReadPixels()</b>,
чтобы получить информацию о RGBA величинах или величинах цветового индекса,
вам, возможно, понадобиться уточнить, к какому буферу вы пытаетесь получить
доступ. Например, если у вас окно с двойной буферизацией, вам нужно указать
считываете ли вы данные из переднего или заднего буферов. Для управления тем,
какой буфер выступает в качестве источника для чтения данных, вызывайте команду
<b>glReadBuffer()</b>.</p>

<p class=text align=left style='text-align:left'>Таблица 8-1. Форматы пикселей
для команд glReadPixels() и glDrawPixels()</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Константа формата</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Формат пикселей</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_COLOR_INDEX<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>единственный цветовой индекс<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_RGB<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>красный компонент цвета, затем зеленый и синий компоненты<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_RGBA<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>красный компонент цвета, затем зеленый, синий и альфа компоненты<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_BGR<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>синий компонент цвета, затем зеленый и красный компоненты<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:5'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_BGRA<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>синий компонент цвета, затем зеленый, красный и альфа компоненты<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:6'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_RED<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>только красный компонент цвета<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:7'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_GREEN<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>только зеленый компонент цвета <o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:8'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_BLUE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>только синий компонент цвета <o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:9'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_ALPHA<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>только альфа компонент цвета <o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:10'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_LUMINANCE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>только светлота <o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:11'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_LUMINANCE_ALPHA<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>светлота, а затем альфа компонент<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:12'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_STENCIL_INDEX<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>только индекс из буфера трафарета<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:13;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_DEPTH_COMPONENT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>только компонент глубины<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=warning>Замечание: Форматы пикселей GL_BGR и GL_BGRA появились в
OpenGL версии 1.2.</p>

<p class=text align=left style='text-align:left'>Таблица 8-2. Типы данных для
glReadPixels() и glDrawPixels()</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Константа типа</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Тип данных</span></b><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_UNSIGNED_BYTE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>8-ми битовое беззнаковое целое<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_BYTE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>8-ми битовое знаковое целое<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_BITMAP<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>по одному биту на пиксель, биты хранятся в 8-ми битовых целых
  (тот же формат, что и для <b>glBitmap()</b>)<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_UNSIGNED_SHORT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>16-ми битовое беззнаковое целое<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:5'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_SHORT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>16-ми битовое знаковое целое<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:6'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_UNSIGNED_INT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>32-ми битовое беззнаковое целое<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:7'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_INT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>32-ми битовое знаковое целое<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:8'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FLOAT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>число с плавающей точкой одинарной точности<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:9'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_UNSIGNED_BYTE_3_3_2<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>упакованный в 8-ми битовое беззнаковое целое<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:10'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_UNSIGNED_BYTE_2_3_3_REV <o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>упакованный в 8-ми битовое беззнаковое целое<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:11'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_UNSIGNED_SHORT_5_6_5 <o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>упакованный в 16-ми битовое беззнаковое целое<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:12'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_UNSIGNED_SHORT_5_6_5_REV <o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>упакованный в 16-ми битовое беззнаковое целое<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:13'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_UNSIGNED_SHORT_4_4_4_4 <o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>упакованный в 16-ми битовое беззнаковое целое<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:14'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_UNSIGNED_SHORT_4_4_4_4_REV <o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>упакованный в 16-ми битовое беззнаковое целое<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:15'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_UNSIGNED_SHORT_5_5_5_1 <o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>упакованный в 16-ми битовое беззнаковое целое<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:16'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_UNSIGNED_SHORT_1_5_5_5_REV <o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>упакованный в 16-ми битовое беззнаковое целое<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:17'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_UNSIGNED_INT_8_8_8_8 <o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>упакованный в 32-ми битовое беззнаковое целое<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:18'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_UNSIGNED_INT_8_8_8_8_REV <o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>упакованный в 32-ми битовое беззнаковое целое<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:19'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_UNSIGNED_INT_10_10_10_2 <o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>упакованный в 32-ми битовое беззнаковое целое<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:20;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_UNSIGNED_INT_2_10_10_10_REV <o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>упакованный в 32-ми битовое беззнаковое целое<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=warning>Замечание: Пиксельные форматы GL_*_REV особенно удобны для
применения в операционных системах MicrosoftWindows.</p>

<p class=text align=left style='text-align:left'>Помните, что в зависимости от
формата, могут считываться ил записываться от одного до четырех элементов.
Например, если формат равен GL_RGBA, и вы производите считывание в 32-х
разрядные целые (то есть <i>type </i>равен GL_UNSIGNED_INT или GL_INT), то
считывание данных для одного пикселя потребует 16 байт пространства в памяти (4
компонента * 4 байта на компонент).</p>

<p class=text align=left style='text-align:left'>Каждый элемент изображения
сохраняется в памяти, как показано в таблице 8-2. Если элемент представляет
собой длинную (точную) величину такую как значение красного, зеленого, синего
или величину освещенности, каждая величина масштабируется имеющегося количества
бит. Предположим, например, что изначально красный компонент был задан в виде
числа с плавающей точкой между 0.0 и 1.0. Если требуется упаковать его в
беззнаковый байт, то сохранятся только 8 бит точности, даже если для красного
компонента в буфере кадра было выделено больше бит. GL_UNSIGNED_SHORT и
GL_UNSIGNED_INT дадут 16 бит и 32 бита точности соответственно. Знаковые версии
GL_BYTE, GL_SHORTи GL_INT дают 7, 15 и 31 бит точности, поскольку отрицательные
величины, как правило, не используются.</p>

<p class=text align=left style='text-align:left'>Если элемент является индексом
(цветовым индексом или индексом из буфера трафарета, например) и тип не равен
GL_FLOAT, величина просто маскируется до доступного числа бит. Знаковые версии
– GL_BYTE, GL_SHORT и GL_INT – имеют маски меньшие на 1 бит. Например, если
цветовой индекс должен быть сохранен в знаковом 8-ми разрядном целом, он
сначала маскируется с 0x7f. Если тип равен GL_FLOAT, индекс просто
конвертируется в число с плавающей точкой одинарной точности (например, индекс 17
будет преобразован к дробному числу 17.0).</p>

<p class=text align=left style='text-align:left'>Для упакованных типов данных
(задаваемых константами, которые начинаются с GL_UNSIGNED_BYTE_*,
GL_UNSIGNED_SHORT_* или GL_UNSIGNED_INT_*), все цветовые компоненты каждого
пикселя ужимаются в один элемент данных, заданного беззнакового типа: или в
байт, или в короткое целое, или в стандартное целое. Для каждого типа данных
допустимы определенные форматы, показанные в таблице 8-3. Если для упакованного
типа данных используется нелегальный формат пикселей, генерируется ошибка
GL_INVALID_OPERATION.</p>

<p class=warning>Замечание: Упакованные форматы пикселей появились в OpenGL
версии 1.2.</p>

<p class=text align=left style='text-align:left'>Таблица 8-3. Допустимые
форматы пикселей для упакованных типов данных</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Константа упакованного типа</span></b><span style='font-size:
  8.0pt;font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Допустимые форматы пикселей</span></b><span style='font-size:
  8.0pt;font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_UNSIGNED_BYTE_3_3_2<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_RGB<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_UNSIGNED_BYTE_2_3_3_REV <o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_RGB<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_UNSIGNED_SHORT_5_6_5 <o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_RGB<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_UNSIGNED_SHORT_5_6_5_REV <o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_RGB<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:5'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_UNSIGNED_SHORT_4_4_4_4 <o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_RGBA, GL_BGRA<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:6'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_UNSIGNED_SHORT_4_4_4_4_REV <o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_RGBA, GL_BGRA<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:7'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_UNSIGNED_SHORT_5_5_5_1 <o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_RGBA, GL_BGRA<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:8'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_UNSIGNED_SHORT_1_5_5_5_REV <o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_RGBA, GL_BGRA<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:9'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_UNSIGNED_INT_8_8_8_8 <o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_RGBA, GL_BGRA<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:10'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_UNSIGNED_INT_8_8_8_8_REV <o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_RGBA, GL_BGRA<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:11'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_UNSIGNED_INT_10_10_10_2 <o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_RGBA, GL_BGRA<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:12;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_UNSIGNED_INT_2_10_10_10_REV <o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_RGBA, GL_BGRA<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Verdana;
color:black'>&nbsp; <o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Порядок цветовых величин в
битовых полях упакованных пиксельных данных определяется по формату пикселей и
по тому, содержит ли константа типа суффикс _REV. Без суффикса _REV цветовые
компоненты располагаются таким образом, что первый цвет занимает старшие биты.
С суффиксом _REV порядок упаковки компонентов становится обратным, то есть
первый цвет начинается с самых младших битов.</p>

<p class=text align=left style='text-align:left'>Для иллюстрации этого,
посмотрите на рисунок 8-5, который показывает порядок битовых полей для типов
GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV и 4 допустимые комбинации
GL_UNSIGNED_SHORT_4_4_4_4 (и REV) типов данных и пиксельных форматов RGBA/BGRA.
Организация битовых полей для других 14-ти допустимых типов данных с форматами
пикселей принципиально не отличается от рассмотренной здесь.</p>

<p class=text align=left style='text-align:left'>Рисунок 8-5. Порядок
компонентов для нескольких типов данных и форматов пикселей </p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1227" type="#_x0000_t75" alt="" style='width:232.5pt;height:330pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image178.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/8-5.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=310 height=440
src="OpenGL%20Red%20Book.files/image178.jpg" v:shapes="_x0000_i1227"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Старший бит каждого цветового
компонента всегда упаковывается в старший бит типа данных. Хранение одного
компонента не затрагивается никакими режимами хранения пикселей, хранение
целого пикселя может затрагиваться режимом переключения байт.</p>

<h2>8.2.1.2&nbsp;&nbsp;&nbsp; Запись пиксельных данных из процессорной памяти в
буфер кадра</h2>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glDrawPixels</b>
  (GLsizei <i>width</i>, GLsizei <i>height</i>, GLenum <i>format</i>, GLenum <i>type</i>,
  const GLvoid *<i>pixels</i>); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Рисует прямоугольник
пиксельных данных размерами <i>width </i>и <i>height</i>. Пиксельный
прямоугольник рисуется таким образом, что его левый нижний угол находится в
текущей позиции растра. Аргументы <i>format </i>и <i>type</i> имеют то же
значение, что и для команды <b>glReadPixels()</b>. (Смотрите таблицы 8-1 и
8-2.) Массив, на который указывает <i>pixels</i>, должен содержать пиксельные
данные для рисования. Если текущая позиция растра недопустима, ничего не
рисуется, а позиция растра остается недопустимой.</p>

<p class=text align=left style='text-align:left'>Пример 8-3 – это часть
программы, которая использует <b>glDrawPixels()</b> для рисования
прямоугольника пикселей в левом нижнем углу окна. Функция <b>makeCheckImage()</b>
создает RGB массив 64x64, содержащий изображение шахматной доски. Команда <b>glRasterPos2i(0,0)</b>
позиционирует левый нижний угол изображения. Пока игнорируйте вызов <b>glPixelStorei()</b>.
</p>

<p class=text align=left style='text-align:left'>Пример 8-3. Использование
glDrawPixels(): файл image.cpp</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal style='margin-bottom:12.0pt'><span lang=EN-US
  style='font-size:8.5pt;font-family:Courier;mso-bidi-font-family:"Courier New";
  color:black;mso-ansi-language:EN-US'>#define checkImageWidth 64<br>
  #define checkImageHeight 64<br>
  <br>
  GLubyte checkImage[checkImageHeight][checkImageWidth][3];<br>
  <br>
  void makeCheckImage()<br>
  {<br>
  &nbsp;&nbsp; int i,j,c;<br>
  <br>
  &nbsp;&nbsp; for (i=0;i&lt;checkImageHeight;i++)<br>
  &nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (j=0;j&lt;checkImageWidth;j++)<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c=(((i&amp;0x08)==0)^((j&amp;0x8)==0))*255;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  checkImage[i][j][0]=(GLubyte)c;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  checkImage[i][j][1]=(GLubyte)c;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  checkImage[i][j][2]=(GLubyte)c;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
  &nbsp;&nbsp; }<br>
  }<br>
  <br>
  void init(void)<br>
  {<br>
  &nbsp;&nbsp; glClearColor(0.0,0.0,0.0,0.0);<br>
  &nbsp;&nbsp; glShadeModel(GL_FLAT);<br>
  &nbsp;&nbsp; makeCheckImage();<br>
  &nbsp;&nbsp; glPixelStorei(GL_UNPACK_ALIGNMENT,1);<br>
  }<br>
  <br>
  void display(void)<br>
  {<br>
  &nbsp;&nbsp; glClear(GL_COLOR_BUFFER_BIT);<br>
  &nbsp;&nbsp; glRasterPos2i(0,0);<br>
  &nbsp;&nbsp;
  glDrawPixels(checkImageWidth,checkImageHeight,GL_RGB,GL_UNSIGNED_BYTE,checkImage);<br>
  &nbsp;&nbsp; glFlush();<br>
  }<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>При использовании <b>glDrawPixels()</b>
для записи RGBA или цвето-индексной информации, вам может потребоваться
управлять тем, какой буфер используется для рисования с помощью команды <b>glDrawBuffer()</b>.</p>

<h2>8.2.1.3&nbsp;&nbsp;&nbsp; Копирование пиксельных данных внутри буфера кадра</h2>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glCopyPixels</b>
  (GLint <i>x</i>, GLint <i>y</i>, GLsizei <i>width</i>, GLsizei <i>height</i>,
  GLenum <i>buffer</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Копирует пиксельные данные из
прямоугольника в буфере кадра, чей левый нижний угол задается координатами (<i>x</i>,
<i>y</i>), а размеры – аргументами <i>width </i>и <i>height</i>. Данные
копируются в новую позицию, чей левый нижний угол задается текущей позицией
растра. Аргумент <i>buffer </i>может принимать значения GL_COLOR, GL_STENCIL
или GL_DEPTH, задавая используемый буфер кадра. <b>glCopyPixels()</b> ведет
себя так же как пара смежных вызовов <b>glReadPixels()</b> и <b>glDrawPixels()</b>
со следующим отображением параметра <i>buffer </i>на значение параметра <i>format</i>:</p>

<p class=text align=left style='margin-left:54.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l35 level1 lfo27;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Если <i>buffer </i>равен GL_DEPTH или
GL_STENCIL, то <i>format </i>равен GL_DEPTH_COMPONENT или GL_STENCIL_INDEX,
соответственно.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l35 level1 lfo27;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Если задан GL_COLOR, используется GL_RGBA или
GL_COLOR_INDEX в зависимости от того, работает ли система в RGBA или индексном
режиме.</p>

<p class=text align=left style='text-align:left'>Заметьте, что для команды <b>glCopyPixels()</b>
нет нужды в параметрах <i>format </i>или <i>type</i>, поскольку данные не
копируются в процессорную память. Буфер – источник и буфер – приемник для
команды <b>glCopyPixels()</b> задаются командами <b>glReadBuffer()</b> и <b>glDrawBuffer()</b>
соответственно.</p>

<p class=text align=left style='text-align:left'>Для всех трех описанных
функций конверсия данных поступающих в или из буфера кадра зависит от того,
какие режимы активны в момент проведения операции.</p>

<h2>8.2.2&nbsp; Конвейер обработки изображений</h2>

<p class=text align=left style='text-align:left'>В этом разделе обсуждается
конвейер обработки изображений: режимы хранения пикселей и операции по передаче
пикселей, которые включают конверсию пиксельных данных. Вы также можете
увеличивать или уменьшать пиксельный прямоугольник до его рисования, применяя
команду <b>glPixelZoom()</b>. Порядок операций показан на рисунке 8-6.</p>

<p class=text align=left style='text-align:left'>Рисунок 8-6. Конвейер
обработки изображений </p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1228" type="#_x0000_t75" alt="" style='width:214.5pt;height:354pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image179.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/8-6.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=286 height=472
src="OpenGL%20Red%20Book.files/image179.jpg" v:shapes="_x0000_i1228"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Когда вызывается команда <b>glDrawPixels()</b>
данные сначала распаковываются из процессорной памяти в соответствии с
активизированными режимами хранения пикселей, затем выполняются операции
пиксельного переноса. Затем получившиеся пиксели растеризуются. Во время
растеризации пиксельный прямоугольник может быть увеличен или уменьшен. Затем
производятся пофрагментные операции, и пиксели заносятся в буфер кадра.</p>

<p class=text align=left style='text-align:left'>Когда вызывается команда <b>glReadPixels()</b>,
данные считываются из буфера кадра, над ними производятся операции пиксельного
переноса, и результирующие данные упаковываются в процессорную память.</p>

<p class=text align=left style='text-align:left'><b>glCopyPixels()</b>
производит все операции пиксельного переноса так же, как это делает <b>glReadPixels()</b>.
Затем получившиеся данные записываются так же как в случае <b>glDrawPixels()</b>,
но преобразования второй раз не производятся.</p>

<p class=text align=left style='text-align:left'>На рисунке 8-7 изображен
процесс перемещения данных командой <b>glCopyPixels()</b> (процесс начинается с
буфера кадра).</p>

<p class=text align=left style='text-align:left'>Рисунок 8-7. Путь пикселей при
вызове команды glCopyPixels() </p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1229" type="#_x0000_t75" alt="" style='width:129pt;height:225.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image180.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/8-7.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=172 height=301
src="OpenGL%20Red%20Book.files/image180.jpg" v:shapes="_x0000_i1229"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Из рисунка 8-8, отображающего
процесс вывода битовой карты, вы можете сделать вывод о том, что визуализация
битовых карт проще, чем визуализация изображений, поскольку ни операции
пиксельного переноса, ни масштабирование не производится.</p>

<p class=text align=left style='text-align:left'>Рисунок 8-8. Путь пикселей при
вызове команды glBitmap() </p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1230" type="#_x0000_t75" alt="" style='width:138pt;height:288.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image181.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/8-8.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=184 height=385
src="OpenGL%20Red%20Book.files/image181.jpg" v:shapes="_x0000_i1230"><![endif]></p>

<p class=text align=left style='text-align:left'>Обратите внимание, режимы
хранения пикселей и операции пиксельного переноса также применяются к
текстурам, во время того, как они считываются из текстурной памяти или записываются
в текстурную память. Рисунок 8-9 демонстрирует эффект от команд <b>glTexImage*()</b>,
<b>glTexSubImage*()</b> и <b>glGenTexImage*()</b>.</p>

<p class=text align=left style='text-align:left'>Рисунок 8-9. Путь пикселей при
вызове команд glTexImage*(), glTexSubImage*() и glGenTexImage*() </p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1231" type="#_x0000_t75" alt="" style='width:214.5pt;height:171.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image182.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/8-9.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=286 height=229
src="OpenGL%20Red%20Book.files/image182.jpg" v:shapes="_x0000_i1231"><![endif]></p>

<p class=text align=left style='text-align:left'>Как показано на рисунке 8-10,
когда данные из буфера кадра копируются в текстурную память (командами <b>glCopyTexImage*()</b>
или <b>glCopyTexSubImage()</b>), производятся только операции пиксельного
переноса.</p>

<p class=text align=left style='text-align:left'>Рисунок 8-10. Путь пикселей
при вызове команд glCopyTexImage*() и glCopyTexSubImage*() </p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1232" type="#_x0000_t75" alt="" style='width:194.25pt;height:122.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image183.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/8-10.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=259 height=163
src="OpenGL%20Red%20Book.files/image183.jpg" v:shapes="_x0000_i1232"><![endif]></p>

<h2>8.2.2.1&nbsp;&nbsp;&nbsp; Упаковка и распаковка пикселей</h2>

<p class=text align=left style='text-align:left'>Упаковка и распаковка пикселей
касается процесса записи данных в процессорную память и считывания их оттуда.</p>

<p class=text align=left style='text-align:left'>Изображение, хранимое в
памяти, состоит из определенного количества фрагментов (от одного до четырех)
на каждый пиксель. Эти фрагменты называются <i>элементами</i>. Данные могут
состоять только из цветовых индексов или светлоты (светлота – это взвешенная
сумма величин красного, зеленого и синего), но они также могут состоять из
красного, зеленого, синего и альфа компонентов для каждого пикселя. Возможные
варианты структуры пиксельных данных, или <i>форматы</i>, определяют число и
порядок элементов для каждого пикселя.</p>

<p class=text align=left style='text-align:left'>Некоторые элементы (такие как
цветовой индекс или индекс трафарета) являются целыми, а другие (такие как
красный, зеленый, синий и альфа компоненты) – числами с плавающей точкой,
обычно варьируясь между 0.0 и 1.0. Дробные компоненты обычно сохраняются в
буфере кадра с меньшим разрешением, чем требуется для сохранения полного числа
с плавающей точкой (цветовые компоненты, например, могут храниться в 8-ми
битах). Точное число битов, используемых для представления компонентов, зависит
от конкретной используемой аппаратуры. Таким образом, часто бессмысленно
хранить компоненты в виде 32-разрядных чисел с плавающей точкой, тем более, что
изображение может состоять из миллионов пикселей.</p>

<p class=text align=left style='text-align:left'>Элементы могут храниться в
памяти в виде различных типов данных от 8-разрядных байтов до 32-разрядных
целых чисел или чисел с плавающей точкой. OpenGL определяет преобразование
каждого компонента каждого формата к каждому из возможных типов данных. Имейте
в виду, пытаясь сохранить компонент с высоким разрешением в тип данных,
представляемый небольшим числом бит,&nbsp; вы можете потерять данные.</p>

<h2>8.2.2.2&nbsp;&nbsp;&nbsp; Управление режимами хранения пикселей</h2>

<p class=text align=left style='text-align:left'>Данные изображения обычно
хранятся в процессорной памяти в двух- или трехмерных прямоугольных массивах.
Довольно часто вам требуется отобразить или сохранить часть изображения,
соответствующую части прямоугольного массива. Кроме того, вам, возможно,
придется учитывать, что различные машины используют разные соглашения о&nbsp;
порядке байт. Наконец, некоторые машины могут включать аппаратуру, которая
эффективнее перемещает данные в буфер кадра и из него, если данные в
процессорной памяти выровнены по границе 2-ух, 4-ех или 8-ми байт. Для таких
машин может понадобиться управление выравниванием байт. Все вопросы, затронутые
в данном абзаце, решаются путем использования режимов хранения пикселей. Вы
задаете эти режимы, используя команду <b>glPixelStore*()</b>, которая уже
использовалась в нескольких примерах.</p>

<p class=text align=left style='text-align:left'>Все режимы хранения пикселей,
поддерживаемые OpenGL, управляются <b>glPixelStore*()</b>. Обычно производится
несколько последовательных вызовов данной команды для установки значений
различных параметров.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glPixelStore</b>{if}
  (GLenum <i>pname</i>, TYPE <i>param</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Устанавливает<span
style='mso-ansi-language:EN-US'> </span>режимы<span style='mso-ansi-language:
EN-US'> </span>хранения<span style='mso-ansi-language:EN-US'> </span>пикселей<span
lang=EN-US style='mso-ansi-language:EN-US'>, </span>которые<span
style='mso-ansi-language:EN-US'> </span>влияют<span style='mso-ansi-language:
EN-US'> </span>на<span style='mso-ansi-language:EN-US'> </span>работу<span
style='mso-ansi-language:EN-US'> </span>команд<span style='mso-ansi-language:
EN-US'> <b><span lang=EN-US>glDrawPixels())</span></b><span lang=EN-US>, <b>glReadPixels()</b>,
<b>glBitmap()</b>, <b>glPolygonStipple()</b>, <b>glTexImage1D()</b>, <b>glTexImage2D()</b>,
<b>glTexImage3D()</b>, <b>glTexSubImage1D()</b>, <b>glTexSubImage2D()</b>, <b>glTexSubImage3D()</b>,
<b>glGetTexImage()</b>, </span></span>а<span style='mso-ansi-language:EN-US'> </span>также<span
lang=EN-US style='mso-ansi-language:EN-US'>, </span>если<span style='mso-ansi-language:
EN-US'> </span>присутствует<span style='mso-ansi-language:EN-US'> </span>подмножество<span
style='mso-ansi-language:EN-US'> </span>команд<span style='mso-ansi-language:
EN-US'> </span>обработки<span style='mso-ansi-language:EN-US'> </span>изображений<span
style='mso-ansi-language:EN-US'> <b><span lang=EN-US>glGetColorTable()</span></b><span
lang=EN-US>, <b>glGetConvolutionFilter()</b>, <b>glGetSeparableFilter()</b>, <b>glGetHistogram()</b>,
<b>glGetMinmax()</b>. </span></span>Возможные<span style='mso-ansi-language:
EN-US'> </span>имена<span style='mso-ansi-language:EN-US'> </span>параметров<span
style='mso-ansi-language:EN-US'> </span>для<span style='mso-ansi-language:EN-US'>
<i><span lang=EN-US>pname</span></i><span lang=EN-US> </span></span>перечислены<span
style='mso-ansi-language:EN-US'> </span>в<span style='mso-ansi-language:EN-US'>
</span>таблице<span lang=EN-US style='mso-ansi-language:EN-US'> 8-4. </span>Параметры<span
lang=EN-US style='mso-ansi-language:EN-US'> GL_UNPACK_* </span>управляют<span
style='mso-ansi-language:EN-US'> </span>тем<span lang=EN-US style='mso-ansi-language:
EN-US'>, </span>как<span style='mso-ansi-language:EN-US'> </span>данные<span
style='mso-ansi-language:EN-US'> </span>распаковываются<span style='mso-ansi-language:
EN-US'> </span>из<span style='mso-ansi-language:EN-US'> </span>памяти<span
style='mso-ansi-language:EN-US'> </span>командами<span style='mso-ansi-language:
EN-US'> <b><span lang=EN-US>glDrawPixels()</span></b><span lang=EN-US>, <b>glBitmap()</b>,
<b>glPolygonStipple()</b>, <b>glTexImage1D()</b>, <b>glTexImage2D()</b>, <b>glTexImage3D()</b>,
<b>glTexSubImage1D()</b>, <b>glTexSubImage2D()</b> </span></span>и<span
style='mso-ansi-language:EN-US'> <b><span lang=EN-US>glTexSubImage3D()</span></b><span
lang=EN-US>. </span></span>Параметры<span lang=EN-US style='mso-ansi-language:
EN-US'> GL_PACK_* </span>управляют<span style='mso-ansi-language:EN-US'> </span>тем<span
lang=EN-US style='mso-ansi-language:EN-US'>, </span>как<span style='mso-ansi-language:
EN-US'> </span>данные<span style='mso-ansi-language:EN-US'> </span>упаковываются<span
style='mso-ansi-language:EN-US'> </span>в<span style='mso-ansi-language:EN-US'>
</span>память<span style='mso-ansi-language:EN-US'> </span>командами<span
style='mso-ansi-language:EN-US'> <b><span lang=EN-US>glReadPixels()</span></b><span
lang=EN-US>, <b>glGenTexImage()</b>, </span></span>а<span style='mso-ansi-language:
EN-US'> </span>также<span lang=EN-US style='mso-ansi-language:EN-US'>, </span>если<span
style='mso-ansi-language:EN-US'> </span>присутствует<span style='mso-ansi-language:
EN-US'> </span>подмножество<span style='mso-ansi-language:EN-US'> </span>команд<span
style='mso-ansi-language:EN-US'> </span>обработки<span style='mso-ansi-language:
EN-US'> </span>изображений<span style='mso-ansi-language:EN-US'> <b><span
lang=EN-US>glGetColorTable()</span></b><span lang=EN-US>, <b>glGetConvolutionFilter()</b>,
<b>glGetSeparableFilter()</b>, <b>glGetHistogram()</b>, <b>glGetMinmax()</b>. </span></span>Параметры<span
lang=EN-US style='mso-ansi-language:EN-US'> GL_UNPACK_IMAGE_HEIGHT,
GL_PACK_IMAGE_HEIGHT, GL_UNPACK_SKIP_IMAGES, GL_PACK_SKIP_IMAGES </span>влияют<span
style='mso-ansi-language:EN-US'> </span>только<span style='mso-ansi-language:
EN-US'> </span>на<span lang=EN-US style='mso-ansi-language:EN-US'> 3D </span>текстурирование<span
lang=EN-US style='mso-ansi-language:EN-US'> (<b>glTexImage3D()</b>, <b>glTexSubImage3D()</b>,
<b>glGenTexImage(GL_TEXTURE_3D,...)</b>).<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Таблица 8-4. Параметры
glPixelStore()</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Имя параметра</span></b><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Тип</span></b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Начальное значение</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Допустимые величины</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_UNPACK_SWAP_BYTES, GL_PACK_SWAP_BYTES<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLboolean<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>TRUE / FALSE<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_UNPACK_LSB_FIRST, GL_PACK_ LSB_FIRST<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLboolean<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>TRUE / FALSE<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_UNPACK_ROW_LENGTH, GL_PACK_ROW_LENGTH<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLint<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>любое неотрицательное целое<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_UNPACK_SKIP_ROWS, GL_PACK_SKIP_ROWS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLint<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>любое неотрицательное целое <o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:5'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_UNPACK_SKIP_PIXELS,
  GL_PACK_SKIP_PIXELS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLint<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>любое неотрицательное целое <o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:6'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_UNPACK_ALIGNMENT, GL_PACK_ALIGNMENT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLint<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>4<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1, 2, 4, 8<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:7'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_UNPACK_IMAGE_HEIGHT,
  GL_PACK_IMAGE_HEIGHT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLint<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>любое неотрицательное целое <o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:8;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_UNPACK_SKIP_IMAGES,
  GL_PACK_SKIP_IMAGES<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLint<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>любое неотрицательное целое <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Поскольку соответствующие
параметры для упаковки и распаковки имеют одинаковый смысл, они обсуждаются
вместе в оставшейся части этого раздела и ссылки на них производятся без
префикса GL_PACK или GL_UNPACK. Например, *SWAP_BYTES относится и к
GL_UNPACK_SWAP_BYTES, и к GL_PACK_SWAP_BYTES.</p>

<p class=text align=left style='text-align:left'>Если параметр *SWAP_BYTES
равен FALSE (значение по умолчанию), то порядок байтов в памяти такой же, как
естественный порядок байтов для клиента OpenGL; если параметр равен TRUE– байты
расположены в обратном порядке. Реверс байтов применяется для элементов любого размера,
но имеет смысл только для элементов, состоящих из нескольких байт.</p>

<p class=text align=left style='text-align:left'>Эффект от реверса байтов может
различаться в разных реализациях OpenGL. Рисунок 8-10 иллюстрирует эффект от
байтового реверса для различных типов данных для реализации, в которой GLubyte
состоит из 8 бит, GLushort – из 16, а GLuint – из 32. Заметьте, что обратный
порядок байт не сказывается на однобайтовых данных.&nbsp;</p>

<p class=text align=left style='text-align:left'>Рисунок 8-11. Обратный порядок
байт для данных типа Byte, Short и Integer </p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1233" type="#_x0000_t75" alt="" style='width:465pt;height:177.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image184.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/8-11.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=620 height=237
src="OpenGL%20Red%20Book.files/image184.jpg" v:shapes="_x0000_i1233"><![endif]><o:p></o:p></span></p>

<p class=warning>Замечание: Если ваше приложение OpenGL не разделяет
изображения с другими машинами, вы можете игнорировать вопросы, связанные с
порядком байт. Если ваша программа должна визуализировать изображение OpenGL,
которое было создано на другой машине с другим порядком байт, этот порядок
может быть изменен с помощью *SWAP_BYTES. Однако параметр *SWAP_BYTES не
позволяет вам изменять порядок элементов (например, поменять местами красный и
зеленый компоненты).</p>

<p class=text align=left style='text-align:left'>Параметр *LSB_FIRST имеет
значение только при рисовании или считывании однобитовых изображений или
битовых карт, для которых на каждый пиксель сохраняется или восстанавливается
по одному биту данных. Если *LSB_FIRST равен FALSE (значение по умолчанию) биты
берутся из байтов начиная со старшего, иначе они забираются в обратном порядке.
Например, если *LSB_FIRSTравен FALSE, а интересующий нас байт – 0x31, битами по
порядку будут {0, 0, 1, 1, 0, 0, 0, 1}. Если же *LSB_FIRST равен TRUE – порядок
будет следующим {1, 0, 0, 0, 1, 1, 0, 0}.</p>

<p class=text align=left style='text-align:left'>Иногда вам нужно нарисовать
или считать только часть прямоугольника данных изображения (также
прямоугольную), сохраненного в памяти. Если прямоугольник в памяти больше, чем
прямоугольник, который нужно нарисовать или считать, вам нужно задать реальную
длину (в пикселях) большего прямоугольник с помощью *ROW_LENGTH. Если
*ROW_LENGTH равен 0 (значение по умолчанию) длина ряда принимается такой же,
как и ширина, задаваемая в командах <b>glReadPixels()</b>, <b>glDrawPixels()</b>
или <b>glCopyPixels()</b>. Вам также нужно задать количество рядов и пикселей,
которые нужно пропустить до начала копирования данных для меньшего
прямоугольника. Эти числа задаются при помощи параметров *SKIP_ROWS и *SKIP_PIXELS,
как показано на рисунке 8-12. По умолчанию оба параметра равны 0, так что
копирование начинается с нижнего левого угла.</p>

<p class=text align=left style='text-align:left'>Рисунок 8-12. Параметры
*SKIP_ROWS, *SKIP_PIXELS и *ROW_LENGTH </p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1234" type="#_x0000_t75" alt="" style='width:465pt;height:338.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image185.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/8-12.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=620 height=451
src="OpenGL%20Red%20Book.files/image185.jpg" v:shapes="_x0000_i1234"><![endif]></p>

<p class=text align=left style='text-align:left'>Часто аппаратура
оптимизирована для перемещения пиксельных данных в память и из памяти, если
данные сохранены в памяти с определенным выравниваем. Например, в машине с 32-х
разрядными словами, аппаратура часто намного быстрее извлекает данные, если они
изначально выровнены по границе 32-разрядов, что обычно означает адрес кратный
4. Похожим образом, 64-битовые архитектуры могут работать лучше, когда данные
выровнены по границам в 8 байт. </p>

<p class=text align=left style='text-align:left'>Для примера, предположим, что
ваша машина лучше работает, когда пиксельные данные выровнены по 4-ех байтовым
границам. Изображения могут быть сохранены более эффективно, если сделать так,
чтобы данные для каждого ряда изображения начинались на 4-ех байтовой границе.
Если изображение имеет ширину в 5 пикселей, и каждый пиксель состоит из 1 байта
на красный, 1 на зеленый и 1 на синий компоненты, для одного ряда требуется
5x3=15 байт данных. Максимальная эффективность может быть достигнута, если
первый и последующие ряды будут начинаться с 4-ех байтовой границы, то есть на
каждый ряд будет тратиться 1 дополнительный байт памяти. Если ваши данные
сохранены подобным образом, верно установите значение параметра *ALIGNMENT (в
данном случае в значение 4).</p>

<p class=text align=left style='text-align:left'>Если *ALIGNMENT равен 1,
используется следующий доступный байт. Если он равен 2, в конце каждого ряда
если это необходимо будет пропущен дополнительный байт, чтобы первый байт
следующего ряда начинался с адреса кратного 2-ум. В случае битовых карт (или
1-битовый изображений), где для каждого пикселя хранится один бит, байтовое
смещение также работает, но вам нужно подсчитывать отдельные биты. Например,
если вы сохраняете по одному биту на пиксель, длина ряда составляет 75
пикселей, а выравнивание равно 4, то каждый ряд потребует 75/8 или 9 3/8 байт.
Поскольку число 12 – это наименьшее число кратное 4 большее 9 3/8, для каждого
ряда будет использоваться 12 байт памяти. Если выравнивание равно 1, то будет
использовано 10 байт, то есть 9 3/8 округленное до целого числа байт.</p>

<p class=warning>&nbsp;Замечание: Значением по умолчанию для *ALIGNMENT
является 4. Предположение о том, что данные изображения плотно упакованы в
памяти (то есть *ALIGNMENT равно 1) является частой ошибкой.</p>

<p class=text align=left style='text-align:left'>Параметры *IMAGE_HEIGHT и
*SKIP_IMAGES влияют только на определение и опрос трехмерных текстур.</p>

<h2>8.2.2.3&nbsp;&nbsp;&nbsp; Операции перемещения пикселей</h2>

<p class=text align=left style='text-align:left'>В то время, как данные
изображения передаются из памяти в буфер кадра или из буфера кадра в память,
OpenGL может производить над ними некоторые операции. Например, могут быть
изменены диапазоны вариации компонентов – обычно красный компонент варьируется
в диапазоне от 0.0 до 1.0, но вам может потребоваться хранить его в каком-либо
другом диапазоне; или может быть данные, используемые вами, пришли из другой
системы с другим диапазоном вариации красного компонента. Вы можете даже
создать карты для конверсии цветовых индексов или цветовых компонентов во время
переноса пикселей. Подобная конверсия, производимая во время передачи пикселей
в буфер кадра или из него, называется операциями перемещения пикселей. Этими
операциями управляют команды <b>glPixelTransfer*()</b>и <b>glPixelMap*()</b>.</p>

<p class=text align=left style='text-align:left'>Имейте в виду, что хотя
цветовой, глубинный и трафаретный буфер имеют много общего, они не ведут себя
одинаково во всех ситуациях, и некоторые из режимов имеют специальное
назначение. Все детали о режимах обсуждаются в данном и последующих разделах,
включая все специальные случаи.</p>

<p class=text align=left style='text-align:left'>Некоторые из характеристик
функционирования операций пиксельного переноса задаются с помощью команды <b>glPixelTransfer*()</b>.
Другие характеристики задаются с помощью <b>glPixelMap*()</b>, описанной в
следующем разделе.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glPixelTransfer</b>{if}
  (GLenum <i>pname</i>, TYPE <i>param</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Устанавливает<span
style='mso-ansi-language:EN-US'> </span>режимы<span style='mso-ansi-language:
EN-US'> </span>пиксельной<span style='mso-ansi-language:EN-US'> </span>передачи<span
lang=EN-US style='mso-ansi-language:EN-US'>, </span>которые<span
style='mso-ansi-language:EN-US'> </span>влияют<span style='mso-ansi-language:
EN-US'> </span>на<span style='mso-ansi-language:EN-US'> </span>функционирование<span
style='mso-ansi-language:EN-US'> </span>команд<span style='mso-ansi-language:
EN-US'> <b><span lang=EN-US>glDrawPixels())</span></b><span lang=EN-US>, <b>glReadPixels()</b>,
<b>glCopyPixels()</b>, <b>glTexImage1D()</b>, <b>glTexImage2D()</b>, <b>glTexImage3D()</b>,
<b>glCopyTexImage1D()</b>, <b>glCopyTexImage2D()</b>, <b>glTexSubImage1D()</b>,
<b>glTexSubImage2D()</b>, <b>glTexSubImage3D()</b>, <b>glCopyTexSubImage1D(),
glCopyTexSubImage2D(), glCopyTexSubImage3D(), glGetTexImage()</b>. </span></span>Аргумент
<i>pname </i>должен принимать одно из значений, приведенных в первой колонке
таблицы 8-5, а <i>param</i>– одно из допустимых для соответствующего параметра
значений.</p>

<p class=text align=left style='text-align:left'>Таблица 8-5. Параметры команды
glPixelTransfer*()</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Имя параметра</span></b><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Тип</span></b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Начальное значение</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Допустимый диапазон</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_MAP_COLOR<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLboolean<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>TRUE/FALSE<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_MAP_STENCIL<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLboolean<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>TRUE/FALSE<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_INDEX_SHIFT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLint<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1235" type="#_x0000_t75"
   alt="" style='width:48.75pt;height:12.75pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image186.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form5.GIF"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=65 height=17
  src="OpenGL%20Red%20Book.files/image186.jpg" v:shapes="_x0000_i1235"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_INDEX_OFFSET<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLint<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1236" type="#_x0000_t75"
   alt="" style='width:48.75pt;height:12.75pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image186.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form5.GIF"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=65 height=17
  src="OpenGL%20Red%20Book.files/image186.jpg" v:shapes="_x0000_i1236"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:5'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_RED_SCALE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLfloat<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1.0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1237" type="#_x0000_t75"
   alt="" style='width:48.75pt;height:12.75pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image186.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form5.GIF"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=65 height=17
  src="OpenGL%20Red%20Book.files/image186.jpg" v:shapes="_x0000_i1237"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:6'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_GREEN_SCALE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLfloat<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1.0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1238" type="#_x0000_t75"
   alt="" style='width:48.75pt;height:12.75pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image186.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form5.GIF"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=65 height=17
  src="OpenGL%20Red%20Book.files/image186.jpg" v:shapes="_x0000_i1238"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:7'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_BLUE_SCALE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLfloat<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1.0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1239" type="#_x0000_t75"
   alt="" style='width:48.75pt;height:12.75pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image186.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form5.GIF"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=65 height=17
  src="OpenGL%20Red%20Book.files/image186.jpg" v:shapes="_x0000_i1239"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:8'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_ALPHA_SCALE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLfloat<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1.0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1240" type="#_x0000_t75"
   alt="" style='width:48.75pt;height:12.75pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image186.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form5.GIF"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=65 height=17
  src="OpenGL%20Red%20Book.files/image186.jpg" v:shapes="_x0000_i1240"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:9'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_DEPTH_SCALE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLfloat<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1.0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1241" type="#_x0000_t75"
   alt="" style='width:48.75pt;height:12.75pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image186.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form5.GIF"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=65 height=17
  src="OpenGL%20Red%20Book.files/image186.jpg" v:shapes="_x0000_i1241"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:10'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_RED_BIAS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLfloat<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0.0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1242" type="#_x0000_t75"
   alt="" style='width:48.75pt;height:12.75pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image186.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form5.GIF"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=65 height=17
  src="OpenGL%20Red%20Book.files/image186.jpg" v:shapes="_x0000_i1242"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:11'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_GREEN_BIAS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLfloat<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0.0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1243" type="#_x0000_t75"
   alt="" style='width:48.75pt;height:12.75pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image186.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form5.GIF"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=65 height=17
  src="OpenGL%20Red%20Book.files/image186.jpg" v:shapes="_x0000_i1243"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:12'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_BLUE_BIAS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLfloat<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0.0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1244" type="#_x0000_t75"
   alt="" style='width:48.75pt;height:12.75pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image186.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form5.GIF"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=65 height=17
  src="OpenGL%20Red%20Book.files/image186.jpg" v:shapes="_x0000_i1244"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:13'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_ALPHA_BIAS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLfloat<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0.0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1245" type="#_x0000_t75"
   alt="" style='width:48.75pt;height:12.75pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image186.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form5.GIF"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=65 height=17
  src="OpenGL%20Red%20Book.files/image186.jpg" v:shapes="_x0000_i1245"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:14'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_DEPTH_BIAS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLfloat<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0.0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1246" type="#_x0000_t75"
   alt="" style='width:48.75pt;height:12.75pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image186.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form5.GIF"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=65 height=17
  src="OpenGL%20Red%20Book.files/image186.jpg" v:shapes="_x0000_i1246"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:15'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_POST_CONVOLUTION_RED_SCALE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLfloat<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1.0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1247" type="#_x0000_t75"
   alt="" style='width:48.75pt;height:12.75pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image186.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form5.GIF"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=65 height=17
  src="OpenGL%20Red%20Book.files/image186.jpg" v:shapes="_x0000_i1247"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:16'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_POST_CONVOLUTION_GREEN_SCALE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLfloat<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1.0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1248" type="#_x0000_t75"
   alt="" style='width:48.75pt;height:12.75pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image186.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form5.GIF"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=65 height=17
  src="OpenGL%20Red%20Book.files/image186.jpg" v:shapes="_x0000_i1248"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:17'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_POST_CONVOLUTION_BLUE_SCALE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLfloat<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1.0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1249" type="#_x0000_t75"
   alt="" style='width:48.75pt;height:12.75pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image186.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form5.GIF"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=65 height=17
  src="OpenGL%20Red%20Book.files/image186.jpg" v:shapes="_x0000_i1249"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:18'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_POST_CONVOLUTION_ALPHA_SCALE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLfloat<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1.0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1250" type="#_x0000_t75"
   alt="" style='width:48.75pt;height:12.75pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image186.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form5.GIF"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=65 height=17
  src="OpenGL%20Red%20Book.files/image186.jpg" v:shapes="_x0000_i1250"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:19'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_POST_CONVOLUTION_RED_BIAS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLfloat<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0.0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1251" type="#_x0000_t75"
   alt="" style='width:48.75pt;height:12.75pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image186.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form5.GIF"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=65 height=17
  src="OpenGL%20Red%20Book.files/image186.jpg" v:shapes="_x0000_i1251"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:20'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_POST_CONVOLUTION_GREEN_BIAS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLfloat<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0.0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1252" type="#_x0000_t75"
   alt="" style='width:48.75pt;height:12.75pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image186.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form5.GIF"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=65 height=17
  src="OpenGL%20Red%20Book.files/image186.jpg" v:shapes="_x0000_i1252"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:21'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_POST_CONVOLUTION_BLUE_BIAS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLfloat<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0.0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1253" type="#_x0000_t75"
   alt="" style='width:48.75pt;height:12.75pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image186.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form5.GIF"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=65 height=17
  src="OpenGL%20Red%20Book.files/image186.jpg" v:shapes="_x0000_i1253"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:22'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_POST_CONVOLUTION_ALPHA_BIAS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLfloat<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0.0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1254" type="#_x0000_t75"
   alt="" style='width:48.75pt;height:12.75pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image186.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form5.GIF"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=65 height=17
  src="OpenGL%20Red%20Book.files/image186.jpg" v:shapes="_x0000_i1254"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:23'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_POST_COLOR_MATRIX_RED_SCALE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLfloat<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1.0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1255" type="#_x0000_t75"
   alt="" style='width:48.75pt;height:12.75pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image186.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form5.GIF"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=65 height=17
  src="OpenGL%20Red%20Book.files/image186.jpg" v:shapes="_x0000_i1255"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:24'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_POST_COLOR_MATRIX_GREEN_SCALE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLfloat<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1.0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1256" type="#_x0000_t75"
   alt="" style='width:48.75pt;height:12.75pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image186.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form5.GIF"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=65 height=17
  src="OpenGL%20Red%20Book.files/image186.jpg" v:shapes="_x0000_i1256"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:25'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_POST_COLOR_MATRIX_BLUE_SCALE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLfloat<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1.0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1257" type="#_x0000_t75"
   alt="" style='width:48.75pt;height:12.75pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image186.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form5.GIF"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=65 height=17
  src="OpenGL%20Red%20Book.files/image186.jpg" v:shapes="_x0000_i1257"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:26'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_POST_COLOR_MATRIX_ALPHA_SCALE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLfloat<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1.0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1258" type="#_x0000_t75"
   alt="" style='width:48.75pt;height:12.75pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image186.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form5.GIF"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=65 height=17
  src="OpenGL%20Red%20Book.files/image186.jpg" v:shapes="_x0000_i1258"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:27'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_POST_COLOR_MATRIX_RED_BIAS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLfloat<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0.0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1259" type="#_x0000_t75"
   alt="" style='width:48.75pt;height:12.75pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image186.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form5.GIF"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=65 height=17
  src="OpenGL%20Red%20Book.files/image186.jpg" v:shapes="_x0000_i1259"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:28'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_POST_COLOR_MATRIX_GREEN_BIAS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLfloat<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0.0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1260" type="#_x0000_t75"
   alt="" style='width:48.75pt;height:12.75pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image186.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form5.GIF"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=65 height=17
  src="OpenGL%20Red%20Book.files/image186.jpg" v:shapes="_x0000_i1260"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:29;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_POST_COLOR_MATRIX_BLUE_BIAS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLfloat<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0.0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1261" type="#_x0000_t75"
   alt="" style='width:48.75pt;height:12.75pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image186.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form5.GIF"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=65 height=17
  src="OpenGL%20Red%20Book.files/image186.jpg" v:shapes="_x0000_i1261"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=warning>Замечание: Параметры GL_POST_CONVOLUTION_* и
GL_POST_COLOR_MATRIX_*&nbsp; присутствуют только в том случае, если ваша
реализация OpenGL поддерживает подмножество команд обработки изображений.</p>

<p class=text align=left style='text-align:left'>Если параметр GL_MAP_COLOR или
GL_MAP_STENCIL равны TRUE, активизировано отображение (mapping) пикселей. Все
остальные параметры непосредственно влияют на величины цветовых компонент
пикселей.</p>

<p class=text align=left style='text-align:left'>Масштаб (scale) и скос (bias)
могут быть применены к красному, зеленому, синему, альфа и глубинному
компонентам. Например, вам нужно масштабировать красный, зеленый и синий
компоненты, считанные из буфера кадра, перед конверсией их к формату светлоты в
процессорной памяти. Светлота (luminance) вычисляется как сумма красного,
зеленого и синего компонентов, то есть если вы используете значения по
умолчанию для GL_RED_SCALE, GL_GREEN_SCALE и GL_BLUE_SCALE, все компоненты
будут вносить одинаковый вклад в результирующую величину интенсивности или
светлоты. Если вам нужно конвертировать RGB в светлоту в соответствии со
стандартом NTSC, установите GL_RED_SCALE в 0.30, GL_GREEN_SCALE в 0.59, а
GL_BLUE_SCALE в 0.11.</p>

<p class=text align=left style='text-align:left'>Индексы (цветовой и
трафаретный) также могут быть трансформированы. В случае индексов применяются
сдвиг (shift) и смещение. Это полезно, если вам нужно управлять тем, какая
часть цветовой таблицы используется.</p>

<h2>8.2.2.4&nbsp;&nbsp;&nbsp; Отображение пикселей</h2>

<p class=text align=left style='text-align:left'>Все цветовые компоненты,
цветовые индексы и трафаретные индексы могут быть изменены с помощью ссылочной
таблицы до помещения в экранную память. Это делается при помощи команды <b>glPixelMap*()</b>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glPixelMap</b>{ui
  us f}<b>v</b> (GLenum <i>map</i>, GLint <i>mapsize</i>, const TYPE *<i>values</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Загружает пиксельную карту,
заданную аргументом <i>map</i>, с числом вхождений <i>mapsize</i>, на величины
которой указывает аргумент <i>values</i>. Таблица 8-6 отображает все имена и
значения карт; все размеры по умолчанию равны 1, а величины по умолчанию – 0.
Размер каждой карты должен быть степенью 2.</p>

<p class=text align=left style='text-align:left'>Таблица 8-6. Имена и значения
параметров glPixelMap*()</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Имя карты</span></b><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Что на входе</span></b><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Что на выходе</span></b><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_PIXEL_MAP_I_I<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>цветовой индекс<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>цветовой индекс <o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_PIXEL_MAP_S_S<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>индекс трафарета<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>индекс трафарета <o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_PIXEL_MAP_I_R<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>цветовой индекс<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>R<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_PIXEL_MAP_I_G<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>цветовой индекс<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>G<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:5'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_PIXEL_MAP_I_B<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>цветовой индекс<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>B<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:6'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_PIXEL_MAP_I_A<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>цветовой индекс<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>A<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:7'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_PIXEL_MAP_R_R<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>R<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>R<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:8'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_PIXEL_MAP_G_G<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>G<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>G<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:9'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_PIXEL_MAP_B_B<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>B<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>B<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:10;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_PIXEL_MAP_A_A<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>A<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>A<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Максимальный размер карты
является машинно-зависимым. Вы можете выяснить размеры пиксельных карт на вашей
машине с помощью команды <b>glGetIntegerv()</b>. Для выяснения максимального
размера всех пиксельных карт используйте аргумент GL_MAX_PIXEL_MAP_TABLE, а для
выяснения текущего размера конкретной карты используйте аргументы
GL_PIXEL_MAP_*_TO_*. Размеры 6 карт, касающихся цветового и трафаретного
индекса, всегда должны быть степенью 2, RGBAкарты могут иметь любой размер от 1
до GL_MAX_PIXEL_MAP_TABLE.</p>

<p class=text align=left style='text-align:left'>Чтобы понять, как работают эти
таблицы, рассмотрим простой пример. Предположим, что вы хотите создать таблицу
в 256 вхождениями, которая отображает цветовые индексы на цветовые индексы
(GL_PIXEL_MAP_I_TO_I). Вы создаете таблицу с одним вхождением для каждой
величины от 0 до 255 и инициализируете ее с помощью <b>glPixelMap*()</b>.
Предположим, что вы используете таблицу, которая отображает все индексы меньше
101 (индексы от 0 до 100 включительно) на 0, а все остальные индексы (от 101 до
255 включительно) на 255. В этом случае ваша таблица состоит из 101 нуля и 155
значений 255. Пиксельная карта включается с помощью установки параметра
GL_MAP_COLOR в TRUE командой <b>glPixelTransfer*()</b>. Как только пиксельная
карта загружена и активизирована входящие цветовые индексы меньше 101 будут
выходить равными 0, а большие или равные 101 – равными 255. Если входящий
пиксель больше 255, он сначала маскируется с 255 (в процессе чего отбрасываются
все биты старше восьмого) и в таблице ищется получившаяся величина. Если
входящий индекс представляет собой число с плавающей точкой (например,
88.14585), он округляется до ближайшего целого (в нашем случае 88) и это число
ищется в таблице (результатом в нашем случае будет 0).</p>

<p class=text align=left style='text-align:left'>Используя пиксельные карты вы
также можете изменять индексы трафарета или конвертировать цветовые индексы в
RGB. </p>

<h2>8.2.2.5&nbsp;&nbsp;&nbsp; Увеличение, уменьшение и отражение изображения</h2>

<p class=text align=left style='text-align:left'>После того как применены
режимы хранения пикселей и операции пиксельного переноса, изображения и битовые
карты растеризуются. Обычно один пиксель изображения записывается в один
пиксель экрана. Однако вы можете увеличивать, уменьшать и даже отражать
изображения с помощью команды <b>glPixelZoom()</b>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=prototype><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>glPixelZoom</b>
  (GLfloat <!--[if gte vml 1]><v:shape id="_x0000_i1262" type="#_x0000_t75"
   alt="" style='width:37.5pt;height:11.25pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image187.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form6b.JPG"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=50 height=15
  src="OpenGL%20Red%20Book.files/image187.jpg" v:shapes="_x0000_i1262"><![endif]>,
  GLfloat <!--[if gte vml 1]><v:shape id="_x0000_i1263" type="#_x0000_t75"
   alt="" style='width:38.25pt;height:15pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image188.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form7b.JPG"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=51 height=20
  src="OpenGL%20Red%20Book.files/image188.jpg" v:shapes="_x0000_i1263"><![endif]>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Задает фактор увеличения или
уменьшения для операций по записи пикселей (<b>glDrawPixels()</b> и <b>glCopyPixels()</b>)
по осям x и y. По умолчанию <!--[if gte vml 1]><v:shape id="_x0000_i1264"
 type="#_x0000_t75" alt="" style='width:36.75pt;height:12pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image189.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form6.JPG"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=49 height=16
src="OpenGL%20Red%20Book.files/image189.jpg" v:shapes="_x0000_i1264"><![endif]>&nbsp;и
<!--[if gte vml 1]><v:shape id="_x0000_i1265" type="#_x0000_t75" alt=""
 style='width:39pt;height:15pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image190.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form7.JPG"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=52 height=20
src="OpenGL%20Red%20Book.files/image190.jpg" v:shapes="_x0000_i1265"><![endif]>&nbsp;равны
1.0. Если оба фактора установить в 2.0, каждый пиксель изображения будет
нарисован на 4-ех пикселях экрана. Заметьте, что допускаются дробные и
отрицательные факторы увеличения или уменьшения изображения. Отрицательные
значения факторов отражают изображение относительно текущей позиции растра и
соответствующей оси.</p>

<p class=text align=left style='text-align:left'>Во время растеризации каждый
пиксель изображения считается прямоугольником площадью <!--[if gte vml 1]><v:shape
 id="_x0000_i1266" type="#_x0000_t75" alt="" style='width:87pt;height:12pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image191.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form12.JPG"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=116 height=16
src="OpenGL%20Red%20Book.files/image191.jpg" v:shapes="_x0000_i1266"><![endif]>,
и фрагменты генерируются для всех пикселей экрана, чьи центры лежат внутри
этого прямоугольника. Более конкретно, обозначим координаты текущей позиции
растра как (<!--[if gte vml 1]><v:shape id="_x0000_i1267" type="#_x0000_t75"
 alt="" style='width:16.5pt;height:13.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image192.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form8.JPG"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=22 height=18
src="OpenGL%20Red%20Book.files/image192.jpg" v:shapes="_x0000_i1267"><![endif]>,<!--[if gte vml 1]><v:shape
 id="_x0000_i1268" type="#_x0000_t75" alt="" style='width:16.5pt;height:15pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image193.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form9.JPG"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=22 height=20
src="OpenGL%20Red%20Book.files/image193.jpg" v:shapes="_x0000_i1268"><![endif]>).
Если отдельная группа элементов (индексов или компонент) является n-ой в ряду и
принадлежит m-ной колонке, то в оконных координатах она будет покрывать регион,
ограниченный прямоугольником с углами в </p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1269" type="#_x0000_t75" alt="" style='width:194.25pt;height:17.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image194.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form10.JPG"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=259 height=23
src="OpenGL%20Red%20Book.files/image194.jpg" v:shapes="_x0000_i1269"><![endif]>и
<!--[if gte vml 1]><v:shape id="_x0000_i1270" type="#_x0000_t75" alt=""
 style='width:248.25pt;height:15pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image195.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form11.JPG"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=331 height=20
src="OpenGL%20Red%20Book.files/image195.jpg" v:shapes="_x0000_i1270"><![endif]>.</p>

<p class=text align=left style='text-align:left'>Любые фрагменты, чьи центры
лежат внутри этого прямоугольника (а также на его нижней или левой границах)
генерируются в соответствии с этой отдельной группой элементов.</p>

<p class=text align=left style='text-align:left'>Отрицательные факторы могут
быть полезны для отражения изображения. В OpenGL изображения описываются снизу
вверх и слева направо. Если у вас есть изображение, описанное сверху вниз,
например, кадр видео, вам может пригодиться <b>glPixelZoom</b>(1.0,-1.0); чтобы
выправить изображение под формат OpenGL. Убедитесь, что вы должным образом
установили текущую растровую позицию.</p>

<p class=text align=left style='text-align:left'>Пример 8-4 демонстрирует
использование команды <b>glPixelZoom()</b>. В начале в нижнем левом углу окна
рисуется изображение шахматной доски. Нажимая клавишу мыши и передвигая ее, вы
выполняете команду <b>glCopyPixels()</b>, копируя нижний левый угол окна в
текущую позицию курсора. (Если вы скопируете изображение само на себя, оно
будет выглядеть довольно неприлично.) Копируемое изображение масштабируется, но
изначально оно масштабируется на величину по умолчанию (1.0), так что вы не
обратите на это внимание. Клавиши ‘z’ и ‘Z’ увеличивают и уменьшают факторы
масштаба на 0.5. Любое повреждение содержимого окна, вызывает его перерисовку.
Нажатие на клавишу ‘r’ сбрасывает изображение и факторы масштаба.</p>

<p class=text align=left style='text-align:left'>Пример 8-4. Рисование,
копирование и масштабирование пиксельных данных: файл image.cpp</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#include &lt;glut.h&gt;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#include &lt;windows.h&gt;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#include &lt;stdio.h&gt;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#define checkImageWidth 64<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#define checkImageHeight 64<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>GLubyte checkImage[checkImageHeight][checkImageWidth][3];<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>GLdouble zoomFactor=1.0;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>GLuint height;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void makeCheckImage()<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>int i,j,c;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>for (i=0;i&lt;checkImageHeight;i++)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>for (j=0;j&lt;checkImageWidth;j++)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>c=(((i&amp;0x08)==0)^((j&amp;0x8)==0))*255;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                 </span><span style='mso-spacerun:yes'> </span>checkImage[i][j][0]=(GLubyte)c;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>checkImage[i][j][1]=(GLubyte)c;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>checkImage[i][j][2]=(GLubyte)c;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void init(void)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glClearColor(0.0,0.0,0.0,0.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glShadeModel(GL_FLAT);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>makeCheckImage();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glPixelStorei(GL_UNPACK_ALIGNMENT,1);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void display(void)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glClear(GL_COLOR_BUFFER_BIT);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glRasterPos2i(0,0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glDrawPixels(checkImageWidth,checkImageHeight, GL_RGB,GL_UNSIGNED_BYTE,checkImage);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glFlush();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void reshape(int w, int h)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glViewport(0,0,(GLsizei) w, (GLsizei) h);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>height=(GLint)h;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glMatrixMode(GL_PROJECTION);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glLoadIdentity();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>gluOrtho2D(0.0,(GLdouble)w,0.0,(GLdouble)h);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glMatrixMode(GL_MODELVIEW);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glLoadIdentity();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void motion(int x,int y)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>static GLint screeny;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>screeny=height-(GLint)y;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glRasterPos2i(x,screeny);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glPixelZoom(zoomFactor,zoomFactor);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glCopyPixels(0,0,checkImageWidth,checkImageHeight,GL_COLOR);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glPixelZoom(1.0,1.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glFlush();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void outMsg(bool reset=false)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>char buffer[100];<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>if (reset)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>sprintf(buffer,&quot;zoomFactor is now %4.1f\n&quot;,zoomFactor);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>else<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>sprintf(buffer,&quot;zoomFactor reset to 1.0\n&quot;);<span style='mso-spacerun:yes'>         </span><o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>MessageBox(NULL,buffer,&quot;Drawing, Copying and Zooming Pixel Data&quot;,MB_OK);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>return;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void keyboard(unsigned char key,int x,int y)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>switch(key)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>case 'r':<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>case 'R':<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>zoomFactor=1.0;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                 </span><span style='mso-spacerun:yes'> </span>outMsg();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>glutPostRedisplay();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>break;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>case 'z':<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>zoomFactor+=0.5;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>if (zoomFactor&gt;=3.0)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                        </span>zoomFactor=3.0;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>outMsg(true);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>             </span><span style='mso-spacerun:yes'>     </span>break;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>case 'Z':<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>zoomFactor-=0.5;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>if (zoomFactor&lt;=0.5)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                        </span>zoomFactor=0.5;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>outMsg(true);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>break;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>case 27:<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>exit(0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>  </span><span style='mso-spacerun:yes'>                </span>break;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>int main(int argc, char **argv)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutInit(&amp;argc,argv);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutInitWindowSize(250,250);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutInitWindowPosition(100,100);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutCreateWindow(&quot;Drawing, Copying and Zooming Pixel Data&quot;);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>init();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutDisplayFunc(display);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutReshapeFunc(reshape);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutKeyboardFunc(keyboard);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutMotionFunc(motion);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutMainLoop();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span></span><span
  style='color:black'>return 0;<span style='mso-spacerun:yes'>   </span><o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<h2>8.2.3&nbsp; Считывание и рисование прямоугольников пикселей</h2>

<p class=text align=left style='text-align:left'>В этом разделе процессы
считывания и записи пикселей в деталях. Преобразования над пикселями во время
их переноса из буфера кадра в память (считывание) похожи, но не идентичны тем,
которые производятся при переносе пикселей в обратном направлении (записи). Вы
можете пропустить этот раздел, если не собираетесь немедленно применять
операции перемещения пикселей.</p>

<h2>8.2.3.1&nbsp;&nbsp;&nbsp; Процесс рисования пиксельного прямоугольника</h2>

<p class=text align=left style='text-align:left'>Рисунок 8-13 и следующий за
ним список описывают процесс рисования пикселей в буфер кадра.</p>

<p class=text align=left style='text-align:left'>Рисунок 8-13. Рисование
пикселей с помощью glDrawPixels() </p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1271" type="#_x0000_t75" alt="" style='width:567.75pt;height:891pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image196.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/8-13.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=757 height=1188
src="OpenGL%20Red%20Book.files/image196.jpg" v:shapes="_x0000_i1271"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l29 level1 lfo28;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>1.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Если пиксели представляют собой не индексы (то
есть формат не равен GL_COLOR_INDEX и GL_STENCIL_INDEX), первым шагом является
преобразование компонентов к формату с плавающей точкой, если это необходимо. </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l29 level1 lfo28;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>2.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Если формат равен GL_LUMINANCE или
GL_LUMINANCE_ALPHA, элемент светлоты конвертируется в R, G и B с использованием
величины светлоты для каждого из R, G и B компонентов. В формате
GL_LUMINANCE_ALPHA альфа величина напрямую переходит в компонент A. Если задан
формат GL_LUMINANCE альфа устанавливается равной 1.0. </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l29 level1 lfo28;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>3.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Каждый компонент (R, G, B , A или глубина)
умножается на соответствующую величину масштаба, и к ней прибавляется
определенный скос. Например, компонент Rумножается на величину GL_RED_SCALE и
складывается с величиной GL_RED_BIAS. </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l29 level1 lfo28;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>4.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Если GL_MAP_COLOR равно TRUE, каждый из R, G, B
и альфа компонент интерполируется до диапазона [0.0, 1.0], умножается на целое
число на единицу меньшее размера цветовой таблицы, его дробная часть
отбрасывается и ищется в таблице. </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l29 level1 lfo28;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>5.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Далее R, G, B и A компоненты интерполируются до
диапазона [0.0, 1.0] (если они не были интерполированы до этого) и
конвертируются в формат с фиксированной точкой с максимально допустимым
количеством бит слева от точки (в соответствии с возможностями буфера кадра для
конкретного компонента). </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l29 level1 lfo28;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>6.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Если вы работаете с индексными величинами (то
есть с трафаретными или цветовыми индексами), величины конвертируются к формату
с фиксированной точкой (если изначально они были числами с плавающей точкой).
Индексы, которые изначально имели формат с фиксированной точкой, остаются
таковыми, а все их биты справа от запятой устанавливаются в 0. Получившиеся
индексы сдвигаются влево или вправо на количество разрядов равное абсолютной
величине GL_INDEX_SHIFT. Индекс сдвигается влево, если GL_INDEX_SHIFT &gt; 0 и
вправо, если GL_INDEX_SHIFT &lt; 0. Наконец, к индексу прибавляется значение
GL_INDEX_OFFSET. </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l29 level1 lfo28;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>7.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Следующий шаг при работе с индексами зависит от
того, функционирует ли приложение в RGBA или в индексном цветовом режиме. В
RGBA режиме индекс конвертируется в RGBA с использованием карт GL_PIXEL_MAP_I_TO_R,
GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B и GL_PIXEL_MAP_I_TO_A. Иначе, если
GL_MAP_COLOR равно GL_TRUE, индекс заменяется согласно таблице
GL_PIXEL_MAP_I_TO_I (если GL_MAP_COLOR равно GL_FALSE– индекс остается
неизменным). Если изображение состоит из трафаретных, а не из цветовых
индексов, и если GL_MAP_STENCIL равно GL_TRUE, индекс изменяется согласно
таблице GL_PIXEL_MAP_S_TO_S. Если GL_MAP_STENCIL равен FALSE трафаретный индекс
не изменяется. </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l29 level1 lfo28;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>8.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Наконец, если индексы не были конвертированы в
RGBA, они маскируются до количества бит допустимых для цветового индекса или
индекса трафарета. </p>

<h2>8.2.3.2&nbsp;&nbsp;&nbsp; Процесс считывания пиксельного прямоугольника</h2>

<p class=text align=left style='text-align:left'>Многие из преобразований,
совершаемых во время рисования пиксельного прямоугольника, также производятся и
в процессе его считывания. Процесс считывания пиксельного прямоугольника
показан на рисунке 8-14 и описан в следующим за ним списке.&nbsp;</p>

<p class=text align=left style='text-align:left'>Рисунок 8-14. Считывание
пикселей с помощью glReadPixels() </p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1272" type="#_x0000_t75" alt="" style='width:496.5pt;height:876.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image197.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/8-14.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=662 height=1169
src="OpenGL%20Red%20Book.files/image197.jpg" v:shapes="_x0000_i1272"><![endif]></p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l15 level1 lfo29;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>1.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Если считываемые индексы не являются индексами
(то есть формат не равен GL_COLOR_INDEX и GL_STENCIL_INDEX), компоненты
отображаются в диапазон [0.0, 1.0]. </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l15 level1 lfo29;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>2.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Далее, к каждому компоненту применяются масштаб
и скос. Если GL_MAP_COLOR равен GL_TRUE, компоненты заменяются согласно таблице
и снова интерполируются в диапазон [0.0, 1.0]. Если желаемый вами формат –
освещенность, компоненты суммируются (L=R+G+B). </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l15 level1 lfo29;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>3.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Если пиксели являются индексами (цветовыми или
трафаретными), они сдвигаются, складываются со смещением и, если GL_MAP_COLOR
равно TRUE, также заменяются с помощью таблицы. </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l15 level1 lfo29;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>4.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Если формат хранения GL_COLOR_INDEX или
GL_STENCIL_INDEX, индексы пикселей маскируются до числа бит в типе хранилища
(1, 8, 16 или 32) и упаковываются в память. </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l15 level1 lfo29;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>5.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Если формат хранения является одним из
основанных на компонентах (таким как светлота или RGB), пиксели всегда
заменяются с помощью карт индекс-к-RGBA. Затем работа с ними ведется так, как
если бы они были RGBA пикселями с самого начала (включая потенциальную
конверсию в формат светлоты). </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l15 level1 lfo29;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>6.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Наконец, и индексные, и компонентные данные
упаковываются в память в соответствии с режимами GL_PACK*&nbsp; установленными
командой <b>glPixelStore*()</b>. </p>

<p class=text align=left style='text-align:left'>Величины масштаба, скоса,
сдвига и смещения такие же как те, что использовались при рисовании пикселей,
так что если вы и рисуете и считываете пиксели, не забывайте сбрасывать эти
величины в нужные вам значения до чтения или рисования. Похожим образом, различные
карты должны быть установлены в нужные значения, если вы планируете
использовать их и для чтения, и для записи.</p>

<p class=warning>Замечание: Может показаться, что светлота обрабатывается
неправильно и при чтении, и при записи. Например, обычно светлота зависит от R,
G и B не в одинаковой степени, как можно предположить из рисунков 8-13 и 8-14.
Если вам нужно, чтобы светлота вычислялась так, чтобы R, G и B вносили в нее
30, 59 и 11 процентов, вы можете установить GL_RED_SCALE в .30, GL_GREEN_SCALE
в .59, а GL_BLUE_SCALE в .11. Тогда вычисленное L будет равно .30R+.59G+.11B.</p>

<h2>8.2.4&nbsp; Советы для увеличения скорости вывода пикселей</h2>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l67 level1 lfo30;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Как вы можете видеть, у OpenGL весьма большие
возможности для считывания, отображения и манипулирования пиксельными данными.
Несмотря на то, что эти возможности часто бывают полезны, они также снижают
быстродействие. Здесь приведено несколько советов для ускорения операций с
пикселями.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l67 level1 lfo30;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Для наилучшего быстродействия, установите все
параметры, связанные с передачей пикселей в их значения по умолчанию, а факторы
масштабирования в (1.0, 1.0).</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l67 level1 lfo30;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Серии фрагментных операций применяются к
пикселям во время их отображения в буфере кадра. Для оптимального
быстродействия заблокируйте все операции над фрагментами.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l67 level1 lfo30;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Когда производятся операции над пикселями,
заблокируйте все остальные расточительные в смысле производительности
механизмы, такие как текстурирование и освещение.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l67 level1 lfo30;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Если вы используете формат изображения и тип,
соответствующие буферу кадра, вы можете сократить работу, которую должна
произвести реализация OpenGL. Например, если вы записываете изображение в буфер
кадра, имеющий формат RGB и 8 бит на компонент, вызывайте <b>glDrawPixels()</b>
с параметром <i>format</i>, установленным в GL_RGB, и <i>type</i>,
установленным в GL_UNSIGNED_BYTE.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l67 level1 lfo30;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Для некоторых реализаций беззнаковые форматы
изображений работают быстрее знаковых.Обычно процесс рисования большого
прямоугольника пикселей работает значительно быстрее, чем процесс рисования
нескольких меньшего размера, поскольку цена переноса пиксельных данных может
быть амортизирована для многих пикселей.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l67 level1 lfo30;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Вполне возможно, что вам удастся снизить затраты
на производительность, уменьшив количество перемещаемых данных. Например, вы
можете уменьшить тип данных (в частности до GL_UNSIGNED_BYTE) или число
компонент (в частности, использовав формат GL_LUMINANCE_ALPHA).</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l67 level1 lfo30;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Операции по переносу пикселей, включая
отображение пикселей, а также масштабирование, скос, смещение и сдвиг, даже
величины, заданные по умолчанию, могут снижать быстродействие. </p>

<h2>8.2.5&nbsp; Подмножество команд по обработке изображений</h2>

<p class=text align=left style='text-align:left'>Подмножество обработки
изображений представляет собой набор команд, предоставляющих дополнительные
возможности по работе с пикселями, в частности, следующие:</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l28 level1 lfo31;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>использование цветовых таблиц для замены величин
пикселей</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l28 level1 lfo31;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>использование фильтров для изображений</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l28 level1 lfo31;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>использование цветовой матрицы для
пространственной конверсии и других линейных преобразований</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l28 level1 lfo31;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>сбор статистики в виде гистограмм, а также
минимальных и максимальных цветовых значений</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l28 level1 lfo31;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>использование уравнений цветового наложения для
вычисления суммы, разницы, минимума и максимума двух изображений</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l28 level1 lfo31;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>использование постоянных факторов цветового
наложения для изменения цветов пикселей.</p>

<p class=text align=left style='text-align:left'>Вам следует использовать
подмножество команд обработки изображений, если вам требуется большие
возможности по работе с пикселями, чем те, что предоставляются командами <b>glPixelTransfer*()</b>
и <b>glPixelMap*()</b>.</p>

<p class=text align=left style='text-align:left'>Подмножество команд по
обработке изображений (ImagingSubset) – это расширение OpenGL. Если в
библиотеке определен элемент GL_ARB_imaging, то подмножество присутствует, и
вам доступна вся функциональность, описываемая в следующих разделах. Если
элемент не определен, никакая часть описанной функциональности не присутствует
в вашей библиотеке.</p>

<p class=text align=left style='text-align:left'>Независимо от того, передаются
ли пиксели OpenGL или считываются из нее, они обрабатываются всеми активизированными
механизмами подмножества. Команды, на которые влияет подмножество, включают
следующие:</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l51 level1 lfo32;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>команды, рисующие и считывающие пиксели: <b>glReadPixels()</b>,
<b>glDrawPixels()</b>, <b>glCopyPixels()</b></p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l51 level1 lfo32;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>команды, определяющие текстуры: <b>glTexImage1D()</b>,<b>glTexImage2D()</b>,
<b>glCopyTextureImage*D()</b>, <b>glSubTexImage1D()</b>, <b>glSubTexImage2D()</b>,
<b>glCopySubTexImage()</b>.</p>

<p class=text align=left style='text-align:left'>Рисунок 8-15 иллюстрирует
операции, производимые подмножеством обработки изображений, над пикселями,
которые поступают в OpenGLили считываются оттуда. Большинство из возможностей подмножества
может быть активизировано или деактивировано (за исключением цветовой матрицы,
которая всегда активизирована).</p>

<p class=text align=left style='text-align:left'>Рисунок 8-15. Операции
подмножества обработки изображений </p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1273" type="#_x0000_t75" alt="" style='width:384.75pt;height:294pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image198.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/8-15.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=513 height=392
src="OpenGL%20Red%20Book.files/image198.jpg" v:shapes="_x0000_i1273"><![endif]><o:p></o:p></span></p>

<p class=warning>Замечание: Константы и функции, связанные с различными
расширениями OpenGL могут быть не объявлены в заголовочном файле gl.h,
поставляемым с вашим средством разработки, поскольку их поставщики не могут
быть заранее уверены, какие расширения поддерживает имеющаяся у вас реализация
OpenGL. Чтобы решить проблему с константами, воспользуйтесь дополнительным
заголовочным файлом <a
href="http://www.progz.ru/download/opengl/chapter8/glext.h">glext.h</a> (более
новую его версию вы можете найти на сайте <a href="http://www.opengl.org/">http://www.opengl.org/</a>).
Для получения адресов команд – расширений следует воспользоваться специфической
для операционной системы функцией. В системах Windows, например, это функция <b>wglGetProcAddress()</b>.
Примеры ее использования будут приведены дальше в этой главе.</p>

<h2>8.2.5.1&nbsp;&nbsp;&nbsp; Цветовые таблицы</h2>

<p class=text align=left style='text-align:left'>Цветовые таблицы используются
для замены цвета пикселя. В приложениях цветовые таблицы могут использоваться
для настройки контраста, фильтрации и балансировки изображения.</p>

<p class=text align=left style='text-align:left'>Существует три отдельные
цветовые таблицы. Они работают на разных этапах пиксельного конвейера.
Таблица&nbsp; 8-7 перечисляет этапы, на которых цвет пикселя может быть
изменен.</p>

<p class=text align=left style='text-align:left'>Таблица 8-7. Цветовые таблицы
и их место на конвейере</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Цветовая таблица</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Воздействует на пиксели</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_COLOR_TABLE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>когда они входят на конвейер<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_POST_CONVOLUTION_COLOR_TABLE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>после фильтрации<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_POST_COLOR_MATRIX_COLOR_TABLE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>после цветовой матрицы<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Каждая таблица может быть
включена отдельно с помощью команды <b>glEnable()</b> с соответствующим
аргументом из таблицы 8-7.</p>

<h2>8.2.5.1.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Настройка цветовых таблиц</h2>

<p class=text align=left style='text-align:left'>Цветовые таблицы задаются тем
же образом, что и одномерные изображения. Как показано на рисунке 8-15,
существует 3 цветовые таблицы для изменения цветовых величин, и все они
задаются командой <b>glColorTable()</b>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=prototype><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glColorTable</b>
  (GLenum <i>target</i>, GLenum <i>internalFormat</i>, GLsizei <i>width</i>,
  GLenum <i>format</i>, GLenum <i>type</i>, const GLvoid *<i>data</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Если<span style='mso-ansi-language:
EN-US'> <i><span lang=EN-US>target </span></i></span>равно<span lang=EN-US
style='mso-ansi-language:EN-US'> GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE
</span>или<span lang=EN-US style='mso-ansi-language:EN-US'>
GL_POST_COLOR_MATRIX_COLOR_TABLE, </span>настраивает<span style='mso-ansi-language:
EN-US'> </span>соответствующую<span style='mso-ansi-language:EN-US'> </span>цветовую<span
style='mso-ansi-language:EN-US'> </span>таблицу<span lang=EN-US
style='mso-ansi-language:EN-US'>, </span>а<span style='mso-ansi-language:EN-US'>
</span>если<span lang=EN-US style='mso-ansi-language:EN-US'>
GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE </span>или<span
lang=EN-US style='mso-ansi-language:EN-US'> GL_
PROXY_POST_COLOR_MATRIX_COLOR_TABLE – </span>проверяет<span lang=EN-US
style='mso-ansi-language:EN-US'>, </span>что<span style='mso-ansi-language:
EN-US'> </span>заданная<span style='mso-ansi-language:EN-US'> </span>цветовая<span
style='mso-ansi-language:EN-US'> </span>таблица<span style='mso-ansi-language:
EN-US'> </span>может<span style='mso-ansi-language:EN-US'> </span>быть<span
style='mso-ansi-language:EN-US'> </span>размещена<span style='mso-ansi-language:
EN-US'> </span>в<span style='mso-ansi-language:EN-US'> </span>доступных<span
style='mso-ansi-language:EN-US'> </span>ресурсах<span lang=EN-US
style='mso-ansi-language:EN-US'>. </span>Аргумент <i>internalFormat </i>используется,
чтобы указать внутреннее представление данных в OpenGL. Он может принимать
следующие символические значения – GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12,
GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12,
GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2,
GL_LUMINANCE_8ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12,
GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8,
GL_INTENSITY12, GL_INTENSITY16, GL_RGB, GL_R3_G3_B2, GL_RGB4, GL_RGB5, GL_RGB8,
GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1,
GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16. Параметр <i>width</i>, который
должен быть степенью 2, индицирует количество пикселей в цветовой таблице.
Аргументы <i>format </i>и <i>type </i>описывают формат и тип данных цветовой
таблицы. Они имеют такое же значение, как и эквивалентные параметры команды <b>glDrawPixels()</b>.</p>

<p class=text align=left style='text-align:left'>Внутренний формат таблицы
определяет то, какие компоненты пикселей изображения будут заменены. Например,
если вы задаете GL_RGB в качестве формата, то красный, зеленый и синий
компоненты каждого входящего пикселя будут искаться в соответствующей цветовой
таблице и заменяться значениями оттуда. Таблица 8-8 описывает, какие компоненты
пикселей будут заменяться при различных внутренних форматах.</p>

<p class=text align=left style='text-align:left'>Таблица 8-8 Замена значений
пикселей цветовой таблицей</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Базовый внутренний формат</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Красный компонент</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Зеленый компонент </span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Синий компонент</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Альфа компонент</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_ALPHA<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>не изменяется<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>не изменяется <o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>не изменяется <o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1274" type="#_x0000_t75"
   alt="" style='width:18.75pt;height:18pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image199.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form13.JPG"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=25 height=24
  src="OpenGL%20Red%20Book.files/image199.jpg" v:shapes="_x0000_i1274"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_LUMINANCE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1275" type="#_x0000_t75"
   alt="" style='width:15pt;height:17.25pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image200.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form14.JPG"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=20 height=23
  src="OpenGL%20Red%20Book.files/image200.jpg" v:shapes="_x0000_i1275"><![endif]><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1276" type="#_x0000_t75"
   alt="" style='width:15pt;height:17.25pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image200.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form14.JPG"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=20 height=23
  src="OpenGL%20Red%20Book.files/image200.jpg" v:shapes="_x0000_i1276"><![endif]><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1277" type="#_x0000_t75"
   alt="" style='width:15pt;height:17.25pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image200.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form14.JPG"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=20 height=23
  src="OpenGL%20Red%20Book.files/image200.jpg" v:shapes="_x0000_i1277"><![endif]><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>не изменяется <o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_LUMINANCE_ALPHA<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1278" type="#_x0000_t75"
   alt="" style='width:15pt;height:17.25pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image200.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form14.JPG"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=20 height=23
  src="OpenGL%20Red%20Book.files/image200.jpg" v:shapes="_x0000_i1278"><![endif]><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1279" type="#_x0000_t75"
   alt="" style='width:15pt;height:17.25pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image200.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form14.JPG"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=20 height=23
  src="OpenGL%20Red%20Book.files/image200.jpg" v:shapes="_x0000_i1279"><![endif]><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1280" type="#_x0000_t75"
   alt="" style='width:15pt;height:17.25pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image200.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form14.JPG"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=20 height=23
  src="OpenGL%20Red%20Book.files/image200.jpg" v:shapes="_x0000_i1280"><![endif]><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1281" type="#_x0000_t75"
   alt="" style='width:18.75pt;height:18pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image199.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form13.JPG"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=25 height=24
  src="OpenGL%20Red%20Book.files/image199.jpg" v:shapes="_x0000_i1281"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_INTENSITY<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1282" type="#_x0000_t75"
   alt="" style='width:14.25pt;height:21pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image201.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form15.JPG"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=19 height=28
  src="OpenGL%20Red%20Book.files/image201.jpg" v:shapes="_x0000_i1282"><![endif]><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1283" type="#_x0000_t75"
   alt="" style='width:14.25pt;height:21pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image201.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form15.JPG"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=19 height=28
  src="OpenGL%20Red%20Book.files/image201.jpg" v:shapes="_x0000_i1283"><![endif]><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1284" type="#_x0000_t75"
   alt="" style='width:14.25pt;height:21pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image201.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form15.JPG"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=19 height=28
  src="OpenGL%20Red%20Book.files/image201.jpg" v:shapes="_x0000_i1284"><![endif]><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1285" type="#_x0000_t75"
   alt="" style='width:14.25pt;height:21pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image201.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form15.JPG"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=19 height=28
  src="OpenGL%20Red%20Book.files/image201.jpg" v:shapes="_x0000_i1285"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:5'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_RGB<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1286" type="#_x0000_t75"
   alt="" style='width:17.25pt;height:18.75pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image202.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form16.JPG"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=23 height=25
  src="OpenGL%20Red%20Book.files/image202.jpg" v:shapes="_x0000_i1286"><![endif]><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1287" type="#_x0000_t75"
   alt="" style='width:18pt;height:20.25pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image203.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form17.JPG"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=24 height=27
  src="OpenGL%20Red%20Book.files/image203.jpg" v:shapes="_x0000_i1287"><![endif]><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1288" type="#_x0000_t75"
   alt="" style='width:15pt;height:19.5pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image204.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form18.JPG"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=20 height=26
  src="OpenGL%20Red%20Book.files/image204.jpg" v:shapes="_x0000_i1288"><![endif]><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>не изменяется <o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:6;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_RGBA<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1289" type="#_x0000_t75"
   alt="" style='width:17.25pt;height:18.75pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image202.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form16.JPG"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=23 height=25
  src="OpenGL%20Red%20Book.files/image202.jpg" v:shapes="_x0000_i1289"><![endif]><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1290" type="#_x0000_t75"
   alt="" style='width:18pt;height:20.25pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image203.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form17.JPG"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=24 height=27
  src="OpenGL%20Red%20Book.files/image203.jpg" v:shapes="_x0000_i1290"><![endif]><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1291" type="#_x0000_t75"
   alt="" style='width:15pt;height:19.5pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image204.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form18.JPG"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=20 height=26
  src="OpenGL%20Red%20Book.files/image204.jpg" v:shapes="_x0000_i1291"><![endif]><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1292" type="#_x0000_t75"
   alt="" style='width:18.75pt;height:18pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image199.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form13.JPG"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=25 height=24
  src="OpenGL%20Red%20Book.files/image199.jpg" v:shapes="_x0000_i1292"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>В таблице 8-8 величины <!--[if gte vml 1]><v:shape
 id="_x0000_i1293" type="#_x0000_t75" alt="" style='width:15pt;height:17.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image200.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form14.JPG"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=20 height=23
src="OpenGL%20Red%20Book.files/image200.jpg" v:shapes="_x0000_i1293"><![endif]>&nbsp;представляют
собой светлоту в цветовой таблице, которая влияет только на красный, зеленый и
синий компоненты. <!--[if gte vml 1]><v:shape id="_x0000_i1294" type="#_x0000_t75"
 alt="" style='width:14.25pt;height:21pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image201.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form15.JPG"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=19 height=28
src="OpenGL%20Red%20Book.files/image201.jpg" v:shapes="_x0000_i1294"><![endif]>&nbsp;представляет
табличные интенсивности, которые одинаково влияют на красный, зеленый, синий и
альфа компоненты.</p>

<p class=text align=left style='text-align:left'>После того как таблица была
применена к изображению, пиксели могут быть смасштабированы и скошены, после
чего, их значения приводятся к диапазону [0; 1]. Факторы GL_COLOR_TABLE_SCALE и
GL_COLOR_TABLE_BIAS для каждой таблицы устанавливаются с помощью команды <b>glColorTableParameter*()</b>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=prototype><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glColorTableParameter</b>{if}<b>v</b>
  (GLenum <i>target</i>, GLenum <i>pname</i>, TYPE *<i>param</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Устанавливаетпараметры<span
lang=EN-US style='mso-ansi-language:EN-US'> GL_COLOR_TABLE_SCALE </span>и<span
lang=EN-US style='mso-ansi-language:EN-US'> GL_COLOR_TABLE_BIAS </span>для<span
style='mso-ansi-language:EN-US'> </span>каждой<span style='mso-ansi-language:
EN-US'> </span>таблицы<span lang=EN-US style='mso-ansi-language:EN-US'>. <i>target</i>
</span>может<span style='mso-ansi-language:EN-US'> </span>быть<span
style='mso-ansi-language:EN-US'> </span>равно<span lang=EN-US style='mso-ansi-language:
EN-US'> GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE </span>или<span
lang=EN-US style='mso-ansi-language:EN-US'> GL_POST_COLOR_MATRIX_COLOR_TABLE </span>и<span
style='mso-ansi-language:EN-US'> </span>задает<span style='mso-ansi-language:
EN-US'> </span>целевую<span style='mso-ansi-language:EN-US'> </span>таблицу<span
lang=EN-US style='mso-ansi-language:EN-US'>, </span>для<span style='mso-ansi-language:
EN-US'> </span>которой<span style='mso-ansi-language:EN-US'> </span>устанавливаются<span
style='mso-ansi-language:EN-US'> </span>параметры<span lang=EN-US
style='mso-ansi-language:EN-US'>. </span>Возможными<span style='mso-ansi-language:
EN-US'> </span>значениями<span style='mso-ansi-language:EN-US'> </span>для<span
style='mso-ansi-language:EN-US'> <i><span lang=EN-US>pnamee</span></i><span
lang=EN-US> </span></span>являются<span lang=EN-US style='mso-ansi-language:
EN-US'> GL_COLOR_TABLE_SCALE </span>и<span lang=EN-US style='mso-ansi-language:
EN-US'> GL_COLOR_TABLE_BIAS. </span>Величина <i>param </i>указывает на массив
из 4-ех величин, представляющих, соответственно, модификаторы для красного,
зеленого, синего и альфа компонент.</p>

<p class=text align=left style='text-align:left'>Пример 8-5 показывает, как
изображение может быть инвертировано посредством цветовой таблицы. Таблица
настраивается таким образом, чтобы она заменяла каждый цвет на его инверсию.
Пример инвертированного цветовой таблицей изображения приведен на рисунке 8-16.</p>

<p class=text align=left style='text-align:left'>Рисунок 8-16. Исходное
изображение айсберга (слева) и то же изображение, инвертированное с помощью
цветовой таблицы (справа)) </p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1295" type="#_x0000_t75" alt="" style='width:465pt;height:174pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image205.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/8-16.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=620 height=232
src="OpenGL%20Red%20Book.files/image205.jpg" v:shapes="_x0000_i1295"><![endif]></p>

<p class=text align=left style='text-align:left'>Пример 8-5. Замена пикселей с
использованием цветовой таблицы: файл colortable.cpp</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#include &lt;glut.h&gt;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#include &lt;GL/glaux.h&gt;<o:p></o:p></span></pre><pre><span
  style='color:black'>#include &quot;glext.h&quot;<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>//Массив для исходного изображения<o:p></o:p></span></pre><pre><span
  style='color:black'>AUX_RGBImageRec *image;<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>//Тип и указатель для функции цветовой таблицы (EXTENSION)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>typedef void (APIENTRY * GLCOLORTABLE) <o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>             </span>(GLenum target,GLenum internalFormat,GLsizei width,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>              </span>GLenum format, GLenum type, const GLvoid *data);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>GLCOLORTABLE glColorTable=NULL;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void init()<o:p></o:p></span></pre><pre><span
  style='color:black'>{<o:p></o:p></span></pre><pre><span style='color:black'><span style='mso-spacerun:yes'>      </span>int i;<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>GLubyte colorTable[256][3];<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>//Загрузить исходное изображение из 24-разрядного файла BMP <o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span></span><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>//(</span><span
  style='color:black'>библиотека</span><span lang=EN-US style='color:black;
  mso-ansi-language:EN-US'> GLAUX)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>image=auxDIBImageLoad(&quot;peak.bmp&quot;);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span></span><span
  style='color:black'>//Получить адрес функции цветовой таблицы<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>//с помощью функции специфической для реализации OpenGL для Windows<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span></span><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glColorTable=(GLCOLORTABLE)wglGetProcAddress(&quot;glColorTable&quot;);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>if (glColorTable==NULL)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>MessageBox(NULL, &quot;Function [glColorTable] from [GL_ARB_imaging] extension not supported!&quot;,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                       </span>&quot;Pixel Replacement Using Color Tables&quot;,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                        </span>MB_OK|MB_ICONSTOP);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>exit(1);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glPixelStorei(GL_UNPACK_ALIGNMENT,1);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glClearColor(0,0,0,0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span></span><span
  style='color:black'>//Инвертирующая цветовая таблица<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>for(i=0;i&lt;256;++i)<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span></span><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>colorTable[i][0]=255-i;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>colorTable[i][1]=255-i;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>colorTable[i][2]=255-i;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glColorTable(GL_COLOR_TABLE,GL_RGB,256,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                    </span>GL_RGB,GL_UNSIGNED_BYTE,colorTable); <o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glEnable(GL_COLOR_TABLE);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void deinit()<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>//</span><span
  style='color:black'>Очислитьпамять</span><span lang=EN-US style='color:black;
  mso-ansi-language:EN-US'> <o:p></o:p></span></pre><pre><span lang=EN-US
  style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>delete image;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void reshape(int w, int h)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glViewport(0,0,(GLsizei) w, (GLsizei) h);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glMatrixMode(GL_PROJECTION);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glLoadIdentity();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>gluOrtho2D(0,500,0,500);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void display()<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glClear(GL_COLOR_BUFFER_BIT);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glRasterPos2i(1,1);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glDrawPixels(image-&gt;sizeX, image-&gt;sizeY,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                    </span>GL_RGB,GL_UNSIGNED_BYTE,image-&gt;data); <o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glFlush();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>int APIENTRY WinMain(HINSTANCE hInstance,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                     </span>HINSTANCE hPrevInstance,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                     </span>LPSTR<span style='mso-spacerun:yes'>     </span>lpCmdLine,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                     </span>int<span style='mso-spacerun:yes'>       </span>nCmdShow)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>char* argv=&quot;&quot;;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>int argc=0;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutInit(&amp;argc,&amp;argv);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutInitWindowSize(540,405);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutCreateWindow(&quot;Pixel Replacement Using Color Tables&quot;);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>init();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutDisplayFunc(display);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutReshapeFunc(reshape);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span></span><span
  style='color:black'>glutMainLoop();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>deinit();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>return 0;<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<p class=warning>Замечание: Поскольку загрузка изображения должна производиться
способом, зависящим от вашей оконной системы, а также потому, что в GLUT нет
подобных функций, в данном примере используется функция <b>auxDIBImageLoad()</b>
из библиотеки GLAUX для Windows.</p>

<p class=text align=left style='text-align:left'>Вместо того, чтобы задавать
цветовую таблицу непосредственно из вашего приложения, вам может понадобиться
использовать в качестве нее изображение, созданное в буфере кадра. Команда <b>glCopyColorTable()</b>
позволяет вам задать ряд пикселей, которые считываются из буфера кадра и
используются в качестве цветовой таблицы.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=prototype><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glCopyColorTable</b>
  (GLenum <i>target</i>, GLenum <i>internalFormat</i>, GLint <i>x</i>, GLint <i>y</i>,
  GLsizei <i>width</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Создает цветовую таблицу,
используя данные из буфера кадра в качестве данных для цветовой таблицы.
Пиксели считываются из текущего буфера для чтения (GL_READ_BUFFER) и
обрабатываются так же как при вызове <b>glCopyPixels()</b>, но без последней
конверсии. Учтите, что производятся также операции, заданные <b>glPixelTransfer*()</b>.
Параметры <i>target </i>и <i>internalFormat </i>имеют то же значение, что и для
<b>glColorTable()</b>. Цветовой массив будет состоять из <i>width </i>пикселей
вправо, начиная с (<i>x</i>, <i>y</i>) буфера кадра.</p>

<h2>8.2.5.1.2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Замена всей цветовой таблицы или ее
части</h2>

<p class=text align=left style='text-align:left'>Если вам требуется заменить
часть цветовой таблицы, вы можете загрузить ее секцию с помощью команд <b>glColorSubTable()</b>
и <b>glCopyColorSubTable()</b>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=prototype><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glColorSubTable</b>
  (GLenum <i>target</i>, GLsizei <i>start</i>, GLsizei <i>count</i>, GLenum <i>format</i>,
  GLenum <i>type</i>, const GLvoid *<i>data</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Заменяет вхождения [<i>start</i>;<i>start+count-1</i>]
цветовой таблица на величины, находящиеся в <i>data</i>. Параметр<span
style='mso-ansi-language:EN-US'> <i><span lang=EN-US>target</span></i><span
lang=EN-US> </span></span>может<span style='mso-ansi-language:EN-US'> </span>принимать<span
style='mso-ansi-language:EN-US'> </span>значения<span lang=EN-US
style='mso-ansi-language:EN-US'> GL_COLOR_TABLE,
GL_POST_CONVOLUTION_COLOR_TABLE, GL_POST_COLOR_MATRIX_COLOR_TABLE. </span>Параметры
<i>format </i>и <i>type </i>идентичны соответствующим параметрам <b>glColorTable()</b>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=prototype><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glCopyColorSubTable</b>
  (GLenum <i>target</i>, GLsizei <i>start</i>, GLint <i>x</i>, GLint <i>y</i>,
  GLsizei <i>count</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Заменяет вхождения [<i>start</i>;<i>start+count-1</i>]
цветовой таблица на <i>count</i>цветовых величин пикселей из ряда буфера кадра,
начинающегося с позиции (<i>x</i>; <i>y</i>). Пиксели конвертируются в <i>internalFormat
</i>оригинальной таблицы.</p>

<h2>8.2.5.1.3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Запрос величин цветовых таблиц</h2>

<p class=text align=left style='text-align:left'>Величины пикселей, сохраненные
в цветовой таблице, могут быть получены с помощью команды <b>glGetColorTable()</b>.</p>

<h2>8.2.5.1.4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Проверка цветовых таблиц</h2>

<p class=text align=left style='text-align:left'>Прокси цветовых таблиц
позволяют заставить OpenGL выяснить, достаточно ли в системе ресурсов для
размещения вашей цветовой таблицы. Если <b>glColorTable() </b>вызывается с
одним из следующих аргументов:<b><o:p></o:p></b></p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l12 level1 lfo33;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>GL_PROXY_COLOR_TABLE</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l12 level1 lfo33;tab-stops:list 36.0pt'><![if !supportLists]><span
lang=EN-US style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol;mso-ansi-language:EN-US'><span style='mso-list:Ignore'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]><span lang=EN-US style='mso-ansi-language:EN-US'>GL_PROXY_POST_CONVOLUTION_COLOR_TABLE<o:p></o:p></span></p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l12 level1 lfo33;tab-stops:list 36.0pt'><![if !supportLists]><span
lang=EN-US style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol;mso-ansi-language:EN-US'><span style='mso-list:Ignore'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]><span lang=EN-US style='mso-ansi-language:EN-US'>GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>OpenGL проверяет, есть ли
ресурсы для размещения соответствующей таблицы. Если таблица не влезает, ее
величины <i>width</i>, <i>format</i> и <i>type</i> устанавливаются в 0. Если вы
хотите выяснить, достаточно ли ресурсов – проверьте одну из этих величин.
Например, так:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glColorTable(GL_PROXY_COLOR_TABLE, GL_RGB, 1024, <o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>             </span>GL_RGB, GL_UNSIGNED_BYTE, NULL); <o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glGetColorTableParameteriv(GL_PROXY_COLOR_TABLE, <o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                           </span>GL_COLOR_TABLE_WIDTH, &amp;width);<o:p></o:p></span></pre><pre><span
  style='color:black'>if(width==0)<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>/*цветовая таблица не умещается*/<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<h2>8.2.5.2&nbsp;&nbsp;&nbsp; Весовые модификаторы</h2>

<p class=text align=left style='text-align:left'>Весовые модификаторы
(convolutions) работают в качестве фильтров, заменяя каждый пиксель изображения
на взвешенное среднее соседствующих с ним пикселей и его самого. Размытие
изображения, нахождение ребер и изменение контраста являются примерами применения
весовые модификаторы.</p>

<p class=text align=left style='text-align:left'>На рисунке 8-18 показано, как
пиксель <!--[if gte vml 1]><v:shape id="_x0000_i1296" type="#_x0000_t75" alt=""
 style='width:21.75pt;height:18pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image206.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form19.JPG"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=29 height=24
src="OpenGL%20Red%20Book.files/image206.jpg" v:shapes="_x0000_i1296"><![endif]>&nbsp;и
соседние с ним обрабатываются весовым модификатором размера 3x3&nbsp; для
получения пикселя <!--[if gte vml 1]><v:shape id="_x0000_i1297" type="#_x0000_t75"
 alt="" style='width:25.5pt;height:17.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image207.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form20.JPG"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=34 height=23
src="OpenGL%20Red%20Book.files/image207.jpg" v:shapes="_x0000_i1297"><![endif]>.</p>

<p class=text align=left style='text-align:left'>Рисунок 8-17. Операция
пиксельной фильтрации </p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1298" type="#_x0000_t75" alt="" style='width:465pt;height:508.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image208.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/8-17.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=620 height=678
src="OpenGL%20Red%20Book.files/image208.jpg" v:shapes="_x0000_i1298"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Весовые модификаторы – это
массивы весов пикселей, и работают они только на RGBA пикселях. Фильтр, также
известный как <i>kernel</i>, является простым двумерным массивом весов. Каждый
пиксель изображения – результата создается умножением группы входящих пикселей
на весовые коэффициенты фильтра и суммированием получившихся произведений.
Например, на рисунке 8-17 пиксель <!--[if gte vml 1]><v:shape id="_x0000_i1299"
 type="#_x0000_t75" alt="" style='width:25.5pt;height:17.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image207.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form20.JPG"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=34 height=23
src="OpenGL%20Red%20Book.files/image207.jpg" v:shapes="_x0000_i1299"><![endif]>&nbsp;вычисляется
суммированием произведений 9-ти пикселей из входящего изображения на 9 весовых
коэффициентов из фильтра.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glConvolutionFilter2D</b>
  (GLenum <i>target</i>,GLenum <i>internalFormat</i>,GLsizei <i>width</i>,GLsizei
  <i>height</i>,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  GLenum <i>format</i>,GLenum <i>type</i>,const GLvoid *<i>image</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Задает двумерный фильтр.
Параметр <i>filter </i>должен быть равен GL_CONVOLUTION_3D. <i>internalFormat </i>задает,
над какими компонентами пикселей будет производиться фильтрация и может
принимать одно из 38 значений, перечисленных для аргумента <i>internalFormat </i>команды
<b>glColorTable()</b>. Аргументы <i>width </i>и <i>height </i>задают размеры
фильтра в пикселях. Максимальная ширина и высота для фильтров может быть
получена с помощью команды <b>glGetConvolutionParameter*()</b>. Как и в случае <b>glDrawPixels()</b>,
аргументы <i>format </i>и <i>type </i>задают формат пикселей, сохраненных в
массиве, на который указывает <i>image</i>.</p>

<p class=text align=left style='text-align:left'>Как и для цветовых таблиц,
внутренний формат фильтра определяет то, с какими компонентами пикселей
требуется работать. Таблица 8-9 описывает, как различные форматы влияют на
пиксели. <!--[if gte vml 1]><v:shape id="_x0000_i1300" type="#_x0000_t75"
 alt="" style='width:18pt;height:16.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image209.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form21.JPG"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=24 height=22
src="OpenGL%20Red%20Book.files/image209.jpg" v:shapes="_x0000_i1300"><![endif]>,
<!--[if gte vml 1]><v:shape id="_x0000_i1301" type="#_x0000_t75" alt=""
 style='width:18pt;height:18pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image210.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form22.JPG"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=24 height=24
src="OpenGL%20Red%20Book.files/image210.jpg" v:shapes="_x0000_i1301"><![endif]>,
<!--[if gte vml 1]><v:shape id="_x0000_i1302" type="#_x0000_t75" alt=""
 style='width:15.75pt;height:17.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image211.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form23.JPG"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=21 height=23
src="OpenGL%20Red%20Book.files/image211.jpg" v:shapes="_x0000_i1302"><![endif]>&nbsp;и
<!--[if gte vml 1]><v:shape id="_x0000_i1303" type="#_x0000_t75" alt=""
 style='width:18.75pt;height:17.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image212.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form24.JPG"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=25 height=23
src="OpenGL%20Red%20Book.files/image212.jpg" v:shapes="_x0000_i1303"><![endif]>&nbsp;представляют
цветовые компоненты исходных пикселей. <!--[if gte vml 1]><v:shape id="_x0000_i1304"
 type="#_x0000_t75" alt="" style='width:18.75pt;height:20.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image213.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form29.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=25 height=27
src="OpenGL%20Red%20Book.files/image213.jpg" v:shapes="_x0000_i1304"><![endif]>&nbsp;представляет
собой величину светлоты фильтра GL_LUMINANCE, а <!--[if gte vml 1]><v:shape
 id="_x0000_i1305" type="#_x0000_t75" alt="" style='width:16.5pt;height:20.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image214.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form30.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=22 height=27
src="OpenGL%20Red%20Book.files/image214.jpg" v:shapes="_x0000_i1305"><![endif]>&nbsp;--
величину интенсивности фильтра GL_INTENSITY. Наконец, <!--[if gte vml 1]><v:shape
 id="_x0000_i1306" type="#_x0000_t75" alt="" style='width:20.25pt;height:19.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image215.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form25.JPG"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=27 height=26
src="OpenGL%20Red%20Book.files/image215.jpg" v:shapes="_x0000_i1306"><![endif]>,
<!--[if gte vml 1]><v:shape id="_x0000_i1307" type="#_x0000_t75" alt=""
 style='width:21pt;height:18.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image216.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form26.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=28 height=25
src="OpenGL%20Red%20Book.files/image216.jpg" v:shapes="_x0000_i1307"><![endif]>,
<!--[if gte vml 1]><v:shape id="_x0000_i1308" type="#_x0000_t75" alt=""
 style='width:19.5pt;height:19.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image217.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form27.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=26 height=26
src="OpenGL%20Red%20Book.files/image217.jpg" v:shapes="_x0000_i1308"><![endif]>&nbsp;и
<!--[if gte vml 1]><v:shape id="_x0000_i1309" type="#_x0000_t75" alt=""
 style='width:21.75pt;height:20.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image218.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form28.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=29 height=27
src="OpenGL%20Red%20Book.files/image218.jpg" v:shapes="_x0000_i1309"><![endif]>&nbsp;представляют
красный, зеленый, синий и альфа компоненты фильтра.</p>

<p class=text align=left style='text-align:left'>Таблица 8-9. Влияние фильтров
на RGBA компоненты пикселей</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Базовый формат фильтра</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Результат по красному компоненту</span></b><span
  style='font-size:8.0pt;font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Результат по зеленому компоненту</span></b><span
  style='font-size:8.0pt;font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Результат по синему компоненту</span></b><span style='font-size:
  8.0pt;font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Результат по альфа компоненту</span></b><span style='font-size:
  8.0pt;font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_ALPHA<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>не изменяется<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>не изменяется<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>не изменяется<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1310" type="#_x0000_t75"
   alt="" style='width:46.5pt;height:18.75pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image219.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form31.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=62 height=25
  src="OpenGL%20Red%20Book.files/image219.jpg" v:shapes="_x0000_i1310"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_LUMINANCE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1311" type="#_x0000_t75"
   alt="" style='width:44.25pt;height:20.25pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image220.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form32.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=59 height=27
  src="OpenGL%20Red%20Book.files/image220.jpg" v:shapes="_x0000_i1311"><![endif]><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1312" type="#_x0000_t75"
   alt="" style='width:45.75pt;height:18.75pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image221.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form33.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=61 height=25
  src="OpenGL%20Red%20Book.files/image221.jpg" v:shapes="_x0000_i1312"><![endif]><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1313" type="#_x0000_t75"
   alt="" style='width:43.5pt;height:19.5pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image222.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form34.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=58 height=26
  src="OpenGL%20Red%20Book.files/image222.jpg" v:shapes="_x0000_i1313"><![endif]><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>не изменяется<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_LUMINANCE_ALPHA<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1314" type="#_x0000_t75"
   alt="" style='width:44.25pt;height:20.25pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image220.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form32.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=59 height=27
  src="OpenGL%20Red%20Book.files/image220.jpg" v:shapes="_x0000_i1314"><![endif]><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1315" type="#_x0000_t75"
   alt="" style='width:45.75pt;height:18.75pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image221.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form33.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=61 height=25
  src="OpenGL%20Red%20Book.files/image221.jpg" v:shapes="_x0000_i1315"><![endif]><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1316" type="#_x0000_t75"
   alt="" style='width:43.5pt;height:19.5pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image222.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form34.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=58 height=26
  src="OpenGL%20Red%20Book.files/image222.jpg" v:shapes="_x0000_i1316"><![endif]><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1317" type="#_x0000_t75"
   alt="" style='width:46.5pt;height:18.75pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image219.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form31.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=62 height=25
  src="OpenGL%20Red%20Book.files/image219.jpg" v:shapes="_x0000_i1317"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_INTENSITY<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1318" type="#_x0000_t75"
   alt="" style='width:43.5pt;height:19.5pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image223.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form36.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=58 height=26
  src="OpenGL%20Red%20Book.files/image223.jpg" v:shapes="_x0000_i1318"><![endif]><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1319" type="#_x0000_t75"
   alt="" style='width:43.5pt;height:20.25pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image224.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form37.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=58 height=27
  src="OpenGL%20Red%20Book.files/image224.jpg" v:shapes="_x0000_i1319"><![endif]><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1320" type="#_x0000_t75"
   alt="" style='width:41.25pt;height:18.75pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image225.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form38.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=55 height=25
  src="OpenGL%20Red%20Book.files/image225.jpg" v:shapes="_x0000_i1320"><![endif]><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1321" type="#_x0000_t75"
   alt="" style='width:43.5pt;height:20.25pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image226.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form39.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=58 height=27
  src="OpenGL%20Red%20Book.files/image226.jpg" v:shapes="_x0000_i1321"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:5'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_RGB<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1322" type="#_x0000_t75"
   alt="" style='width:44.25pt;height:19.5pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image227.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form40.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=59 height=26
  src="OpenGL%20Red%20Book.files/image227.jpg" v:shapes="_x0000_i1322"><![endif]><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1323" type="#_x0000_t75"
   alt="" style='width:47.25pt;height:19.5pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image228.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form41.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=63 height=26
  src="OpenGL%20Red%20Book.files/image228.jpg" v:shapes="_x0000_i1323"><![endif]><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1324" type="#_x0000_t75"
   alt="" style='width:44.25pt;height:19.5pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image229.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form42.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=59 height=26
  src="OpenGL%20Red%20Book.files/image229.jpg" v:shapes="_x0000_i1324"><![endif]><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>не изменяется<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:6;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_RGBA<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1325" type="#_x0000_t75"
   alt="" style='width:44.25pt;height:19.5pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image227.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form40.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=59 height=26
  src="OpenGL%20Red%20Book.files/image227.jpg" v:shapes="_x0000_i1325"><![endif]><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1326" type="#_x0000_t75"
   alt="" style='width:47.25pt;height:19.5pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image228.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form41.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=63 height=26
  src="OpenGL%20Red%20Book.files/image228.jpg" v:shapes="_x0000_i1326"><![endif]><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1327" type="#_x0000_t75"
   alt="" style='width:44.25pt;height:19.5pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image229.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form42.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=59 height=26
  src="OpenGL%20Red%20Book.files/image229.jpg" v:shapes="_x0000_i1327"><![endif]><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1328" type="#_x0000_t75"
   alt="" style='width:46.5pt;height:18.75pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image219.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form31.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=62 height=25
  src="OpenGL%20Red%20Book.files/image219.jpg" v:shapes="_x0000_i1328"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Чтобы активизировать 2D
фильтрацию, используйте <b>glEnable (GL_CONVOLUTION_2D)</b>. </p>

<p class=text align=left style='text-align:left'>Пример 8-6 демонстрирует
использование нескольких 2D фильтров GL_LUMINANCE размером 3x3 для поиска ребер
в RGBизображении. Клавиши ‘h’, ‘v’ и ‘l’ переключают режимы. </p>

<p class=text align=left style='text-align:left'>Результат работы программы
можно увидеть на рисунке 8-18 (яркость и контрастность изображений увеличена
для наглядности). Слева вверху находится исходное изображение пирамиды, справа
вверху – то же изображение, обработанное фильтром, позволяющим обнаружить
горизонтальные ребра, внизу слева – похожий фильтр, но на этот раз
вертикальный, справа внизу – изображение обработанное фильтром Лапласа.</p>

<p class=text align=left style='text-align:left'>Рисунок 8-18. Пример обработки
изображения двумерным фильтром для обнаружения ребер </p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1329" type="#_x0000_t75" alt="" style='width:465pt;height:348pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image230.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/8-18.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=620 height=464
src="OpenGL%20Red%20Book.files/image230.jpg" v:shapes="_x0000_i1329"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Пример 8-6. Использование
двумерных фильтров: файл convolution.cpp</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#include &lt;windows.h&gt;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#include &lt;glut.h&gt;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#include &lt;GL/glaux.h&gt;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#include &quot;glext.h&quot;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>//Указатель на память, где будет содержаться картинка<o:p></o:p></span></pre><pre><span
  style='color:black'>AUX_RGBImageRec *image;<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>//Определить фильтры<o:p></o:p></span></pre><pre><span
  style='color:black'>GLfloat horizontal[3][3]={{0,-1,0},{0,1,0},{0,0,0}};<o:p></o:p></span></pre><pre><span
  style='color:black'>GLfloat vertical[3][3]=<span style='mso-spacerun:yes'>  </span>{{0,0,0},{-1,1,0},{0,0,0}};<o:p></o:p></span></pre><pre><span
  style='color:black'>GLfloat laplacian[3][3]= {{-0.125,-0.125,-0.125},<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                          </span>{-0.125,1,-0.125},<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                          </span>{-0.125,-0.125,-0.125}};<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>//Тип и указатель для фильтра (если конечно расширение поддерживается)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>typedef void (APIENTRY * GLCONVOLUTIONFILTER2D) <o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>(GLenum target,GLenum internalFormat,GLsizei width,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>       </span>GLsizei height,GLenum format, GLenum type, const GLvoid *data);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>GLCONVOLUTIONFILTER2D glConvolutionFilter2D=NULL;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void init()<o:p></o:p></span></pre><pre><span
  style='color:black'>{<o:p></o:p></span></pre><pre><span style='color:black'><span style='mso-spacerun:yes'>      </span>//Проверяем, присутствует ли расширение GL_ARB_imaging (imaging subset)<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span></span><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>if (glutExtensionSupported(&quot;GL_ARB_imaging&quot;)==0)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>MessageBox(NULL,&quot;ARB_imaging extension not supported&quot;,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>          </span><span style='mso-spacerun:yes'>  </span>&quot;Using Two-Dimensional Convolution Filters&quot;,MB_OK|MB_ICONHAND);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span></span><span
  style='color:black'>exit(1);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>}<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>//Получаем указатель на функцию расширения<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glConvolutionFilter2D=(GLCONVOLUTIONFILTER2D)<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                             </span>wglGetProcAddress(&quot;glConvolutionFilter2D&quot;);<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>//Загружаем любую непалитровую картинку BMP<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span></span><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>image=auxDIBImageLoad(&quot;peak.bmp&quot;);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glPixelStorei(GL_UNPACK_ALIGNMENT,1);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glClearColor(0,0,0,0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void deinit()<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>//</span><span
  style='color:black'>Освобождаемпамять</span><span lang=EN-US
  style='color:black;mso-ansi-language:EN-US'> <o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>delete image;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void keyboard(unsigned char key, int x, int y)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>switch(key)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>case 'h':<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>MessageBox(NULL,&quot;Using horizontal filter&quot;,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                        </span>&quot;Using Two-Dimensional Convolution Filters&quot;,MB_OK);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>glConvolutionFilter2D(GL_CONVOLUTION_2D,GL_LUMINANCE,3,3,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                                       </span>GL_LUMINANCE,GL_FLOAT,horizontal);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>glEnable(GL_CONVOLUTION_2D);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>break;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>case 'v':<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>MessageBox(NULL,&quot;Using vertical filter&quot;,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                        </span>&quot;Using Two-Dimensional Convolution Filters&quot;,MB_OK);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>glConvolutionFilter2D(GL_CONVOLUTION_2D,GL_LUMINANCE,3,3,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                                       </span>GL_LUMINANCE,GL_FLOAT,vertical);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>               </span><span style='mso-spacerun:yes'>   </span>glEnable(GL_CONVOLUTION_2D);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>break;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>case 'l':<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>MessageBox(NULL,&quot;Using laplacian filter&quot;,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                        </span>&quot;Using Two-Dimensional Convolution Filters&quot;,MB_OK);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>glConvolutionFilter2D(GL_CONVOLUTION_2D,GL_LUMINANCE,3,3,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                                       </span>GL_LUMINANCE,GL_FLOAT,laplacian);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>glEnable(GL_CONVOLUTION_2D);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>break;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>case 'r':<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>MessageBox(NULL,&quot;No filter used&quot;,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>  </span><span style='mso-spacerun:yes'>                      </span>&quot;Using Two-Dimensional Convolution Filters&quot;,MB_OK);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>glDisable(GL_CONVOLUTION_2D);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>break;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>case 27:<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>exit(0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutPostRedisplay();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void reshape(int w, int h)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glViewport(0,0,(GLsizei) w, (GLsizei) h);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glMatrixMode(GL_PROJECTION);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glLoadIdentity();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>gluOrtho2D(0,540,0,405);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void display()<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glClear(GL_COLOR_BUFFER_BIT);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glRasterPos2i(1,1);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glDrawPixels(image-&gt;sizeX,image-&gt;sizeY,GL_RGB, <o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                   </span>GL_UNSIGNED_BYTE,image-&gt;data);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glFlush();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>int APIENTRY WinMain(HINSTANCE hInstance,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                     </span>HINSTANCE hPrevInstance,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                     </span>LPSTR<span style='mso-spacerun:yes'>     </span>lpCmdLine,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                     </span>int<span style='mso-spacerun:yes'>       </span>nCmdShow)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>char* argv=&quot;&quot;;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>int argc=0;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutInit(&amp;argc,&amp;argv);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutInitWindowSize(540,405);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutCreateWindow(&quot;Using Two-Dimensional Convolution Filters&quot;);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>init();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutDisplayFunc(display);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutReshapeFunc(reshape);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutKeyboardFunc(keyboard);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutMainLoop();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>deinit();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>return 0;<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Как и в случае с цветовыми
таблицами, вы можете задать фильтр с помощью пиксельных величин, взятых из
буфера кадра. Команда <b>glCopyConvolutionFilter2D()</b> копирует прямоугольник
пикселей из текущего буфера для чтения (GL_READ_BUFFER) для использования в
качестве данных фильтра. Если в качестве внутреннего формата используется
GL_LUMINANCE или GL_INTENSITY, то в качестве величин фильтра берутся красные
компоненты пикселей.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glCopyConvolutionFilter2D</b>
  (GLenum <i>target</i>, GLenum <i>internalFormat</i>, GLint <i>x</i>, GLint <i>y</i>,
  GLsizei <i>width</i>, GLsizei <i>height</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Задает двумерный фильтр,
инициализируя его пикселями из цветового буфера кадра. Аргумент <i>target </i>должен
иметь значение GL_CONVOLUTION_2D, а <i>internalFormat </i>должен быть
установлен в одно из значений, допустимых для <b>glConvolutionFilter2D()</b>.&nbsp;&nbsp;&nbsp;&nbsp;
Прямоугольник пикселей с левым нижним углом в точке (<i>x</i>; <i>y</i>) и
размерами <i>width </i>и <i>height</i> считывается из буфера кадра и
конвертируется в <i>internalFormat</i>. </p>

<h2>8.2.5.2.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Разделяемые двумерные фильтры</h2>

<p class=text align=left style='text-align:left'>Фильтры являются разделяемым,
если они могут быть представлены в виде произведения двух одномерных фильтров.</p>

<p class=text align=left style='text-align:left'>Для создания двух одномерных
фильтров, представляющих разделяемый двумерный фильтр, применяется команда <b>glSeparableFilter2D()</b>.
Также как и в случае <b>glConvolutionFilter2D()</b> внутренний формат определяет
то, как будут обрабатываться пиксели.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glSeparableFilter2D</b>
  (GLenum <i>target</i>, GLenum <i>internalFormat</i>, GLsizei <i>width</i>,
  GLsizei <i>height</i>,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  GLenum <i>format</i>, GLenum <i>type</i>, const GLvoid *<i>row</i>, const
  GLvoid *<i>column</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Создает разделяемый двумерный
фильтр. <i>target </i>должен быть установлен в значение GL_SEPARABLE_2D.
Аргумент <i>internalFormat </i>может иметь те же значения, что и для команды <b>glConvolutionFilter2D()</b>.
Аргумент <i>width </i>задает количество пикселей в массиве <i>row</i>. Похожим
образом <i>height </i>задает число пикселей в массиве <i>column</i>. <i>type </i>и
<i>format</i> так же как в команде <b>glConvolutionFilter2D()</b> определяют
формат хранения для массивов <i>row </i>и <i>column</i>.</p>

<p class=text align=left style='text-align:left'>Чтобы включить обработку
пикселей разделяемыми двумерными фильтрами, используйте <b>glEnable(GL_SEPARABLE_2D)</b>.
Если создан разделяемый фильтр, то он будет работать только в случае если
активизированы оба режима: GL_CONVOLUTION_2D и GL_SEPARABLE_2D.</p>

<p class=text align=left style='text-align:left'>Например, вы можете создать
фильтр 3x3, задав одномерный фильтр [-1/2, 1, -1/2] и для <i>row</i>, и для <i>column
</i>разделяемого фильтра GL_LUMINANCE. OpenGL вычислит результирующее
изображение с использованием двух одномерных фильтров так же, как она вычисляет
его с использованием двумерного фильтра, вычислив следующее произведение: </p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1330" type="#_x0000_t75" alt="" style='width:291pt;height:64.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image231.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form44.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=388 height=86
src="OpenGL%20Red%20Book.files/image231.jpg" v:shapes="_x0000_i1330"><![endif]>.</p>

<p class=text align=left style='text-align:left'>Использование разделяемых
двумерных фильтров более эффективно с точки зрения вычислений, чем
использование неразделимого двумерного фильтра.</p>

<h2>8.2.5.2.2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Одномерные фильтры</h2>

<p class=text align=left style='text-align:left'>Одномерные фильтры идентичны
двумерным за тем исключением, что высота фильтра предполагается равной 1.
Однако одномерные фильтры влияют только на одномерные текстуры.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glConvolutionFilter1D</b>
  (GLenum <i>target</i>, GLenum <i>internalFormat</i>, GLsizei <i>width</i>,
  GLenum <i>format</i>, GLenum <i>type</i>, const GLvoid *<i>image</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Задает одномерный фильтр.
Аргумент <i>target </i>должен быть установлен в значение GL_CONVOLUTION_1D.
Аргумент <i>width </i>задает количество пикселей в фильтре. Аргументы <i>internalFormat</i>,
<i>type </i>и <i>format</i> имеют то же значение, что и соответствующие
параметры <b>glConvolutionFilter2D()</b>. <i>image </i>указывает на одномерное
изображение, которое будет использоваться в качестве фильтра.</p>

<p class=text align=left style='text-align:left'>Для активизации одномерной
фильтрации используйте команду <b>glEnablee(GL_CONVOLUTION_1D)</b>.</p>

<p class=text align=left style='text-align:left'>Возможно, вам понадобится
задать фильтр с помощью величин, взятых из буфера кадра. Команда <b>glCopyConvolutionFilterr1D()</b>
копирует ряд пикселей из текущего буфера для чтения (GL_READ_BUFFER),
конвертирует их в заданный внутренний формат и использует их в качестве
фильтра.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glCopyConvolutionFilter1D</b>
  (GLenum <i>target</i>, GLenum <i>internalFormat</i>, GLint <i>x</i>, GLint <i>y</i>,
  GLsizei <i>width</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Создает одномерный фильтр с
помощью пикселей взятых из буфера кадра. <b>glCopyConvolutionFilter1D()</b>
копирует <i>width </i>пикселей, начиная с позиции (<i>x</i>, <i>y</i>) и
конвертирует их в <i>internalFormat</i>.</p>

<p class=text align=left style='text-align:left'>Когда фильтр создан, он может
быть смасштабирован и скошен. Масштаб и скос задаются с помощью команды <b>glConvolutionParameter*()</b>.
Фильтр не приводится к какому-либо диапазону после масштабирования и скоса.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glConvolutionParameter</b>{if}
  (GLenum <i>target</i>, GLenum <i>pname</i>, TYPE <i>param</i>);<br>
  void <b>glConvolutionParameter</b>{if}<b>v</b> (GLenum <i>target</i>, GLenum <i>pname</i>,
  TYPE *<i>params</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Устанавливают параметры,
управляющие тем, как производится фильтрация. Аргумент <i>target</i>должен быть
установлен в значения GL_CONVOLUTION_1D, GL_CONVOLUTION_2D или GL_SEPARABLE_2D.
Аргумент<span style='mso-ansi-language:EN-US'> <i><span lang=EN-US>pname</span></i><span
lang=EN-US> </span></span>должен<span style='mso-ansi-language:EN-US'> </span>принимать<span
style='mso-ansi-language:EN-US'> </span>одно<span style='mso-ansi-language:
EN-US'> </span>из<span style='mso-ansi-language:EN-US'> </span>значений<span
lang=EN-US style='mso-ansi-language:EN-US'> GL_CONVOLUTION_BORDER_MODE,
GL_CONVOLUTION_FILTER_SCALE </span>или<span lang=EN-US style='mso-ansi-language:
EN-US'> GL_CONVOLUTION_FILTER_BIAS. </span>Указание в качестве аргумента <i>pname
</i>значения GL_CONVOLUTION_BORDER_MODE устанавливает режим границы фильтрации.
В<span style='mso-ansi-language:EN-US'> </span>этом<span style='mso-ansi-language:
EN-US'> </span>случае<span style='mso-ansi-language:EN-US'> <i><span
lang=EN-US>params</span></i><span lang=EN-US> </span></span>должно<span
style='mso-ansi-language:EN-US'> </span>иметь<span style='mso-ansi-language:
EN-US'> </span>значение<span lang=EN-US style='mso-ansi-language:EN-US'>
GL_REDUCE, GL_CONSTANT_BORDER </span>или<span lang=EN-US style='mso-ansi-language:
EN-US'> GL_REPLICATE_BORDER. </span>Если <i>pname </i>установлен в
GL_CONVOLUTION_FILTER_SCALE или GL_CONVOLUTION_FILTER_BIAS, <i>params </i>должен
указывать на массив из 4-ех цветовых величин для красного, зеленого, синего и
альфа, соответственно.</p>

<h2>8.2.5.2.3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Режимы границы</h2>

<p class=text align=left style='text-align:left'>Пиксели изображения,
находящиеся на верхней и левой границах, обрабатываются иначе, чем внутренние
пиксели. Результат по ним подвергается модификации в зависимости от режима
границы фильтра. Существует три варианта фильтрования граничных пикселей:</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l27 level1 lfo34;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>режим GL_REDUCE приводит к тому, что изображение
уменьшается в каждом из направлений. Ширина изображения уменьшается до (<i>width</i>-1).
Точно так же высота изображения сокращается (<i>height</i>-1). Если такое
сокращение приводит к тому, что изображение имеет нулевые или отрицательные
размеры, выходное изображение не генерируется, но также не генерируется никаких
ошибок.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l27 level1 lfo34;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>GL_CONSTANT_BORDER вычисляет фильтрованные
граничные пиксели с использованием постоянной пиксельной величины для пикселей
вне исходного изображения. Постоянная пиксельная величина задается с помощью
команды <b>glConvolutionParameter*()</b>. Размер результирующего изображения
совпадает с размерами исходного.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l27 level1 lfo34;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>GL_REPLICATE_BORDER производит вычисления
способом аналогичным GL_CONSTANT_BORDER за тем исключением, что последний ряд и
колонка пикселей используется для пикселей, лежащих вне исходного изображения.
Размер результирующего изображения совпадает с размерами исходного.</p>

<h2>8.2.5.2.4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Пост фильтрационные операции</h2>

<p class=text align=left style='text-align:left'>После того, как операция
фильтрации завершена, пиксели могут быть масштабированы и скошены. Затем они
приводятся к диапазону [0; 1]. Величины масштаба и скоса задаются командой <b>glPixelTransfer*()</b>,
с аргументами GL_POST_CONVOLUTION_*_SCALEили GL_POST_CONVOLUTION_*_BIAS. Если
задать цветовую таблицу командой <b>glColorTable()</b> с аргументом
GL_POST_CONVOLUTION_COLOR_TABLE, то пиксели после фильтрации будут заменены с
использованием этой таблицы.</p>

<h2>8.2.5.3&nbsp;&nbsp;&nbsp; Цветовая матрица</h2>

<p class=text align=left style='text-align:left'>Для конверсии цветовых
пространств и линейных преобразований пиксельных величин, подмножество
обработки изображений поддерживает стек матриц 4x4, выбираемый с помощью
команды <b>glMatrixMode(GL_COLOR)</b>. Например, чтобы преобразовать цветовое
пространство RGB в CMY (cyan – голубой, magenta – фиолетовый, yellow – желтый)
можно произвести следующие вызовы:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  style='color:black'>GLfloat rgb2cmy[16]= {-1,0,0,0,<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                       </span>0,-1,0,0,<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                       </span>0,0,-1,0,<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>       </span><span style='mso-spacerun:yes'>                </span>1,1,1,1}; <o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>glMatrixMode(GL_COLOR);<span style='mso-spacerun:yes'>      </span>//войти в режим цветовой матрицы<o:p></o:p></span></pre><pre><span
  style='color:black'>glLoadMatrixf(rgb2cmy);<o:p></o:p></span></pre><pre><span
  style='color:black'>glMatrixMode(GL_MODELVIEW);<span style='mso-spacerun:yes'>  </span>//назад к видовой матрице<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<p class=warning><b>Замечание:</b> помните о том, что матрицы в OpenGL хранятся
по столбцам.</p>

<p class=text align=left style='text-align:left'>Стек цветовых матриц должен
быть достаточного размера для хранения как минимум двух матриц. В отличие от
других частей подмножества обработки изображений конверсия с помощью цветовой
матрицы производится всегда и не может быть выключена.</p>

<p class=text align=left style='text-align:left'>Пример 8-7 иллюстрирует
использование цветовой матрицы для перемены местами красного и зеленого
компонентов изображения. Результат работы программы показан на рисунке 8-19.
Здесь слева изображено исходное изображение, а справа – обработанное с помощью
цветовой матрицы.</p>

<p class=text align=left style='text-align:left'>Рисунок 8-19. Результат
обработки изображения цветовой матрицей, меняющей местами компоненты R и G </p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1331" type="#_x0000_t75" alt="" style='width:465pt;height:174pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image232.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/8-19.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=620 height=232
src="OpenGL%20Red%20Book.files/image232.jpg" v:shapes="_x0000_i1331"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Пример 8-7. Обмен цветовых
компонент с помощью цветовой матрицы: файл colormatrix.cpp</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#include &lt;windows.h&gt;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#include &lt;glut.h&gt;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#include &lt;glaux.h&gt;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#include &quot;glext.h&quot;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>//Указатель на память, где будет содержаться картинка<o:p></o:p></span></pre><pre><span
  style='color:black'>AUX_RGBImageRec *image;<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>//Задать цветовую матрицу для изменения порядка цветов в пикселе<o:p></o:p></span></pre><pre><span
  style='color:black'>//изображения с RGB в GBR<o:p></o:p></span></pre><pre><span
  style='color:black'>GLfloat m[16]={<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>0.0,1.0,0.0,0.0,<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>0.0,0.0,1.0,0.0,<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>1.0,0.0,0.0,0.0,<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>0.0,0.0,0.0,1.0<o:p></o:p></span></pre><pre><span
  style='color:black'>};<o:p></o:p></span></pre><pre><span style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>//Флаг показывающий, используем мы матрицу или нет<o:p></o:p></span></pre><pre><span
  style='color:black'>bool reversing;<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>void init()<o:p></o:p></span></pre><pre><span
  style='color:black'>{<o:p></o:p></span></pre><pre><span style='color:black'><span style='mso-spacerun:yes'>  </span><span style='mso-spacerun:yes'>    </span>//Проверяем, присутствует ли расширение GL_ARB_imaging (imaging subset)<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span></span><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>if (glutExtensionSupported(&quot;GL_ARB_imaging&quot;)==0)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>MessageBox(NULL,&quot;ARB_imaging extension not supported&quot;,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>&quot;Using Color Matrix&quot;,MB_OK|MB_ICONHAND);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span></span><span
  style='color:black'>exit(1);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>}<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>//Загружаем любую непалитровую картинку BMP<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span></span><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>image=auxDIBImageLoad(&quot;tree.bmp&quot;);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glPixelStorei(GL_UNPACK_ALIGNMENT,1);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glClearColor(0,0,0,0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>reversing=false;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void deinit()<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>//</span><span
  style='color:black'>Освобождаем</span><span style='color:black;mso-ansi-language:
  EN-US'> </span><span style='color:black'>память</span><span lang=EN-US
  style='color:black;mso-ansi-language:EN-US'> <o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>delete image;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void reshape(int w, int h)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glViewport(0,0,(GLsizei) w, (GLsizei) h);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glMatrixMode(GL_PROJECTION);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glLoadIdentity();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>gluOrtho2D(0,542,0,407);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void keyboard(unsigned char key,int x,int y)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>    </span><span style='mso-spacerun:yes'>  </span>switch(key)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>case 'r':<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>if (!reversing)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span></span><span
  style='color:black'>{<o:p></o:p></span></pre><pre><span style='color:black'><span style='mso-spacerun:yes'>                        </span>//Для расширения цветовой таблицы<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                        </span>//нужен только идентификатор GL_COLOR<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                        </span>//при отсутствии этого расширения<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                        </span>//код ниже не сработает<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                        </span></span><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glMatrixMode(GL_COLOR);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                        </span>glLoadMatrixf(m);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                        </span>glMatrixMode(GL_MODELVIEW);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>else<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>   </span><span style='mso-spacerun:yes'>               </span>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                        </span>glMatrixMode(GL_COLOR);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                        </span>glLoadIdentity();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                        </span>glMatrixMode(GL_MODELVIEW);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>reversing=!reversing;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>glutPostRedisplay();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>break;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>case 27:<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>exit(0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>break;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void display()<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glClear(GL_COLOR_BUFFER_BIT);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glRasterPos2i(1,1);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glDrawPixels(image-&gt;sizeX,image-&gt;sizeY,GL_RGB,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>             </span><span style='mso-spacerun:yes'>       </span>GL_UNSIGNED_BYTE,image-&gt;data);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glFlush();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>int APIENTRY WinMain(HINSTANCE hInstance,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                     </span>HINSTANCE hPrevInstance,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                     </span>LPSTR<span style='mso-spacerun:yes'>     </span>lpCmdLine,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                     </span>int<span style='mso-spacerun:yes'>       </span>nCmdShow)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>char* argv=&quot;&quot;;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>    </span><span style='mso-spacerun:yes'>  </span>int argc=0;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutInit(&amp;argc,&amp;argv);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutInitWindowSize(542,407);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutCreateWindow(&quot;Exchanging Color Components Using the Color Matrix&quot;);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>init();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutDisplayFunc(display);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>     </span><span style='mso-spacerun:yes'> </span>glutReshapeFunc(reshape);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutKeyboardFunc(keyboard);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutMainLoop();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>deinit();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>return 0;<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<h2>8.2.5.3.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Пост матричные операции</h2>

<p class=text align=left style='text-align:left'>Также как и в случае пост –
фильтрационных&nbsp; операций, после применения цветовой матрицы пиксели могут
быть масштабированы и скошены. Вызовы функции <b>glPixelTransfer*()</b> с
аргументами GL_POST_COLOR_MATRIX_*_SCALE или GL_POST_COLOR_MATRIX_*_BIAS
позволяют задать параметры масштабирования или скоса соответственно. После
масштабирования и скоса пиксели приводятся к диапазону [0; 1].</p>

<h2>8.2.5.4&nbsp;&nbsp;&nbsp; Гистограмма</h2>

<p class=text align=left style='text-align:left'>Используя подмножество
обработки изображений, вы можете собирать статистику по изображениям.
Гистограмма позволяет увидеть распределение цветовых величин по изображению,
которое, например, может быть использовано для балансировки контраста
изображения.</p>

<p class=text align=left style='text-align:left'>Команда <b>glHistogram()</b>
позволяет задать, какие компоненты изображения вы хотите использовать для
создания гистограммы, а также, хотите ли вы только собрать статистику или
продолжить обработку изображения. Чтобы собрать гистограммную статистику, вы
должны выполнить команду <b>glEnable(GL_HISTOGRAMM)</b>.</p>

<p class=text align=left style='text-align:left'>Для гистограммы, так же как и
для цветовых таблиц, прокси механизм доступен для того, чтобы определить
достаточно ли в системе ресурсов для хранения требуемой гистограммы. Если
ресурсов не хватает, длина гистограммы, ее формат и разрешения компонент
устанавливаются в 0. Вы можете запросить результаты прокси гистограммы,
используя команду <b>glHistogramParameter()</b>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glHistogram</b>
  (GLenum <i>target</i>, GLsizei <i>width</i>, GLenum <i>internalFormat</i>,
  GLboolean <i>sink</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Задает, как должны сохраняться
данные гистограммы изображения. Параметр <i>target </i>должен быть установлен в
одно из значений GL_HISTOGRAM или GL_PROXY_HISTOGRAM. Параметр <i>width </i>задает
количество вхождений в таблицу гистограммы. Его значение должно быть степенью
2. Параметр <i>internalFormat </i>определяет, как должны сохраняться данные
гистограммы. Допустимыми значениями являются: GL_ALPHA, GL_ALPHA4, GL_ALPHA8,
GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8,
GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4,
GL_LUMINANCE6_ALPHA2, GL_LUMINANCE_8ALPHA8, GL_LUMINANCE12_ALPHA4,
GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_RGB, GL_RGB2, &nbsp;GL_RGB4,
GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4,
GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16. В этом списке нет
величин GL_INTENSITY*. Этот список отличается от величин допустимых для <b>glColorTable()</b>.
Параметр <i>sink </i>индицирует, должны ли пиксели проходить дальше на этап
вычисления минимума/максимума или следует их отбросить..</p>

<p class=text align=left style='text-align:left'>После того, как вы передали
пиксели на конвейер с использованием <b>glDrawPixels()</b>, вы можете получить
результаты гистограммы, используя <b>glGetHistogram()</b>. Помимо получения
значений гистограммы, <b>glGetHistogram()</b> может быть использована для
сброса внутреннего хранилища гистограммы. Внутреннее хранилище также может быть
сброшено с помощью функции <b>glResetHistogram()</b>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glGetHistogram</b>
  (GLenum <i>target</i>, GLboolean <i>reset</i>, GLenum <i>format</i>, GLenum <i>type</i>,
  GLvoid *<i>values</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Возвращает собранную
статистику в виде гистограммы. Параметр <i>target </i>должен быть установлен в
значение GL_HISTOGRAM. Параметр <i>reset</i>задает, должно ли внутренне
хранилище гистограммы быть сброшено. Параметры <i>format </i>и <i>type </i>задают
формат хранения массива <i>values</i> и то, как данные гистограммы должны быть
возвращены приложению. Эти аргументы принимают те же значения, что и
соответствующие параметры <b>glDrawPixels()</b>.</p>

<p class=text align=left style='text-align:left'>В примере 8-8 программа
вычисляет гистограмму изображения и выводит результирующее распределение на
экран. Клавиша ‘s’ влияет на значение параметра <i>sink</i>, контролирующего
дальнейший путь пикселей исходного изображения – будут ли они пропущены на
следующий этап конвейера или отброшены. Рисунок 8-20 демонстрирует исходное
изображение (слева), а также изображение с наложенной на него гистограммой
(справа).</p>

<p class=text align=left style='text-align:left'>Рисунок 8-20. Исходное
изображение и его гистограмма </p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1332" type="#_x0000_t75" alt="" style='width:464.25pt;height:174pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image233.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/8-20.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=619 height=232
src="OpenGL%20Red%20Book.files/image233.jpg" v:shapes="_x0000_i1332"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Пример 8-8. Вычисление
гистограммы изображения: файл histogram.cpp</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#include &lt;windows.h&gt;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#include &lt;glut.h&gt;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#include &lt;glaux.h&gt;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#include &quot;glext.h&quot;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#define HISTOGRAM_SIZE 256<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>GLboolean sink=GL_FALSE;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>//Указатель на память, где будет содержаться картинка<o:p></o:p></span></pre><pre><span
  style='color:black'>AUX_RGBImageRec *image;<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>//Тип и указатель для функции определяющей как данные гистограммы изображения будут сохранены<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>typedef void (APIENTRY * GLHISTOGRAM) <o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>(GLenum target,GLsizei width, <o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>       </span>GLenum internalFormat, GLboolean sink);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>GLHISTOGRAM glHistogram=NULL;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>//Тип и указатель для функции получения статистики по гистограмме<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>typedef void (APIENTRY * GLGETHISTOGRAM) <o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>(GLenum target,GLboolean reset, GLenum format, <o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>       </span>GLenum type, const GLvoid *values);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>GLGETHISTOGRAM glGetHistogram=NULL;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void init()<o:p></o:p></span></pre><pre><span
  style='color:black'>{<o:p></o:p></span></pre><pre><span style='color:black'><span style='mso-spacerun:yes'>      </span>//Проверяем, присутствует ли расширение GL_ARB_imaging (imaging subset)<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span></span><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>if (glutExtensionSupported(&quot;GL_ARB_imaging&quot;)==0)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>MessageBox(NULL,&quot;ARB_imaging extension not supported&quot;,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>&quot; Compute and Diagram an Image's Histogram &quot;,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>MB_OK|MB_ICONHAND);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>exit(1);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>//</span><span
  style='color:black'>Получаем</span><span style='color:black;mso-ansi-language:
  EN-US'> </span><span style='color:black'>указатель</span><span
  style='color:black;mso-ansi-language:EN-US'> </span><span style='color:black'>на</span><span
  style='color:black;mso-ansi-language:EN-US'> </span><span style='color:black'>функции</span><span
  style='color:black;mso-ansi-language:EN-US'> </span><span style='color:black'>расширения</span><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glHistogram=(GLHISTOGRAM)wglGetProcAddress(&quot;glHistogram&quot;);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glGetHistogram=(GLGETHISTOGRAM)wglGetProcAddress(&quot;glGetHistogram&quot;);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>//</span><span
  style='color:black'>Загружаем</span><span style='color:black;mso-ansi-language:
  EN-US'> </span><span style='color:black'>любую</span><span style='color:black;
  mso-ansi-language:EN-US'> </span><span style='color:black'>непалитровую</span><span
  style='color:black;mso-ansi-language:EN-US'> </span><span style='color:black'>картинку</span><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'> BMP<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>image=auxDIBImageLoad(&quot;pyr.bmp&quot;);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glPixelStorei(GL_UNPACK_ALIGNMENT,1);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glClearColor(0,0,0,0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glHistogram(GL_HISTOGRAM,HISTOGRAM_SIZE,GL_RGB,sink);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glEnable(GL_HISTOGRAM);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void deinit()<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>//</span><span
  style='color:black'>Освобождаем</span><span style='color:black;mso-ansi-language:
  EN-US'> </span><span style='color:black'>память</span><span lang=EN-US
  style='color:black;mso-ansi-language:EN-US'> <o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>delete image;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void keyboard(unsigned char key, int x, int y)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>switch(key)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>case 's':<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>sink=!sink;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>glHistogram(GL_HISTOGRAM,HISTOGRAM_SIZE,GL_RGB,sink);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>glutPostRedisplay();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>break;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>case 27:<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>deinit();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>exit(0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>break;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void reshape(int w, int h)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glViewport(0,0,(GLsizei) w, (GLsizei) h);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glMatrixMode(GL_PROJECTION);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glLoadIdentity();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>gluOrtho2D(0,540,0,405);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void display()<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>int i;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>GLushort values[HISTOGRAM_SIZE][3];<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glClear(GL_COLOR_BUFFER_BIT);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glRasterPos2i(1,1);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glDrawPixels(image-&gt;sizeX,image-&gt;sizeY,GL_RGB,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                   </span>GL_UNSIGNED_BYTE,image-&gt;data);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glGetHistogram(GL_HISTOGRAM,GL_TRUE,GL_RGB,GL_UNSIGNED_SHORT,values);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>//Plot histogram<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glBegin(GL_LINE_STRIP);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>           </span><span style='mso-spacerun:yes'> </span>glColor3f(1.0,0.0,0.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>for(i=0;i&lt;HISTOGRAM_SIZE;i++)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>glVertex2s(i,values[i][0]);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glEnd();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glBegin(GL_LINE_STRIP);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>glColor3f(0.0,1.0,0.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>for(i=0;i&lt;HISTOGRAM_SIZE;i++)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>glVertex2s(i,values[i][1]);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glEnd();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glBegin(GL_LINE_STRIP);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>glColor3f(0.0,0.0,1.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>for(i=0;i&lt;HISTOGRAM_SIZE;i++)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>glVertex2s(i,values[i][2]);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glEnd();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glFlush();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>  </span><o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>int APIENTRY WinMain(HINSTANCE hInstance,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                     </span>HINSTANCE hPrevInstance,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                     </span>LPSTR<span style='mso-spacerun:yes'>     </span>lpCmdLine,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                     </span>int<span style='mso-spacerun:yes'>       </span>nCmdShow)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>char* argv=&quot;&quot;;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>int argc=0;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutInit(&amp;argc,&amp;argv);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutInitWindowSize(540,405);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutCreateWindow(&quot;Compute and Diagram an Image's Histogram&quot;);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>init();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutDisplayFunc(display);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutReshapeFunc(reshape);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutKeyboardFunc(keyboard);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutMainLoop();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>deinit();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>return 0;<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Команда <b>glResetHistogram()</b>
сбрасывает гистограмму без извлечения ее данных.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>glResetHistogram</b>
  (GLenum <i>target</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Сбрасывает счетчики
гистограммы в 0. Параметр <i>target </i>должен быть установлен в GL_HISTOGRAM.</p>

<h2>8.2.5.5&nbsp;&nbsp;&nbsp; Минимум и максимум</h2>

<p class=text align=left style='text-align:left'>Команда <b>glMinmax()</b>
вычисляет минимальное и максимальное значения компонентов пикселя из
пиксельного прямоугольника. Как и в случае <b>glHistogram()</b> после
вычисления минимальной и максимальной величин вы можете либо передать пиксели
дальше по конвейеру, либо прекратить процесс визуализации.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glMinmax</b>
  (GLenum <i>target</i>, GLenum <i>internalFormat</i>, GLboolean <i>sink</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Вычисляет минимальное и
максимальное значения пикселей изображения. Аргумент <i>target </i>должен быть
установлен в GL_MINMAX.&nbsp; <i>internalFormat </i>задает для каких компонент
должны быть вычислены значения минимума и максимума. Допустимыми значениями для
<i>internalFormat </i>команды <b>glMinmax()</b> являются те же, что и для
команды <b>glHistogram()</b>. Если аргумент <i>sink </i>установлен в GL_TRUE,
то после вычисления минимума и максимума путь пикселей по конвейеру
прекращается, иначе их обработка продолжается.</p>

<p class=text align=left style='text-align:left'>&nbsp;Для получения
вычисленных значений используется команда <b>glGetMinmax()</b>. Так же как в
случае <b>glGetHistogram()</b> внутренние значения могут быть сброшены после их
получения.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glGetMinmax</b>
  (GLenum <i>target</i>, GLboolean <i>reset</i>, GLenum <i>format</i>, GLenum <i>type</i>,
  GLvoid *<i>values</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Возвращает результаты
вычисления минимума и максимума. Аргумент <i>target </i>должен быть установлен
в GL_MINMAX. Если аргумент <i>reset </i>равен GL_TRUE, значения минимума и максимума
сбрасываются в свои начальные значения. Аргументы <i>format </i>и <i>type </i>задают
формат значений возвращаемых в массиве <i>values </i>и могут принимать те же
значения, что и аналогичные параметры команды <b>glDrawPixels()</b>.</p>

<p class=text align=left style='text-align:left'>Пример 8-9 демонстрирует
использование команды <b>glMinMax()</b> для вычисления минимального и
максимального значений компонент пикселей в формате GL_RGB. Пример исходного
изображения и результатов работы программы можно увидеть на рисунке 8-21.
Операция вычисления минимума и максимума должна быть активизирована с
использованием команды <b>glEnable(GL_MINMAX)</b>. </p>

<p class=text align=left style='text-align:left'>В массиве, возвращенном
командой <b>glGetMinmax()</b> первыми элементами идут вычисленные минимумы для
всех трех цветовых компонент, а следом за ними – все максимумы.</p>

<p class=text align=left style='text-align:left'>Рисунок 8-21. Изображение и
экстремумы цветовых компонент его пикселей </p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1333" type="#_x0000_t75" alt="" style='width:390.75pt;height:337.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image234.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/8-21.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=521 height=450
src="OpenGL%20Red%20Book.files/image234.jpg" v:shapes="_x0000_i1333"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Пример 8-9. Вычисление
минимума и максимума пиксельных величин: файл minmax.cpp</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#include &lt;windows.h&gt;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#include &lt;glut.h&gt;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#include &lt;glaux.h&gt;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#include &lt;stdio.h&gt;<o:p></o:p></span></pre><pre><span
  style='color:black'>#include &quot;glext.h&quot;<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>//Указатель на память, где будет содержаться картинка<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>AUX_RGBImageRec *image;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>typedef void (APIENTRY * GLMINMAX) GLenum target, GLenum internalFormat, GLboolean sink);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>GLMINMAX glMinmax=NULL;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>typedef void (APIENTRY * GLGETMINMAX) GLenum target,GLboolean reset, GLenum format,GLenum type, const GLvoid *values);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>GLGETMINMAX glGetMinmax=NULL;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void init()<o:p></o:p></span></pre><pre><span
  style='color:black'>{<o:p></o:p></span></pre><pre><span style='color:black'><span style='mso-spacerun:yes'>      </span>//Проверяем, присутствует ли расширение GL_ARB_imaging (imaging subset)<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span></span><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>if (glutExtensionSupported(&quot;GL_ARB_imaging&quot;)==0)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>exit(1);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glMinmax=(GLMINMAX)wglGetProcAddress(&quot;glMinmax&quot;);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glGetMinmax=(GLGETMINMAX)wglGetProcAddress(&quot;glGetMinmax&quot;);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>//</span><span
  style='color:black'>Загружаем</span><span style='color:black;mso-ansi-language:
  EN-US'> </span><span style='color:black'>любую</span><span style='color:black;
  mso-ansi-language:EN-US'> </span><span style='color:black'>непалитровую</span><span
  style='color:black;mso-ansi-language:EN-US'> </span><span style='color:black'>картинку</span><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'> BMP<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>image=auxDIBImageLoad(&quot;tree.bmp&quot;);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glPixelStorei(GL_UNPACK_ALIGNMENT,1);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glClearColor(0,0,0,0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glMinmax(GL_MINMAX,GL_RGB,GL_FALSE);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glEnable(GL_MINMAX);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void deinit()<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>//</span><span
  style='color:black'>Освобождаем</span><span style='color:black;mso-ansi-language:
  EN-US'> </span><span style='color:black'>память</span><span lang=EN-US
  style='color:black;mso-ansi-language:EN-US'> <o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>delete image;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void reshape(int w, int h)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glViewport(0,0,(GLsizei) w, (GLsizei) h);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glMatrixMode(GL_PROJECTION);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glLoadIdentity();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>gluOrtho2D(0,540,0,405);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void display()<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>GLubyte values[6];<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glClear(GL_COLOR_BUFFER_BIT);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glRasterPos2i(1,1);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glDrawPixels(image-&gt;sizeX,image-&gt;sizeY,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                   </span>GL_RGB,GL_UNSIGNED_BYTE,image-&gt;data);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glGetMinmax(GL_MINMAX,GL_TRUE,GL_RGB,GL_UNSIGNED_BYTE,values);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glFlush();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>printf(&quot;Red<span style='mso-spacerun:yes'>  </span>: min = %d max = %d\n&quot;,values[0],values[3]);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>printf(&quot;Green: min = %d max = %d\n&quot;,values[1],values[4]);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>printf(&quot;Blue : min = %d max = %d\n&quot;,values[3],values[5]);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>int main(int argc,char* argv[])<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutInit(&amp;argc,argv);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutInitWindowSize(540,405);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutCreateWindow(&quot;Computing Minimum and Maximum Pixel Values&quot;);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>init();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutDisplayFunc(display);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutReshapeFunc(reshape);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span></span><span
  style='color:black'>glutMainLoop();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>deinit();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>return 0;<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Несмотря на то, что команда <b>glGetMinmax()</b>
позволяет сбрасывать величины минимума и максимума в их начальные значений, вы
также можете сделать это в любой момент при помощи команды <b>glResetMinmax()</b>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>glResetMinmax</b>
  (GLenum <i>target</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Сбрасывает величины минимума и
максимума в их начальные значения. Аргумент <i>target </i>должен быть
установлен в значение GL_MINMAX.</p>

<h2>8.2.5.6&nbsp;&nbsp;&nbsp; Комбинирование пикселей с использованием
уравнений наложения</h2>

<p class=text align=left style='text-align:left'>При использовании цветового
наложения цвета в буфере кадра складываются с поступающими фрагментами,
создавая новые цвета в буфере кадра. Подмножество обработки изображений
расширяет возможности цветового наложения, определяя дополнительные
математические комбинации. С помощью команды <b>glBlendEquation()</b> можно
указать, как модифицировать операцию, используемую для цветового наложения
входящих фрагментов на цвета в буфере кадра.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>glBlendEquation</b>
  (GLenum <i>mode</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Задает как цвета в буфере
кадра и цвета источника должны соединяться. Допустимыми значениями для <i>mode </i>являются
GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE, GL_MIN и GL_MAX. Значением <i>mode
</i>по умолчанию является GL_FUNC_ADD (сложение), которое, кроме того, является
единственно возможным при отсутствии подмножества обработки изображений.
Влияние различных режимов на результат цветового наложения отражен в таблице
8-10.</p>

<p class=text align=left style='text-align:left'>&nbsp;В таблице 8-10 <!--[if gte vml 1]><v:shape
 id="_x0000_i1334" type="#_x0000_t75" alt="" style='width:19.5pt;height:17.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image235.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form45.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=26 height=23
src="OpenGL%20Red%20Book.files/image235.jpg" v:shapes="_x0000_i1334"><![endif]>&nbsp;и
<!--[if gte vml 1]><v:shape id="_x0000_i1335" type="#_x0000_t75" alt=""
 style='width:19.5pt;height:18pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image236.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form46.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=26 height=24
src="OpenGL%20Red%20Book.files/image236.jpg" v:shapes="_x0000_i1335"><![endif]>&nbsp;представляют
цвета источника и приемника, параметры S и D в таблице представляют факторы
наложения источника и приемника, чье значение определяется в соответствии с
аргументами команды <b>glBlendFunc()</b>.</p>

<p class=text align=left style='text-align:left'>Таблица 8-10. Математические
операции, связанные с режимами наложения подмножества обработки изображений</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Режим наложения</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Математическая операция</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FUNC_ADD<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1336" type="#_x0000_t75"
   alt="" style='width:70.5pt;height:18pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image237.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form47.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=94 height=24
  src="OpenGL%20Red%20Book.files/image237.jpg" v:shapes="_x0000_i1336"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FUNC_SUBTRACT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1337" type="#_x0000_t75"
   alt="" style='width:70.5pt;height:17.25pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image238.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form48.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=94 height=23
  src="OpenGL%20Red%20Book.files/image238.jpg" v:shapes="_x0000_i1337"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FUNC_REVERSE_SUBTRACT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1338" type="#_x0000_t75"
   alt="" style='width:71.25pt;height:18.75pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image239.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form49.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=95 height=25
  src="OpenGL%20Red%20Book.files/image239.jpg" v:shapes="_x0000_i1338"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_MIN<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1339" type="#_x0000_t75"
   alt="" style='width:90.75pt;height:16.5pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image240.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form50.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=121 height=22
  src="OpenGL%20Red%20Book.files/image240.jpg" v:shapes="_x0000_i1339"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:5;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_MAX<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1340" type="#_x0000_t75"
   alt="" style='width:93pt;height:17.25pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image241.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form51.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=124 height=23
  src="OpenGL%20Red%20Book.files/image241.jpg" v:shapes="_x0000_i1340"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>В примере 8-10 демонстрируются
различные уравнения наложения. Для выбора режима наложения используются клавиши
‘a’, ’s’, ’r’, ’m’, ’x’. В качестве источника используется синий квадрат, в
качестве приемника используется желтый квадрат на заднем фоне. Фактор наложения
для обоих цветов установлен в GL_ONEкомандой <b>glBlendFunc()</b>.
Результирующее изображение во всех режимах вы можете увидеть на рисунке
8-22.&nbsp;</p>

<p class=text align=left style='text-align:left'>Рисунок 8-22. Различные
уравнения цветового наложения </p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1341" type="#_x0000_t75" alt="" style='width:465pt;height:96pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image242.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/8-22.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=620 height=128
src="OpenGL%20Red%20Book.files/image242.jpg" v:shapes="_x0000_i1341"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Пример 8-10. Демонстрация
уравнений наложения: файл blendeqn.cpp</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>/*<span style='mso-spacerun:yes'>   </span>'a' -&gt; GL_FUNC_ADD<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'> *<span style='mso-spacerun:yes'>   </span>'s' -&gt; GL_FUNC_SUBTRACT<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'> *<span style='mso-spacerun:yes'>   </span>'r' -&gt; GL_FUNC_REVERSE_SUBTRACT<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'> *<span style='mso-spacerun:yes'>   </span>'m' -&gt; GL_MIN<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'> *<span style='mso-spacerun:yes'>   </span>'x' -&gt; GL_MAX<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'> */<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#include &lt;glut.h&gt;<o:p></o:p></span></pre><pre><span
  style='color:black'>#include &quot;glext.h&quot;<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>//Тип и указатель для функции смешивающего уравнения<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>typedef void (APIENTRY * GLBLENDEQUATION) (GLenum mode);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>GLBLENDEQUATION glBlendEquation=NULL;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void init()<o:p></o:p></span></pre><pre><span
  style='color:black'>{<o:p></o:p></span></pre><pre><span style='color:black'><span style='mso-spacerun:yes'>      </span>//Проверяем, присутствует ли расширение GL_ARB_imaging (imaging subset)<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span></span><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>if (glutExtensionSupported(&quot;GL_ARB_imaging&quot;)==0)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>exit(1);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>   </span><span style='mso-spacerun:yes'>   </span>//</span><span
  style='color:black'>Получить</span><span style='color:black;mso-ansi-language:
  EN-US'> </span><span style='color:black'>указатель</span><span
  style='color:black;mso-ansi-language:EN-US'> </span><span style='color:black'>на</span><span
  style='color:black;mso-ansi-language:EN-US'> </span><span style='color:black'>функцию</span><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glBlendEquation=(GLBLENDEQUATION)wglGetProcAddress(&quot;glBlendEquation&quot;);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glClearColor(1.0,1.0,0.0,0.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glBlendFunc(GL_ONE,GL_ONE);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glEnable(GL_BLEND);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void keyboard(unsigned char key, int x, int y)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>switch(key)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>case 'a': case 'A':<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>glBlendEquation(GL_FUNC_ADD);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>break;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>case 's': case 'S':<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>glBlendEquation(GL_FUNC_SUBTRACT);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>break;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>         </span><span style='mso-spacerun:yes'>   </span>case 'r': case 'R':<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>glBlendEquation(GL_FUNC_REVERSE_SUBTRACT);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>break;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>case 'm': case 'M':<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>glBlendEquation(GL_MIN);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>break;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>case 'x': case 'X':<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>               </span><span style='mso-spacerun:yes'>   </span>glBlendEquation(GL_MAX);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>break;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>case 27:<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>exit(0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutPostRedisplay();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void reshape(int w, int h)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glViewport(0,0,(GLsizei) w, (GLsizei) h);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glMatrixMode(GL_PROJECTION);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>     </span><span style='mso-spacerun:yes'> </span>glLoadIdentity();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>gluOrtho2D(-1,1,-1,1);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void display()<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glClear(GL_COLOR_BUFFER_BIT);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glColor3f(0.0,0.0,1.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glRectf(-0.5,-0.5,0.5,0.5);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glFlush();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>int main (int argc, char **argv)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutInit(&amp;argc,argv);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>     </span><span style='mso-spacerun:yes'> </span>glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutInitWindowSize(500,500);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutCreateWindow(&quot;Demonstrating The Blend Equation Modes&quot;);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>init();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutDisplayFunc(display);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutReshapeFunc(reshape);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span></span><span
  style='color:black'>glutKeyboardFunc(keyboard);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glutMainLoop();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>return 0;<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<h2>8.2.5.7&nbsp;&nbsp;&nbsp; Постоянные факторы наложения</h2>

<p class=text align=left style='text-align:left'>Подмножество обработки
изображений предоставляет дополнительные факторы наложения, которые могут быть
использованы в команде <b>glBlendFunc()</b>. Эти дополнительные факторы описаны
в таблице 8-11.</p>

<p class=text align=left style='text-align:left'>Таблица 8-11. Факторы
наложения, предоставляемые подмножеством обработки изображений</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width=650 style='width:487.6pt;
 mso-cellspacing:1.5pt;margin-left:1.05pt;border:solid black 1.0pt;mso-border-alt:
 solid black .75pt;mso-padding-left-alt:3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Константа</span></b><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Принадлежность</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Вычисляемый фактор</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_CONSTANT_COLOR<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>источник или приемник<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>&nbsp; <!--[if gte vml 1]><v:shape id="_x0000_i1342" type="#_x0000_t75"
   alt="" style='width:92.25pt;height:18pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image243.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form52.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=123 height=24
  src="OpenGL%20Red%20Book.files/image243.jpg" v:shapes="_x0000_i1342"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_ONE_MINUS_CONSTANT_COLOR<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>источник или приемник<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1343" type="#_x0000_t75"
   alt="" style='width:143.25pt;height:18.75pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image244.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form53.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=191 height=25
  src="OpenGL%20Red%20Book.files/image244.jpg" v:shapes="_x0000_i1343"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_CONSTANT_ALPHA<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>источник или приемник<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1344" type="#_x0000_t75"
   alt="" style='width:90pt;height:18.75pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image245.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form54.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=120 height=25
  src="OpenGL%20Red%20Book.files/image245.jpg" v:shapes="_x0000_i1344"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_ONE_MINUS_CONSTANT_ALPHA<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>источник или приемник<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1345" type="#_x0000_t75"
   alt="" style='width:141.75pt;height:19.5pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image246.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов8.mht!http://www.progz.ru/images/opengl/chapter8/form55.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=189 height=26
  src="OpenGL%20Red%20Book.files/image246.jpg" v:shapes="_x0000_i1345"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:Verdana;
mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:Verdana;
mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:Verdana;
mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><a name=Глава9><span lang=EN-US style='display:none;
mso-hide:all;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></a></p>

<h1 align=left style='text-align:left'><span style='mso-bookmark:Глава9'>Глава
9. Текстурирование</span></h1>

<span style='mso-bookmark:Глава9'></span>

<p class=text align=left style='text-align:left'>До сих пор мы рисовали все
геометрические объекты либо одним цветом, либо с плавной закраской (когда
внутренние цвета рассчитываются интерполяцией цветов в вершинах) – то есть
объекты рисовались без текстурирования. Если вы хотите нарисовать массивную
кирпичную стену без текстурирования, каждый кирпичик должен быть нарисован в
виде отдельного полигона. Без текстурирования такая стена может потребовать
тысяч полигонов, хотя сама она является прямоугольной, и даже тогда кирпичи
будут выглядеть слишком гладкими и одинаковыми, то есть недостаточно
реалистичными.</p>

<p class=text align=left style='text-align:left'>Текстурирование (или наложение
текстур) позволяет прикрепить изображение кирпичной стены (полученное,
возможно, сканированием реальной фотографии) к полигону и нарисовать всю стену
в виде одного полигона. При использовании текстурирования можно быть уверенным
в том, что с полигоном в процессе всех преобразований будут происходить
правильные изменения. Например, если вы наблюдаете стену в перспективе,
кирпичи, находящиеся дальше от вас, будут выглядеть меньше тех, что ближе.
Другие примеры использования текстур включают симуляцию растительности на
полигонах, представляющих землю; наложение обоев на стены или придание объектам
вида физических материалов, например, мрамора, дерева или гранита. Хотя
наиболее естественным является наложение текстур на полигоны, текстуру можно
наложить на любой примитив – точку, линию, полигон, битовую карту или
изображение.</p>

<p class=text align=left style='text-align:left'>Поскольку существует так много
возможностей, текстурирование – это большой сложный предмет, и при работе с ним
вам несколько раз придется делать выбор техники программирования. Например,
большинство людей интуитивно понимают смысл двумерных текстур, но текстуры
могут также быть одномерными и даже трехмерными. Вы можете накладывать текстуры
на поверхности, созданные из нескольких полигонов, и на изогнутые поверхности,
вы также можете повторять текстуру в одном, двух или трех направлениях (в
зависимости от того в каком числе направлений текстура описана). Кроме того вы
можете накладывать текстуру таким образом, чтобы она выделяла контуры других
свойств рассматриваемого объекта. Блестящие объекты могут быть текстурированы
таким образом, как будто они находятся в центре комнаты и отражают изображения
окружающих предметов. Наконец, текстура может быть наложена на объект различными
способами. Она может быть нарисована на объекте, использоваться для модуляции
его цветов или комбинироваться с ними.</p>

<p class=text align=left style='text-align:left'>Текстуры – это просто
прямоугольные массивы данных, например, цветовых, световых или цветовых и
альфа. Индивидуальные элементы (значения) текстуры часто называются <i>тэкселями</i>
(<i>texels</i>). Что делает текстурирование сложным, так это то, что
прямоугольная текстура может быть наложена на непрямоугольный объект, и это
должно быть сделано каким-либо разумным способом.</p>

<p class=text align=left style='text-align:left'>Рисунок 9-1 иллюстрирует
процесс текстурирования. Левая часть рисунка представляет собой саму текстуру,
а белая линия – четырехугольную форму, углы которой будут наложены на
соответствующие точки текстуры. Когда четырехугольник отображается на экране,
он может быть искажен за счет различных преобразований – поворотов, переносов,
масштабирования и проецирования. Правая часть рисунка демонстрирует, как
выглядит четырехугольник на экране после этих преобразований. (Заметьте, что
четырехугольник является вогнутым и без предварительной тесселяции может быть
неверно отображен OpenGL.)</p>

<p class=text align=left style='text-align:left'>Рисунок 9-1. Процесс
текстурирования</p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1346" type="#_x0000_t75" alt="" style='width:465pt;height:168.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image247.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/9-1.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=620 height=225
src="OpenGL%20Red%20Book.files/image247.jpg" v:shapes="_x0000_i1346"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Обратите внимание на то, что
текстура изменяется, чтобы соответствовать искажениям четырехугольника. В
данном случае она слегка растянута в направлении xи сжата в направлении y. В
зависимости от размера текстуры, степени искажения четырехугольника и размера
изображения на экране. некоторые тэксели могут быть наложены более чем на один
фрагмент, а некоторые фрагменты могут покрываться несколькими тэкселями.
Поскольку текстура состоит из целого числа тэкселей (в данном случае 256x256),
для наложения тэкселей на фрагменты следует выполнить операцию фильтрации.
Например, если несколько тэкселей соответствуют одному фрагменту, следует взять
их среднее, которое уместится на фрагменте, если один тэксель попадает на
несколько фрагментов, следует вычислить взвешенное среднее соседних тэкселей.
Из-за этих расчетов текстурирование&nbsp; -- довольно дорогая операция с точки
зрения объема расчетов, поэтому многие аппаратные средства включают встроенную
поддержку наложения текстур.</p>

<p class=text align=left style='text-align:left'>Приложение может создавать
текстурные объекты, каждый из которых содержит одну текстуру (и, возможно,
связанные с ней <i>мипмапы</i> (<i>mipmaps</i>)). Некоторые реализации OpenGL
поддерживают&nbsp; <i>рабочее подмножество</i> (<i>workingset</i>) текстурных
объектов, которые работают быстрее, чем другие. Говорят, что эти объекты
являются <i>резидентными</i> (<i>resident</i>) и могут иметь специальную
аппаратную и/или программную поддержку. С помощью OpenGL вы можете создавать и
уничтожать текстурные объекты, а также выяснять, какие из текстур могут быть
размещены в рабочем подмножестве.</p>

<p class=text align=left style='text-align:left'>Несколько операций по наложению
текстур появились в OpenGL версии 1.1:</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l52 level1 lfo35;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Дополнительные внутренние форматы изображений
текстуры.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l52 level1 lfo35;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Текстурное прокси, позволяющее заранее выяснить,
уместится ли нужная текстура в памяти.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l52 level1 lfo35;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]><i>Частичные текстуры</i> (<i>subtextures</i>),
позволяющие заменять все изображение существующей текстуры или его часть. До их
появления нужно было целиком удалить и создать текстуру заново.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l52 level1 lfo35;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Создание текстуры из данных буфера кадра (а
также из системной памяти)</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l52 level1 lfo35;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Объекты текстуры, включая резиденты и
приоритеты.</p>

<p class=text align=left style='text-align:left'>Версия 1.2 добавила еще несколько
операций, связанных с текстурированием:</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l9 level1 lfo36;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>3D текстуры.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l9 level1 lfo36;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Новый режим вычисления текстурных координат
GL_CLAMP_TO_EDGE, отделяющий тэксели от ребра изображения текстуры, а не от его
границы.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l9 level1 lfo36;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Больший контроль над мипмапами, представляющими
разные уровни детализации (levels-of-details -- LOD).</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l9 level1 lfo36;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Вычисление зеркального блика (от источника)
после текстурирования.</p>

<p class=text align=left style='text-align:left'>Версия 1.2 также позволила
производителям добавлять стандартизованные (принятые ARB) опциональные
расширения, включая:</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l48 level1 lfo37;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Мультитекстурирование, позволяющее накладывать
на один примитив несколько текстур.</p>

<p class=text align=left style='text-align:left'>Если вы пытаетесь использовать
одну из перечисленных операций и не можете сделать этого, проверьте версию
вашей реализации OpenGL, чтобы убедиться в том, что она действительно
поддерживает требуемую операцию.</p>

<h2>9.1 Введение и пример</h2>

<p class=text align=left style='text-align:left'>В данном разделе перечисляются
шаги, которые необходимо выполнить для наложения текстуры. В нем также
приводится относительно простая программа, производящая наложение текстуры.</p>

<h2>9.1.1&nbsp;&nbsp;&nbsp;&nbsp; Наложение текстуры по шагам</h2>

<p class=text align=left style='text-align:left'>Чтобы использовать наложение
текстуры, вы должны выполнить следующие шаги:</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l37 level1 lfo38;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>1.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Создать текстурный объект и задать текстуру для
него</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l37 level1 lfo38;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>2.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Задать, как текстура должна воздействовать на
каждый пиксель</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l37 level1 lfo38;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>3.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Активизировать механизм текстурирования</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l37 level1 lfo38;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>4.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Нарисовать сцену, передавая на конвейер визуализации
и геометрические координаты и координаты текстуры</p>

<p class=text align=left style='text-align:left'>Имейте в виду, что
текстурирование работает только в RGBA режиме. Результат попытки применения
текстурирования в индексном режиме не определен.</p>

<h2>9.1.1.1&nbsp;&nbsp;&nbsp; Создание текстурного объекта и указание текстуры
для него</h2>

<p class=text align=left style='text-align:left'>Обычно считается, что текстура
является двумерной, как и большинство изображений, однако она может быть и
одномерной, и трехмерной. Данные, описывающие текстуру могут состоять из
одного, двух, трех или четырех элементов на тэксель и представлять все, что
угодно от константы модуляции до четверки (R, G, B, A).</p>

<p class=text align=left style='text-align:left'>В довольно простом примере 9-1
создается один текстурный объект, управляющий одной двумерной текстурой. Данный
пример предварительно не выясняет, сколько имеется доступной памяти. Поскольку
создается только одна текстура, не делается никаких попыток по оптимизации
работы программы (нет приоритезации или другой работы с рабочим подмножеством
текстур). Другие более сложные техники, такие как границы текстуры и мипмапы, в
этом простом примере также не используются.</p>

<h2>9.1.1.2&nbsp;&nbsp;&nbsp; Задать способ, которым текстура должна
накладываться на каждый пиксель</h2>

<p class=text align=left style='text-align:left'>Вы можете выбрать любую из 4
функций для вычисления финальной RGBA величины на основании фрагмента и
текстуры. Одна из возможностей заключается в использовании цвета текстуры в
качестве результирующего цвета (этот режим называется режимом <i>замены</i> – <i>replace</i>;
текстура просто рисуется поверх фрагмента) (Этот режим как раз и используется в
примере 9-1.) Другой метод заключается в использовании текстуры для <i>модуляции</i>
(<i>modulate</i>) или масштабирования цвета фрагмента; эта техника полезна при
комбинировании эффектов освещения и текстурирования. Наконец, на основании
величины текстуры на фрагмент может быть наложена константная величина цвета.</p>

<h2>9.1.1.3&nbsp;&nbsp;&nbsp; Активизация наложения текстур</h2>

<p class=text align=left style='text-align:left'>До того, как вы нарисуете свою
сцену, вам следует включить текстурирование. Текстурирование включается и
выключается с использованием команд <b>glEnable()</b> и <b>glDisable()</b> с
символическими константами GL_TEXTURE_1D, GL_TEXTURE_2D или GL_TEXTURE_3D в
качестве аргумента для активизации одномерного, двумерного или трехмерного
текстурирования соответственно. (Если активизированы два или все три режима,
используется режим с большим числом измерений. Для лучшей вразумительности
программы следует использовать только один режим.)</p>

<h2>9.1.1.4&nbsp;&nbsp;&nbsp; Нарисовать сцену, поставляя и текстурные, и
геометрические координаты</h2>

<p class=text align=left style='text-align:left'>Вам нужно указать, как
текстура должна быть выровнена относительно фрагментов до того, как она будет к
ним прикреплена. То есть во время передачи объекта на конвейер, вам нужно
поставлять не только геометрические, но и текстурные координаты. Для двумерной
карты текстуры, например, координаты текстуры лежат в диапазоне [0; 1] в обоих
направлениях, однако координаты текстурируемых элементов могут быть любыми.
Например, чтобы наложить кирпичную текстуру на стену, предположим, что стена
имеет квадратную форму и что должна использоваться только одна копия текстуры.
Тогда в коде вам, вероятно, потребуется ассоциировать текстурные координаты
(0,0) (1, 0) (1, 1) и (1, 1) с четырьмя углами стены. Если стена весьма велика,
вы, возможно, захотите нарисовать на ней несколько копий текстуры. Чтобы
сделать это, текстура должна быть создана таким образом, чтобы кубики на левой
границе точно подходили к кубикам на правой границе, и то же должно относиться
к кубикам на верхней и нижней границах.</p>

<p class=text align=left style='text-align:left'>Вы также должны определиться с
тем, как будут трактоваться координаты текстуры за пределами диапазона [0; 1].
Должна ли текстура повторяться, чтобы накрыть объект, или координаты следует
отсечь по допустимой границе.</p>

<h2>9.1.2&nbsp;&nbsp;&nbsp;&nbsp; Простая программа</h2>

<p class=text align=left style='text-align:left'>Одной из проблем с примерами,
демонстрирующими текстуры, является то, что интересные текстуры, как правило,
велики. Обычно, текстуры считываются из файлов изображений, поскольку программное
создание текстуры может вылиться в сотни строк кода. В примере 9-1 текстура,
которая состоит из чередующихся белых и черных квадратиков, подобно шахматной
доске, создается программно. Программа накладывает эту текстуру на два
квадрата, которые затем выводятся в перспективе, при этом один из них
перпендикулярен направлению обзора, а второй повернут на 45 градусов, как
показано на рисунке 9-2. В объектных координатах оба квадрата имеют одинаковый
размер.</p>

<p class=text align=left style='text-align:left'>Рисунок 9-2. Текстурированные
квадраты</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1347" type="#_x0000_t75" alt="" style='width:232.5pt;height:2in'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image248.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/9-2.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=310 height=192
src="OpenGL%20Red%20Book.files/image248.jpg" v:shapes="_x0000_i1347"><![endif]></p>

<p class=text align=left style='text-align:left'>Пример 9-1. Текстурированная
шахматная доска: файл checker.cpp</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  style='color:black'>#include &lt;glut.h&gt;<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>//Параметры текстуры шахматной доски<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#define checkImageWidth 64<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#define checkImageHeight 64<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>GLubyte checkImage[checkImageHeight][checkImageWidth][4];<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>GLuint texName;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void makeCheckImage()<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>int i,j,c;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>for (i=0;i&lt;checkImageHeight;i++)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>for (j=0;j&lt;checkImageWidth;j++)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>c=(((i&amp;0x8)==0)^((j&amp;0x8)==0))*255;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>checkImage[i][j][0]=(GLubyte)c;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>checkImage[i][j][1]=(GLubyte)c;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>checkImage[i][j][2]=(GLubyte)c;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>checkImage[i][j][3]=(GLubyte)255;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void init(void)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glClearColor(0.0,0.0,0.0,0.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glShadeModel(GL_FLAT);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glEnable(GL_DEPTH_TEST);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>makeCheckImage();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glPixelStorei(GL_UNPACK_ALIGNMENT,1);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glGenTextures(1,&amp;texName);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glBindTexture(GL_TEXTURE_2D,texName);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_REPEAT);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,GL_REPEAT);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_NEAREST);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_NEAREST);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexImage2D(GL_TEXTURE_2D,0,GL_RGBA,checkImageWidth,checkImageHeight,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>0,GL_RGBA,GL_UNSIGNED_BYTE,checkImage);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void display(void)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glEnable(GL_TEXTURE_2D);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexEnvf(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_REPLACE);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glBindTexture(GL_TEXTURE_2D,texName);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glBegin(GL_QUADS);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexCoord2f(0.0,0.0); glVertex3f(-2.0,-1.0,0.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexCoord2f(0.0,1.0); glVertex3f(-2.0,1.0,0.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexCoord2f(1.0,1.0); glVertex3f(0.0,1.0,0.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexCoord2f(1.0,0.0); glVertex3f(0.0,-1.0,0.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexCoord2f(0.0,0.0); glVertex3f(1.0,-1.0,0.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexCoord2f(0.0,1.0); glVertex3f(1.0,1.0,0.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexCoord2f(1.0,1.0); glVertex3f(2.41421,1.0,-1.41421);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexCoord2f(1.0,0.0); glVertex3f(2.41421,-1.0,-1.41421);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glEnd();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glFlush();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glDisable(GL_TEXTURE_2D);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void reshape(int w, int h)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glViewport(0,0,(GLsizei) w, (GLsizei) h);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glMatrixMode(GL_PROJECTION);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glLoadIdentity();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>gluPerspective(60.0,(GLfloat)w/(GLfloat)h,1.0,30.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glMatrixMode(GL_MODELVIEW);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glLoadIdentity();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTranslatef(0.0,0.0,-3.6);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>int main(int argc, char ** argv)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glutInit(&amp;argc,&amp;argv);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB|GLUT_DEPTH);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glutInitWindowSize(250,250);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glutCreateWindow(&quot;Texture-Mapped Checkerboard&quot;);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>init();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glutDisplayFunc(display);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glutReshapeFunc(reshape);<o:p></o:p></span></pre><pre><span
  style='color:black'>glutMainLoop();<o:p></o:p></span></pre><pre><span
  style='color:black'>return 0;<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Текстура в виде шахматной
доски генерируется в функции <b>makeCheckImage()</b>, а вся инициализация текстурирования
производится в функции <b>init()</b>. Команды <b>glGenTextures()</b> и <b>glBindTexture()</b>
именуют и создают текстурный объект для изображения текстуры. Единственная
карта текстуры с полным разрешением задается командой <b>glTexImage2D()</b>,
чьи параметры индицируют размер, тип, расположение и другие параметры
изображения текстуры.</p>

<p class=text align=left style='text-align:left'>Четыре вызова команды <b>glTexParameter*()</b>
задают, как текстура должна быть наложена, и как должны фильтроваться цвета,
если количество тэкселей в текстуре и пикселей на экране точно не совпадают.</p>

<p class=text align=left style='text-align:left'>В функции <b>display()</b>
команда <b>glEnable()</b> включает текстурирование. Команда <b>glTexEnv*()</b>
устанавливает режим рисования в GL_REPLACE, чтобы текстурированные полигоны
рисовались с использованием цветов карты текстуры (без принятия в расчет того
цвета, которым они рисовались бы без текстурирования).</p>

<p class=text align=left style='text-align:left'>Затем рисуются два полигона.
Заметьте, что координаты текстуры задаются вместе с координатами вершин.
Команда <b>glTexCoord*()</b> ведет себя аналогично <b>glNormal*()</b>. Команда <b>glTexCoord*()</b>
устанавливает текущие координаты текстуры; эти координаты ассоциируются со
всеми последующими вызовами <b>glVertex*()</b> пока <b>glTexCoord*()</b> не
будет вызвана снова.</p>

<p class=warning>Замечание: Изображение шахматной доски может неверно выглядеть
на экране, если скомпилируете и запустите программу на своей машине. Например,
вместо двух квадратов вы можете увидеть 4 треугольника с различно –
спроецированным изображением. Если это произошло, попробуйте с помощью команды <b>glHint()</b>
установить параметр GL_PERSPECTIVE_CORRECTION_HINT в значение GL_NICEST.</p>

<h2>9.2 Создание текстуры</h2>

<p class=text align=left style='text-align:left'>Команда&nbsp; <b>glTexImage2D()</b>
определяет двумерную текстуру. Она принимает несколько аргументов, которые
кратко описаны здесь и более подробно – в последующих разделах. Аналогичные
команды для одномерных и трехмерных текстур – <b>glTexImage1D()</b> и <b>glTexImage3D()</b>
описаны в соответствующих разделах.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glTexImage2D</b>
  (GLenum <i>target</i>, GLint <i>level</i>, GLint <i>internalFormat</i>,
  GLsizei <i>width</i>, GLsizei <i>height</i>, <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  GLint <i>border</i>, GLenum <i>format</i>, GLenum <i>type</i>, const GLvoid *<i>texels</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Определяет двумерную текстуру.
Аргумент <i>target </i>должен быть установлен в GL_TEXTURE_2D или
GL_PROXY_TEXTURE_2D. Параметр <i>level </i>используется в том случае, если вы
создаете несколько разрешений текстурной карты, в случае одного разрешения, <i>level
</i>должен быть равен 0. Следующий аргумент <i>internalFormat </i>определяет,
какие величины – R, G, B, A, светлота или интенсивность выбраны для
использования в описании тэкселей изображения. Значение для <i>internalFormat</i>–
это число от 1 до 4 или одна из 38 символических констант. Далее приводится
список 38 допустимых констант: GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12,
GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12,
GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2,
GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12,
GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8,
GL_INTENSITY12, GL_INTENSITY16, GL_RGB, GL_R3_G3_B2, GL_RGB4, GL_RGB5, GL_RGB8,
GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1,
GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16. Если значение <i>internalFormat </i>равно
одной из 38 символических констант, это значит, что вы запрашиваете конкретные
компоненты и, возможно, разрешение этих компонент. Например, если <i>internalFormat
</i>равен GL_R3_G3_B2, вы требуете, чтобы в каждом тэкселе было 3 бита на
красный компонент, 3 бита на зеленый и 2 бита на синий, однако OpenGL не
гарантирует, что все будет именно так. Вместо этого, OpenGL попытается выбрать
внутреннее представление данных, которое наиболее точно подходит к тому, что вы
запросили. Точное совпадение обычно не требуется. Внутренние форматы
GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGBи GL_RGBA по определению являются
обобщенными, поскольку в них отсутствует запрос на конкретное разрешение.
(Из-за требований совместимости с OpenGLверсии 1.0 числовые величины для <i>internalFormat</i>–
1, 2, 3 и 4 – являются эквивалентами символических констант GL_LUMINANCE,
GL_LUMINANCE_ALPHA, GL_RGB и GL_RGBA соответственно.) Аргументы <i>width </i>и <i>height
</i>задают размеры изображения текстуры; <i>border </i>задает толщину границы и
должно быть равно либо 0 (граница отсутствует), либо 1. И <i>width</i>, и <i>height</i>
должны иметь форму <!--[if gte vml 1]><v:shape id="_x0000_i1348" type="#_x0000_t75"
 alt="" style='width:49.5pt;height:16.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image249.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form001.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=66 height=22
src="OpenGL%20Red%20Book.files/image249.jpg" v:shapes="_x0000_i1348"><![endif]>,
где m – неотрицательное целое (которое может иметь разное значение для <i>width
</i>и <i>height</i>), а bравно аргументу border. Максимальный размер текстуры
зависит от реализации OpenGL, но он должен быть как минимум 64x64 (то есть 66x66
вместе с границами). Аргументы <i>format </i>и <i>type </i>описывают формат и
тип данных изображения текстуры. Они имеют то же значение, что и для команды <b>glDrawPixels()</b>.
Вообще говоря, данные текстуры имеют тот же формат, что и данные, используемые <b>glDrawPixels()</b>,
таким образом, имеют значение установки команд <b>glPixelStore*()</b> и <b>glPixelTransfer*()</b>.
(В примере 9-1 вызов</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>glPixelsStorei(GL_UNPACK_ALIGNMENT,1);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>производится потому, что
данные не выравниваются специальным образом в конце каждого ряда тэкселей.)
Аргумент <i>format </i>может принимать значения GL_COLOR_INDEX, GL_RGB,
GL_RGBA, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA–
то есть форматы могут быть такими же, как и у команды <b>glDrawPixels()</b> за
исключением GL_STENCIL_INDEX и GLL_DEPTH_COMPONENT. Похожим образом аргумент <i>type
</i>может принимать значения GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT,
GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, GL_BITMAP или одно из
значений, означающих упакованный тип данных. Наконец, аргумент <i>texels </i>является
указателем на данные изображения текстуры. Эти данные описывают само
изображение и его границы.</p>

<p class=text align=left style='text-align:left'>Внутренний формат изображения
текстуры может воздействовать на быстродействие текстурных операций. Например,
некоторые реализации производят GL_RGBA текстурирование быстрее, чем GL_RGB,
поскольку цветовые компоненты лучше выравниваются в процессорной памяти.
Поскольку таких аспектов может быть множество, вам следует проверить информацию
о своей реализации.</p>

<p class=text align=left style='text-align:left'>Внутренний формат изображения
текстуры также определяет то, сколько памяти поглощается этим изображением.
Например, текстура с внутренним форматом GL_RGB8 использует 32 бита на тэксель,
а текстура с внутренним форматом GL_R3_G3_B2 использует только 8 бит на
тэксель. Конечно, существует определенное противоречие между объемом
поглощаемой памяти и цветовым разрешением.</p>

<p class=text align=left style='text-align:left'>Несмотря на то, что результат
текстурирования в индексном режиме не определен, вы все-таки можете создать
текстуру из изображения в формате GL_COLOR_INDEX. В этом случае до создания
текстуры применяются операции пиксельного переноса для табличной конверсии
индексов в RGBA величины.</p>

<p class=text align=left style='text-align:left'>Если ваша реализация OpenGL
поддерживает подмножество обработки изображений и какие-либо механизмы этого
подмножества активизированы, эти механизмы будут воздействовать на изображение
текстуры. Например, если включена двумерная фильтрация, то изображение текстуры
будет отфильтровано (фильтрация может изменить ширину и/или высоту
изображения).</p>

<p class=text align=left style='text-align:left'>Число тэкселей в каждом ряду и
каждом столбце изображения текстуры без опциональной границы должно быть
степенью 2. Если ваше исходное изображение не соответствует этому ограничению,
вы можете использовать функцию <b>gluScaleImage()</b> из библиотеки утилит GLU,
чтобы изменить размер ваших текстур.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>int <b>gluScaleImage</b>
  (GLenum <i>format</i>, GLint <i>widthin</i>, GLint <i>heightin</i>, GLenum <i>typein</i>,
  const *<i>datain</i>,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  GLint <i>widthout</i>, GLint <i>heightout</i>, GLenum <i>typeout</i>, void *<i>dataout</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Масштабирует изображения,
используя установленный режим хранения пикселей для распаковки данных из <i>datain</i>.
Аргументы <i>format</i>, <i>typein </i>и <i>typeout </i>могут иметь любые
значения форматов и типов данных, поддерживаемые командой <b>glDrawPixels()</b>.
Масштабирование от размеров <i>widthin</i> x <i>heightin</i> до размеров <i>widthout</i>
x <i>heightout</i> производится с использованием линейной интерполяции.
Результирующее изображение записывается в <i>dataout</i>с использованием
текущих режимов хранения пикселей GL_PACK*. Ответственность за выделение
достаточного количества памяти для хранения результирующего изображения лежит
на программисте. В случае успеха функция возвращает 0, в случае неудачи – код
ошибки GLU.</p>

<p class=warning>Замечание: В GLU версии 1.3 <b>gluScaleImage()</b>
поддерживает упакованные пиксельные форматы (и связанные с ними типы данных),
появившиеся в OpenGL 1.2.</p>

<p class=text align=left style='text-align:left'>Буфер кадра также может быть
использован в качестве источника данных для текстуры. Команда <b>glCopyTexImage2D()</b>
считывает прямоугольник пикселей из буфера кадра и использует его в качестве
тэкселей новой текстуры.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glCopyTexImage2D</b>
  (GLenum <i>target</i>, GLint <i>level</i>, GLint <i>internalFormat</i>, GLint
  <i>x</i>, GLint <i>y</i>, GLsizei <i>width</i>, GLsizei <i>height</i>, GLint <i>border</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Создает двумерную текстуру,
используя в качестве тэкселей данные из буфера кадра. Пиксели считываются из
текущего буфера для чтения (GL_READ_BUFFER) и обрабатываются точно так же, как
в случае вызова <b>glCopyPixels()</b>, однако вместо перемещения в буфер кадра,
пиксели помещаются в текстурную память. Во время обработки применяются
установки команды <b>glPixelTransfer*()</b> и другие операции переноса
пикселей. Аргумент <i>target </i>должен быть установлен в значение
GL_TEXTURE_2D. Аргументы <i>level</i>, <i>internalFormat </i>и <i>border </i>имеют
тот же эффект, что и для команды <b>glTexImage2D()</b>. Текстурный массив
извлекается из экранного прямоугольника пикселей с нижним левым углом в точке (<i>x</i>,
<i>y</i>). Аргументы <i>width </i>и <i>height </i>задают размеры этого
прямоугольника. И <i>width</i>, и <i>height</i> должны иметь форму <!--[if gte vml 1]><v:shape
 id="_x0000_i1349" type="#_x0000_t75" alt="" style='width:49.5pt;height:16.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image249.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form001.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=66 height=22
src="OpenGL%20Red%20Book.files/image249.jpg" v:shapes="_x0000_i1349"><![endif]>,
где m – неотрицательное целое (которое может иметь разное значение для <i>width</i>и
<i>height</i>), а b равно аргументу border.</p>

<p class=text align=left style='text-align:left'>В следующих разделах детали
текстурирования, в том числе использование параметров <i>target</i>, <i>border </i>и
<i>level</i>, излагаются более подробно. Параметр <i>target </i>может
использоваться для запроса точного размера текстуры (для этого нужно создать
текстурное прокси командой <b>glTexImage*D()</b>), а также для выяснения того,
может ли конкретная текстура использоваться с учетом объема ресурсов реализации
OpenGL. Существует возможность переопределения части текстуры. Детализируется
использование границы текстуры. Параметр <i>level </i>может использоваться для
создания текстур с различным разрешением, он также связан с техникой
мипмаппинга, который в свою очередь требует понимания фильтрации текстур.</p>

<h2>9.2.1 Текстурное прокси</h2>

<p class=text align=left style='text-align:left'>Для программиста OpenGL,
использующего текстуры, размер действительно имеет значение. Обычно текстурные
ресурсы ограничены, а ограничения на форматы текстур меняются в зависимости от
реализации. Существует механизм текстурного прокси, которое позволяет
определить, способна ли ваша реализация OpenGL работать с текстурой конкретного
формата и конкретного размера.</p>

<p class=text align=left style='text-align:left'>Команда <b>glGetIntegerv</b>(GL_MAX_TEXTURE_SIZE,
...); выдаст вам нижнюю границу (ширину или высоту) максимально большой
текстуры (без учета границы текстуры). Обычно наибольшая текстура бывает
квадратной. Константа GL_MAX_3D_TEXTURE_SIZE может быть использована для
получения максимально допустимого измерения 3D текстуры (ширины, высоты или
глубины, без учета границ).</p>

<p class=text align=left style='text-align:left'>Однако ни GL_MAX_TEXTURE_SIZE,
ни GL_MAX_3D_TEXTURE_SIZE не заботится о внутреннем формате изображения или
таких аспектах, как мипмаппинг. Изображение текстуры, сохраненное в формате
GL_RGB16 занимает 64 бита памяти под каждый тэксель, тогда как в формате
GL_LUMINANCE4 оно занимало бы в 16 раз меньше. (Кроме того, изображения, для
которых требуется граница или мипмапы, могут еще быстрее сокращать объем
доступной памяти.)</p>

<p class=text align=left style='text-align:left'>Специальный механизм – прокси
изображения текстуры позволяет программе более точно выяснить может ли OpenGL
принять текстуру желаемого внутреннего формата. Для использования текстурного
прокси вы должны вызвать команду <b>glTexImage2D()</b> с аргументом <i>target</i>,
установленным в значение GL_PROXY_TEXTURE_2D и желаемыми аргументами <i>level</i>,
<i>internalFormat</i>, <i>width</i>, <i>height</i>, <i>border</i>, <i>format </i>и
<i>type</i>. (Для одномерных и трехмерных текстур используйте соответствующие
1D и 2D команды и константы.) При работе с прокси в качестве аргумента <i>texels</i>вы
должны передать NULL.</p>

<p class=text align=left style='text-align:left'>Чтобы выяснить, достаточно ли
свободных ресурсов присутствует в системе для вашей текстуры, после создания
прокси опросите переменные состояния текстуры с помощью команды <b>glGetTexLevelParameter*()</b>.
Если ресурсов недостаточно, такие параметры как ширина и высота текстуры,
ширина ее границы и разрешение ее компонентов будут равны 0.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glGetTexLevelParameter</b>{if}<b>v</b>
  (GLenum <i>target</i>, GLint <i>level</i>, GLenum <i>pname</i>, TYPE *<i>params</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>В аргументе <i>params </i>команда
возвращает значения параметров текстуры для заданного с помощью аргумента <i>level
</i>уровня детализации. Аргумент <i>target </i>задает целевую текстуру и может
быть равен GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_PROXY_TEXTURE_1D,
GL_PROXY_TEXTURE_2D, GL_PROXY_TEXTURE_3D. Допустимыми<span style='mso-ansi-language:
EN-US'> </span>значениями<span style='mso-ansi-language:EN-US'> </span>для<span
style='mso-ansi-language:EN-US'> </span>аргумента<span style='mso-ansi-language:
EN-US'> <i><span lang=EN-US>pname</span></i><span lang=EN-US> </span></span>являются<span
lang=EN-US style='mso-ansi-language:EN-US'>: GL_TEXTURE_WIDTH,
GL_TEXTURE_HEIGHT, GL_TEXTURE_DEPTH, GL_TEXTURE_BORDER,
GL_TEXTURE_INTERNAL_FORMAT, GL_TEXTURE_RED_SIZE, GL_TEXTURE_GREEN_SIZE,
GL_TEXTURE_BLUE_SIZE, GL_TEXTURE_ALPHA_SIZE, GL_TEXTURE_LUMANANCE_SIZE,
GL_TEXTURE_INTENSITY_SIZE. </span>Для аргумента <i>pname </i>также доступно
значение GL_TEXTURE_COMPONENTS, но только из-за необходимости совместимости с
версией OpenGL 1.0. Для последующих версий рекомендуется использовать константу
GL_TEXTURE_INTERNAL_FORMAT.</p>

<p class=text align=left style='text-align:left'>Пример 9-2 демонстрирует
технику использования текстурного прокси для того, чтобы выяснить достаточно ли
в системе ресурсов под создание текстуры размером 64 x 64 тэкселя в формате
RGBA с 8 битами на компонент. Если ресурсов достаточно, <b>glGetTexLevelParameteriv()</b>
сохраняет внутренний формат (в данном случае GL_RGBA8) в переменной <i>format</i>.</p>

<p class=text align=left style='text-align:left'>Пример 9-2. Опрос текстурных
ресурсов с помощью текстурного прокси</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>GLint width;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexImage2D(GL_PROXY_TEXTURE_2D, 0, GL_RGBA8, 64, 64, 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glGetTexLevelParameteriv(GL_PROXY_TEXTURE_2D, 0, GL_TEXTURE_WIDTH, &amp;width);<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<p class=warning>Замечание: Существует одно серьезно ограничение на
использование прокси: текстурное прокси отвечает на вопрос о том, может ли
текстура быть загружена в текстурную память. Прокси дает один и тот же ответ
вне зависимости от того, сколько ресурсов уже используется в текущий момент.
Если ресурсы заняты другими текстурами, ответ на запрос может быть
утвердительным, однако ресурсов может быть недостаточно для того, чтобы сделать
вашу текстуру резидентной (то есть частью высокоскоростного рабочего
подмножества текстур, которое поддерживается). Текстурное прокси, таким
образом, не отвечает на вопрос о том, есть ли достаточно ресурсов для обработки
текстуры на данный конкретный момент.</p>

<h2>9.2.2 Замена всего изображения текстуры или его части</h2>

<p class=text align=left style='text-align:left'>Создание новой текстуры с
точки зрения вычислений может быть значительно дороже, чем модификация существующей.
Начиная с OpenGL версии 1.1, были введены несколько новых команд для замещения
всего изображения текстуры или его части новой информацией. Это может быть
весьма полезно для некоторых приложений, например, для тех, которые используют
в качестве текстуры видеоизображение, захваченное в реальном времени. Для таких
приложений имеет смысл создать одну текстуру и затем использовать команду <b>glTexSubImage2D()</b>
для многократной замены данных текстуры новыми видеоизображениями. Кроме того,
для команды <b>glTexSubImage2D()</b> нет ограничений на ширину или высоту – они
не обязаны быть степенью 2. (Обычно это полезно для обработки видеоизображений,
размеры которых обычно не являются степенью 2. Однако вы должны загружать
изображения в первоначальную большую текстуру, размеры которой и по ширине, и
по высоте должны быть <!--[if gte vml 1]><v:shape id="_x0000_i1350" type="#_x0000_t75"
 alt="" style='width:19.5pt;height:17.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image250.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form002.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=26 height=23
src="OpenGL%20Red%20Book.files/image250.jpg" v:shapes="_x0000_i1350"><![endif]>,
а также вам нужно настраивать координаты текстуры под новое изображение.)</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glTexSubImage2D</b>
  (GLenum <i>target</i>, GLint <i>level</i>, GLint <i>xoffset</i>, GLint <i>yoffset</i>,
  GLsizei <i>width</i>, GLsizei <i>height</i>,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  GLenum <i>format</i>, GLenum <i>type</i>, const GLvoid *<i>texels</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Задает двумерное текстурное
изображение, которое заменяет непрерывный подрегион (в 2D это просто
прямоугольник) текущего существующего текстурного изображения. Аргумент <i>target
</i>должен быть установлен в значение GL_TEXTURE_2D. Аргументы <i>level</i>, <i>format
</i>и <i>type </i>имеют тот же смысл, что и аналогичные аргументы команды <b>glTexImage2D()</b>.
<i>level</i>– это номер уровня детализации. Указание параметров <i>width </i>и <i>height</i>
установленных в 0 не является ошибкой, но в этом случае команда не имеет
эффекта. <i>format </i>и <i>type</i> описывают формат и тип данных в
изображении текстуры. на новое изображение также влияют установки команд <b>glPixelStore*()</b>,
<b>glPixelTransfer*()</b> и другие операции передачи пикселей. <i>texels </i>содержит
данные для подтекстуры. <i>width </i>и <i>height </i>являются размерами
подрегиона, который заменяет все или часть текущего изображения текстуры. <i>xoffset
</i>и <i>yoffset</i> задают смещение от левого нижнего угла текстуры в пикселях
по x и y осям соответственно, то есть они задают, где в исходном изображении
должны быть помещены новые данные. Подрегион не может включать тэксели вне
оригинального изображения текстуры.</p>

<p class=text align=left style='text-align:left'>Пример 9-3 представляет собой
модификацию примера 9-1. Нажатие на клавишу ‘s’ заменяет часть изображения
текстуры новым изображением. (Результирующее изображение приведено на рисунке
9-3.) Нажатие на клавишу ‘r’ восстанавливает исходное изображение. В примере
9-3 были добавлены функции <b>makeCheckImages() </b>и <b>keyboard())</b>.</p>

<p class=text align=left style='text-align:left'>Рисунок 9-3. Текстура с
частично измененным изображением</p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1351" type="#_x0000_t75" alt="" style='width:232.5pt;height:141pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image251.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/9-3.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=310 height=188
src="OpenGL%20Red%20Book.files/image251.jpg" v:shapes="_x0000_i1351"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Пример 9-3. Замещение части
текстуры: файл texsub.cpp</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  style='color:black'>//Параметры текстуры шахматной доски<o:p></o:p></span></pre><pre><span
  style='color:black'>#define checkImageWidth 64<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#define checkImageHeight 64<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#define subImageWidth 16<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#define subImageHeight 16<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>GLubyte checkImage[checkImageHeight][checkImageWidth][4];<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>GLubyte subImage[subImageHeight][subImageWidth][4];<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void makeCheckImages()<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>int i,j,c;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>for (i=0;i&lt;checkImageHeight;i++)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>for (j=0;j&lt;checkImageWidth;j++)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>c=(((i&amp;0x8)==0)^((j&amp;0x8)==0))*255;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>checkImage[i][j][0]=(GLubyte)c;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>checkImage[i][j][1]=(GLubyte)c;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>checkImage[i][j][2]=(GLubyte)c;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>checkImage[i][j][3]=(GLubyte)255;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>for (i=0;i&lt;subImageHeight;i++)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>for (j=0;j&lt;subImageWidth;j++)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>c=(((i&amp;0x4)==0)^((j&amp;0x4)==0))*255;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>subImage[i][j][0]=(GLubyte)c;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>subImage[i][j][1]=(GLubyte)0;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>subImage[i][j][2]=(GLubyte)0;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>subImage[i][j][3]=(GLubyte)255;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void keyboard(unsigned char key, int x, int y)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>switch (key)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>case 's':<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>case 'S':<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glBindTexture(GL_TEXTURE_2D,texName);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexSubImage2D(GL_TEXTURE_2D,0,12,44,subImageWidth,subImageHeight,GL_RGBA,GL_UNSIGNED_BYTE,subImage);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glutPostRedisplay();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>break;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>case 'r':<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>case 'R':<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glBindTexture(GL_TEXTURE_2D,texName);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexImage2D(GL_TEXTURE_2D,0,GL_RGBA,checkImageWidth,checkImageHeight,0,GL_RGBA,GL_UNSIGNED_BYTE,checkImage);<o:p></o:p></span></pre><pre><span
  style='color:black'>glutPostRedisplay();<o:p></o:p></span></pre><pre><span
  style='color:black'>break;<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre><pre><span style='color:black'>}<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Буфер кадра также может
использоваться в качестве источника текстурных данных – на этот раз в качестве
источника данных для подтекстуры. Команда <b>glCopyTexSubImage2D()</b>
считывает прямоугольник пикселей из буфера кадра и замещает ими часть массива
существующей текстуры. (<b>glCopyTexSubImage2D()</b> – это что-то среднее между
<b>glCopyTexImage2D()</b>и <b>glTexSubImage2D()</b>.)</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glCopyTexSubImage2D</b>
  (GLenum <i>target</i>, GLint <i>level</i>, GLine <i>xoffset</i>, GLint <i>yoffset</i>,
  GLint <i>x</i>, GLint <i>y</i>, GLsizei <i>width</i>, GLsizei <i>height</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Использует данные изображения
из буфера кадра для замещения целого или части непрерывного подрегиона текущей
существующей двумерной текстуры. Пиксели считываются из текущего буфера для
чтения (GL_READ_BUFFER) и обрабатываются так же как в случае <b>glCopyPixels()</b>,
но вместо переноса в буфер кадра, пиксели помещаются в текстурную память. На
переносимые пиксели влияют установки команд <b>glPixelStore*()</b>, <b>glPixelTransfer*()</b>
и другие операции передачи пикселей. Аргумент <i>target </i>должен быть
установлен в значение GL_TEXTURE_2D. <i>level </i>представляет собой уровень
детализации мипмапа. <i>xoffset </i>и <i>yoffset</i> задают смещение от левого
нижнего угла текстуры в пикселях по осям абсцисс и ординат соответственно, то
есть они задают, где в исходном изображении должны быть помещены новые данные.
Подизображение извлекается из экранного прямоугольника пикселей с левым нижним
углом в точке (<i>x</i>, <i>y</i>). Аргументы <i>width </i>и <i>height </i>задают
размер этого прямоугольника.</p>

<h2>9.2.3&nbsp;Одномерные текстуры</h2>

<p class=text align=left style='text-align:left'>Иногда одномерная текстура
просто необходима – например, если вы рисуете текстурированные отрезки, когда
все вариации внешнего вида происходят только&nbsp; в одном направлении.
Одномерная текстура ведет себя так же как двумерная текстура с высотой равной 1
и отсутствием границ сверху и снизу. Все команды создания двумерных текстур и
подтекстур имеют свои аналоги в одномерном варианте. Чтобы создать простую
одномерную текстуру, используйте команду <b>glTexImage1D()</b>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glTexImage1D</b>
  (GLenum <i>target</i>, GLint <i>level</i>, GLint <i>internalFormat</i>,
  GLsizei <i>width</i>, GLint <i>border</i>,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  GLenum <i>format</i>, GLenum <i>type</i>, const GLvoid *<i>texels</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Создает одномерную текстуру.
Все параметры имеют то же назначение, что и аналогичные параметры <b>glTexImage2D()</b>
за тем исключением, что аргумент <i>texels </i>в данном случае является одномерным
массивом. Как и раньше значение <i>width </i>должно быть равно <!--[if gte vml 1]><v:shape
 id="_x0000_i1352" type="#_x0000_t75" alt="" style='width:22.5pt;height:17.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image252.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form003.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=30 height=23
src="OpenGL%20Red%20Book.files/image252.jpg" v:shapes="_x0000_i1352"><![endif]>&nbsp;(или
<!--[if gte vml 1]><v:shape id="_x0000_i1353" type="#_x0000_t75" alt=""
 style='width:43.5pt;height:17.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image253.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form004.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=58 height=23
src="OpenGL%20Red%20Book.files/image253.jpg" v:shapes="_x0000_i1353"><![endif]>,
если присутствует граница), где m – неотрицательное целое. Вы можете
использовать мипмаппинг и текстурное прокси (для этого нужно вызвать команду с
аргументом <i>target</i>, установленным в GL_PROXY_TEXTURE_1D), также
присутствуют аналогичные варианты фильтрации.</p>

<p class=text align=left style='text-align:left'>В качестве примера программы,
использующей одномерную текстуру, обратитесь к примеру 9-8.</p>

<p class=text align=left style='text-align:left'>Если ваша реализация OpenGL
поддерживает подмножество обработки изображений и активизирована одномерная
фильтрация (GL_CONVOLUTION_1D), то изображение фильтруется. (Фильтрация может
изменить ширину изображения текстуры.) Также могут применяться и другие
пиксельные операции.</p>

<p class=text align=left style='text-align:left'>Чтобы заменить все или часть
тэкселей одномерной текстуры, используйте команду <b>glTexSubImage1D()</b>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glTexSubImage1D</b>
  (GLenum <i>target</i>, GLint <i>level</i>, GLint <i>xoffset</i>, GLsizei <i>width</i>,
  GLenum <i>format</i>, GLenum <i>type</i>, const GLvoid *<i>texels</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Создает одномерный текстурный
массив, который заменяет весь или часть региона (то есть в 1D – ряда) текущего
существующего изображения одномерной текстуры. Аргумент <i>target </i>должен
быть установлен в значение GL_TEXTURE_1D. Аргументы <i>level</i>, <i>format </i>и
<i>type </i>имеют то же значение, что и для команды <b>glTexImage1D()</b>. <i>level
</i>– это уровень детализации мипмапа. <i>format </i>и <i>type</i> описывают
формат и тип данных изображения текстуры. Частичное изображение подвержено
влиянию режимов, установленных командами <b>glPixelsStore*()</b>, <b>glPixelsTransfer*()</b>
и другим операциям пиксельного переноса. Аргумент <i>texels </i>содержит данные
изображения частичной текстуры. <i>width</i> – это количество тэкселей, которые
заменяют все изображение текущей текстуры или его часть. <i>xoffset </i>задает
смещение в тэкселях от начала массива существующей текстуры, индицируя то
место, с которого будут начинаться новые данные.</p>

<p class=text align=left style='text-align:left'>Для использования буфера кадра
в качестве источника данных для новой одномерной текстуры или частичного
изображения одномерной текстуры, которое заместит существующее, используйте
команды <b>glCopyTexImage1D()</b> или <b>glCopyTexSubImage1D()</b>
соответственно.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glCopyTexImage1D</b>
  (GLenum <i>target</i>, GLint <i>level</i>, GLint <i>internalFormat</i>, GLint
  <i>x</i>, GLint <i>y</i>, GLsizei <i>width</i>, GLint <i>border</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Создает одномерную текстуру,
используя данные из буфера кадра в качестве тэкселей. Пиксели считываются из
текущего буфера для чтения (GL_READ_BUFFER) и обрабатываются точно так же, как
в случае вызова <b>glCopyPixels()</b>, однако вместо перемещения в буфер кадра,
пиксели помещаются в текстурную память. Во время обработки применяются установки
команды <b>glPixelTransfer*()</b> и другие операции переноса пикселей. Аргумент
<i>target </i>должен быть установлен в значение GL_TEXTURE_1D. Аргументы <i>level</i>,
<i>internalFormat </i>и <i>border </i>имеют тот же эффект, что и для команды <b>glCopyTexImage2D()</b>.
Текстурный массив извлекается из экранного ряда пикселей с нижним левым углом в
точке (<i>x</i>, <i>y</i>). Значение <i>width </i>должно быть равно <!--[if gte vml 1]><v:shape
 id="_x0000_i1354" type="#_x0000_t75" alt="" style='width:22.5pt;height:17.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image252.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form003.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=30 height=23
src="OpenGL%20Red%20Book.files/image252.jpg" v:shapes="_x0000_i1354"><![endif]>&nbsp;(или
<!--[if gte vml 1]><v:shape id="_x0000_i1355" type="#_x0000_t75" alt=""
 style='width:43.5pt;height:17.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image253.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form004.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=58 height=23
src="OpenGL%20Red%20Book.files/image253.jpg" v:shapes="_x0000_i1355"><![endif]>,
если присутствует граница), где m – неотрицательное целое.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glCopyTexSubImage1D</b>
  (GLenum <i>target</i>, GLint <i>level</i>, GLint <i>xoffset</i>, GLint <i>x</i>,
  GLint <i>y</i>, GLsizei <i>width</i>, GLint <i>border</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Использует данные изображения
из буфера кадра для замещения целого или части непрерывного подрегиона текущей
существующей одномерной текстуры. Пиксели считываются из текущего буфера для
чтения (GL_READ_BUFFER) и обрабатываются так же как в случае <b>glCopyPixels()</b>,
но вместо переноса в буфер кадра, пиксели помещаются в текстурную память. На
переносимые пиксели влияют установки команд <b>glPixelStore*()</b>, <b>glPixelTransfer*()</b>
и другие операции передачи пикселей. Аргумент <i>target </i>должен быть
установлен в значение GL_TEXTURE_1D. <i>level </i>представляет собой уровень
детализации мипмапа. <i>xoffset </i>задает смещение внутри массива существующей
текстуры, то есть оно задает, где в исходном изображении должны быть помещены
новые данные. Подизображение извлекается из экранного ряда пикселей с левым
нижним углом в точке (<i>x</i>, <i>y</i>). Аргумент <i>width </i>задает число
пикселей в этом ряду.</p>

<h2>9.2.4&nbsp;&nbsp;&nbsp;&nbsp; Трехмерные текстуры</h2>

<p class=text align=left style='text-align:left'>Трехмерные текстуры чаще всего
используются в медицинских и геологических приложениях. В медицинских
приложениях трехмерная текстура может представлять многослойную компьютерную
томографию или визуализацию магнитного резонанса. Для исследователей, связанных
с нефтью и газом, трехмерная текстура может применяться для моделирования слоев
камня. (Трехмерные текстуры являются неотъемлемой частью определенного класса
приложений, связанных с <i>визуализацией объема – volume rendering applications</i>.
Наиболее продвинутые из этих приложений работают с <i>вокселями</i> – <i>voxels</i>,
которые представляют данные в виде сущностей, зависимых от объема.)</p>

<p class=text align=left style='text-align:left'>Из-за своего размера
трехмерные текстуры могут поглощать большой объем текстурных ресурсов системы.
Даже самая простая трехмерная текстура может занимать в 16 или даже 32 раза
больше памяти, чем одна двумерная.</p>

<p class=text align=left style='text-align:left'>До версии 1.2 трехмерные
текстуры были довольно распространенным расширением от нескольких
производителей реализаций OpenGL. В версии 1.2 поддержка трехмерных текстур
была включена в ядро OpenGL. Большинство команд для работы с двумерными
текстурами и подтекстурами имеют свои аналоги для трехмерного варианта.</p>

<p class=text align=left style='text-align:left'>Можно представить себе
трехмерную текстуру в виде слоев двумерных прямоугольников подизображений. В
памяти эти прямоугольники выстроены в последовательность. Чтобы создать простую
трехмерную текстуру используйте команду <b>glTexImage3D ()</b>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glTexImage3D</b>
  (GLenum <i>target</i>, GLint <i>level</i>, GLint <i>internalFormat</i>,
  GLsizei <i>width</i>, GLsizei <i>height</i>,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  GLsizei <i>depth</i>, GLint <i>border</i>, GLenum <i>format</i>, GLenum <i>type</i>,
  const GLvoid *<i>texels</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Создает трехмерную текстуру.
Все параметры имеют то же значение, что и для команды <b>glTexImage2D()</b>, за
исключением того, что здесь <i>texels </i>представляет собой трехмерный массив.
Кроме того, добавился параметр <i>depth</i>. Величина <i>depth </i>должна иметь
форму <!--[if gte vml 1]><v:shape id="_x0000_i1356" type="#_x0000_t75" alt=""
 style='width:22.5pt;height:17.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image252.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form003.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=30 height=23
src="OpenGL%20Red%20Book.files/image252.jpg" v:shapes="_x0000_i1356"><![endif]>&nbsp;(или
<!--[if gte vml 1]><v:shape id="_x0000_i1357" type="#_x0000_t75" alt=""
 style='width:43.5pt;height:17.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image253.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form004.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=58 height=23
src="OpenGL%20Red%20Book.files/image253.jpg" v:shapes="_x0000_i1357"><![endif]>,
если присутствует граница), где m – неотрицательное целое. Вы можете
использовать мипмаппинг и текстурное прокси (для этого нужно вызвать команду с
аргументом <i>target</i>, установленным в GL_PROXY_TEXTURE_3D), также
присутствуют аналогичные варианты фильтрации.</p>

<p class=warning>Замечание: В подмножестве обработки изображений отсутствуют
трехмерные фильтры, однако вы можете использовать двумерные фильтры для
воздействия на изображения трехмерной текстуры.</p>

<p class=text align=left style='text-align:left'>Пример 9-4 является частью
программы, использующей трехмерные текстуры.</p>

<p class=text align=left style='text-align:left'>Пример 9-4. Трехмерное
текстурирование: файл texture3d.cpp</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#define iwidth 16<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#define iheight 16<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#define idepth 16<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>GLubyte image [idepth][iheight][iwidth][3];<o:p></o:p></span></pre><pre><span
  style='color:black'>GLuint texName;<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>//Функция создает массив размерности 16x16x16x3, с различными цветовыми<o:p></o:p></span></pre><pre><span
  style='color:black'>//величинами [r, g, b] в каждом элементе. Значения величин лежат в диапазоне<o:p></o:p></span></pre><pre><span
  style='color:black'>//от 0 до 255<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void makeImage(void)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>int s, t, r;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>for(s=0;s&lt;16;s++)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>for(t=0;t&lt;16;t++)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>for(r=0;r&lt;16;r++)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>image[r][t][s][0]=s*17;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>image[r][t][s][1]=t*17;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>image[r][t][s][2]=r*17;<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre><pre><span style='color:black'>}<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>//Инициализировать состояние: объект 3D текстуры и ее изображение<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void init(void)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glClearColor(0.0,0.0,0.0,0.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glShadeModel(GL_FLAT);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glEnable(GL_DEPTH_TEST);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>makeImage();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glPixelStorei(GL_UNPACK_ALIGNMENT,1);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glGenTextures(1, &amp;texName);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glBindTexture(GL_TEXTURE_3D,texName);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_S, GL_CLAMP);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_T, GL_CLAMP);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_R, GL_CLAMP);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexImage3D(GL_TEXTURE_3D,0,GL_RGB,iWidth,iHeight,iDepth,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>0,GL_RGB,GL_UNSIGNED_BYTE,image);<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Чтобы заменить все или часть
тэкселей трехмерной текстуры, используйте команду <b>glTexSubImage3D()</b>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glTexSubImage3D</b>
  (GLenum <i>target</i>, GLint <i>level</i>, GLint <i>xoffset</i>, GLint <i>yoffset</i>,
  GLint <i>zoffset</i>, <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  GLsizei <i>width</i>, GLsizei <i>height</i>, GLsizei <i>depth</i>, GLenum <i>format</i>,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  GLenum <i>type</i>, const GLvoid *<i>texels</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Создает трехмерный текстурный
массив, который заменяет весь или часть подрегиона текущего существующего
изображения трехмерной текстуры. Аргумент <i>target </i>должен быть установлен
в значение GL_TEXTURE_3D. Аргументы <i>level</i>, <i>format </i>и <i>type </i>имеют
то же значение, что и для команды <b>glTexImage3D()</b>. <i>level</i>– это
уровень детализации мипмапа. <i>format </i>и <i>type</i> описывают формат и тип
данных изображения текстуры. Частичное изображение подвержено влиянию режимов,
установленных командами <b>glPixelsStore*()</b>, <b>glPixelsTransfer*()</b> и
другим операциям пиксельного переноса. Аргумент <i>texels </i>содержит данные
изображения частичной текстуры. <i>width</i>, <i>height </i>и <i>depth </i>представляют
собой размеры подизображения в тэкселях. <i>xoffset</i>, <i>yoffset </i>и <i>zoffset
</i>задают смещение в тэкселях от начала массива существующей текстуры,
индицируя то место, индицируя то место, куда нужно поместить новые данные.</p>

<p class=text align=left style='text-align:left'>Для использования буфера кадра
в качестве источника данных для частичного изображения одномерной текстуры,
которое заместит существующее, используйте команду <b>glCopyTexSubImage3D()</b>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glCopyTexSubImage3D</b>
  (GLenum <i>target</i>, GLint <i>level</i>, GLint <i>xoffset</i>, GLint <i>yoffset</i>,
  GLint <i>zoffset</i>,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  GLint <i>x</i>, GLint <i>y</i>, GLsizei <i>width</i>, GLint <i>border</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Использует данные изображения
из буфера кадра для замещения целого или части непрерывного подрегиона текущей
существующей трехмерной текстуры. Пиксели считываются из текущего буфера для
чтения (GL_READ_BUFFER) и обрабатываются так же как в случае <b>glCopyPixels()</b>,
но вместо переноса в буфер кадра, пиксели помещаются в текстурную память. На
переносимые пиксели влияют установки команд <b>glPixelStore*()</b>, <b>glPixelTransfer*()</b>
и другие операции передачи пикселей. Аргумент <i>target </i>должен быть
установлен в значение GL_TEXTURE_3D. <i>level </i>представляет собой уровень
детализации мипмапа. Подизображение извлекается из экранного прямоугольника
пикселей с левым нижним углом в точке (<i>x</i>, <i>y</i>). Аргументы <i>width </i>и
<i>height </i>задают размеры этого прямоугольника. <i>xoffset</i>, <i>yoffset </i>и
<i>zoffset </i>задают смещение внутри массива существующей текстуры, то есть
они определяют место, куда следует поместить извлеченные данные. Поскольку
подизображение является двумерным, оно может заместить только часть или целое
изображение в одном срезе (срезе со смещением <i>zoffset</i>).</p>

<h2>9.2.4.1&nbsp;&nbsp;&nbsp; Режимы хранения пикселей для трехмерных текстур</h2>

<p class=text align=left style='text-align:left'>Режимы хранения пикселей
контролируют пропуски между рядами каждого слоя (иными словами, одного
двумерного прямоугольника). Команда <b>glPixelStore*()</b> устанавливает режимы
хранения пикселей с такими параметрами, как *ROW_LENGTH, *ALIGNMENT,
*SKIP_PIXELS и *SKIP_ROWS (где * означает или GL_PACK или GL_UNPACK), что
управляет разрешением части целого прямоугольника (также прямоугольной)
пиксельных или тэксельных данных.</p>

<p class=text align=left style='text-align:left'>Перечисленные ранее режимы
хранения пикселей остаются полезными для описания двух из трех измерений, но
для поддержки разрешения частичных объемов изображения трехмерной текстуры
требуются дополнительные режимы. Новые параметры *IMAGE_HEIGHT и *SKIP_IMAGES
позволяют командам <b>glTexImage3D()</b>, <b>glTexSubImage3D()</b> и <b>glGetTexImage()</b>
получать доступ к любому желаемому частичному объему.</p>

<p class=text align=left style='text-align:left'>Если трехмерная текстура в
памяти больше, чем определенный частичный объем, вам необходимо указать высоту
одного частичного изображения с помощью параметра *IMAGE_HEIGHT. Также, если
частичный объем начинается не с самого первого слоя, следует установить
параметр *SKIP_IMAGES.</p>

<p class=text align=left style='text-align:left'>*IMAGE_HEIGHT – это параметр
хранения пикселей, который определяет высоту (количество рядов) одного слоя
изображения трехмерной текстуры. Если значение *IMAGE_HEIGHT равно 0
(отрицательная величина не является допустимой), число рядов в каждом двумерном
прямоугольнике имеет величину <i>height</i>, являющуюся аргументом команд <b>glTexImage3D()</b>
или <b>glTexSubImage3D()</b>. (Эта ситуация встречается часто, поскольку
величиной по умолчанию для *IMAGE_HEIGHT является именно 0.) В ином случае
высота одного слоя равна величине *IMAGE_HEIGHT.</p>

<p class=text align=left style='text-align:left'>Рисунок 9-4 показывает, как
*IMAGE_HEIGHT задает высоту изображения (когда параметр <i>height </i>задает
только высоту частичного изображения). На рисунке изображена трехмерная
текстура с двумя слоями.</p>

<p class=text align=left style='text-align:left'>Рисунок 9-4. Режим хранения
пикселей *IMAGE_HEIGHT</p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1358" type="#_x0000_t75" alt="" style='width:465pt;height:312pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image254.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/9-4.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=620 height=416
src="OpenGL%20Red%20Book.files/image254.jpg" v:shapes="_x0000_i1358"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>*SKIP_IMAGES определяет,
сколько слоев нужно пройти до того, как можно будет получить доступ к данным
частичного объема. Если *SKIP_IMAGES равно положительному целому числу (назовем
его значением n), то указатель в данных изображения текстуры сдвигается на это
число слоев (то есть на n*размер одного слоя тэкселей). Результирующий
частичный объем начинается со слоя n и продолжается на несколько слоев вглубь –
на сколько вглубь, определяет аргумент <i>depth</i>, передаваемый командам <b>glTexImage3D()</b>
или <b>glTexSubImage3D()</b>. Если *SKIP_IMAGES равно 0 (значение по
умолчанию), доступ к данным тэкселей начинается с самого первого слоя,
описанного в тэксельном массиве.</p>

<p class=text align=left style='text-align:left'>Рисунок 9-5 показывает, как
параметр *SKIP_IMAGES проходит через несколько слоев, чтобы попасть туда, где в
действительности расположен нужный частичный объем. В данном примере
*SKIP_IMAGES равно 3, и частичный объем начинается со слоя 3.</p>

<p class=text align=left style='text-align:left'>Рисунок 9-5. Режим хранения
пикселей *SKIP_IMAGES</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1359" type="#_x0000_t75" alt="" style='width:465pt;height:303.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image255.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/9-5.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=620 height=405
src="OpenGL%20Red%20Book.files/image255.jpg" v:shapes="_x0000_i1359"><![endif]></p>

<h2>9.2.5&nbsp;&nbsp;&nbsp;&nbsp; Использование границ текстуры</h2>

<p class=text align=left style='text-align:left'>Дополнительно:<b> </b>Если вам
нужно использовать большую текстуру, чем позволяет ваша реализация OpenGL, вы
можете эффективно создавать большие текстуры, заполняя пространство текстурами
меньшего размера. Например, если вам нужно наложить на квадрат текстуру
размером вдвое большим, чем максимально допустимый, нарисуйте квадрат в виде
4-ех квадратов меньшего размера, и на каждый из них наложите текстуру,
представляющую собой четверть изображения исходной, большой текстуры (загружая
новую четверть перед рисованием каждого из 4-ех квадратов).</p>

<p class=text align=left style='text-align:left'>Поскольку в каждый конкретный
момент доступна только одна карта текстуры, такой подход может привести к
проблемам на ребрах текстур, особенно если используется одна из разновидностей
линейной фильтрации. Значение текстуры, используемой для пикселей на ребрах,
должно вычисляться с использованием чего-то за этими ребрами, в идеале, с
чем-то, находящимся в соседней карте текстуры. Если для каждой текстуры вы
определите границу, чьи величины тэкселей равны величинам тэкселей на ребре
соседней карты текстуры, то при линейной фильтрации будет обеспечено корректное
поведение.</p>

<p class=text align=left style='text-align:left'>Чтобы сделать это правильно,
имейте в виду, что каждая текстура может иметь 8 соседей – по одной текстуре,
прилегающей к каждому ребру и по одной, касающейся каждого из углов. Величины
тэкселей в углах границы должны соответствовать тэкселям на ребрах карт
текстуры, касающихся углов. Если же ваша текстура является граничной для всей
большой составной текстуры, вам нужно решить, какие значения помещать на ее
границах. Простейшее разумное решение заключается в копировании соседних величин
той же текстурной карты с помощью команды <b>glTexSubImage2D()</b>.</p>

<p class=text align=left style='text-align:left'>Цвет границы текстуры также
используется в том случае, если текстура накладывается таким образом, что она
только частично накрывает примитив.</p>

<h2>9.2.6&nbsp;&nbsp;&nbsp;&nbsp; Несколько уровней детализации</h2>

<p class=text align=left style='text-align:left'><b>Дополнительно: </b>Текстурированные
объекты, как и все остальные объекты сцены, могут рассматриваться с разных
дистанций от точки наблюдения. В динамической сцене в процессе перемещения
текстурированного объекта дальше от точки наблюдения карта текстуры должна
уменьшаться в размере вместе с размером проецируемого изображения. Чтобы
достичь этого OpenGL должна фильтровать карту текстуры при ее уменьшении до
размера, нужного для наложения на объект, таким образом, чтобы избежать
появления визуальных артефактов. Например, чтобы визуализировать каменную
стену, вы можете использовать большое изображение текстуры (скажем 128x128
тэкселей), если стена находится близко к наблюдателю. Однако если стена
постепенно перемещается дальше от наблюдателя до тех пор, пока не будет размером
с один пиксель, фильтрованная текстура может изменяться прерывисто, в
определенные моменты.</p>

<p class=text align=left style='text-align:left'>Чтобы избежать подобных
неприятностей, вы можете задавать серии предварительно отфильтрованных карт
текстуры с разными разрешениями (128x128, 64x64, 32x32 и так далее). Эти карты
называются мипмапами и показаны на рисунке 9-6. Термин <i>мипмап</i> (<i>mipmap</i>)
был введен Лансом Вильямсом (Lance Williams), когда он представлял эту идею в
своей статье «Пирамидальные параметрики» («Pyramidal Parametrics»)
(SIGGRAPH1983). «<i>Mip</i>» происходит от латинского «<i>multum in parvo</i>»,
что означает «много вещей в одном месте». Мипмаппинг использует некоторые
ухищренные методы упаковки данных в памяти.</p>

<p class=text align=left style='text-align:left'>Рисунок 9-6. Мипмапы</p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1360" type="#_x0000_t75" alt="" style='width:465pt;height:447pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image256.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/9-6.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=620 height=596
src="OpenGL%20Red%20Book.files/image256.jpg" v:shapes="_x0000_i1360"><![endif]><o:p></o:p></span></p>

<p class=warning>Замечание: Для полного понимания мипмапов, вам требуется
понимание уменьшающих фильтров.</p>

<p class=text align=left style='text-align:left'>При использовании мипмаппинга,
OpenGL автоматически определяет, какую текстурную карту нужно использовать в
зависимости от размера (в пикселях) текстурируемого объекта. При таком подходе
уровень детализации текстурной карты соответствует изображению, рисуемому на
экране – в то время, как объект на экране становится меньше, сокращается размер
карты текстуры. Мипмаппинг требуется некоторых дополнительных расчетов и
текстурной памяти; однако если его не использовать, текстуры, накладываемые на
маленькие объекты, могут искажаться и мигать в процессе перемещения этих
объектов.</p>

<p class=text align=left style='text-align:left'>Чтобы использовать мипмаппинг
вы должны предоставить вашу текстуру во всех размерах, равных степеням 2, от
самого большого до размера 1x1. Например, если наибольшее разрешение карты
составляет 64x16, вы должны также предоставить карты с размерами 32x8, 16x4,
8x2, 4x1, 2x1 и 1x1. Меньшие карты обычно представляют собой фильтрованные и
уменьшенные версии больших. Каждый тэксель в меньшей карте является средним
между 4 соответствующими тэкселями в большей. (Поскольку OpenGL не накладывает
никаких ограничений на метод вычисления меньших карт, карты текстуры разного
размера могут быть абсолютно не связаны между собой. На практике несвязанные
мипмапы могут сделать переходы между ними визуально весьма заметными, как на
рисунке 9-7.)</p>

<p class=text align=left style='text-align:left'>Чтобы задать все текстуры,
вызовите команду <b>glTexImage2D()</b> по одному разу для каждого разрешения
карты текстуры, каждый раз задавая новые значения для аргументов <i>level</i>, <i>width</i>,
<i>height </i>и <i>image</i>. Начиная с 0, <i>level </i>идентифицирует, какая
именно текстура в серии задается в текущий момент. В предыдущем примере тектура
с самым высоким разрешением размера 64x16, должна быть объявлена с аргументом <i>level</i>=0,
текстура размера 32x8 – с <i>level</i>=1, и так далее. Кроме того, чтобы
мипмаппинг заработал, вам следует выбрать один из режимов фильтрации.</p>

<p class=warning>Замечание: В данном описании процесса мипмаппинга в OpenGL
отсутствует подробное обсуждение фактора масштаба (известного как <!--[if gte vml 1]><v:shape
 id="_x0000_i1361" type="#_x0000_t75" alt="" style='width:12.75pt;height:15pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image257.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form005y.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=17 height=20
src="OpenGL%20Red%20Book.files/image257.jpg" v:shapes="_x0000_i1361"><![endif]>).
Оно также приводится в предположении, что параметры GL_TEXTURE_MIN_LOD,
GL_TEXTURE_MAX_LOD, GL_TEXTURE_BASE_LEVEL и GL_TEXTURE_MAX_LEVEL имеют значения
по умолчанию. (Эти 4 параметра появились в OpenGL версии 1.2.) Объяснение
фактора <!--[if gte vml 1]><v:shape id="_x0000_i1362" type="#_x0000_t75" alt=""
 style='width:12.75pt;height:15pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image257.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form005y.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=17 height=20
src="OpenGL%20Red%20Book.files/image257.jpg" v:shapes="_x0000_i1362"><![endif]>&nbsp;и
воздействия параметров приводится далее в этой главе.</p>

<p class=text align=left style='text-align:left'>Пример 9-5 иллюстрирует
использование серии из 6 текстурных карт, уменьшающихся от размера 32x32 до
размера 1x1. Эта программа рисует один длинный прямоугольник, который
начинается на переднем плане и уходит вглубь до тех пор, пока не превращается в
точку, как показано на рисунке 9-7. Обратите внимание, что координаты текстуры
ранжируются от 0.0 до 8.0, таким образом, для покрытия всего прямоугольника
требуется 64 копии текстуры (по 8 в каждом направлении). Для иллюстрации того,
как одна карта текстуры продолжает другую, каждая из них имеет свой цвет.</p>

<p class=text align=left style='text-align:left'>Рисунок 9-7. Пример применения
мипмаппинга</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1363" type="#_x0000_t75" alt="" style='width:345pt;height:215.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image258.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/9-7.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=460 height=287
src="OpenGL%20Red%20Book.files/image258.jpg" v:shapes="_x0000_i1363"><![endif]></p>

<p class=text align=left style='text-align:left'>Пример 9-5. Мипмаппинг: файл
mipmap.cpp</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#include &lt;glut.h&gt;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>GLubyte mipmapImage32[32][32][4];<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>GLubyte mipmapImage16[16][16][4];<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>GLubyte mipmapImage8[8][8][4];<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>GLubyte mipmapImage4[4][4][4];<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>GLubyte mipmapImage2[2][2][4];<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>GLubyte mipmapImage1[1][1][4];<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>GLuint texName;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void makeImages()<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>int i,j;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>for (i=0;i&lt;32;i++)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>for (j=0;j&lt;32;j++)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>mipmapImage32[i][j][0]=255;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>mipmapImage32[i][j][1]=255;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>mipmapImage32[i][j][2]=0;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>mipmapImage32[i][j][3]=255;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>for (i=0;i&lt;16;i++)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>for (j=0;j&lt;16;j++)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>mipmapImage16[i][j][0]=255;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>mipmapImage16[i][j][1]=0;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>mipmapImage16[i][j][2]=255;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>mipmapImage16[i][j][3]=255;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>for (i=0;i&lt;8;i++)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>for (j=0;j&lt;8;j++)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>mipmapImage8[i][j][0]=255;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>mipmapImage8[i][j][1]=0;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>mipmapImage8[i][j][2]=0;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>mipmapImage8[i][j][3]=255;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>for (i=0;i&lt;4;i++)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>for (j=0;j&lt;4;j++)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>mipmapImage4[i][j][0]=0;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>mipmapImage4[i][j][1]=255;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>mipmapImage4[i][j][2]=0;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>mipmapImage4[i][j][3]=255;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>for (i=0;i&lt;2;i++)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>for (j=0;j&lt;2;j++)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>mipmapImage2[i][j][0]=0;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>mipmapImage2[i][j][1]=0;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>mipmapImage2[i][j][2]=255;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>mipmapImage2[i][j][3]=255;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>mipmapImage1[i][j][0]=255;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>mipmapImage1[i][j][1]=255;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>mipmapImage1[i][j][2]=255;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>mipmapImage1[i][j][3]=255;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void init()<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glEnable(GL_DEPTH_TEST);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glShadeModel(GL_FLAT);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTranslatef(0.0,0.0,-3.6);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>makeImages();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glPixelStorei(GL_UNPACK_ALIGNMENT,1);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glGenTextures(1,&amp;texName);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glBindTexture(GL_TEXTURE_2D,texName);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_REPEAT);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,GL_REPEAT);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_NEAREST);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>GL_NEAREST_MIPMAP_NEAREST);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexImage2D(GL_TEXTURE_2D,0,GL_RGBA,32,32,0,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>GL_RGBA,GL_UNSIGNED_BYTE,mipmapImage32);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexImage2D(GL_TEXTURE_2D,1,GL_RGBA,16,16,0,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>GL_RGBA,GL_UNSIGNED_BYTE,mipmapImage16);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexImage2D(GL_TEXTURE_2D,2,GL_RGBA,8,8,0,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>GL_RGBA,GL_UNSIGNED_BYTE,mipmapImage8);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexImage2D(GL_TEXTURE_2D,3,GL_RGBA,4,4,0,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>GL_RGBA,GL_UNSIGNED_BYTE,mipmapImage4);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexImage2D(GL_TEXTURE_2D,4,GL_RGBA,2,2,0,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>GL_RGBA,GL_UNSIGNED_BYTE,mipmapImage2);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexImage2D(GL_TEXTURE_2D,5,GL_RGBA,1,1,0,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>GL_RGBA,GL_UNSIGNED_BYTE,mipmapImage1);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexEnvf(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_REPLACE);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glEnable(GL_TEXTURE_2D);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void display()<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glBindTexture(GL_TEXTURE_2D,texName);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glBegin(GL_QUADS);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexCoord2f(0.0,0.0); glVertex3f(-2.0,-1.0,0.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexCoord2f(0.0,8.0); glVertex3f(-2.0,1.0,0.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexCoord2f(8.0,8.0); glVertex3f(2000.0,1.0,-6000.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexCoord2f(8.0,0.0); glVertex3f(2000.0,-1.0,-6000.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glEnd();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glFlush();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void reshape(int w,int h)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glViewport(0,0,w,h);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glMatrixMode(GL_PROJECTION);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glLoadIdentity();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>gluPerspective(60.0,w/h,1.0,30000);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glMatrixMode(GL_MODELVIEW);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glLoadIdentity();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>int main(int argc, char **argv)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glutInit(&amp;argc,argv);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB|GLUT_DEPTH);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glutInitWindowSize(500,500);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glutInitWindowPosition(100,100);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glutCreateWindow(&quot;Mipmap Textures&quot;);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>init();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glutDisplayFunc(display);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glutReshapeFunc(reshape);<o:p></o:p></span></pre><pre><span
  style='color:black'>glutMainLoop();<o:p></o:p></span></pre><pre><span
  style='color:black'>return 0;<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Пример 9-5 иллюстрирует
мипмаппинг с помощью мипмапов разного цвета. Таким образом, точки, в которых
одна карта переходит в другую, очевидны. В реальных условиях мипмапы обычно
создаются таким образом, чтобы переходы между ними были настолько плавными и
незаметными, насколько это возможно. Таким образом, карты меньшего размера
обычно представляют собой отфильтрованные и уменьшенные копии карты с большим
разрешением. Построение таких изображений – это программный процесс и,
следовательно, он не является частью OpenGL. Однако, поскольку конструирование мипмапов
– это очень важный процесс, библиотека утилит GLU содержит три функции, которые
помогают в манипуляциях с изображениями, используемыми в качестве мипмапов.</p>

<h2>9.2.6.1&nbsp;&nbsp;&nbsp; Автоматическое создание мипмапов</h2>

<p class=text align=left style='text-align:left'>Предполагая, что вы построили
текстурную карты с высочайшим разрешением уровня 0, функции <b>gluBuild1DMipmaps()</b>,
<b>gluBuild2DMipmaps()</b> и <b>gluBuild3DMipmaps()</b> конструируют и создают
пирамиду мипмапов до разрешения 1x1 (или 1 для одномерной текстуры, или 1x1x1
для трехмерной). Если размеры вашего изображения не являются степенями 2,
функции <b>gluBuild*DMipmaps()</b> масштабируют его до ближайших степеней 2.
Кроме того, если ваша текстура слишком велика, <b>gluBuild*DMipmaps()</b>
сократит ее до допустимого размера (с помощью механизма текстурного прокси).</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>int <b>gluBuild1DMipmaps</b>
  (GLenum <i>target</i>, GLint <i>internalFormat</i>, GLint <i>width</i>,
  GLenum <i>format</i>, GLenum <i>type</i>, void *<i>texels</i>);<br>
  int <b>gluBuild2DMipmaps</b> (GLenum <i>target</i>, GLint <i>internalFormat</i>,
  GLint <i>width</i>, GLint <i>height</i>, GLenum <i>format</i>, GLenum <i>type</i>,
  void *<i>texels</i>);<br>
  int <b>gluBuild3DMipmaps</b> (GLenum <i>target</i>, GLint <i>internalFormat</i>,
  GLint <i>width</i>, GLint <i>height</i>, <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  GLint <i>depth</i>, GLenum <i>format</i>, GLenum <i>type</i>, void *<i>texels</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Конструирует серию мипмапов и
вызывает <b>glTexImage*D()</b> для загрузки изображений. Назначение аргументов <i>target</i>,
<i>internalFormat</i>, <i>width</i>, <i>height</i>, <i>depth</i>, <i>format</i>,
<i>type </i>и <i>texels </i>в точности соответствует тем, что передаются в <b>glTexImage1D()</b>,
<b>glTexImage2D()</b> и <b>glTexImage3D()</b>. Если все мипмапы сконструированы
успешно, функция возвращает 0. В случае неудачи возвращается код ошибки GLU.</p>

<h2>9.2.6.2&nbsp;&nbsp;&nbsp; Дополнительные детали мипмаппинга</h2>

<p class=text align=left style='text-align:left'>Расчет мипмаппинга зависит от
фактора масштаба между изображением текстуры и размером текстурируемого
полигона (в пикселях). Давайте назовем этот фактор <!--[if gte vml 1]><v:shape
 id="_x0000_i1364" type="#_x0000_t75" alt="" style='width:11.25pt;height:14.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image259.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form006.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=15 height=19
src="OpenGL%20Red%20Book.files/image259.jpg" v:shapes="_x0000_i1364"><![endif]>&nbsp;и
определим вторую величину -- <!--[if gte vml 1]><v:shape id="_x0000_i1365"
 type="#_x0000_t75" alt="" style='width:12.75pt;height:15pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image260.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form005.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=17 height=20
src="OpenGL%20Red%20Book.files/image260.jpg" v:shapes="_x0000_i1365"><![endif]>,
причем <!--[if gte vml 1]><v:shape id="_x0000_i1366" type="#_x0000_t75" alt=""
 style='width:59.25pt;height:18.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image261.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form007.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=79 height=25
src="OpenGL%20Red%20Book.files/image261.jpg" v:shapes="_x0000_i1366"><![endif]>.
(Поскольку изображения текстуры могут лежать в нескольких измерениях, важно
прояснить, что <!--[if gte vml 1]><v:shape id="_x0000_i1367" type="#_x0000_t75"
 alt="" style='width:11.25pt;height:14.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image259.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form006.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=15 height=19
src="OpenGL%20Red%20Book.files/image259.jpg" v:shapes="_x0000_i1367"><![endif]>&nbsp;--
это максимальный фактор масштаба во всех измерениях.) Если <!--[if gte vml 1]><v:shape
 id="_x0000_i1368" type="#_x0000_t75" alt="" style='width:42.75pt;height:18pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image262.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form008.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=57 height=24
src="OpenGL%20Red%20Book.files/image262.jpg" v:shapes="_x0000_i1368"><![endif]>,
то текстура меньше, чем полигон, и используется увеличивающий фильтр. Если же <!--[if gte vml 1]><v:shape
 id="_x0000_i1369" type="#_x0000_t75" alt="" style='width:42.75pt;height:15.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image263.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form009.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=57 height=21
src="OpenGL%20Red%20Book.files/image263.jpg" v:shapes="_x0000_i1369"><![endif]>,
используется уменьшающий фильтр. Если выбранный уменьшающий фильтр использует
мипмаппинг, то <!--[if gte vml 1]><v:shape id="_x0000_i1370" type="#_x0000_t75"
 alt="" style='width:12.75pt;height:15pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image260.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form005.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=17 height=20
src="OpenGL%20Red%20Book.files/image260.jpg" v:shapes="_x0000_i1370"><![endif]>&nbsp;означает
уровень используемого мипмапа.</p>

<p class=text align=left style='text-align:left'>Например, если размер
изображения текстуры 64x64 тэкселя, а размер полигона -- 32x32 пикселя, то <!--[if gte vml 1]><v:shape
 id="_x0000_i1371" type="#_x0000_t75" alt="" style='width:41.25pt;height:17.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image264.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form010.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=55 height=23
src="OpenGL%20Red%20Book.files/image264.jpg" v:shapes="_x0000_i1371"><![endif]>&nbsp;(а
не 4.0) и <!--[if gte vml 1]><v:shape id="_x0000_i1372" type="#_x0000_t75"
 alt="" style='width:42pt;height:17.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image265.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form011.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=56 height=23
src="OpenGL%20Red%20Book.files/image265.jpg" v:shapes="_x0000_i1372"><![endif]>.
Если изображение текстуры 64x32 тэкселя, а размер полигона -- 8x16 пикселей, то
<!--[if gte vml 1]><v:shape id="_x0000_i1373" type="#_x0000_t75" alt=""
 style='width:43.5pt;height:17.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image266.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form012.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=58 height=23
src="OpenGL%20Red%20Book.files/image266.jpg" v:shapes="_x0000_i1373"><![endif]>&nbsp;(масштаб
по x равен 8.0, а по y –2.0) и <!--[if gte vml 1]><v:shape id="_x0000_i1374"
 type="#_x0000_t75" alt="" style='width:43.5pt;height:15pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image267.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form013.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=58 height=20
src="OpenGL%20Red%20Book.files/image267.jpg" v:shapes="_x0000_i1374"><![endif]>.</p>

<p class=warning>Замечание: Точкой равновесия между применением уменьшающего
фильтра и увеличивающего обычно является <!--[if gte vml 1]><v:shape id="_x0000_i1375"
 type="#_x0000_t75" alt="" style='width:42.75pt;height:15.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image268.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form014y.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=57 height=21
src="OpenGL%20Red%20Book.files/image268.jpg" v:shapes="_x0000_i1375"><![endif]>,
но это не всегда так. Если в качестве увеличивающего фильтра выбран GL_LINEAR,
а в качестве уменьшающего – GL_NEAREST_MIPMAP_NEAREST или
GL_NEAREST_MIPMAP_LINEAR, то эта точка находится в <!--[if gte vml 1]><v:shape
 id="_x0000_i1376" type="#_x0000_t75" alt="" style='width:42.75pt;height:15.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image269.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form015y.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=57 height=21
src="OpenGL%20Red%20Book.files/image269.jpg" v:shapes="_x0000_i1376"><![endif]>.
Это предотвращает ситуацию, когда уменьшенная текстура выглядит более резкой,
чем ее увеличенная версия.</p>

<p class=text align=left style='text-align:left'>До OpenGL версии 1.2
применение мипмаппинга накладывало на программиста дополнительные ограничения.
Например, нельзя было «на лету» производить такие изменения, как добавление
новых мипмапов. Кроме того, в течение процесса уменьшения или увеличения
полигона, текстура могла изменяться скачками в точках замены одного мипмапа
другим, разрешение которого радикально выше.</p>

<p class=text align=left style='text-align:left'>В добавление к этому
приходилось предоставлять мипмапы для всех уровней разрешения, даже для
невероятно маленьких. При применении некоторых техник следует избегать
представления данных в виде очень маленьких мипмапов. Например, вам может
пригодиться техника <i>мозаики</i>, когда несколько небольших изображений
помещены на одной текстуре. Один из примеров мозаики показан на рисунке 9-8,
где изображен набор символов, помещенный на одной текстуре. использование
мозаики в данном случае более эффективно, чем создание отдельной текстуры для
каждого символа. Для наложения на полигон одной буквы, вам следует произвести
расчет координат текстуры, дабы выделить эту букву из всего изображения.</p>

<p class=text align=left style='text-align:left'>Рисунок 9-8. Использование
техники «мозаика»</p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1377" type="#_x0000_t75" alt="" style='width:232.5pt;height:141.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image270.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/9-8.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=310 height=189
src="OpenGL%20Red%20Book.files/image270.jpg" v:shapes="_x0000_i1377"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Однако, если вы предоставите
действительно маленькие мипмапы для мозаики, то на текстурах с низким
разрешением детали из нескольких букв будут сливаться. В OpenGL версии 1.2 вы
можете установить ограничение на самое низкое разрешение.</p>

<p class=text align=left style='text-align:left'>В OpenGL 1.2 появились новые
параметры для управления уровнями мипмаппинга: GL_TEXTURE_MIN_LOD,
GL_TEXTURE_MAX_LOD, GL_TEXTURE_BASE_LEVEL и GL_TEXTURE_MAX_LEVEL. Первые два
параметра (будем для краткости называть их BASE_LEVEL и MAX_LEVEL) управляют
тем, какие уровни мипмаппинг используются и, следовательно, тем, какие из них
должны быть предоставлены. Оставшиеся два параметра (MIN_LOD и MAX_LOD)
управляют активным диапазоном упоминавшегося ранее фактора масштаба <!--[if gte vml 1]><v:shape
 id="_x0000_i1378" type="#_x0000_t75" alt="" style='width:12.75pt;height:15pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image260.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form005.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=17 height=20
src="OpenGL%20Red%20Book.files/image260.jpg" v:shapes="_x0000_i1378"><![endif]>.</p>

<p class=text align=left style='text-align:left'>BASE_LEVEL и MAX_LEVEL
используются для управления тем, какой диапазон мипмапов следует использовать.
BASE_LEVEL – это уровень детализации с максимально высоким разрешением.
Значением по умолчанию для BASE_LEVEL является 0. Однако, впоследствии вы
можете изменять это значение, если вы добавляете мипмап с еще более высоким
разрешением «на лету». Похожим образом MAX_LEVEL ограничивает диапазон сверху,
не давая использовать мипмапы с уровнем детализации больше MAX_LEVEL (то есть,
не давая использовать мипмапы с более низкими разрешениями).</p>

<p class=text align=left style='text-align:left'>Для того, чтобы мипмаппинг
заработал, следует загрузить все мипмапы между BASEE_LEVEL и MAX_LEVEL. Самый
большой возможный уровень – это наименьшая из двух величин: MAX_LEVEL или
уровень детализации, на котором мипмап содержит только 1 тэксель. Значение по
умолчанию для MAX_LEVEL – 1000, что почти всегда означает, что наименьшее
разрешение текстуры – 1 тэксель.</p>

<p class=warning>Замечание: Если вы забудете загрузить один из необходимых
мипмапов, текстурирование может таинственно деактивироваться. Если не работают
ни мипмаппинг, ни просто текстурирование, проверьте загрузили ли вы все нужные
мипмапы.</p>

<p class=text align=left style='text-align:left'>Чтобы установить базовый и
максимальный уровни мипмапов, используйте команду <b>glTexParameter*()</b> с
первым аргументом, установленным в GL_TEXTURE_1D, GL_TEXTURE_2D или
GL_TEXTURE_3D, в зависимости от ваших текстур. Второй аргумент должен быть
одним из параметров, описанных в таблице 9-1. Третий аргумент представляет
собой значение параметра.</p>

<p class=text align=left style='text-align:left'>Таблица 9-1. Параметры
управления уровнями мипмаппинга</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Параметр</span></b><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Описание</span></b><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Значения</span></b><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TEXTURE_BASE_LEVEL<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>уровень текстуры с наивысшим используемым разрешением
  (наименьшее значение уровня по номеру)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>любое неотрицательное целое<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TEXTURE_MAX_LEVEL<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>уровень текстуры с наименьшим используемым разрешением
  (наибольшее значение уровня по номеру)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>любое неотрицательное целое<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Код в примере 9-6
устанавливает базовый и максимальный уровни мипмапов в 2 и 5 соответсвенно.
Поскольку изображение на базовом уровне (уровне 2) имеет разрешение 64x32
тэкселя, мипмапы на уровнях 3, 4 и 5 должны иметь меньшее разрешение.</p>

<p class=text align=left style='text-align:left'>Пример 9-6. Установки базового
и максимального уровней мипмапов</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_BASE_LEVEL,2);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAX_LEVEL,5);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexImage2D(GL_TEXTURE_2D,2,GL_RGBA, 64,32,0,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>GL_RGBA, GL_UNSIGNED_BYTE, image1);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexImage2D(GL_TEXTURE_2D,3,GL_RGBA, 32,16,0,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>GL_RGBA, GL_UNSIGNED_BYTE, image2);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexImage2D(GL_TEXTURE_2D,4,GL_RGBA, 16,8,0,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>GL_RGBA, GL_UNSIGNED_BYTE, image3);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexImage2D(GL_TEXTURE_2D,5,GL_RGBA, 8,4,0,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>GL_RGBA, GL_UNSIGNED_BYTE, image4);<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Позже в этой программе вам
может понадобиться добавить дополнительные мипмапы с большим или меньшим
разрешением. Например, вы можете добавить в этот набор текстуру с разрешением
128x64 тэкселя на уровне 1. Однако не забудьте изменить значение параметра
BASE_LEVEL.</p>

<h2>9.2.6.3&nbsp;Управление уровнем детализации мипмапа</h2>

<p class=text align=left style='text-align:left'>MIN_LOD и MAX_LOD представляют
минимальное и максимальное значения для <!--[if gte vml 1]><v:shape id="_x0000_i1379"
 type="#_x0000_t75" alt="" style='width:12.75pt;height:15pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image260.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form005.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=17 height=20
src="OpenGL%20Red%20Book.files/image260.jpg" v:shapes="_x0000_i1379"><![endif]>&nbsp;(фактора
масштаба текстурного изображения к полигону) для минификации и неявно задают,
какой из мипмапов следует использовать.</p>

<p class=text align=left style='text-align:left'>Если ваш полигон занимает
64xx64 пикселя, и MIN_LOD равно своему значению по умолчанию, то есть 0.0, то
текстурная карта уровня 0 с разрешением 64x64 тэкселя может быть использована
для минификации (заданный BASE_LEVEL=0; как правило, BASE_LEVEL
&lt;=&nbsp;MIN_LOD). Однако, если MIN_LOD равен 2.0, то самая большая текстура,
которая может быть использована для минификации имеет разрешение 16x16
тэкселей, что соответствует <sub><!--[if gte vml 1]><v:shape id="_x0000_i1380"
 type="#_x0000_t75" alt="" style='width:41.25pt;height:15pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image271.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form016.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=55 height=20
src="OpenGL%20Red%20Book.files/image271.jpg" v:shapes="_x0000_i1380"><![endif]></sub>.</p>

<p class=text align=left style='text-align:left'>MAX_LOD имеет влияние только в
том случае, если он меньше максимального <!--[if gte vml 1]><v:shape id="_x0000_i1381"
 type="#_x0000_t75" alt="" style='width:12.75pt;height:15pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image260.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form005.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=17 height=20
src="OpenGL%20Red%20Book.files/image260.jpg" v:shapes="_x0000_i1381"><![endif]>&nbsp;(которое
равно либо MAX_LEVEL, либо уровню, на котором текстура имеет размер в 1
тэксель). В случае карты текстуры размером 64x64 тэкселя, <!--[if gte vml 1]><v:shape
 id="_x0000_i1382" type="#_x0000_t75" alt="" style='width:41.25pt;height:15pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image272.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form017.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=55 height=20
src="OpenGL%20Red%20Book.files/image272.jpg" v:shapes="_x0000_i1382"><![endif]>&nbsp;соответствует
мипмапу размером 1x1 тэксель. Если в той же ситуации MAX_LOD равен 4.0, то ни
один мипмап меньше чем 4x4 тэкселя не будет использоваться для минификации.</p>

<p class=text align=left style='text-align:left'>Избирательное использование
MIN_LOD может уменьшить количество визуальных артефактов на текстурах с высоким
разрешением, а использование MAX_LOD – на текстурах с низким. Вы обнаружите,
что использование MIN_LOD незначительно большего BASE_LEVEL и MAX_LOD
незначительно меньшего MAX_LEVEL дает наилучшие результаты по сокращению
визуальных эффектов, связанных с переходами между мипмапами.</p>

<p class=text align=left style='text-align:left'>Как и в случае с BASE_LEVEL и
MAX_LEVEL, для управления параметрами MAX_LOD и MIN_LOD применяется команда <b>glTexParameter*()</b>.
Возможные значения перечислены в таблице 9-2.</p>

<p class=text align=left style='text-align:left'>Таблица 9-2. Параметры
управления уровнями детализации мипмаппинга</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Параметр</span></b><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Описание</span></b><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Значения</span></b><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TEXTURE_MIN_LOD<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>минимальная величина для <!--[if gte vml 1]><v:shape id="_x0000_i1383"
   type="#_x0000_t75" alt="" style='width:12.75pt;height:15pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image260.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form005.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=17 height=20
  src="OpenGL%20Red%20Book.files/image260.jpg" v:shapes="_x0000_i1383"><![endif]><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>любое значение<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TEXTURE_MAX_LOD<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>максимальная величина для <!--[if gte vml 1]><v:shape id="_x0000_i1384"
   type="#_x0000_t75" alt="" style='width:12.75pt;height:15pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image260.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form005.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=17 height=20
  src="OpenGL%20Red%20Book.files/image260.jpg" v:shapes="_x0000_i1384"><![endif]><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>любое значение<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Следующий код иллюстрирует
пример установки параметров управления уровнями детализации.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_LOD,2.5);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAX_LOD,4.5);<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<h2>9.2.6.4&nbsp;Автоматическое создание подмножества мипмапов</h2>

<p class=text align=left style='text-align:left'>При использовании описанного
контроля над уровнями мипмапов, вам может понадобиться конструирование только
некоторого их подмножества. (Например, вы возможно захотите остановиться на
изображении размером 4x4 тэкселя, а не идти до наименьшего мипмапа размером
1x1). Чтобы сконструировать и загрузить подмножество мипмапов, вы можете
использовать функцию <b>gluBuild*DMipmapLevels()</b>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>int <b>gluBuild1DMipmapLevels</b>
  (GLenum <i>target</i>, GLint <i>internalFormat</i>, GLint <i>width</i>,
  GLenum <i>format</i>, <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  GLenum <i>type</i>, GLint <i>level</i>, GLint <i>base</i>, GLint <i>max</i>,
  void *<i>texels</i>); <br>
  int <b>gluBuild2DMipmapLevels</b> (GLenum <i>target</i>, GLint <i>internalFormat</i>,
  GLint <i>width</i>, GLenum <i>height</i>, GLenum <i>format</i>,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  GLenum <i>type</i>, GLint <i>level</i>, GLint <i>base</i>, GLint <i>max</i>,
  void *<i>texels</i>); <br>
  int <b>gluBuild3DMipmapLevels</b> (GLenum <i>target</i>, GLint <i>internalFormat</i>,
  GLint <i>width</i>, GLenum <i>height</i>, GLenum <i>depth</i>, <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  GLenum <i>format</i>, GLenum <i>type</i>, GLint <i>level</i>, GLint <i>base</i>,
  GLint <i>max</i>, void *<i>texels</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Конструируют серию мипмапов и
вызывают <b>glTexImage*D()</b> для загрузки изображений. <i>level </i>индицирует
уровень мипмапа изображения, заданного в аргументе <i>texels</i>. Аргументы <i>base
</i>и <i>max</i> задают нижнюю и верхнюю границы диапазона уровней мипмапов,
которые будут произведены из изображения, заданного аргументом <i>texels</i>.
Остальные аргументы – <i>target</i>, <i>internalFormat</i>, <i>width</i>, <i>height</i>,
<i>depth</i>, <i>format</i> и <i>type</i> – имеют то же значение, что и для
команд <b>glTexImage1D()</b>, <b>glTexImage2D()</b> и <b>glTexImage3D()</b>. В
случае успешного выполнения функции, она возвращает 0. Функция возвращает код
ошибки GLU в случае неудачи.</p>

<p class=warning>Замечание: В GLU версии 1.3 функции <b>gluBuild*DMipmaps()</b>
и <b>gluBuild*DMipmapLevels()</b> поддерживают упакованные форматы пикселей (и
связанные с ними типы данных), представленные в OpenGL 1.2.</p>

<h2>9.3<i>&nbsp;</i>Фильтрация</h2>

<p class=text align=left style='text-align:left'>Текстурные карты бывают
квадратными или прямоугольными, но после наложения на полигон или поверхность и
трансформации в экранные координаты, индивидуальные тэксели текстуры редко
соответствуют индивидуальным пикселям на экране. В зависимости от используемых
преобразований и параметров текстурирования один пиксель на экране может
соответствовать чему угодно от части тэкселя (увеличение) до большой группы тэкселей
(уменьшение), как показано на рисунке 9-9. В любом случае не совсем понятно,
какие тэксели будут использоваться и как они должны интерполироваться. OpenGL
позволяет вам выбирать одну из нескольких опций фильтрации, определяющих
процесс означенных вычислений. Эти опции весьма варьируются по соотношениям
скорость/качество изображения. Вы можете задавать режимы фильтрации отдельно и
независимо для увеличения и уменьшения.</p>

<p class=text align=left style='text-align:left'>Рисунок 9-9. Увеличение и
уменьшение текстуры</p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1385" type="#_x0000_t75" alt="" style='width:465pt;height:190.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image273.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/9-9.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=620 height=254
src="OpenGL%20Red%20Book.files/image273.jpg" v:shapes="_x0000_i1385"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>В некоторых случаях ответ на
вопрос о том, что использовать: увеличение или уменьшение, не является
очевидным. Если текстурная карта должна быть растянута или сжата в обоих
направлениях (x и y), то требуется увеличение или уменьшение соответственно.
Если же карту текстуры требуется растянуть в одном направлении и сжать в
другом, OpenGL делает свой выбор между увеличением и уменьшением, и этот выбор
в большинстве случаев дает наилучший результат. Однако лучше избегать ситуаций,
используя координаты текстуры, позволяющие наложить ее на объект без подобных
искажений.</p>

<p class=text align=left style='text-align:left'>Следующие строки являются
примерами того, как использовать команду <b>glTexParameter*()</b> для выбора
методов увеличивающей и уменьшающей фильтрации:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>glTexParameteri(GL_TEXTURE_2D,
  GL_TEXTURE_MAG_FILTER, GL_NEAREST);<br>
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Первый аргумент команды должен
быть установлен в GL_TEXTURE_1D, GL_TEXTURE_2D или GL_TEXTURE_3D в зависимости
от вашей текстуры. Для данного обсуждения второй аргумент должен быть
установлен либо в GL_TEXTURE_MAG_FILTER, либо в GL_TEXTURE_MIN_FILTER,
определяя, задаете ли вы метод фильтрации для увеличения или для уменьшения.
Третий аргумент задает метод фильтрации. Все возможные методы перечислены в
таблице 9-3.</p>

<p class=text align=left style='text-align:left'>Таблица 9-3. Методы фильтрации
при увеличении и уменьшении</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Параметр</span></b><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Значения</span></b><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TEXTURE_MAG_FILTER<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_NEAREST, GL_LINEAR<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TEXTURE_MIN_FILTER<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_NEAREST, GL_LINEAR,
  GL_NEAREST_MIPMAP_NEAREST, GL_NEAREST_MIPMAP_LINEAR,<br>
  GL_LINEAR_MIPMAP_NEAREST, GL_LINEAR_MIPMAP_LINEAR<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Если вы выберите GL_NEAREST,
то для увеличения и уменьшения будет использоваться тэксель с ближайшими к
центру пикселя координатами. Это может привести к нежелательным визуальным
эффектам (иногда серьезным). Если же вы выберите GL_LINEAR, то для увеличения
или уменьшения будет использоваться взвешенная сумма массива тэкселей 2x2,
которые находятся ближе всего к центру пикселя. (В случае трехмерных текстур
используется массив размерностью 2x2x2, а в случае одномерных используются два
соседних пикселя.) Когда координаты текстуры близки к границе текстурной карты,
в массив ближайших тэкселей могут попасть те из них, которые находятся все карты.
В таких случаях величины используемых тэкселей зависят от того, какой из
режимов GL_REPEAT, GL_CLAMP или GL_CLAMP_TO_EDGE находится в действии, а также
от того, обозначили ли вы границу для текстуры. GL_NEAREST требует меньше
расчетов, чем GL_LINEAR и, таким образом, может выполняться быстрее, однако
GL_LINEAR дает визуально лучшие результаты.</p>

<p class=text align=left style='text-align:left'>При увеличении, независимо от
того, предоставили ли вы мипмапы, всегда используется текстура базового уровня.
При уменьшении вы можете выбрать метод фильтрации, который использует один или
два наиболее подходящих мипмапа, как описано в следующем абзаце. (Если для
уменьшения заданы методы GL_NEAREST или GL_LINEAR, то опять таки будет
использована только текстура базового уровня.)</p>

<p class=text align=left style='text-align:left'>Как показано в таблице 9-3,
для уменьшения с применением мипмапов доступно 4 дополнительных метода
фильтрации. Внутри индивидуального мипмапа вы можете выбрать ближайший тэксель
(GL_NEAREST_MIPMAP_NEAREST) или линейную интерполяцию
(GL_LINEAR_MIPMAP_NEAREST). Использование ближайших тэкселей быстрее, но
приводит к недостаточно качественным результатам. Выбор того, какой конкретный
мипмап использовать зависит от того, какое количество уменьшения требуется;
существуют граничные значения, на которых производится переход от одного
мипмапа к другому. Чтобы избежать неожиданных переходов, используйте
GL_NEAREST_MIPMAP_LINEAR или GL_LINEAR_MIPMAP_LINEAR для линейной интерполяции
величин тэкселей из двух ближайших мипмапов. GL_NEAREST_MIPMAP_LINEAR выбирает
ближайшие тэксели в обоих мипмапах, а затем производит линейную интерполяцию
между их величинами. GL_LINEAR_MIPMAP_LINEAR производит линейную интерполяцию
для вычисления величины тэкселей двух карт, а затем интерполирует еще и между
ними. Как вы можете предположить, использование режима GL_LINEAR_MIPMAP_LINEAR
дает лучшие визуальные результаты, но требует больших вычислений и работает
медленнее.</p>

<p class=warning>Замечание: Если вы выберите один из фильтров, использующих
мипмапы, но забудете загрузить один из необходимых мипмапов, OpenGL не выдаст
никаких ошибок, но деактивирует текстурирование. Если не работают ни
мипмаппинг, ни просто текстурирование, проверьте загрузили ли вы все нужные
мипмапы.</p>

<p class=text align=left style='text-align:left'>Некоторые из описанных
фильтров известны под более популярными именами. GL_NEAREST часто называется <i>точечной
фильтрацией</i> (<i>point sampling</i>). GL_LINEAR известен как <i>билинейная
фильтрация</i> (<i>bilinear sampling</i>), поскольку для двумерных текстур
используется массив тэкселей размерности 2x2. GL_LINEAR_MIPMAP_LINEAR иногда
называют <i>трилинейной фильтрацией</i> (<i>trilinear sampling</i>), поскольку
используется линейное среднее между двумя билинейно фильтрованными мипмапами.</p>

<h2>9.4&nbsp;Текстурные объекты</h2>

<p class=text align=left style='text-align:left'>Текстурные объекты хранят
данные текстуры и позволяют ими управлять. Вы можете контролировать
одновременно несколько текстур и возвращаться к текстурам, которые были
загружены ранее. Использование текстурных объектов обычно быстрейший способ
работы с текстурами, что выражается в большом выигрыше по производительности,
поскольку переключиться на существующую текстуру (повторно использовать ее)
можно гораздо быстрее, чем загружать ее заново командой <b>glTexImage*D()</b>.</p>

<p class=text align=left style='text-align:left'>Кроме того, некоторые
реализации поддерживают ограниченное рабочее подмножество быстродействующих
текстур. Вы можете использовать текстурные объекты для загрузки самых часто
используемых текстур в эту ограниченную область.</p>

<p class=text align=left style='text-align:left'>Чтобы использовать объекты
текстуры для данных текстуры выполните следующие шаги.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l11 level1 lfo39;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Сгенерируйте имена текстур.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l11 level1 lfo39;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Привяжите объекты текстуры к данным текстуры (в
частности к массивам изображений и свойствам).</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l11 level1 lfo39;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Если ваша реализация поддерживает рабочее
подмножество быстродействующих текстур, проверьте, достаточно ли у вас
пространства для всех ваших текстурных объектов. Если пространство
недостаточно, возможно вам стоит установить приоритет для каждого текстурного
объекта, чтобы наиболее часто используемые текстуры оставались в рабочем
подмножестве.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l11 level1 lfo39;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Выбирайте (повторно связывайте) ваши текстурные
объекты, делая их текущими для визуализации текстурированных моделей.</p>

<p class=warning>Замечание:<b> </b>Текстурные объекты появились в OpenGL версии
1.1.</p>

<h2>9.4.1 Именование текстурных объектов</h2>

<p class=text align=left style='text-align:left'>В качестве имени текстуры
может быть использовано любое ненулевое беззнаковое целое. Чтобы избежать
случайного повторного использования имен, постоянно используйте команду <b>glGenTextures()</b>
для получения неиспользуемых имен текстур.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glGenTextures</b>
  (GLsizei <i>n</i>, GLuint *<i>textureNmes</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Возвращает <i>n </i>неиспользуемых
имен текстурных объектов в массиве <i>textureNames</i>. Имена, возвращаемые в
массиве <i>textureNames</i>, не обязаны составлять один непрерывный интервал.
Возвращенные имена помечаются как используемые, однако следует помнить, что
привязка имени к состоянию и размерности текстуры (1D, 2D или 3D)
осуществляется только в момент его первой выдачи. Ноль – это зарезервированное
имя текстуры, и оно никогда не возвращается командой <b>glGenTextures()</b>.</p>

<p class=text align=left style='text-align:left'>Команда <b>glIsTexture()</b>
определяет, используется ли конкретное имя текстуры в данный момент. Если имя
текстуры было возвращено командой <b>glGenTextures()</b>, но еще не было
связано с данными (хотя бы однократным вызовом команды <b>glBindTexture()</b>),
команда <b>glIsTexture()</b> возвратит GL_FALSE.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>glIsTexture</b>
  (GLuint <i>textureName</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Возвращает GL_TRUE, если <i>textureName
</i>является именем текстуры, которое было связано и впоследствии не было
удалено. Возвращает GL_FALSE в случае, если <i>textureName </i>равно 0, или
если оно не равно 0, но не является именем существующей текстуры.</p>

<h2>9.4.2&nbsp;&nbsp;&nbsp;&nbsp; Создание и использование текстурных объектов</h2>

<p class=text align=left style='text-align:left'>Одна и та же команда <b>glBindTexture()</b>
используется и при создании, и при использовании текстурных объектов. При
начальном связывании (с использованием <b>glBindTexture()</b>) создается новый
текстурный объект с величинами по умолчанию для изображения текстуры и ее
свойств. Последующие обращения к командам <b>glTexImage*()</b>, <b>glTexSubImage*()</b>,
<b>glCopyTexImage*()</b>, <b>glCopyTexSubImage*()</b>, <b>glTexParameter*()</b>
и <b>glPrioritizeTextures()</b> сохраняются данные в текстурном объекте. Объект
текстуры может содержать изображение текстуры и ассоциированные с ним мипмапы
(если они присутствуют), а также ассоциированные с текстурой данные, такие как
ширина, высота, ширина границы, внутренний формат, разрешение компонент и
свойства текстуры. Сохраняемые свойства текстуры включают уменьшающий и
увеличивающий фильтры, режим наложения, цвет границы и приоритет.</p>

<p class=text align=left style='text-align:left'>Когда объект текстуры
связывается впоследствии, данные, содержащиеся в нем, становятся текущим
состоянием текстуры, замещая предыдущее состояние.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glBindTexture</b>
  (GLenum <i>target</i>, GLuint <i>textureName</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'><b>glBindTexture()</b> делает
три вещи. При использовании в качестве <i>textureName </i>беззнакового целого
неравного 0 в первый раз, создается новый объект текстуры, и переданное имя
текстуры ассоциируется с ним. Если привязка осуществляется к предварительно
созданному объекту текстуры, то этот объект становится текущим. Когда
связывание производится при <i>textureName </i>равном 0, OpenGL перестает
использовать объекты текстуры и возвращается к безымянной текстуре по
умолчанию. При начальном связывании текстурного объекта (то есть при его
создании) с ним ассоциируется размерность текстуры, то есть GL_TEXTURE_1D,
GL_TEXTURE_2D или GL_TEXTURE_3D, задаваемая в аргументе <i>target</i>. Сразу
после начального связывания состояние текстурного объекта совпадает с
состоянием GL_TEXTURE_1D, GL_TEXTURE_2D или GL_TEXTURE_3D (в зависимости от
размерности текстуры) по умолчанию при инициализации OpenGL. В начальном
состоянии свойства текстуры, такие как уменьшающий и увеличивающий фильтры,
режим наложения, цвет границы и приоритет установлены в свои значения по
умолчанию.</p>

<p class=text align=left style='text-align:left'>В примере 9-7 в функции <b>init()</b>
создаются 2 текстурных объекта. В функции <b>display()</b> каждый из объектов
используется для визуализации одного четырехстороннего полигона. Результат
работы программы изображен на рисунке 9-10.</p>

<p class=text align=left style='text-align:left'>Рисунок 9-10. Два полигона
текстурированных с помощью объектов текстуры</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#include &lt;glut.h&gt;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#define checkImageWidth 64<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#define checkImageHeight 64<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>GLubyte checkImage[checkImageHeight][checkImageWidth][4];<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>GLubyte otherImage[checkImageHeight][checkImageWidth][4];<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>GLuint texName[2];<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>//Создание изображения текстуры<o:p></o:p></span></pre><pre><span
  style='color:black'>void makeCheckImage()<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>int i,j,c;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>for(i=0;i&lt;checkImageHeight;i++)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>for(j=0;j&lt;checkImageWidth;j++)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>c=(((i&amp;0x8)==0)^((j&amp;0x8)==0))*255;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>checkImage[i][j][0]=(GLubyte)c;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>checkImage[i][j][1]=(GLubyte)0;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>checkImage[i][j][2]=(GLubyte)0;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>checkImage[i][j][3]=(GLubyte)1.0;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>c=(((i&amp;0x10)==0)^((j&amp;0x10)==0))*255;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>otherImage[i][j][0]=(GLubyte)0;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>otherImage[i][j][1]=(GLubyte)c;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>otherImage[i][j][2]=(GLubyte)0;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>otherImage[i][j][3]=(GLubyte)1.0;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void init(void)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glClearColor(1.0,1.0,1.0,0.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glShadeModel(GL_FLAT);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glEnable(GL_DEPTH_TEST);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>makeCheckImage();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glPixelStorei(GL_UNPACK_ALIGNMENT,1);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glGenTextures(2,texName);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glBindTexture(GL_TEXTURE_2D,texName[0]);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S, GL_CLAMP);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T, GL_CLAMP);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER, GL_NEAREST);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER, GL_NEAREST);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexImage2D(GL_TEXTURE_2D,0,GL_RGBA,checkImageWidth,checkImageHeight,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>0,GL_RGBA,GL_UNSIGNED_BYTE,checkImage);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glBindTexture(GL_TEXTURE_2D,texName[1]);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S, GL_CLAMP);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T, GL_CLAMP);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER, GL_NEAREST);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER, GL_NEAREST);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexEnvf(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_REPLACE);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexImage2D(GL_TEXTURE_2D,0,GL_RGBA,checkImageWidth,checkImageHeight,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>0,GL_RGBA,GL_UNSIGNED_BYTE,otherImage);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glEnable(GL_TEXTURE_2D);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void display(void)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glClear (GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glBindTexture(GL_TEXTURE_2D,texName[0]);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glBegin(GL_QUADS);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexCoord2f(0.0,0.0); glVertex3f(-2.0,-1.0,0.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexCoord2f(0.0,1.0); glVertex3f(-2.0,1.0,0.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexCoord2f(1.0,1.0); glVertex3f(0.0,1.0,0.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexCoord2f(1.0,0.0); glVertex3f(0.0,-1.0,0.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glEnd();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glBindTexture(GL_TEXTURE_2D,texName[1]);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glBegin(GL_QUADS);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexCoord2f(0.0,0.0); glVertex3f(1.0,-1.0,0.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexCoord2f(0.0,1.0); glVertex3f(1.0,1.0,0.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexCoord2f(1.0,1.0); glVertex3f(2.41421,1.0,-1.41421);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexCoord2f(1.0,0.0); glVertex3f(2.41421,-1.0,-1.41421);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glEnd();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glFlush();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void reshape(int w, int h)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glViewport(0,0,(GLsizei) w, (GLsizei) h);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glMatrixMode(GL_PROJECTION);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glLoadIdentity();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>if (w&lt;=h)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glOrtho(-3.0,3.0,-3.0*(GLfloat)h/(GLfloat)w,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>3.0*(GLfloat)h/(GLfloat)w,-10.0,10.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>else<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glOrtho(-3.0*(GLfloat)w/(GLfloat)h,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>3.0*(GLfloat)w/(GLfloat)h,-3.0,3.0,-10.0,10.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glMatrixMode(GL_MODELVIEW);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glLoadIdentity();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>int main(int argc, char **argv)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glutInit(&amp;argc,argv);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB|GLUT_DEPTH);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glutInitWindowSize(620,620);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glutInitWindowPosition(100,100);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glutCreateWindow(&quot;Binding Texture Objects&quot;);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>init();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glutDisplayFunc(display);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glutReshapeFunc(reshape);<o:p></o:p></span></pre><pre><span
  style='color:black'>glutMainLoop();<o:p></o:p></span></pre><pre><span
  style='color:black'>return 0;<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Если текстурный объект
становится активным (то есть вторично связывается), вы можете редактировать его
содержимое. Любые вызываемые вами команды, изменяющие изображение текстуры или
ее свойства, будут изменять содержимое текущего текстурного объекта.</p>

<p class=text align=left style='text-align:left'>В примере 9-7 после завершения
функции <b>display()</b> вы все еще связаны с текстурой имеющей имя <i>texName[1]</i>.
Будьте осторожны: если вы спонтанно вызовите какую-либо команду, изменяющую
текущее состояние текстуры, она также изменит и содержимое текущего текстурного
объекта.</p>

<p class=text align=left style='text-align:left'>При использовании мипмапов,
все мипмапы, связанные с одним текстурным изображением, должны быть помещены в
один текстурный объект. В примере 9-5 уровни мипмапов 0-5 помещаются в один
текстурный объект именуемый <i>texName</i>.</p>

<h2>9.4.3&nbsp;&nbsp;&nbsp;&nbsp; Очистка текстурных объектов</h2>

<p class=text align=left style='text-align:left'>В то время как вы производите
первичное или вторичное связывание текстурных объектов, их данные по-прежнему
находятся где-то в текстурных ресурсах. Если эти ресурсы ограничены, удаление
текстур является единственным способом освобождения памяти.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glDeleteTextures</b>
  (GLsizei <i>n</i>, const GLuint *<i>textureNames</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Удаляет <i>n</i>текстурных
объектов, чьи имена переданы в аргументе <i>textureNames</i>. Освобожденные
имена могут быть повторно использованы (например, возвращены командой <b>glGenTextures()</b>).
Если удаляется текущая текстура, состояние переходит к текстуре по умолчанию,
как если бы была вызвана команда <b>glBindTextures()</b> с аргументом <i>textureName
</i>равным 0. Попытки удаления имен несуществующих текстур игнорируются без
генерации каких-либо ошибок.</p>

<h2>9.4.4&nbsp;&nbsp;&nbsp;&nbsp; Рабочее подмножество резидентных текстур</h2>

<p class=text align=left style='text-align:left'>Некоторые реализации OpenGL
поддерживают рабочее подмножество быстродействующих текстур, о которых говорят,
что они резидентны. Обычно, в этих реализациях имеется специализированная
аппаратура для выполнения текстурных операций и ограниченный аппаратный кэш для
хранения изображений текстур. В таких случаях рекомендуется использовать
текстурные объекты, поскольку вы можете загрузить несколько текстур в рабочее
подмножество и управлять ими.</p>

<p class=text align=left style='text-align:left'>Если все текстуры, требуемые
приложению, превышают размер кэша, некоторые из них не могут быть резидентными.
Если вам нужно выяснить, является ли конкретная текстура резидентной, сделайте
ее объект текущим, а затем используйте команду <b>glGetTexParameter*v()</b>,
чтобы выяснить значение величины, связанной с переменной состояния
GL_TEXTURE_RESIDENT. Если вам нужно выяснить резидентность состояния нескольких
текстур, используйте команду <b>glAreTexturesResident()</b>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>GLboolean
  <b>glAreTexturesResident</b> (GLsizei <i>n</i>, const GLuint *<i>textureNames</i>,
  GLboolean *<i>residences</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Запрашивает текстурный статус
резидентности <i>n</i>текстурных объектов, чьи имена передаются в массиве <i>textureNames</i>.
<i>residences </i>– это массив, в котором статусы резидентности возвращаются
для соответствующих текстурных объектов в массиве <i>textureNames</i>. Если все
текстуры, переданные в массиве <i>textureNames</i>, являются резидентными,
команда возвращает значение GL_TRUE, а содержимое массива <i>residences </i>не
изменяется. Если хотя бы одна из текстур в <i>textureNames</i>не является
резидентной, команда возвращает GL_FALSE, и элементы массива <i>residences</i>,
соответствующие нерезидентным текстурам из массива <i>textureNames</i>, также
устанавливаются в GL_FALSE.</p>

<p class=text align=left style='text-align:left'>Обратите внимание на то, что <b>glAreTexturesResident()</b>
возвращает текущий резидентный статус. Текстурные ресурсы очень динамичны, и
этот статус может изменяться в любое время. Некоторые реализации кэшируют
текстуры в момент их первого использования. Возможно, понадобится нарисовать
хотя бы один текстурированный объект, а уже затем проверять резидентность его
текстуры.</p>

<p class=text align=left style='text-align:left'>Если ваша реализация OpenGL не
поддерживает рабочего подмножества текстур, то все текстурные объекты всегда
считаются резидентными. В этом случае <b>glAreTexturesResident()</b>всегда
будет возвращать GL_TRUE.</p>

<h2>9.4.4.1&nbsp;&nbsp;&nbsp; Стратегии резидентности текстур</h2>

<p class=text align=left style='text-align:left'>Если вы можете создать рабочее
подмножество текстур и хотите получить наилучшее возможное быстродействие при
работе с текстурами, вам действительно нужно знать специфику вашей реализации и
приложения. Например, если вы создаете визуальный симулятор или компьютерную
игру, вам нужно следить за быстродействием во всех ситуациях. В этом случае вам
никогда не следует обращаться к нерезидентной текстуре. Для таких приложений
вам нужно загрузить все ваши текстуры на этапе инициализации и обеспечить их
резидентность. Если вам не хватает текстурной памяти, возможно, вам следует
сократить размер, разрешение или количество мипмапов для ваших текстур или
использовать <b>glTexSubImage*()</b> для повторного использования одной и той
же текстурной памяти.</p>

<p class=warning>Замечание: Если у вас есть несколько текстур одинакового
размера, которые нужны лишь на короткий период, вы можете использовать <b>glTexSubImage*()</b>
для загрузки новых данных в существующие объекты текстуры. Эта техника может
работать быстрее, чем удаление и создание новых текстур.</p>

<p class=text align=left style='text-align:left'>Для приложений, которые
создают текстуры «на лету», избежание нерезидентных текстур может быть трудной
задачей. Если определенные текстуры используются чаще, чем другие, вы можете
присвоить их текстурным объектам более высокий приоритет, что повысит их шансы
на резидентность. Удаление текстурных объектов также освобождает пространство.
Говоря коротко, присвоение текстурному объекту низкого приоритета может сделать
его первым в очереди на удаление из рабочего подмножества. Для назначения
приоритетов используется команда <b>glPrioritizeTextures()</b>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glPrioritizeTextures</b>
  (GLsizei <i>n</i>, const GLuint *<i>textureNames</i>, const GLclampf *<i>priorities</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Команда назначает n
приоритетов из массива <i>priorities</i> для <i>n </i>соответствующих
текстурных объектов из массива <i>textureNames</i>. перед назначением величины
приоритетов приводятся к диапазону [0; 1]. 0 означает низший приоритет (такие
текстуры вряд ли будут резидентными), а 1 – наивысший. <b>glPrioritizeTextures()</b>
не требует, чтобы какие-либо имена из <i>textureNames </i>были связаны с
существующими текстурами. Однако приоритет не имеет никакого действия на объект
до тех пор, пока он не связан.</p>

<p class=text align=left style='text-align:left'>Для назначения приоритета
одной текстуре также может быть использована команда <b>glTexParameter*()</b>,
но только в том случае, если имя текстуры уже связано. Кроме того,
использование <b>glTexParameter*()</b> – это единственный способ назначить
приоритет текстуре по умолчанию.</p>

<p class=text align=left style='text-align:left'>Если текстурные объекты имеют
одинаковый приоритет, типичная реализация OpenGL при принятии решения о том,
какую текстуру следует переместить из рабочего подмножества, применяет
стратегию <i>наиболее давно использованного элемента</i> (<i>least recently
used</i> -- LRU). Если вы уверены, что в вашей реализации действует именно этот
алгоритм, тогда назначение одинаковых приоритетов всем объектам текстуры,
создает разумную LRU систему по распределению текстурных ресурсов.</p>

<p class=text align=left style='text-align:left'>Если ваша реализация OpenGL не
использует стратегию LRU для текстурных объектов с одинаковыми приоритетами
(или если вы не знаете, какую стратегию она использует), вы можете разработать
свою собственную стратегию LRU, аккуратно управляя приоритетами текстурных
объектов. Когда текстура находится в использовании (когда она связывается), вы
можете установить максимальный приоритет, что соответствует наиболее недавнему
использованию. Затем через регулярные промежутки времени вы можете уменьшать
приоритеты всех объектов текстуры.</p>

<p class=warning>Замечание: Фрагментация текстурной памяти может быть
проблемой, особенно если вы удаляете и создаете много новых текстур. Несмотря
на то, что можно загрузить все текстуры в рабочее подмножество, произведя
связывание последовательно в одной цепочке, связывание их в другой цепочке
может оставить некоторые текстуры нерезидентными.</p>

<h2>9.4.55&nbsp;&nbsp;&nbsp;&nbsp; Функции текстурирования</h2>

<p class=text align=left style='text-align:left'>В каждом из представленных в
этой главе примеров величины в карте текстуры непосредственно использовались в
качестве цветов, рисуемых на поверхности объектов. Вы также можете использовать
текстуру для модуляции того цвета, которым объект был бы нарисован без
текстурирования или комбинировать цвет в карте текстуры с оригинальным цветом
поверхности. Вы выбираете одну из 4 функций текстурирования, передавая нужные
аргументы команде <b>glTexEnv*()</b>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glTexEnv</b>{if}
  (GLenum <i>target</i>, GLenum <i>pname</i>, TYPE <i>param</i>);<br>
  void <b>glTexEnv</b>{if}<b>v</b> (GLenum <i>target</i>, GLenum <i>pname</i>,
  TYPE *<i>params</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Устанавливает текущую функцию
текстурирования. Аргумент <i>target </i>должен быть установлен в значения
GL_TEXTURE_1D, GL_TEXTURE_2D или GL_TEXTURE_3D. Если <i>pname </i>равен
GL_TEXTURE_ENV_MODE, то <i>param </i>должен быть равен GL_DECAL, GL_REPLACE,
GL_MODULATE или GL_BLEND, задавая метод, которым величины текстуры должны
комбинироваться с обрабатываемыми фрагментами. Если <i>pname </i>равен GL_TEXTURE_ENV_COLOR,
<i>param </i>представляет собой массив из 4 чисел с плавающей точкой,
являющихся компонентами R, G, B и A. Эти величины используются только если
текущей функцией текстурирования является GL_BLEND.</p>

<p class=text align=left style='text-align:left'>Комбинация функции
текстурирования и базового внутреннего формата определяет, как применяется
текстура для каждого ее компонента. Функции текстурирования оперируют
выбранными компонентами текстуры и цветовыми величинами, которые использовались
бы без текстурирования. (Заметьте, что этот выбор осуществляется после
выполнения операций передачи пикселей.) Вспомните, что при создании ваших
текстурных карт командой <b>glTexImage*D()</b>, вы передаете спецификатор
внутреннего формата в третьем аргументе.</p>

<p class=text align=left style='text-align:left'>В таблицах 9-4 и 9-5
перечислены формулы текстурирования, используемые для каждого компонента
текстуры. Существует 6 базовых внутренних форматов (буквы в скобках показывают,
как они обозначены в таблице): GL_ALPHA (A), GL_LUMINANCE (L),
GL_LUMINANCE_ALPHA (L и A), GL_INTENSITY (I), GL_RGB (C) и GL_RGBA (C и A).
Остальные внутренние форматы задают желаемое разрешение компонент текстуры, и
работа с ними ведется так же как с одним из перечисленных выше форматов.</p>

<p class=warning>Замечание: В таблице 9-4 нижний индекс <i>t</i> означает
величину текстуры, <i>f</i> – величину входящего фрагмента, <i>c</i> – величину,
присвоенную переменной состояния GL_TEXTURE_ENV_COLOR, а отсутствие нижнего
индекса – означает финальную вычисленную величину. Также в этих таблицах
умножение цветовой тройки на скаляр означает умножение каждого из трех
компонент R, G и B на этот скаляр; умножение (или суммирование) двух цветовых
троек означает попарное умножение (или суммирование) соответствующих
компонентов из каждой тройки.</p>

<p class=text align=left style='text-align:left'>Таблица 9-4. Текстурные
функции GL_REPLACE и GL_MODULATE</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Базовый внутренний формат</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Функция GL_REPLACE</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Функция GL_MODULATE</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Функция GL_DECAL</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Функция GL_BLEND</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_ALPHA<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1386" type="#_x0000_t75"
   alt="" style='width:43.5pt;height:19.5pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image274.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form018.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=58 height=26
  src="OpenGL%20Red%20Book.files/image274.jpg" v:shapes="_x0000_i1386"><![endif]><br>
  <!--[if gte vml 1]><v:shape id="_x0000_i1387" type="#_x0000_t75" alt=""
   style='width:40.5pt;height:17.25pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image275.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form019.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=54 height=23
  src="OpenGL%20Red%20Book.files/image275.jpg" v:shapes="_x0000_i1387"><![endif]><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1388" type="#_x0000_t75"
   alt="" style='width:43.5pt;height:19.5pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image274.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form018.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=58 height=26
  src="OpenGL%20Red%20Book.files/image274.jpg" v:shapes="_x0000_i1388"><![endif]><br>
  <!--[if gte vml 1]><v:shape id="_x0000_i1389" type="#_x0000_t75" alt=""
   style='width:57pt;height:18.75pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image276.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form020.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=76 height=25
  src="OpenGL%20Red%20Book.files/image276.jpg" v:shapes="_x0000_i1389"><![endif]><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>не определена<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1390" type="#_x0000_t75"
   alt="" style='width:43.5pt;height:19.5pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image274.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form018.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=58 height=26
  src="OpenGL%20Red%20Book.files/image274.jpg" v:shapes="_x0000_i1390"><![endif]><br>
  <!--[if gte vml 1]><v:shape id="_x0000_i1391" type="#_x0000_t75" alt=""
   style='width:57pt;height:18.75pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image276.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form020.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=76 height=25
  src="OpenGL%20Red%20Book.files/image276.jpg" v:shapes="_x0000_i1391"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_LUMINANCE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1392" type="#_x0000_t75"
   alt="" style='width:39.75pt;height:18pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image277.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form021.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=53 height=24
  src="OpenGL%20Red%20Book.files/image277.jpg" v:shapes="_x0000_i1392"><![endif]><br>
  <!--[if gte vml 1]><v:shape id="_x0000_i1393" type="#_x0000_t75" alt=""
   style='width:44.25pt;height:18pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image278.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form022.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=59 height=24
  src="OpenGL%20Red%20Book.files/image278.jpg" v:shapes="_x0000_i1393"><![endif]><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1394" type="#_x0000_t75"
   alt="" style='width:57.75pt;height:19.5pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image279.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form023.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=77 height=26
  src="OpenGL%20Red%20Book.files/image279.jpg" v:shapes="_x0000_i1394"><![endif]><br>
  <!--[if gte vml 1]><v:shape id="_x0000_i1395" type="#_x0000_t75" alt=""
   style='width:44.25pt;height:18pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image278.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form022.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=59 height=24
  src="OpenGL%20Red%20Book.files/image278.jpg" v:shapes="_x0000_i1395"><![endif]><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>не определена<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1396" type="#_x0000_t75"
   alt="" style='width:128.25pt;height:20.25pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image280.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form031.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=171 height=27
  src="OpenGL%20Red%20Book.files/image280.jpg" v:shapes="_x0000_i1396"><![endif]><br>
  <!--[if gte vml 1]><v:shape id="_x0000_i1397" type="#_x0000_t75" alt=""
   style='width:44.25pt;height:18pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image278.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form022.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=59 height=24
  src="OpenGL%20Red%20Book.files/image278.jpg" v:shapes="_x0000_i1397"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_LUMINANCE_ALPHA<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1398" type="#_x0000_t75"
   alt="" style='width:39.75pt;height:18pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image277.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form021.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=53 height=24
  src="OpenGL%20Red%20Book.files/image277.jpg" v:shapes="_x0000_i1398"><![endif]><br>
  <!--[if gte vml 1]><v:shape id="_x0000_i1399" type="#_x0000_t75" alt=""
   style='width:40.5pt;height:17.25pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image275.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form019.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=54 height=23
  src="OpenGL%20Red%20Book.files/image275.jpg" v:shapes="_x0000_i1399"><![endif]><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1400" type="#_x0000_t75"
   alt="" style='width:57.75pt;height:19.5pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image279.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form023.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=77 height=26
  src="OpenGL%20Red%20Book.files/image279.jpg" v:shapes="_x0000_i1400"><![endif]><br>
  <!--[if gte vml 1]><v:shape id="_x0000_i1401" type="#_x0000_t75" alt=""
   style='width:57pt;height:18.75pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image276.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form020.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=76 height=25
  src="OpenGL%20Red%20Book.files/image276.jpg" v:shapes="_x0000_i1401"><![endif]><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>не определена<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1402" type="#_x0000_t75"
   alt="" style='width:128.25pt;height:20.25pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image280.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form031.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=171 height=27
  src="OpenGL%20Red%20Book.files/image280.jpg" v:shapes="_x0000_i1402"><![endif]><br>
  <!--[if gte vml 1]><v:shape id="_x0000_i1403" type="#_x0000_t75" alt=""
   style='width:57pt;height:18.75pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image276.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form020.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=76 height=25
  src="OpenGL%20Red%20Book.files/image276.jpg" v:shapes="_x0000_i1403"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_INTENSITY<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1404" type="#_x0000_t75"
   alt="" style='width:38.25pt;height:18.75pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image281.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form024.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=51 height=25
  src="OpenGL%20Red%20Book.files/image281.jpg" v:shapes="_x0000_i1404"><![endif]><br>
  <!--[if gte vml 1]><v:shape id="_x0000_i1405" type="#_x0000_t75" alt=""
   style='width:37.5pt;height:15.75pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image282.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form025.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=50 height=21
  src="OpenGL%20Red%20Book.files/image282.jpg" v:shapes="_x0000_i1405"><![endif]><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1406" type="#_x0000_t75"
   alt="" style='width:57pt;height:20.25pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image283.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form026.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=76 height=27
  src="OpenGL%20Red%20Book.files/image283.jpg" v:shapes="_x0000_i1406"><![endif]><br>
  <!--[if gte vml 1]><v:shape id="_x0000_i1407" type="#_x0000_t75" alt=""
   style='width:54.75pt;height:20.25pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image284.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form027.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=73 height=27
  src="OpenGL%20Red%20Book.files/image284.jpg" v:shapes="_x0000_i1407"><![endif]><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>не определена<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1408" type="#_x0000_t75"
   alt="" style='width:123.75pt;height:18.75pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image285.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form032.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=165 height=25
  src="OpenGL%20Red%20Book.files/image285.jpg" v:shapes="_x0000_i1408"><![endif]><br>
  <!--[if gte vml 1]><v:shape id="_x0000_i1409" type="#_x0000_t75" alt=""
   style='width:124.5pt;height:18.75pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image286.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form033.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=166 height=25
  src="OpenGL%20Red%20Book.files/image286.jpg" v:shapes="_x0000_i1409"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:5'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_RGB<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1410" type="#_x0000_t75"
   alt="" style='width:42pt;height:19.5pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image287.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form028.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=56 height=26
  src="OpenGL%20Red%20Book.files/image287.jpg" v:shapes="_x0000_i1410"><![endif]><br>
  <!--[if gte vml 1]><v:shape id="_x0000_i1411" type="#_x0000_t75" alt=""
   style='width:44.25pt;height:18pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image278.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form022.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=59 height=24
  src="OpenGL%20Red%20Book.files/image278.jpg" v:shapes="_x0000_i1411"><![endif]><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1412" type="#_x0000_t75"
   alt="" style='width:58.5pt;height:19.5pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image288.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form029.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=78 height=26
  src="OpenGL%20Red%20Book.files/image288.jpg" v:shapes="_x0000_i1412"><![endif]><br>
  <!--[if gte vml 1]><v:shape id="_x0000_i1413" type="#_x0000_t75" alt=""
   style='width:44.25pt;height:18pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image278.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form022.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=59 height=24
  src="OpenGL%20Red%20Book.files/image278.jpg" v:shapes="_x0000_i1413"><![endif]><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1414" type="#_x0000_t75"
   alt="" style='width:42pt;height:19.5pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image287.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form028.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=56 height=26
  src="OpenGL%20Red%20Book.files/image287.jpg" v:shapes="_x0000_i1414"><![endif]><br>
  <!--[if gte vml 1]><v:shape id="_x0000_i1415" type="#_x0000_t75" alt=""
   style='width:44.25pt;height:18pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image278.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form022.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=59 height=24
  src="OpenGL%20Red%20Book.files/image278.jpg" v:shapes="_x0000_i1415"><![endif]><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1416" type="#_x0000_t75"
   alt="" style='width:129.75pt;height:21pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image289.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form034.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=173 height=28
  src="OpenGL%20Red%20Book.files/image289.jpg" v:shapes="_x0000_i1416"><![endif]><br>
  <!--[if gte vml 1]><v:shape id="_x0000_i1417" type="#_x0000_t75" alt=""
   style='width:44.25pt;height:18pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image278.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form022.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=59 height=24
  src="OpenGL%20Red%20Book.files/image278.jpg" v:shapes="_x0000_i1417"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:6;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_RGBA<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1418" type="#_x0000_t75"
   alt="" style='width:42pt;height:19.5pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image287.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form028.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=56 height=26
  src="OpenGL%20Red%20Book.files/image287.jpg" v:shapes="_x0000_i1418"><![endif]><br>
  <!--[if gte vml 1]><v:shape id="_x0000_i1419" type="#_x0000_t75" alt=""
   style='width:40.5pt;height:17.25pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image275.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form019.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=54 height=23
  src="OpenGL%20Red%20Book.files/image275.jpg" v:shapes="_x0000_i1419"><![endif]><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1420" type="#_x0000_t75"
   alt="" style='width:58.5pt;height:19.5pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image288.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form029.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=78 height=26
  src="OpenGL%20Red%20Book.files/image288.jpg" v:shapes="_x0000_i1420"><![endif]><br>
  <!--[if gte vml 1]><v:shape id="_x0000_i1421" type="#_x0000_t75" alt=""
   style='width:57pt;height:18.75pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image276.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form020.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=76 height=25
  src="OpenGL%20Red%20Book.files/image276.jpg" v:shapes="_x0000_i1421"><![endif]><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1422" type="#_x0000_t75"
   alt="" style='width:127.5pt;height:19.5pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image290.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form030.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=170 height=26
  src="OpenGL%20Red%20Book.files/image290.jpg" v:shapes="_x0000_i1422"><![endif]><br>
  <!--[if gte vml 1]><v:shape id="_x0000_i1423" type="#_x0000_t75" alt=""
   style='width:44.25pt;height:18pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image278.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form022.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=59 height=24
  src="OpenGL%20Red%20Book.files/image278.jpg" v:shapes="_x0000_i1423"><![endif]><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1424" type="#_x0000_t75"
   alt="" style='width:129.75pt;height:21pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image289.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form034.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=173 height=28
  src="OpenGL%20Red%20Book.files/image289.jpg" v:shapes="_x0000_i1424"><![endif]><br>
  <!--[if gte vml 1]><v:shape id="_x0000_i1425" type="#_x0000_t75" alt=""
   style='width:57pt;height:18.75pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image276.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form020.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=76 height=25
  src="OpenGL%20Red%20Book.files/image276.jpg" v:shapes="_x0000_i1425"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=warning>Замечание: Замещающая текстурная функция (GL_REPLACE) просто
берет цвет, которым объект был бы нарисован без текстурирования (цвет
фрагмента), отбрасывает его и замещает цветом текстуры. Функцию замещения
следует использовать в случаях, когда на объект нужно наложить непрозрачную
текстуру.</p>

<p class=text align=left style='text-align:left'>Функция GL_DECAL (переводная
картинка) похожа на замещение за исключением того, что она работает только для
внутренних форматов RGB и RGBA и обрабатывает альфа величины иначе. В формате
RGBA результирующий цвет является результатом наложения цвета текстуры на цвет
фрагмента, причем доли этих цветов определяются альфа компонентом текстуры, а
альфа фрагмента в расчетах не участвует и не изменяется. Эта функция может
использоваться для наложения таких текстур, как знак авиакомпании на крыле
самолета (исходный цвет крыла виден везде, кроме того места, где нарисован
знак).</p>

<p class=text align=left style='text-align:left'>При модуляции (GL_MODULATE)
цвет фрагмента модулируется содержимым текстурной карты. Если базовый формат –
GL_LUMINANCE, GL_LUMINANCE_ALPHA или GL_INTENSITY, цветовые величины умножаются
на одинаковую величину, и цветовая карта модулирует между цветом фрагмента
(если светлота или интенсивность равны 1) и черным цветом (если они равны 0).
Для форматов RGB и RGBA каждый из компонентов входящего цвета умножается на
соответствующую (и, возможно, разную для разных компонентов) величину в карте
текстуры. Если присутствует альфа, ото умножается на альфа фрагмента. Модуляция
хороша для использования с освещением, поскольку цвет освещенного полигона
может быть использован для ослабления цвета текстуры. Белые зеркальные полигоны
часто используются для визуализации освещенных объектов, а карта текстуры
предоставляет диффузный цвет.</p>

<p class=text align=left style='text-align:left'>Текстурная функция наложения –
это единственная функция, которая использует цвет, задаваемый переменной
состояния GL_TEXTURE_ENV_COLOR. Величина светлоты, интенсивности или цвета в
каком-то смысле используется в качестве значения альфа для наложения
GL_TEXTURE_ENV_COLOR на цвет фрагмента.</p>

<h2>9.4.5.1&nbsp;&nbsp;&nbsp; Наложение зеркального цвета после текстурирования</h2>

<p class=text align=left style='text-align:left'>По умолчанию операции,
связанные с текстурированием выполняются после расчета освещенности. Однако
наложение текстуры на зеркальный блик обычно снижает визуальный эффект
освещения.</p>

<p class=text align=left style='text-align:left'>Вы можете отделить наложение
зеркального цвета, чтобы он добавлялся к цвету фрагмента после текстурирования.
Если зеркальный цвет отделяется, то при расчете освещенности получается два
цвета на вершину: первичный, который представляет собой сумму всех незеркальных
световых вкладов, и вторичный, представляющий собой сумму всех зеркальных
вкладов. Во время наложения текстуры с ее цветами комбинируется только
первичный цвет. Вторичный (зеркальный) цвет добавляется к цвету фрагмента после
того, как его текстурный цвет вычислен и текстура наложена. В результате
зеркальный блик на освещенном и текстурированном объекте получается более
четким.</p>

<h2>9.4.6&nbsp;&nbsp;&nbsp;&nbsp; Назначение координат текстуры</h2>

<p class=text align=left style='text-align:left'>Когда вы рисуете
текстурированную сцену, вы должны предоставить для каждой вершины и объектные,
и текстурные координаты. Объектные координаты после преобразований определяют
место, где будет нарисована каждая вершина. Координаты текстуры задают, какой
из тэкселей текстурной карты назначается этой вершине. Точно так же как цвета
интерполируются между двумя вершинами плавно залитого полигона или линии, между
двумя вершинами интерполируются координаты текстуры. (Помните, что текстуры
являются прямоугольными массивами данных.)</p>

<p class=text align=left style='text-align:left'>Координаты текстуры могут
включать в себя 1, 2, 3 или 4 элемента. Обычно на них ссылаются как на координаты
<i>s</i>, <i>t</i>, <i>r</i> и <i>q</i>, чтобы отделить от объектных координат
(<i>x</i>, <i>y</i>, <i>z</i>, <i>w</i>) и координат вычислителей (<i>u</i>, <i>v</i>).
Для одномерных текстур используется только координата <i>s</i>; для двумерных
используются <i>s </i>и <i>t</i>; для трехмерных – <i>s</i>, <i>t </i>и <i>r</i>.
Координате <i>q</i>, как и объектной координате <i>w</i>, обычно присваивается
значение 1. Она может быть использована для создания одномерных координат.
Команда для передачи координат текстуры <b>glTexCoord*()</b> похожа на <b>glVertex*()</b>,
<b>glColor*()</b> и <b>glNormal*()</b> – она имеет те же вариации и
используется таким же образом между парами <b>glBegin()</b> и <b>glEnd()</b>.
Обычно величины координат текстуры ранжируются от 0 до 1, однако им можно
присваивать значения и вне этого диапазона.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glTexCoord</b>{1234}{sifd}
  (TYPE <i>coords</i>);<br>
  void <b>glTexCoord</b>{1234}{sifd}<b>v</b> (TYPE <i>*coords</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Устанавливает текущие
координаты текстуры (<i>s</i>, <i>t</i>, <i>r</i>, <i>q</i>). Последующие
обращения к команде <b>glVertex*()</b> ассоциируют с передаваемыми вершинами
текущие координаты текстуры. При использовании команды <b>glTexCoord1*()</b>
координата <i>s</i>устанавливается в передаваемую величину, <i>t </i>и <i>r</i>
устанавливаются в 0, а <i>q</i>– в 1. При использовании <b>glTexCoord3*()</b> <i>q
</i>устанавливается в 1, в <i>s</i>, <i>t </i>и <i>r </i>в передаваемые
значения. Все 4 координаты вы можете задать с помощью команды <b>glTexCoord4*()</b>.
Используйте нужный суффикс (s, i, f или d) и соответствующее значение для TYPE
(GLshort, GLint, GLfloat или GLdouble), чтобы задать тип данных для координат.
Вы можете передавать координаты индивидуально или воспользоваться векторной
версией команды, чтобы передать их в виде указателя на массив, который их содержит.
До того, как будет выполнено наложение текстуры, текстурные координаты
умножаются на текстурную матрицу размерности 4x4. Обратите внимание на то, что
целые координаты интерпретируются непосредственно, а не отображаются на
диапазон [-1; 1] как координаты нормалей.</p>

<p class=text align=left style='text-align:left'>В следующем разделе
объясняется, как вычислить правильные текстурные координаты. Вместо того, чтобы
назначать их непосредственно, вы можете запросить у OpenGL автоматическое
вычисление текстурных координат как функции от координат вершин.</p>

<h2>9.4.7 Вычисление правильных координат текстуры</h2>

<p class=text align=left style='text-align:left'>Двумерные текстуры являются
квадратами или прямоугольниками изображений, которые обычно накладываются на
полигоны, составляющие полигональную модель. В простейшем случае вы
накладываете прямоугольную текстуру на прямоугольную же модель – например, если
ваша текстура представляет собой отсканированное изображение каменной стены, а
полигон, на который она должна быть наложена – прямоугольная стена здания.
Предположим, что и стена и текстура имеют квадратную форму, и вы хотите
наложить всю текстуру на всю стену. В порядке против часовой стрелки координаты
текстуры будут (0,0), (1,0), (1,1), (1,0). Когда вы рисуете стену, просто
передайте эти текстурные координаты в то же время, когда передаете координаты
вершин в порядке против часовой стрелки.</p>

<p class=text align=left style='text-align:left'>Теперь предположим, что высота
стены равна 2/3 ее ширины, а текстура по-прежнему квадратная. Чтобы избежать
искажения текстуры, вам нужно наложить на стену только ее часть, сохранением
пропорций изображения. Предположим, что для этого вы решили использовать нижние
2/3 изображения текстуры. В этом случае при передаче вершин в порядке против
часовой стрелки используйте следующие координаты текстуры – (0,0), (1, 0), (1,
2/3), (0, 2/3).</p>

<p class=text align=left style='text-align:left'>В качестве более сложного
примера, предположим, что вы хотите нарисовать тонкую консервную банку и
наложить на нее текстуру с изображением этикетки. Чтобы это сделать, вы
покупаете консервную банку, отделяете этикетку и сканируете ее. Предположим,
что она имеет 4 единицы в высоту и 12 в ширину, что соответствует пропорции
размера 3 к 1. Поскольку текстуры должны иметь пропорции <!--[if gte vml 1]><v:shape
 id="_x0000_i1426" type="#_x0000_t75" alt="" style='width:19.5pt;height:17.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image250.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form002.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=26 height=23
src="OpenGL%20Red%20Book.files/image250.jpg" v:shapes="_x0000_i1426"><![endif]>&nbsp;к
1, вы можете либо не использовать верхнюю треть текстуры, либо, скопировав,
присоединить к левому (правому) краю текстуры ее часть с правого (левого) края
шириной 4 единицы. Предположим, вы решили не использовать верхнюю треть. Пусть
банка представляет собой цилиндр, аппроксимированный 30 полигонами по 4 единицы
высотой (что составляет высоту банки) и шириной 12/30 (что составляет 1/30
длины окружности банки). Для каждого из аппроксимирующих прямоугольников вы
можете использовать следующие координаты текстуры:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1:<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>(0,0)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>(1/30,0)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>(1/30,2/3)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>(0,2/3)<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>2:<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>(1/30,0)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>(2/30,0)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>(2/30,2/3)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>(1/30,2/3)<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>3:<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>(2/30,0)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>(3/30,0)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>(3/30,2/3)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>(2/30,2/3)<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>...<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><o:p>&nbsp;</o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><o:p>&nbsp;</o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><o:p>&nbsp;</o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><o:p>&nbsp;</o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>30:<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>(29/30,0)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>(1,0)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>(1,2/3)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>(29/30, 2/3)<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Только некоторые изогнутые
поверхности, такие как конусы и цилиндры допускают наложение плоских
поверхностей без геодезического искажения (геодезической дисторсия). Другие
формы требуют некоторой доли искажения. Вообще, чем больше кривизна
поверхности, тем больше искажений появляется в текстуре.</p>

<p class=text align=left style='text-align:left'>Если вы не озабочены
искажением текстуры, часто довольно просто найти приемлемое решение. Например,
рассмотрим сферу, чьи координаты заданы в форме <!--[if gte vml 1]><v:shape
 id="_x0000_i1427" type="#_x0000_t75" alt="" style='width:152.25pt;height:17.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image291.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form035.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=203 height=23
src="OpenGL%20Red%20Book.files/image291.jpg" v:shapes="_x0000_i1427"><![endif]>,
где <!--[if gte vml 1]><v:shape id="_x0000_i1428" type="#_x0000_t75" alt=""
 style='width:60pt;height:14.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image292.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form036.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=80 height=19
src="OpenGL%20Red%20Book.files/image292.jpg" v:shapes="_x0000_i1428"><![endif]>&nbsp;и
<!--[if gte vml 1]><v:shape id="_x0000_i1429" type="#_x0000_t75" alt=""
 style='width:54pt;height:17.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image293.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form037.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=72 height=23
src="OpenGL%20Red%20Book.files/image293.jpg" v:shapes="_x0000_i1429"><![endif]>.
Прямоугольная карта текстуры может быть непосредственно наложена на каждый
прямоугольник <!--[if gte vml 1]><v:shape id="_x0000_i1430" type="#_x0000_t75"
 alt="" style='width:32.25pt;height:16.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image294.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form038.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=43 height=22
src="OpenGL%20Red%20Book.files/image294.jpg" v:shapes="_x0000_i1430"><![endif]>,
но искажение текстуры будет увеличиваться при приближении к полюсам. Вся
верхняя линия текстуры накладывается на северный полюс, а вся нижняя – на
южный. Для других поверхностей, таких как торус (бублик) с большим отверстием
координаты текстуры естественным образом ложатся на координаты поверхности,
производя лишь небольшое искажение, которое можно считать приемлемым для
большинства приложений. На рисунке 9-11 показаны два торуса, один с небольшим
отверстием (и, как следствие, с большим искажением текстуры вблизи центра),
другой с большим отверстием (с небольшим искажением).</p>

<p class=text align=left style='text-align:left'>Рисунок 9-11. Искажение
текстурной карты</p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1431" type="#_x0000_t75" alt="" style='width:460.5pt;height:192pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image295.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/9-11.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=614 height=256
src="OpenGL%20Red%20Book.files/image295.jpg" v:shapes="_x0000_i1431"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Если вы текстурируете
сплайновую поверхность, сгенерированную вычислителями, параметры поверхности <i>u</i>и
<i>v</i> иногда могут использоваться в качестве координат текстуры. Однако, в
общем случае, при наложении текстуры на аппроксимированные полигонами или
криволинейные поверхности большое значение имеет артистический компонент.</p>

<h2>9.4.8 Повторение и подтягивание текстуры</h2>

<p class=text align=left style='text-align:left'>Вы можете задавать текстурные
координаты за пределами диапазона [0,1], в результате чего текстура будет
повторена или подтянута. В режиме повторения, если у вас есть большая
плоскость, текстурные координаты на которой варьируются от 0.0 до 10.0 в обоих
направления, вы получите 100 копий текстуры, расположенных на экране вплотную
друг к другу (по аналогии с паркетом или кусками линолеума).&nbsp; В процессе
повторения целые части текстурных координат игнорируются, и копии заполняют
поверхность. Для большинства приложений, использующих повторение текстуры, тэксели
в верхнем и нижнем рядах текстуры должны совпадать, то же касается и левого и
правого столбца.</p>

<p class=text align=left style='text-align:left'>Другой возможность является
подтягивание текстурных координат: любые величины больше 1.0 устанавливаются
равными 1.0, любые величины меньше 0.0 устанавливаются в 0.0. Подтягивание
полезно для приложений, в которых требуется, чтобы одна копия текстуры
покрывала большую площадь. Если текстурные координаты поверхности варьируются
от 0.0 до 10.0 в обоих направлениях, появится только одна копия текстуры в
левом нижнем углу поверхности.</p>

<p class=text align=left style='text-align:left'>Если вы используете текстуры с
границами или задали цвет границы, то и режим прикрепления, и метод фильтрации
оказывают влияние на то, будет ли использоваться информация о границе и, если
будет, то каким образом. Если вы выбрали метод фильтрации GL_NEAREST,
используется ближайший тэксель в текстуре, а граница (или цвет границы) всегда
игнорируется.</p>

<p class=text align=left style='text-align:left'>Если вы выбрали GL_LINEAR в
качестве метода фильтрации, для наложения текстуры используется взвешенная
комбинация цветовых данных из массива 2x2 (для двумерных текстур). Если
присутствует граница или цвет границы, то текстура и этот цвет используются
вместе следующим образом:</p>

<p class=text align=left style='text-align:left'>В режиме прикрепления
GL_REPEAT граница всегда игнорируется. Массив взвешенных тэкселей размерности
2x2 прикрепляется к противоположному краю текстуры. Таким образом, тэксели на
правом краю усредняются с теми, что находятся на левом. То же касается тэкселей
на верхнем и нижнем краях.</p>

<p class=text align=left style='text-align:left'>В режиме крепления GL_CLAMP
тэксели на границе (или тэксели цвета GL_TEXTURE_BORDER_COLOR) используются в
массиве взвешенных тэкселей 2x2.</p>

<p class=text align=left style='text-align:left'>В режиме крепления
GL_CLAMP_TO_EDGE граница всегда игнорируется. Для текстурных вычислений
используются тэксели на краю (или близко к краю) текстуры, а не граница или ее
цвет. (Режим GL_CLAMP_TO_EDGE появился в OpenGL версии 1.2.)</p>

<p class=text align=left style='text-align:left'>Заметьте, что если вы
используете подтягивание, вы можете избежать воздействия текстуры на остаток
поверхности. Чтобы добиться этого, используйте альфа равное 0 для тэкселей на
краях текстуры (или на границе). Функция текстурирования GL_DECAL
непосредственно использует альфа при вычислениях. Если вы используете другую
текстурную функцию, вам, возможно, понадобиться использовать цветовое
наложение.</p>

<p class=text align=left style='text-align:left'>Чтобы оценить эффекты разных
режимов крепления текстуры, мы должны установить текстурные координаты за
пределами диапазона [0.0, 1.0]. Начнем с рассмотрения примера 9-1,
модифицировав код таким образом, чтобы при наложении текстуры на квадраты ее
координаты изменялись от 0.0 до 3.0.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glBegin (GL_QUADS);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexCoord2f (0.0,0.0); glVertex3f(-2.0,-1.0,0.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexCoord2f (0.0,3.0); glVertex3f(-2.0,1.0,0.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexCoord2f (3.0,3.0); glVertex3f(0.0,1.0,0.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexCoord2f (3.0,0.0); glVertex3f(0.0,-1.0,0.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexCoord2f (0.0,0.0); glVertex3f(1.0,-1.0,0.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexCoord2f (0.0,3.0); glVertex3f(1.0,1.0,0.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexCoord2f (3.0,3.0); glVertex3f(2.41421,1.0, -1.41421);<o:p></o:p></span></pre><pre><span
  style='color:black'>glTexCoord2f (3.0,0.0); glVertex3f(2.41421,-1.0, 2.41421);<o:p></o:p></span></pre><pre><span
  style='color:black'>glEnd();<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Результат работы этого кода в
режиме прикрепления GL_REPEAT показан на рисунке 9-12.</p>

<p class=text align=left style='text-align:left'>Рисунок 9-12. Повторение
текстуры</p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1432" type="#_x0000_t75" alt="" style='width:258pt;height:143.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image296.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/9-12.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=344 height=191
src="OpenGL%20Red%20Book.files/image296.jpg" v:shapes="_x0000_i1432"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>В этом случае текстура
повторяется в направлении <i>s</i>, и в направлении <i>t</i>, поскольку в
тексте присутствуют два вызова:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_REPEAT);<br>
  glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,GL_REPEAT);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Если в каждом из направлений
использовать GL_CLAMP вместо GL_REPEAT, вы получите нечто похожее на рисунок
9-13.</p>

<p class=text align=left style='text-align:left'>Рисунок 9-13. Подтягивание
текстуры</p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1433" type="#_x0000_t75" alt="" style='width:258pt;height:144.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image297.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/9-13.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=344 height=193
src="OpenGL%20Red%20Book.files/image297.jpg" v:shapes="_x0000_i1433"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Вы также можете повторять
текстуру в одном направлении и подтягивать в другом, как на рисунке 9-14.</p>

<p class=text align=left style='text-align:left'>Рисунок 9-14. Повторение и
подтягивание текстуры</p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1434" type="#_x0000_t75" alt="" style='width:258.75pt;height:144.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image298.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/9-14.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=345 height=193
src="OpenGL%20Red%20Book.files/image298.jpg" v:shapes="_x0000_i1434"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Теперь вы изучили все
аргументы команды <b>glTexParameter*()</b>. Они перечислены в следующей
таблице.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glTexParameter</b>{if}
  (GLenum <i>target</i>, GLenum <i>pname</i>, TYPE <i>param</i>);<br>
  void <b>glTexParameter</b>{if}<b>v</b> (GLenum <i>target</i>, GLenum <i>pname</i>,
  TYPE *<i>param</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Устанавливает различные
параметры, управляющие тем, как обрабатывается текстура в процессе наложения на
фрагмент или сохранения в текстурном объекте. Аргумент <i>target</i> может
принимать значения GL_TEXTURE_1D, GL_TEXTURE_2D или GL_TEXTURE_3D, индицируя
размерность текстур, параметр которых изменяется. Возможные значения для <i>pname
</i>и <i>param</i> перечислены в таблице 9-5. Вы можете использовать векторную
версию команды для установки параметра GL_TEXTURE_BORDER_COLOR или задавать
индивидуальные значения других параметров с помощью невекторной версии. Если
значения передаются как целые, они преобразуются в формат с плавающей точкой
согласно таблице 4-1; они также приводятся к диапазону [0, 1].</p>

<p class=text align=left style='text-align:left'>Таблица 9-5. Параметры,
устанавливаемые glTexParameter*()</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Параметр</span></b><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Возможные значения</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TEXTURE_WRAP_S<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_CLAMP, GL_REPEAT, GL_CLAMP_TO_EDGE<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TEXTURE_WRAP_T<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_CLAMP, GL_REPEAT, GL_CLAMP_TO_EDGE<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TEXTURE_WRAP_R<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_CLAMP, GL_REPEAT, GL_CLAMP_TO_EDGE<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TEXTURE_MAG_FILTER<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_NEAREST, GL_LINEAR<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:5'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TEXTURE_MIN_FILTER<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_NEAREST, GL_LINEAR,
  GL_NEAREST_MIPMAP_NEAREST, GL_NEAREST_MIPMAP_LINEAR,GL_LINEAR_MIPMAP_NEAREST,
  GL_LINEAR_MIPMAP_LINEAR<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:6'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TEXTURE_BORDER_COLOR<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>любые 4 величины в диапазоне [0.0, 1,0]<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:7'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TEXTURE_PRIORITY<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>[0.0, 1.0] для текущего текстурного объекта<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:8'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TEXTURE_MIN_LOD<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>любое число с плавающей точкой<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:9'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TEXTURE_MAX_LOD<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>любое число с плавающей точкой<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:10'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TEXTURE_BASE_LEVEL<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>любое число с плавающей точкой<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:11;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TEXTURE_MAX_LEVEL<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>любое число с плавающей точкой<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<h2>9.5<i> </i>Автоматическое генерирование текстурных координат</h2>

<p class=text align=left style='text-align:left'>Вы можете использовать
текстурирование для создания контуров ваших моделей или для имитации отражения
от окружающих предметов на блестящих поверхностях. Чтобы добиться этих
результатов, позвольте OpenGL автоматически генерировать для вас координаты
текстуры вместо того, чтобы задавать их непосредственно командой <b>glTexCoord*()</b>.
Для автоматического генерирования текстурных координат используйте команду <b>glTexGen*()</b>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glTexGen</b>{ifd}
  (GLenum <i>coord</i>, GLenum <i>pname</i>, TYPE <i>param</i>);<br>
  void <b>glTexGen</b>{ifd}<b>v</b> (GLenum <i>coord</i>, GLenum <i>pname</i>,
  TYPE *<i>param</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Задает функцию для
автоматического вычисления текстурных координат. Первый аргумент <i>coord</i>может
принимать значения GL_S, GL_T, GL_R или GL_Q, указывая на то, какая из
координат: <i>s</i>, <i>t</i>, <i>r </i>или <i>q</i> должна быть вычислена.
Аргумент<span style='mso-ansi-language:EN-US'> <i><span lang=EN-US>pname</span></i><span
lang=EN-US> </span></span>может<span style='mso-ansi-language:EN-US'> </span>принимать<span
style='mso-ansi-language:EN-US'> </span>значения<span lang=EN-US
style='mso-ansi-language:EN-US'> GL_TEXTURE_GEN_MODE, GL_OBJECT_PLANE,
GL_EYE_PLANE, GL_SPHERE_MAP. </span>Если<span style='mso-ansi-language:EN-US'> </span>задано<span
style='mso-ansi-language:EN-US'> </span>значение<span lang=EN-US
style='mso-ansi-language:EN-US'> GL_TEXTURE_GEN_MODE, <i>param</i> </span>должен<span
style='mso-ansi-language:EN-US'> </span>быть<span style='mso-ansi-language:
EN-US'> </span>целым<span style='mso-ansi-language:EN-US'> </span>числом<span
lang=EN-US style='mso-ansi-language:EN-US'> (</span>или<span style='mso-ansi-language:
EN-US'> </span>указателем<span style='mso-ansi-language:EN-US'> </span>на<span
style='mso-ansi-language:EN-US'> </span>целое<span style='mso-ansi-language:
EN-US'> </span>число<span lang=EN-US style='mso-ansi-language:EN-US'>, </span>если<span
style='mso-ansi-language:EN-US'> </span>используется<span style='mso-ansi-language:
EN-US'> </span>векторная<span style='mso-ansi-language:EN-US'> </span>версия<span
style='mso-ansi-language:EN-US'> </span>команды<span lang=EN-US
style='mso-ansi-language:EN-US'>), </span>которое<span style='mso-ansi-language:
EN-US'> </span>равно<span lang=EN-US style='mso-ansi-language:EN-US'>
GL_OBJECT_LINEAR, GL_EYE_LINEAR </span>или<span lang=EN-US style='mso-ansi-language:
EN-US'> GL_SPHERE_MAP. </span>Эти символические константы указывают на то,
какая функция должна использоваться для вычисления координат текстуры. Со всеми
остальными возможными значениями для <i>pname</i>, <i>param </i>должен
представлять собой указатель на массив величин (в векторной версии команды),
задавая параметры функции вычисления текстурных координат.</p>

<p class=text align=left style='text-align:left'>Различные методы генерирования
текстурных координат имеют различное назначение. Использование плоскости в
объектных координатах лучше всего применять, если изображение текстуры должно
оставаться фиксированным на движущемся объекте. Таким образом, GL_OBJECT_LINEAR
может использоваться для наложения текстуры дерева на крышку стола.
Использование плоскости в видовых координатах (GL_EYE_LINEAR) лучше всего
использовать для создания динамических контурных линий на движущихся объектах.
GL_EYE_LINEAR может быть использована специалистами по геодезии, работающими с
нефтью и газом. По мере того как скважина уходит глубже в землю, она может быть
нарисована разными цветами, чтобы показать слои камня на разных глубинах.
GL_SPHERE_MAP главным образом используется для создания <i>наложения окружающей
обстановки</i> (<i>environmental mapping</i>).</p>

<h2>9.5.1 Создание контуров</h2>

<p class=text align=left style='text-align:left'>Когда заданы
GL_TEXTURE_GEN_MODE и GL_OBJECT_LINEAR, функция вычисления текстурных координат
– это линейная комбинация объектных координат вершины <!--[if gte vml 1]><v:shape
 id="_x0000_i1435" type="#_x0000_t75" alt="" style='width:87pt;height:17.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image299.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form039.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=116 height=23
src="OpenGL%20Red%20Book.files/image299.jpg" v:shapes="_x0000_i1435"><![endif]>:</p>

<p class=text align=left style='text-align:left'>сгенерированная координата = <!--[if gte vml 1]><v:shape
 id="_x0000_i1436" type="#_x0000_t75" alt="" style='width:163.5pt;height:15.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image300.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form040.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=218 height=21
src="OpenGL%20Red%20Book.files/image300.jpg" v:shapes="_x0000_i1436"><![endif]></p>

<p class=text align=left style='text-align:left'>Величины <!--[if gte vml 1]><v:shape
 id="_x0000_i1437" type="#_x0000_t75" alt="" style='width:50.25pt;height:15.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image301.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form043.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=67 height=21
src="OpenGL%20Red%20Book.files/image301.jpg" v:shapes="_x0000_i1437"><![endif]>&nbsp;передаются
в аргументе <i>param </i>команды <b>glTexGen*v()</b> при <i>pname</i>,
установленным в GL_OBJECT_PLANE. При правильно нормализованных <!--[if gte vml 1]><v:shape
 id="_x0000_i1438" type="#_x0000_t75" alt="" style='width:50.25pt;height:15.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image301.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form043.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=67 height=21
src="OpenGL%20Red%20Book.files/image301.jpg" v:shapes="_x0000_i1438"><![endif]>&nbsp;функция
дает дистанцию от вершины до плоскости. Например, если <!--[if gte vml 1]><v:shape
 id="_x0000_i1439" type="#_x0000_t75" alt="" style='width:75.75pt;height:15.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image302.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form041.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=101 height=21
src="OpenGL%20Red%20Book.files/image302.jpg" v:shapes="_x0000_i1439"><![endif]>,
а <!--[if gte vml 1]><v:shape id="_x0000_i1440" type="#_x0000_t75" alt=""
 style='width:35.25pt;height:16.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image303.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form042.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=47 height=22
src="OpenGL%20Red%20Book.files/image303.jpg" v:shapes="_x0000_i1440"><![endif]>,
функция дает дистанцию между вершиной и плоскостью x=0. Дистанция положительна
на одной стороне плоскости, отрицательна на другой и равна 0, если вершина
лежит в этой плоскости.</p>

<p class=text align=left style='text-align:left'>В самом начале в примере 9-8
на чайнике с равными пропусками рисуются контурные линии; линии показывают
дистанцию от плоскости x=0. Коэффициенты для плоскости x=0 находятся в массиве:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>GLfloat
  xequalzero[]={1.0,0.0,0.0,0.0};<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>В данном случае вычисляется
только 1 величина (дистанция от плоскости), что позволяет наложить одномерную
текстуру. Текстура полностью зеленая, однако, через равные промежутки времени
на ней помещены красные маркеры. Поскольку чайник как бы стоит на плоскости xy,
все контуры перпендикулярны его основанию. Изображение нарисованное программой
показано на рисунке 9-15.</p>

<p class=text align=left style='text-align:left'>Рисунок 9-15. Красные контуры
параллельны плоскости x=0</p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1441" type="#_x0000_t75" alt="" style='width:252pt;height:249.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image304.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/9-15.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=336 height=333
src="OpenGL%20Red%20Book.files/image304.jpg" v:shapes="_x0000_i1441"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>В этом же примере нажатие на
клавишу ‘s’ изменяет параметры плоскости:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>GLfloat
  stanted[]={1.0,1.0,1.0,0.0};<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Теперь красные контуры
параллельны плоскости x+y+z=0. Соответствующее изображение показано на рисунке
9-16. Чтобы восстановить уравнение, соответствующее плоскости x=0, нажмите
клавишу ‘x’.</p>

<p class=text align=left style='text-align:left'>Рисунок 9-16. Красные контуры
параллельны плоскости x+y+z=0</p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1442" type="#_x0000_t75" alt="" style='width:255pt;height:256.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image305.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/9-16.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=340 height=342
src="OpenGL%20Red%20Book.files/image305.jpg" v:shapes="_x0000_i1442"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Пример 9-8. Автоматическое
генерирование координат текстуры: файл texgen.cpp</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#include &lt;glut.h&gt;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#define stripeImageWidth 32<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>GLubyte stripeImage[4*stripeImageWidth];<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>GLuint texName;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void makeStripeImage()<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>int j;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>for(j=0;j&lt;stripeImageWidth;j++)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>stripeImage[4*j]=(GLubyte) ((j&lt;=4) ? 255 : 0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>stripeImage[4*j+1]=(GLubyte) ((j&gt;4) ? 255 : 0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>stripeImage[4*j+2]=(GLubyte) 0;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>stripeImage[4*j+3]=(GLubyte) 255;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>GLfloat xequalzero[]={1.0,0.0,0.0,0.0};<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>GLfloat slanted[]={1.0,1.0,1.0,0.0};<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>GLfloat *currentCoeff;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>GLenum currentPlane;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>GLint currentGenMode;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void init()<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glClearColor(0.0,0.0,0.0,0.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glEnable(GL_DEPTH_TEST);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glShadeModel(GL_SMOOTH);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>makeStripeImage();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glPixelStorei(GL_UNPACK_ALIGNMENT,1);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glGenTextures(1,&amp;texName);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glBindTexture(GL_TEXTURE_1D,texName);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexParameteri(GL_TEXTURE_1D,GL_TEXTURE_WRAP_S,GL_REPEAT);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexParameteri(GL_TEXTURE_1D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexParameteri(GL_TEXTURE_1D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexImage1D(GL_TEXTURE_1D,0,GL_RGBA,stripeImageWidth,0,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>GL_RGBA,GL_UNSIGNED_BYTE,stripeImage);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexEnvf(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_MODULATE);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>currentCoeff=xequalzero;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>currentGenMode=GL_OBJECT_LINEAR;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>currentPlane=GL_OBJECT_PLANE;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexGeni(GL_S,GL_TEXTURE_GEN_MODE,currentGenMode);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexGenfv(GL_S,currentPlane,currentCoeff);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glEnable(GL_TEXTURE_GEN_S);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glEnable(GL_TEXTURE_1D);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glEnable(GL_CULL_FACE);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glEnable(GL_LIGHTING);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glEnable(GL_LIGHT0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glEnable(GL_AUTO_NORMAL);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glEnable(GL_NORMALIZE);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glFrontFace(GL_CW);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glCullFace(GL_BACK);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glMaterialf(GL_FRONT,GL_SHININESS,64.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void display()<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glPushMatrix();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glRotatef(45.0,0.0,0.0,1.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glBindTexture(GL_TEXTURE_1D,texName);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glutSolidTeapot(2.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glPopMatrix();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glFlush();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void reshape(int w, int h)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glViewport(0,0,(GLsizei) w, (GLsizei) h);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glMatrixMode(GL_PROJECTION);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glLoadIdentity();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>if (w&lt;=h)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glOrtho(-3.5,3.5,-3.5*(GLfloat)h/(GLfloat)w,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>3.5*(GLfloat)h/(GLfloat)w,-3.5,3.5);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>else<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glOrtho(-3.5*(GLfloat)w/(GLfloat)h,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>3.5*(GLfloat)w/(GLfloat)h,-3.5,3.5,-3.5,3.5);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glMatrixMode(GL_MODELVIEW);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glLoadIdentity();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void keyboard(unsigned char key,int x, int y)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>switch(key)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>case 'e':<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>case 'E':<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>currentGenMode=GL_EYE_LINEAR;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>currentPlane=GL_EYE_PLANE;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexGeni(GL_S,GL_TEXTURE_GEN_MODE,currentGenMode);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexGenfv(GL_S,currentPlane,currentCoeff);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glutPostRedisplay();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>break;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>case 'o':<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>case 'O':<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>currentGenMode=GL_OBJECT_LINEAR;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>currentPlane=GL_OBJECT_PLANE;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexGeni(GL_S,GL_TEXTURE_GEN_MODE,currentGenMode);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexGenfv(GL_S,currentPlane,currentCoeff);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glutPostRedisplay();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>break;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>case 's':<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>case 'S':<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>currentCoeff=slanted;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexGenfv(GL_S,currentPlane,currentCoeff);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glutPostRedisplay();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>break;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>case 'x':<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>case 'X':<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>currentCoeff=xequalzero;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexGenfv(GL_S,currentPlane,currentCoeff);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glutPostRedisplay();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>break;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>int main(int argc, char **argv)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glutInit(&amp;argc,argv);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB|GLUT_DEPTH);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glutInitWindowSize(350,350);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glutInitWindowPosition(100,100);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glutCreateWindow(&quot;Automatic Texture-Coordinate Generation&quot;);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>init();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glutDisplayFunc(display);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glutReshapeFunc(reshape);<o:p></o:p></span></pre><pre><span
  style='color:black'>glutKeyboardFunc(keyboard);<o:p></o:p></span></pre><pre><span
  style='color:black'>glutMainLoop();<o:p></o:p></span></pre><pre><span
  style='color:black'>return 0;<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Вы можете включить
автоматический расчет s-координат текстур, передав аргумент GL_TEXTURE_GEN_S
команде <b>glEnable()</b>. Для автоматической генерации координат t, r или q
нужно передать той же команде аргументы GL_TEXTURE_GEN_T, GL_TEXTURE_GEN_R или
GL_TEXTURE_GEN_Q соответственно. Для выключения генерации координат текстуры
используйте <b>glDisable()</b> с теми же аргументами.</p>

<p class=text align=left style='text-align:left'>Функция GL_OBJECT_LINEAR
вычисляет координаты текстуры в координатной системе модели. В примере 9-8
изначально используется функция GL_OBJECT_LINEAR, и линии контура остаются
перпендикулярными основанию чайника независимо от того, как поворачивается
чайник, и с какой стороны на него смотрят. Однако, если нажать клавишу ‘e’
режим генерирования координат изменится с GL_OBJECT_LINEAR на GL_EYE_LINEAR, и
координаты будут рассчитываться относительно видовой координатной системы.
(Нажатие на клавишу ‘o’ восстанавливает режим GL_OBJECT_LINEAR.) Если в
качестве плоскости определена x=0, то линии контура на чайнике будут
параллельны плоскости yz относительно точки наблюдения, как показано на рисунке
9-17. Говоря математически, вектор <!--[if gte vml 1]><v:shape id="_x0000_i1443"
 type="#_x0000_t75" alt="" style='width:88.5pt;height:18pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image306.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form045.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=118 height=24
src="OpenGL%20Red%20Book.files/image306.jpg" v:shapes="_x0000_i1443"><![endif]>&nbsp;умножается
на матрицу обратную к видовой для получения значений, используемых для
вычисления дистанции до плоскости. Координаты текстуры генерируются следующей
функцией:</p>

<p class=text align=left style='text-align:left'>сгенерированная координата = <!--[if gte vml 1]><v:shape
 id="_x0000_i1444" type="#_x0000_t75" alt="" style='width:177pt;height:18pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image307.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form046.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=236 height=24
src="OpenGL%20Red%20Book.files/image307.jpg" v:shapes="_x0000_i1444"><![endif]>,
где <!--[if gte vml 1]><v:shape id="_x0000_i1445" type="#_x0000_t75" alt=""
 style='width:236.25pt;height:21.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image308.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form048.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=315 height=29
src="OpenGL%20Red%20Book.files/image308.jpg" v:shapes="_x0000_i1445"><![endif]>.</p>

<p class=text align=left style='text-align:left'>В этом случае <!--[if gte vml 1]><v:shape
 id="_x0000_i1446" type="#_x0000_t75" alt="" style='width:84pt;height:18pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image309.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form044.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=112 height=24
src="OpenGL%20Red%20Book.files/image309.jpg" v:shapes="_x0000_i1446"><![endif]>&nbsp;--
это видовые координаты вершины, а величины <!--[if gte vml 1]><v:shape id="_x0000_i1447"
 type="#_x0000_t75" alt="" style='width:50.25pt;height:15.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image301.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form043.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=67 height=21
src="OpenGL%20Red%20Book.files/image301.jpg" v:shapes="_x0000_i1447"><![endif]>&nbsp;передаются
в аргументе <i>param </i>команды <b>glTexGen*v()</b> при <i>pname</i>,
установленным в GL_EYE_PLANE. Величины <!--[if gte vml 1]><v:shape id="_x0000_i1448"
 type="#_x0000_t75" alt="" style='width:108.75pt;height:17.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image310.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form047.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=145 height=23
src="OpenGL%20Red%20Book.files/image310.jpg" v:shapes="_x0000_i1448"><![endif]>&nbsp;вычисляют
только один раз в момент их передачи <b>glTexGen*v()</b>, так что эта операция
вовсе не так затратна с точки зрения вычислений, как кажется с первого взгляда.</p>

<p class=text align=left style='text-align:left'>Рисунок 9-17. Красные контуры
параллельны плоскости yz в видовых координатах</p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1449" type="#_x0000_t75" alt="" style='width:255pt;height:253.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image311.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/9-17.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=340 height=338
src="OpenGL%20Red%20Book.files/image311.jpg" v:shapes="_x0000_i1449"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Во всех приведенных примерах
для создания контуров использовалась только одна сгенерированная координата.
Однако координаты s, t и (если необходимо) r могут генерироваться независимо,
отражая дистанцию между одной, двумя или тремя разными плоскостями. Если
правильно построить двумерную или трехмерную текстурную карту, два или три
набора контуров можно будет наблюдать одновременно. В качестве дополнительного
усложнения вы можете смешивать генерирующие функции. Например, вы можете
вычислять <i>s</i>координату с помощью GL_OBJECT_LINEAR, а <i>t</i>– с
использованием GL_EYE_LINEAR.</p>

<h2>9.5.2 Наложение изображения окружающихся предметов</h2>

<p class=text align=left style='text-align:left'>Целью наложения окружающей
обстановки является визуализация предмета, как будто он идеально блестящий и
гладкий, и цвета на его поверхности – это цвета окружающих его объектов,
отраженные в глаз наблюдателя. Другими словами, если вы смотрите на идеально
отполированный, идеально отражающий серебряный объект в комнате, вы видите на
нем отражение стен, пола и других предметов в комнате. (Классическим примером
этой техники является изображение киборга T1000 из фильма Терминатор 2.)
Объекты, отражения которых вы видите, зависят от точки наблюдения и углов
поверхности серебряного объекта. Чтобы производить наложение окружающей
обстановки, все, что вам нужно сделать – это создать подходящую карту текстуры,
а затем заставить OpenGL автоматически сгенерировать для вас текстурные
координаты.</p>

<p class=text align=left style='text-align:left'>Наложение <i>окружающей
обстановки</i> (<i>environmental mapping</i>) – это аппроксимация, основанная
на предположении о том, что элементы обстановки находятся далеко в сравнении с
блестящим отражающим объектом – то есть маленький объект находится в большой
комнате. При таком предположении для нахождения цвета точки на поверхности
нужно выпустить луч из глаза наблюдателя в точку поверхности, а затем отразить
его от поверхности. Направление отраженного луча полностью определяет цвет,
который нужно нарисовать в точке отражения. Кодирование цвета для каждого
направления на плоской текстурной карте эквивалентно помещению полированной
сферы без изъянов в центр окружения и снятию с нее фотографии с помощью камеры,
имеющей линзы с очень большой фокальной длиной и находящейся далеко от сферы.
Говоря математически, линзы имеют бесконечно большую фокальную длину, а камера
бесконечно удалена от сферы. Таким образом, кодирование покрывает циркулярный
регион текстурной карты, находящийся вплотную к ее верхнему, нижнему, правому и
левому краям. Величины вне этого круга не важны, поскольку при наложении
обстановки доступ к ним никогда не осуществляется (они попросту не нужны).</p>

<p class=text align=left style='text-align:left'>Для получения абсолютно
правильной карты обстановки, вам нужно раздобыть большую серебристую сферу,
снять с нее фотографию в некоторой обстановке с помощью камеры, расположенной
бесконечно далеко и имеющей линзы с бесконечно большой фокальной длиной, и
отсканировать эту фотографию. Для получения приблизительно верного результата
вы можете использовать отсканированную фотографию обстановки, снятую камерой,
имеющей линзы с очень большим углом (рыбий глаз).</p>

<p class=text align=left style='text-align:left'>После того, как вы создали
текстуру, разработанную для наложения окружающей обстановки, вам нужно
активизировать соответствующий алгоритм OpenGL. Этот алгоритм находит точку на
поверхности сферы, которая находится там же, где и точка на поверхности
визуализируемого отражающего объекта и закрашивает точку объекта цветом,
находящимся в соответствующей точке сферы.</p>

<p class=text align=left style='text-align:left'>Чтобы автоматически
сгенерировать координаты текстуры для поддержки наложения окружающей
обстановки, используйте в программе следующий код:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_SPHERE_MAP);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_SPHERE_MAP);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glEnable(GL_TEXTURE_GEN_S);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glEnable(GL_TEXTURE_GEN_T);<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Константа GL_SPHERE_MAP
создает правильные текстурные координаты для наложения обстановки. Как показано
выше, вам нужно установить этот режим в обоих направлениях (<i>s</i> и <i>t</i>).
Однако вам не требуется задавать никаких параметров для функции, генерирующей
координаты текстуры.</p>

<p class=text align=left style='text-align:left'>Функция GL_SPHERE_MAP
генерирует координаты текстуры в несколько шагов:</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l13 level1 lfo40;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>1.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Пусть <b><i>u</i></b> – это вектор единичной
длины направленный из начала координат к вершине (в видовых координатах).</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l13 level1 lfo40;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>2.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Пусть <b><i>n</i>’</b> – текущий вектор нормали
после преобразования в видовые координаты.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l13 level1 lfo40;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>3.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Пусть <b><i>r</i></b> – это вектор отражения <!--[if gte vml 1]><v:shape
 id="_x0000_i1450" type="#_x0000_t75" alt="" style='width:68.25pt;height:24pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image312.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form049.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=91 height=32
src="OpenGL%20Red%20Book.files/image312.jpg" v:shapes="_x0000_i1450"><![endif]>,
вычисляемый как <!--[if gte vml 1]><v:shape id="_x0000_i1451" type="#_x0000_t75"
 alt="" style='width:69.75pt;height:20.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image313.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form053.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=93 height=27
src="OpenGL%20Red%20Book.files/image313.jpg" v:shapes="_x0000_i1451"><![endif]>.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l13 level1 lfo40;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>4.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Затем вычисляет промежуточная величина <!--[if gte vml 1]><v:shape
 id="_x0000_i1452" type="#_x0000_t75" alt="" style='width:153pt;height:33pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image314.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form050.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=204 height=44
src="OpenGL%20Red%20Book.files/image314.jpg" v:shapes="_x0000_i1452"><![endif]>.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l13 level1 lfo40;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>5.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Наконец, координаты текстуры s и t вычисляются
следующим образом: <!--[if gte vml 1]><v:shape id="_x0000_i1453" type="#_x0000_t75"
 alt="" style='width:76.5pt;height:33.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image315.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form051.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=102 height=45
src="OpenGL%20Red%20Book.files/image315.jpg" v:shapes="_x0000_i1453"><![endif]>и
<!--[if gte vml 1]><v:shape id="_x0000_i1454" type="#_x0000_t75" alt=""
 style='width:76.5pt;height:33.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image316.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form052.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=102 height=45
src="OpenGL%20Red%20Book.files/image316.jpg" v:shapes="_x0000_i1454"><![endif]>.</p>

<p class=text align=left style='text-align:left'>Естественно, что с помощью
описанной техники на блестящих объектах можно получать не только изображения
окружающих предметов, а вообще всего, чего угодно. Единственное условие –
необходима сферическая карта текстуры. На рисунке 9-18 слева изображена одна из
вариаций фрактала Мальденброда, а справа то же самое изображение,
преобразованное к сферическому виду с помощью одного из графических редакторов.
На рисунке 9-19 показан результат наложения этого изображения на чайник Юта.</p>

<p class=text align=left style='text-align:left'>Рисунок 9-18. Изображение,
преобразованное в сферическую карту текстуры</p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1455" type="#_x0000_t75" alt="" style='width:465pt;height:174.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image317.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/9-18.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=620 height=233
src="OpenGL%20Red%20Book.files/image317.jpg" v:shapes="_x0000_i1455"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Рисунок 9-19. Изображение
множества Мальденброда на чайнике Юта</p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1456" type="#_x0000_t75" alt="" style='width:225pt;height:222pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image318.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/9-19.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=300 height=296
src="OpenGL%20Red%20Book.files/image318.jpg" v:shapes="_x0000_i1456"><![endif]><o:p></o:p></span></p>

<h2>9.6 Дополнительные возможности</h2>

<p class=text align=left style='text-align:left'><b>Дополнительно:</b> В данном
разделе описано, как использовать стек текстурных матриц (и связанную с ним
координату <i>q</i>), а также мультитекстурирование. Эти техники считаются
весьма сложными и не понадобятся для большинства приложений.</p>

<h2>9.6.1 Стек текстурных матриц</h2>

<p class=text align=left style='text-align:left'>Точно так же как координаты
вашей модели преобразуются матрицами до завершения визуализации, текстурные
координаты умножаются на матрицу 4x4 до того как происходит наложение. По
умолчанию текстурная матрица представляет собой единичную, следовательно,
заданные или автоматически сгенерированные координаты остаются неизменными.
Однако, модифицируя текстурную матрицу в процессе перерисовки объекта, вы можете
заставить текстуру двигаться по поверхности объекта, поворачиваться вокруг нее,
растягиваться и сжиматься или формировать любую комбинацию всего
перечисленного.&nbsp; Вообще говоря, поскольку текстурная матрица – это обычная
матрица 4x4, можно добиться даже эффекта перспективы.</p>

<p class=text align=left style='text-align:left'>На самом деле текстурная
матрица является верхней матрицей текстурного стека, который, как минимум,
должен иметь глубину 2 матрицы. Все стандартные команды манипуляций с матрицами
– <b>glPushMatrix()</b>, <b>glPopMatrix()</b>, <b>glMultMatrix()</b>, <b>glRotate*()</b>
и другие – могут применяться к текстурным матрицам. Чтобы изменить текущую
текстурную матрицу, установите режим матрицы в GL_TEXTURE следующим образом:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  style='color:black'>glMatrixMode(GL_TEXTURE); /* войти в режим текстурной матрицы */<o:p></o:p></span></pre><pre><span
  style='color:black'>glRotated(...);<o:p></o:p></span></pre><pre><span
  style='color:black'>/*...другие манипуляции с матрицей...*/<o:p></o:p></span></pre><pre><span
  style='color:black'>glMatrixMode(GL_MODELVIEW);<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<h2>9.6.1.1 Координата q</h2>

<p class=text align=left style='text-align:left'>Математика четвертой
текстурной координаты <i>q</i> похожа на математику координаты w из четверки (<i>x</i>,
<i>y</i>, <i>z</i>, <i>w</i>) объектных координат. Когда четверка текстурных
координат (<i>s</i>, <i>t</i>, <i>r</i>, <i>q</i>) умножается на матрицу
текстуры, результирующий вектор (<i>s’</i>, <i>t’</i>, <i>r’</i>, <i>q’</i>)
интерпретируется как четверка однородных координат текстуры. Другими словами
текстурная карта индексируется величинами <i>s’/q’</i>, <i>t’/q’</i> и <i>r’/q’</i>.</p>

<p class=text align=left style='text-align:left'>Вы можете использовать <i>q</i>в
случаях, когда требуется более одного проекционного или перспективного
преобразования. Например, предположим, что вы хотите смоделировать прожектор с
неравномерным лучом, который ярче ближе к центру или имеет не круглую форму
из-за линз. Вы можете эмулировать сияние такого луча на плоской поверхности,
создав текстурную карту, которая соответствует форме и интенсивности света, и
спроецировав ее на нужную поверхность с использованием проекционного
преобразования. Проектирование конуса света на поверхности сцены требует
перспективного преобразования (<!--[if gte vml 1]><v:shape id="_x0000_i1457"
 type="#_x0000_t75" alt="" style='width:29.25pt;height:15.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image319.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/form054.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=39 height=21
src="OpenGL%20Red%20Book.files/image319.jpg" v:shapes="_x0000_i1457"><![endif]>),
поскольку свет может появляться на поверхностях, которые неперпендикулярны его
источнику. Второе перспективное преобразование необходимо потому, что
наблюдатель видит сцену с другой (но тоже перспективной) точки наблюдения.</p>

<p class=text align=left style='text-align:left'>Другой пример может возникнуть
в ситуации, когда в качестве текстуры должна использовать фотография, сама имеющая
перспективу. Как и в случае с источником света, результирующее изображение
зависит от комбинации двух перспективных преобразований.</p>

<h2>9.6.2 Мультитекстурирование</h2>

<p class=text align=left style='text-align:left'>Во время стандартного
текстурирования на полигон накладывается единственное изображение текстуры. В
OpenGL версии 1.2 появилось мультитекстурирование, которое позволяет
накладывать на один и тот же полигон несколько текстур одну за одной.</p>

<p class=text align=left style='text-align:left'>Мультитекстурирование – это
опциональное расширение. Таким образом, несмотря на то, что оно было одобрено
OpenGL Architecture Review Board (ARB – совет по рассмотрению архитектуры
OpenGL), который является управляющим органом по всем вопросам, связанным с
OpenGL, реализация OpenGL версии 1.2 <b>не</b> обязательно поддерживает
мультитекстурирование.</p>

<p class=text align=left style='text-align:left'>Если ваша реализация
поддерживает мультитекстурирование, у вас в распоряжении имеется серия <i>текстурных
блоков или модулей </i>(<i>texture units</i>), каждый из которых производит
одну операцию текстурирования и передает свой результат в следующий текстурный
блок. Так происходит до тех пор, пока все определенные текстурные блоки не
завершат свои операции. Рисунок 9-20 показывает, как фрагмент претерпевает 4
текстурные операции – по одной на каждый текстурный блок.</p>

<p class=text align=left style='text-align:left'>Рисунок 9-20. Конвейер
мультитекстурирования</p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1458" type="#_x0000_t75" alt="" style='width:465pt;height:555pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image320.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов9.mht!http://www.progz.ru/images/opengl/chapter9/9-20.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=620 height=740
src="OpenGL%20Red%20Book.files/image320.jpg" v:shapes="_x0000_i1458"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Мультитекстурирование
позволяет применять усложненные техники визуализации, такие как световые
эффекты, композиция и детализированные текстуры.</p>

<h2>9.6.2.1 Мультитекстурирование по шагам</h2>

<p class=text align=left style='text-align:left'>Для написания кода,
использующего мультитекстурирование, нужно выполнить следующие шаги:</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l30 level1 lfo41;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>1.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Проверьте, поддерживается ли расширение
мультитекстурирования. Если оно не поддерживается, возможно, вам удастся
достигнуть тех же результатов с помощью нескольких проходов визуализации. Чтобы
выяснить какое количество текстурных блоков присутствует в вашей реализации,
вызовите <b>glGetIntegerv(GL_MAX_TEXTURE_UNITS_ARB, ...)</b>. При наиболее
плохом сценарии возвращенное число будет равно 1, что соответствует
единственному текстурному блоку.</p>

<p class=warning>Замечание: Даже в случае, когда расширение поддерживается, в
режиме отклика (feedback) результат мультитекстурирования не определен за
пределами первого текстурного блока.</p>

<ol start=2 type=1>
 <li class=MsoNormal style='color:black;mso-margin-top-alt:auto;mso-margin-bottom-alt:
     auto;mso-list:l46 level1 lfo42;tab-stops:list 36.0pt'><span
     style='font-size:10.0pt;font-family:Verdana'>Установите нужное состояние
     текстурирования, включая изображение текстуры, фильтры, окружение, режим
     генерирования координат и матрицу, для каждого текстурного блока. Для
     смены текущего текстурного блока используйте команду <b>glActiveTextureARB()</b>.<o:p></o:p></span></li>
 <li class=MsoNormal style='color:black;mso-margin-top-alt:auto;mso-margin-bottom-alt:
     auto;mso-list:l46 level1 lfo42;tab-stops:list 36.0pt'><span
     style='font-size:10.0pt;font-family:Verdana'>Задавая вершины, используйте <b>glMultiTexCoord*ARB()</b>
     чтобы задавать несколько наборов координат для разных текстур. В каждом
     текстурном блоке используется свой набор координат. Каждый набор
     текстурных координат будет использован в период текстурирования
     определенным текстурным блоком (в одном из нескольких проходов).
     Автоматическое генерирование координат и передача координат в виде
     вершинного массива являются специальными случаями.<o:p></o:p></span></li>
</ol>

<h2>9.6.2.2 Настройка текстурных блоков</h2>

<p class=text align=left style='text-align:left'>Мультитекстурирование
предоставляет множественные текстурные блоки, которые производят дополнительные
проходы по наложению текстуры. Каждый из текстурных блоков имеет одинаковые
возможности и свое собственное состояние, включая:</p>

<p class=text align=left style='margin-left:54.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l26 level1 lfo43;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>изображение текстуры</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l26 level1 lfo43;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>параметры фильтрации</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l26 level1 lfo43;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>режимы наложения</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l26 level1 lfo43;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>стек текстурных матриц</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l26 level1 lfo43;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>функции автоматического генерирования текстурных
координат</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l26 level1 lfo43;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>спецификацию вершинного массива (если она
требуется).</p>

<p class=text align=left style='text-align:left'>Каждый текстурный блок
комбинирует предыдущий цвет фрагмента со своим текстурным изображением в
соответствии со своим состоянием. Результирующий цвет фрагмента поступает в
следующий текстурный блок, если он активен.</p>

<p class=text align=left style='text-align:left'>Команда <b>glActiveTextureARB()</b>
выбирает текущий модифицируемый текстурный блок, чтобы можно было изменять его
состояние. После этого вызовы команд <b>glTexImage*()</b>, <b>glTexParameter*()</b>,
<b>glTexEnv*()</b>, <b>glTexGen*()</b> и <b>glBindTexture()</b> воздействуют
только на текущий текстурный блок. Запрос значений переменных состояния
текстурирования также возвращает значения из текущего текстурного блока, также
как запрос значений текущих координат текстуры и текущих растровых координат
текстуры.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>glActiveTextureARB</b>
  (GLenum <i>texUnit</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Выбирает текстурный блок,
который будет модифицироваться текстурными командами. <i>texUnit </i>– это
символическая константа в форме GL_TEXTURE<i>i</i>_ARB, где <i>i </i>должно
иметь значение в диапазоне от <i>0</i> до <i>k-1</i>, где <i>k</i>–
максимальное число текстурных блоков.</p>

<p class=text align=left style='text-align:left'>Если вы используете объекты
текстуры, вы можете связать текстуру с текущим текстурным блоком. Текущий
текстурный блок будет иметь состояние, содержащееся в текстурном объекте
(включая изображение текстуры).</p>

<p class=text align=left style='text-align:left'>Следующий пример кода в
примере 9-9 имеет две части. В первой части создаются два обычных текстурных
объекта (в предположении о том, что <i>texelss0</i> и <i>texels1</i> содержат
изображения текстур). Во второй части два текстурных объекта используются для
настройки двух текстурных блоков.</p>

<p class=text align=left style='text-align:left'>Пример 9-9. Инициализация
текстурных блоков для мультитекстурирования</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  style='color:black'>/* Создание обычных текстурных объектов */<o:p></o:p></span></pre><pre><span
  style='color:black'>GLuint texNames[2];<o:p></o:p></span></pre><pre><span
  style='color:black'>glGenTextures(2, texNames);<o:p></o:p></span></pre><pre><span
  style='color:black'>glBindTexture(GL_TEXTURE_2D,texNames[0]);<o:p></o:p></span></pre><pre><span
  style='color:black'>glTexImage2D(GL_TEXTURE_2D,0,GL_RGBA,32,32,0,<o:p></o:p></span></pre><pre><span
  style='color:black'>GL_RGBA,GL_UNSIGNED_BYTE,texels0);<o:p></o:p></span></pre><pre><span
  style='color:black'>glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_NEAREST);<o:p></o:p></span></pre><pre><span
  style='color:black'>glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAX_FILTER,GL_NEAREST);<o:p></o:p></span></pre><pre><span
  style='color:black'>glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_REPEAT);<o:p></o:p></span></pre><pre><span
  style='color:black'>glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,GL_REPEAT);<o:p></o:p></span></pre><pre><span
  style='color:black'>glBindTexture(GL_TEXTURE_2D,texNames[1]);<o:p></o:p></span></pre><pre><span
  style='color:black'>glTexImage2D(GL_TEXTURE_2D,0,GL_RGBA,16,16,0,<o:p></o:p></span></pre><pre><span
  style='color:black'>GL_RGBA,GL_UNSIGNED_BYTE,texels1);<o:p></o:p></span></pre><pre><span
  style='color:black'>glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);<o:p></o:p></span></pre><pre><span
  style='color:black'>glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAX_FILTER,GL_LINEAR);<o:p></o:p></span></pre><pre><span
  style='color:black'>glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_CLAMP_TO_EDGE);<o:p></o:p></span></pre><pre><span
  style='color:black'>glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,GL_CLAMP_TO_EDGE);<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>/* Использование 2 текстурных объектов для настройки 2 текстурных блоков, */<o:p></o:p></span></pre><pre><span
  style='color:black'>/* участвующих в мультитекстурировании */<o:p></o:p></span></pre><pre><span
  style='color:black'>glActiveTextureARB(GL_TEXTURE0_ARB);<o:p></o:p></span></pre><pre><span
  style='color:black'>glEnable(GL_TEXTURE_2D);<o:p></o:p></span></pre><pre><span
  style='color:black'>glBindTexture(GL_TEXTURE_2D,texNames[0]);<o:p></o:p></span></pre><pre><span
  style='color:black'>glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);<o:p></o:p></span></pre><pre><span
  style='color:black'>glMatrixMode(GL_TEXTURE);<o:p></o:p></span></pre><pre><span
  style='color:black'>glLoadIdentity();<o:p></o:p></span></pre><pre><span
  style='color:black'>glTranslatef(0.5,0.5,0.0);<o:p></o:p></span></pre><pre><span
  style='color:black'>glRotatef(45.0,0.0,0.0,1.0);<o:p></o:p></span></pre><pre><span
  style='color:black'>glTranslatef(-0.5,-0.5,0.0);<o:p></o:p></span></pre><pre><span
  style='color:black'>glMatrixMode(GL_MODELVIEW);<o:p></o:p></span></pre><pre><span
  style='color:black'>glActiveTextureARB(GL_TEXTURE1_ARB);<o:p></o:p></span></pre><pre><span
  style='color:black'>glEnable(GL_TEXTURE_2D);<o:p></o:p></span></pre><pre><span
  style='color:black'>glBindTexture(GL_TEXTURE_2D,texNames[1]);<o:p></o:p></span></pre><pre><span
  style='color:black'>glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Результатом будет то, что
текстурированный полигон при обработке будет визуализирован с использованием 2
текстурных блоков. В первом блоке накладывается текстура с изображением <i>texels0</i>,
с фильтрацией GL_NEAREST, режимом присоединения GL_REPEAT, режимом наложения
GL_REPLACE и поворачивающей текстурной матрицей. После завершения работы
первого блока, уже текстурированный полигон направляется во второй блок
текстуры (GL_TEXTURE1_ARB), где на него накладывается текстура с изображением <i>texels1</i>,
режимом фильтрации GL_LINEAR, режимом присоединения GL_CLAMP_TO_EDGE, режимом
наложения GL_MODULATE и текстурной матрицей по умолчанию.</p>

<p class=warning>Замечание: Операции по работе с группами атрибутов (с
использованием команд <b>glPushAttrib()</b>, <b>glPushClientAttrib()</b>, <b>glPopAttrib()</b>
или <b>glPopClientAttrib()</b>) сохраняют и восстанавливают состояние
текстурирования <i>для всех блоков текстуры</i> (но не сохраняют стек
текстурных матриц).</p>

<h2>9.6.2.3 Указание вершин и их текстурных координат</h2>

<p class=text align=left style='text-align:left'>При мультитекстурировании
недостаточно задать один набор текстурных координат. Вам нужно иметь по одному
набору для каждой вершины на каждый текстурный блок. Вместо команды <b>glTexCoord*()</b>
вы должны использовать команду <b>glMultiTexCoord*ARB()</b>, которая позволяет
задать координаты текстуры и текстурный блок, к которому они относятся.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>glMultiTexCoord</b>{1234}{sifd}<b>ARB</b>
  (GLenum texUnit, TYPE coords);<br>
  void <b>glMultiTexCoord</b>{1234}{sifd}<b>vARB</b> (GLenum texUnit, TYPE
  *coords);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Устанавливает текстурные
координаты (<i>s</i>, <i>t</i>, <i>r</i>, <i>q</i>) в значения, передаваемые в
аргументе <i>coords</i>. Координаты будут использованы в текстурном блоке <i>texUnit</i>.
Возможные значения для аргумента <i>texUnit</i>такие же, как и в команде <b>glActiveTextureARB()</b>.</p>

<p class=text align=left style='text-align:left'>В примере 9-10 треугольнику
присваивается два набора текстурных координат, необходимых для
мультитекстурирования с двумя активными текстурными блоками.</p>

<p class=text align=left style='text-align:left'>Пример 9-10. Указание вершин
для мультитекстурирования</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  style='color:black'>glBegin(GL_TRIANGLES);<o:p></o:p></span></pre><pre><span
  style='color:black'>glMultiTexCoord2fARB(GL_TEXTURE0_ARB,0.0,0.0);<o:p></o:p></span></pre><pre><span
  style='color:black'>glMultiTexCoord2fARB(GL_TEXTURE1_ARB,1.0,0.0);<o:p></o:p></span></pre><pre><span
  style='color:black'>glVertex2f(0.0,0.0);<o:p></o:p></span></pre><pre><span
  style='color:black'>glMultiTexCoord2fARB(GL_TEXTURE0_ARB,0.5,1.0);<o:p></o:p></span></pre><pre><span
  style='color:black'>glMultiTexCoord2fARB(GL_TEXTURE1_ARB,0.5,0.0);<o:p></o:p></span></pre><pre><span
  style='color:black'>glVertex2f(50.0,100.0);<o:p></o:p></span></pre><pre><span
  style='color:black'>glMultiTexCoord2fARB(GL_TEXTURE0_ARB,1.0,0.0);<o:p></o:p></span></pre><pre><span
  style='color:black'>glMultiTexCoord2fARB(GL_TEXTURE1_ARB,1.0,1.0);<o:p></o:p></span></pre><pre><span
  style='color:black'>glVertex2f(100.0,0.0);<o:p></o:p></span></pre><pre><span
  style='color:black'>glEnd();<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<p class=warning>Замечание: Если вы используете мультитекстурирование и
вызываете <b>glTexCoord*()</b>, вы устанавливаете значения координат для
первого текстурного блока. Другими словами, использование <b>glTexCoord*()</b>
эквивалентно использованию <b>glMultiTexCoord*ARB(GL_TEXTURE0_ARB, ...)</b>.</p>

<p class=text align=left style='text-align:left'>В редких случаях, когда вы
применяете мультитекстурирование к битовой карте или изображению, вам нужно
ассоциировать несколько наборов текстурных координат с каждой позицией растра.
То есть, вы должны вызвать <b>glMultiTexCoord*ARB()</b> несколько раз, по
одному на каждый активный текстурный блок для каждого вызова <b>glRasterPos*()</b>.
(Поскольку для каждого изображения и битовой карты существует только одна
позиция растра, может быть задано лишь по одному набору координат для каждого
текстурного блока, что сильно ограничивает эстетические возможности.)</p>

<p class=text align=left style='text-align:left'>Если вы применяете
мультитекстурирование и используете автоматическую генерацию текстурных
координат, <b>glActiveTextureARB()</b> задает текстурный блок, на который
воздействуют следующие команды:</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l59 level1 lfo44;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]><b>glTexGen*(...);</b></p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l59 level1 lfo44;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]><b>glEnable(GL_TEXTURE_GEN_*);</b></p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l59 level1 lfo44;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]><b>glDisable(GL_TEXTURE_GEN_*);</b></p>

<p class=text align=left style='text-align:left'>Если вы применяете
мультитекстурирование и передаете координаты текстуры в вершинном массиве,
используйте команду <b>glClientActiveTextureARB()</b>, устанавливающую
текстурный блок, для которого команда <b>glTexCoordPointer()</b> задает
текстурные координаты.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>glCLientActiveTextureARB</b>
  (GLenum <i>texUnit</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Выбирает текстурный блок, для
которого координаты текстуры задаются в вершинном массиве. <i>texUnit</i>– это
символическая константа в форме GL_TEXTURE<i>i</i>_ARB, могущая принимать те же
значения, что и в команде <b>glActiveTextureARB()</b>.</p>

<p class=MsoNormal><a name=Глава10><span style='display:none;mso-hide:all'><o:p>&nbsp;</o:p></span></a></p>

<h1 align=left style='text-align:left'><span style='mso-bookmark:Глава10'>Глава
10. Буфер кадра</span></h1>

<span style='mso-bookmark:Глава10'></span>

<p class=MsoNormal><a href="mailto:ahinar@list.ru"></a><span style='font-size:
10.0pt;font-family:Verdana'>Целью практически каждой графической программы
является отображение изображений на экране. Экран представляет собой
прямоугольный массив пикселей, каждый из которых способен отобразить
миниатюрный квадрат цвета, соответствующий цвету точки изображения. После этапа
растеризации (включая текстурирование и туман) данные все еще не являются
пикселями – они являются фрагментами. Каждый фрагмент имеет координаты,
соответствующие пикселю, а также значения цвета и глубины. Далее каждый из
фрагментов проходит через серию текстов и операций.<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Если фрагмент переживает тесты
и операции, он становится пикселем. Чтобы нарисовать пиксели, требуется знать
какого они цвета. Эта информация сохраняется в цветовом буфере. Поскольку
данные хранятся одинаково для каждого пикселя, хранилище всех пикселей и
называется <i>буфером</i>. Разные буферы могут содержать различное количество
информации на каждый пиксель, но внутри одного буфера на каждый пиксель приходится
одинаковое количество информации. Буфер, который хранит по одному биту
информации на каждый пиксель, называется <i>битовой плоскостью</i>.</p>

<p class=text align=left style='text-align:left'>Как показано на рисунке 10-1,
нижний левый пиксель OpenGL– это пиксель (<i>0</i>, <i>0</i>), что
соответствует оконным координатам нижнего левого угла региона размером 1x1,
занятого этим пикселем. Вообще пиксель с координатами (<i>x</i>, <i>y</i>)
заполняет область, ограниченную слева – <i>x</i>, справа – <i>x+1</i>, снизу – <i>y</i>,
сверху – <i>y+1</i>.</p>

<p class=text align=left style='text-align:left'>Рисунок 10-1. Область,
занимаемая пикселем </p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1459" type="#_x0000_t75" alt="" style='width:465pt;height:223.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image321.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов10.mht!http://www.progz.ru/images/opengl/chapter10/10-1.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=620 height=298
src="OpenGL%20Red%20Book.files/image321.jpg" v:shapes="_x0000_i1459"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>В качестве примера буфера
давайте подробнее рассмотрим цветовой буфер, содержащий цветовую информацию,
которая должна быть отображена на экране. Предположим, что экран имеет ширину
1280 пикселей, высоту – 1024 пикселя и 24 бита на цвет – то есть существует <!--[if gte vml 1]><v:shape
 id="_x0000_i1460" type="#_x0000_t75" alt="" style='width:24pt;height:20.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image322.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов10.mht!http://www.progz.ru/images/opengl/chapter10/form001.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=32 height=27
src="OpenGL%20Red%20Book.files/image323.jpg" v:shapes="_x0000_i1460"><![endif]>&nbsp;(или
16,777,216) цветов, которые можно отобразить. Поскольку 24 бита являются тремя
байтами (по 8 бит на 1 байт), цветовой буфер из нашего примера должен хранить,
как минимум, по 3 байта данных на каждый из 1,310,720 (1280*1024) пикселей
экрана. Конкретная аппаратная система может содержать больше или меньше
пикселей на экране, а так же больше или меньше цветовых данных на пиксель.
Однако любой цветовой буфер содержит одинаковое количество информации на каждый
пиксель.</p>

<p class=text align=left style='text-align:left'>Цветовой буфер – это только
один из нескольких буферов, хранящих информацию о пикселе. Например, информация
о глубине для каждого пикселя хранится в буфере глубины. Сам цветовой буфер
может состоять из нескольких буферов. Системный <i>буфер кадра</i> &nbsp;(<i>framebuffer</i>)
объединяет (включает в себя) все буферы. Вы не видите содержимого буферов (за
исключением цветового буфера или буферов) непосредственно; вместо этого они
используются для таких целей, как удаление невидимых поверхностей,
антиалиасинга всей сцены, трафарета, рисования плавного движения и других.</p>

<p class=text align=left style='text-align:left'>Эта глава описывается все
буферы, которые могут существовать в OpenGL и методы их использования. Также
обсуждаются серии тестов и операций, которые производятся до того, как
какие-либо данные записываются в цветовой буфер. Наконец, здесь объясняется,
как использовать аккумуляторный буфер, используемый для накопления изображений,
отображаемых в цветовом буфере.</p>

<h2>10.1 Буферы и их использование</h2>

<p class=text align=left style='text-align:left'>Система OpenGL может
манипулировать следующими буферами:</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l7 level1 lfo45;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Цветовые буферы: передний левый, передний
правый, задний левый, задний правый, а также любое число дополнительных
цветовых буферов.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l7 level1 lfo45;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Буфер глубины</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l7 level1 lfo45;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Буфер трафарета</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l7 level1 lfo45;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Аккумулирующий буфер</p>

<p class=text align=left style='text-align:left'>Какие буферы поддерживаются, и
сколько бит на пиксель хранит каждый буфер, определяет ваша реализация OpenGL.
Кроме того, у вас может быть множество типов окон, поддерживающих различные
буферы. Список всех параметров команды <b>glGetIntegerv()</b>, позволяющих
опрашивать OpenGL на предмет количества бит на пиксель в буферах ее реализации
приведен в таблице 10-1.</p>

<p class=warning>Замечание: Если вы работаете в системе XWindow, вам
гарантирован, как минимум, один визуальный объект с цветовым буфером в режиме
RGBA, а также ассоциированные буферы трафарета, глубины и аккумуляции, имеющие
ненулевые размеры цветовых компонент. Кроме того, если ваша система
поддерживает визуальный объект Pseudo-Color вам также гарантировано наличие
визуального объекта с цветовым буфером в режиме цветовых индексов и
ассоциированных буферов глубины и трафарета. Для получения информации о
системе, вам, возможно, придется использовать команду <b>glXGetConfig()</b>.</p>

<p class=text align=left style='text-align:left'>Таблица 10-1. Параметры опроса
для выяснения числа бит на пиксель в разных буферах</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Параметр</span></b><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Значение</span></b><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_RED_BITS, GL_GREEN_BITS,
  GL_BLUE_BITS, GL_ALPHA_BITS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>количество бит на R, G, B и Aкомпоненты в цветовом буфере<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_INDEX_BITS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>количество бит на индекс в цветовом буфере<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_DEPTH_BITS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>количество бит на пиксель в буфере глубины<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_STENCIL_BITS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>количество бит на пиксель в буфере трафарета<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:5;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_ACCUM_RED_BITS, GL_ACCUM_GREEN_BITS,<br>
  GL_ACCUM_BLUE_BITS,<br>
  GL_ACCUM_ALPHA_BITS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>количество бит на R, G, B и Aкомпоненты в буфере аккумулятора<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<h2>10.1.1 Типы буферов</h2>

<h2>10.1.1.1 Цветовые буферы</h2>

<p class=text align=left style='text-align:left'>Цветовые буферы – это те, что
обычно рисуются на экране. Они содержат либо цветовые индексы, либо данные RGB
цвета, а также могут содержать значения альфа. Реализация OpenGL,
поддерживающая стереоскопический просмотр, имеет левый и правый цветовые буферы
для левого и правого стереоскопических изображений. Если стерео не
поддерживается, используются только левые буферы. Аналогично, системы с двойной
буферизацией поддерживают передний и задний буферы, а системы с однократной
буферизацией – только передние. Любая реализация OpenGL должна как минимум
предоставлять левый передний цветовой буфер.</p>

<p class=text align=left style='text-align:left'>Опционально могут поддерживаться
дополнительные цветовые буферы, которые не отображаются на экране. OpenGL не
определяет конкретных нужд, для которых должны использоваться эти буферы, так
что вы можете определять и использовать их как угодно. Например, вы можете
использовать их для хранения часто применяемых изображений. Затем вместо того,
чтобы перерисовывать изображение, вы можете просто скопировать его из
дополнительного буфера в один из основных.</p>

<p class=text align=left style='text-align:left'>Для выяснения того,
поддерживает ли ваша система стерео просмотр (то есть, присутствуют ли в ней
левые и правые буферы) или двойную буферизацию (то есть, присутствуют ли в ней
передний и задний буферы), вы можете использовать команду <b>glGetBooleanv()</b>
с аргументами GL_STEREO или GL_DOUBLEBUFFER соответственно. Для того, чтобы
выяснить количество дополнительных цветовых буферов в системе (если они вообще
есть), используйте <b>glGetIntegerv()</b> с аргументом GL_AUX_BUFFERS.</p>

<h2>10.1.1.2 Буфер глубины</h2>

<p class=text align=left style='text-align:left'>Буфер глубины хранит значение
глубины для каждого пикселя. Глубина обычно измеряется в виде дистанции от
глаза наблюдателя, таким образом, пиксели с большими значениями глубины
затираются пикселями с меньшими значениями. Однако, это всего лишь обычное
соглашение, и поведение буфера глубины может быть изменено. Буфер глубины
иногда называется <i>z буфером </i>(<i>z </i>в этом термине берет свое начало
от того факта, что <i>x</i>и <i>y</i> определяют горизонтально и вертикальное
положение на экране, а <i>z</i>– дистанцию перпендикулярно плоскости экрана).</p>

<h2>10.1.1.3 Буфер трафарета</h2>

<p class=text align=left style='text-align:left'>Одно из назначений буфера
трафарета заключается в том, чтобы блокировать рисование определенных областей
на экране (по аналогии с реальным трафаретом). Например, если вы хотите
нарисовать изображение так, как оно выглядело бы через железную решетку, вам
нужно сохранить изображение решетки в буфере трафарета и нарисовать всю сцену.
Буфер трафарета не позволит частям изображения, которые были бы не видны через
решетку, быть нарисованными на экране. Таким образом, если ваше приложение –
это симулятор вождения, вы можете нарисовать все детали и инструменты,
находящиеся внутри машины, только единожды, а затем, в процессе движения,
машины обновлять только объекты снаружи машины.</p>

<h2>10.1.1.4 Аккумуляторный буфер</h2>

<p class=text align=left style='text-align:left'>Аккумуляторный буфер цветовые
данные RGBA точно так же как цветовые буферы в режиме RGBA (результат
использования буфера аккумулятора в индексном режиме не определен). Обычно он
используется для сборки серии последовательных изображений в одно составное
изображение. С помощью этого метода вы можете использовать такую технику, как
антиалиасинг всей сцены. Для этого нужно аккумулировать серию изображений одной
и той же сцены (обычно под слегка разными углами) и усреднить их между собой
для получения результирующих цветовых величин. Эти величины впоследствии
рисуются в цветовом буфере. Вы не производите рисование в аккумуляторный буфер
непосредственно; аккумуляторные операции, которые обычно передают данные в или
из буфера аккумулятора, всегда производятся над прямоугольными блоками.</p>

<h2>10.1.2 Очистка буферов</h2>

<p class=text align=left style='text-align:left'>Очистка экрана (и любых
буферов) это обычно одна из самых дорогих операций в графических программах –
на мониторе с разрешением 1280x1024 она затрагивает более миллиона пикселей. В
простых графических приложениях очистка экрана может занимать больше времени,
чем требуется на все остальное рисование. Если вам нужно очистить не только
цветовой буфер, но еще и буфер глубины, и буфер трафарета, время выполнения
очистки увеличивается втрое.</p>

<p class=text align=left style='text-align:left'>Для решения этой проблемы
некоторые машины имеют в своем составе аппаратуру, позволяющую очищать более
одного буфера одновременно. Команды очистки OpenGL построены с учетом
преимуществ таких архитектур. Сначала вы задаете для каждого буфера величины,
которые будут записаны в него при очистке. Затем вы выполняете единственную
команду, передавая ей список всех буферов, которые должны быть очищены. Если
аппаратура способна производить одновременную очистку, все указанные буферы
очищаются одновременно; если нет – они очищаются последовательно.</p>

<p class=text align=left style='text-align:left'>Следующие команды
устанавливают очищающие значения для каждого буфера.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glClearColor</b>
  (GLclampf <i>red</i>, GLclampf <i>green</i>, GLclampf <i>blue</i>, GLclampf <i>alpha</i>);<br>
  void <b>glClearIndex</b> (GLfloat <i>index</i>);<br>
  void <b>glClearDepth</b> (GLclampd <i>depth</i>);<br>
  void <b>glClearStencil</b> (GLint <i>s</i>);<br>
  void <b>glClearAccum</b> (GLfloat <i>red</i>, GLfloat <i>green</i>, GLfloat <i>blue</i>,
  GLfloat <i>alpha</i>); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Задают очищающие значения для
цветового буфера (в RGBA режиме), цветового буфера (в индексном режиме), буфера
глубины, буфера трафарета и аккумуляторного буфера. Аргументы типов GLclampf и
GLclampd (усеченное с плавающей точкой одинарной точности и усеченное с
плавающей точкой двойной точности) усекаются по границам диапазона [0.0, 1.0]
(то есть должны лежать в нем). Очищающая глубина по умолчанию равна 1.0; все
остальные очищающие величины – 0.0. Величины установленные этими командами
остаются в силе до тех пор, пока они не будут изменены теми же командами.</p>

<p class=text align=left style='text-align:left'>После выбора очищающих величин
для буферов можно очистить их командой <b>glClear()</b>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>glClear</b>
  (GLbitfield <i>mask</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Очищает заданные буферы.
Значение <i>mask</i>– это побитовое логическое ИЛИ некоторой комбинации
значений GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT, GL_STENCIL_BUFFER_BIT и
GL_ACCUM_BUFFER_BIT, задающих нужные буферы. GL_COLOR_BUFFER_BIT очищает либо
цветовой буфер RGBA, либо индексный цветовой буфер в зависимости от того, в
каком режиме система находится в момент вызова. Когда вы очищаете цветовой или
цветоиндексный буфер, очищаются все цветовые буферы в момент вызова доступные
для записи. Тест принадлежности пикселей, тест отреза и цветовое микширование,
если они активизированы, влияют на работу очищающих команд. Маскирующие
операции, такие как <b>glColorMask()</b> и <b>glIndexMask()</b> также работают.
Альфа тест, тест трафарета и тест глубины не оказывают влияния на работу <b>glClear()</b>.</p>

<h2>10.1.3 Выбор цветовых буферов для записи и чтения</h2>

<p class=text align=left style='text-align:left'>Результаты операций рисования
и считывания могут в любой цветовой буфер и из любого цветового буфера:
переднего, заднего, переднего левого, переднего правого, заднего левого,
заднего правого и любого из дополнительных буферов. Вы можете выбрать
конкретный буфер, который будет источником для чтения или местом назначения для
записи. Для операций рисования вы можете выбрать одновременно более одного
буфера – рисование в них будет происходить одновременно. Используйте команду <b>glDrawBuffer()</b>
для выбора буфера, в который буфет производиться рисование и <b>glReadBuffer()</b>
для выбора буфера, который буфет выступать в качестве источника данных для
команд <b>glReadPixels()</b>, <b>glCopyPixels()</b>, <b>glCopyTexImage*()</b> и
<b>glCopyTexSubImage*()</b>.</p>

<p class=text align=left style='text-align:left'>Если вы используете двойную
буферизацию, вам обычно следует рисовать только в задний буфер (и переключать
буферы после завершения рисования). В некоторых случаях вам может потребоваться
работать с дважды буферизированным окном так, как если бы оно было окном с
однократной буферизацией. Это можно сделать с помощью команды <b>glDrawBuffer()</b>,
активизировав для записи оба буфера – передний и задний.</p>

<p class=text align=left style='text-align:left'><b>glDrawBuffer()</b> также
используется при визуализации стерео изображений (GL*LEFTи GL*RIGHT) и для
вывода в дополнительные цветовые буферы (GL_AUX<i>i</i>).</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>glDrawBuffer</b>
  (GLenum <i>mode</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Выбирает цветовые буферы
доступные для записи и очистки и запрещает для записи и очистки буферы,
выбранные предыдущим вызовом той же команды. В каждый конкретный момент для
записи и очистки может быть выбрано несколько буферов. Значением аргумента <i>mode
</i>может быть любая из следующих констант:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FRONT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FRONT_LEFT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_AUX<i>i</i><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_BACK<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FRONT_RIGHT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FRONT_AND_BACK<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_LEFT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_BACK_LEFT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_NONE<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_RIGHT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_BACK_RIGHT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>&nbsp;<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Verdana;
color:black'>&nbsp; <o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Аргументы, в которых не
упоминается LEFT и RIGHT, обозначают и левый и правый буферы. Точно так же
аргументы, в которых нет FRONT и BACK, относятся и переднему, и к заднему
буферу. <i>i </i>в GL_AUX<i>i </i>идентифицирует конкретный дополнительный
буфер. По умолчанию <i>mode </i>равно GL_FRONT для режима с однократной
буферизацией и GL_BACK для режима с двойной буферизацией.</p>

<p class=warning>Замечание: Вы можете активизировать запись в несуществующие
буферы, если в том же вызове команды <b>glDrawBuffer()</b> открывается для
записи хотя бы один из существующих. Если же ни один из указанных в <i>mode</i>
буферов не существует, будет сгенерирована ошибка.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>glReadBuffer</b>
  (GLenum <i>mode</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Выбирает цветовой буфер,
который будет служить в качестве источника для чтения пикселей последующими
вызовами команд <b>glReadPixels()</b>, <b>glCopyPixels()</b>, <b>glCopyTexImage*()</b>,
<b>glCopyTexSubImage*()</b> и <b>glCopyConvolutionFilter*()</b> и запрещает для
чтения буфер, выбранный предыдущим вызовом той же команды. Значением аргумента <i>mode
</i>может быть любая из следующих констант:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FRONT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FRONT_LEFT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_AUX<i>i</i><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_BACK<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FRONT_RIGHT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>&nbsp; <o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_LEFT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_BACK_LEFT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>&nbsp; <o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_RIGHT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_BACK_RIGHT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>&nbsp;<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Verdana;
color:black'>&nbsp; <o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Буферы для <b>glReadBuffers()</b>
те же самые, что и для команды <b>glDrawBuffers()</b>. По умолчанию <i>mode </i>равно
GL_FRONT для режима с однократной буферизацией и GL_BACK для режима с двойной
буферизацией. </p>

<p class=warning>Замечание: Вы можете активизировать чтение только из
существующего буфера. В противном случае будет сгенерирована ошибка.</p>

<h2>10.1.4 Маскирование буферов</h2>

<p class=text align=left style='text-align:left'>До того, как OpenGL записывает
данные в доступные цветовые, глубинный или трафаретный буферы, к данным
применяется операция маскирования, заданная одной из следующих команд. Над
записываемыми данными и маской производится побитовое логическое И.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glIndexMask</b>
  (GLuint <i>mask</i>);<br>
  void <b>glColorMask</b> (GLboolean <i>red</i>, GLboolean <i>green</i>,
  GLboolean <i>blue</i>, GLboolean <i>alpha</i>);<br>
  void <b>glDepthMask</b> (GLboolean <i>flag</i>);<br>
  void <b>glStencilMask</b> (GLuint <i>mask</i>); <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Устанавливают маски,
управляющие записью в буферы. Маска, заданная командой <b>glIndexMask()</b>
применяется только в индексном режиме. Если в маске в определенном разряде
оказывается 1, соответствующий разряд записывается в цветоиндексный буфер; если
там оказывается 0 – бит не записывается. Точно также <b>glColorMask()</b>
работает только в режиме RGBA. Величины <i>red</i>, <i>green</i>, <i>blue </i>и
<i>alpha </i>управляют тем, будут ли записываться соответствующие компоненты
(GL_TRUE означает, что компонент будет записан). Если <i>flag </i>в <b>glDepthMask()</b>
равен GL_TRUE, буфер глубины доступен для записи; иначе – нет. Маска для <b>glStencilMask()</b>
используется с данными трафарета точно так же, как маска для индексного
цветового буфера. Значения по умолчанию для всех булевских значений – GL_TRUE,
а для двух целых масок – все единицы.</p>

<p class=text align=left style='text-align:left'>С помощью цветового
маскирования в индексном режиме вы можете совершать массу трюков. Например, вы
можете использовать каждый бит индекса, как отдельный слой и устанавливать
взаимодействие между отдельными слоями с помощью определенных установок в
цветовой карте. Вы можете создавать подслои и надслои, а также выполнять так
называемую анимацию цветовой палитры. Маскирование в RGBA режиме используется
несколько реже, но вы можете использовать его для загрузки трех разных
изображений в красные, зеленые и синие битовые плоскости, например.</p>

<p class=text align=left style='text-align:left'>Запрещение буфера глубины для
записи можно использовать в том случае, если для последовательности кадров
используется один и тот же задний план, и вы хотите добавить несколько деталей,
которые могут загораживаться частями заднего плана. Например, предположим, что
ваш задний план – это лес, и вы хотите нарисовать серию кадров с одними и теми
же деревьями, но с объектами, которые движутся среди них. После того, как
деревья нарисованы, и их глубина записана в буфер глубины, сохраните изображение
деревьев и нарисуйте новые объекты при заблокированном для записи буфере
глубины. До тех пор, пока объекты не накладываются друг на друга, картинка
выглядит так, как нужно. Чтобы нарисовать следующий кадр, восстановите
изображение деревьев и продолжайте. Вам не нужно восстанавливать значения в
буфере глубины. Этот трюк особенно полезен, если задний план весьма сложен –
настолько сложен, что его изображение намного быстрее скопировать в цветовой
буфер, чем заново рассчитать из геометрических данных.</p>

<p class=text align=left style='text-align:left'>Маскирование буфера трафарета
позволяет вам использовать многобитный буфер трафарета для хранения нескольких
трафаретов (по одному на бит)..</p>

<p class=warning>Замечание: Маска, задаваемая с помощью <b>glStencilMask()</b>
управляет тем, какие из битовых плоскостей трафарета доступны для записи. Эта
маска никак не связана с маской, задаваемой в качестве третьего параметра <b>glStencilFunc()</b>.
Та маска определяет, какие битовые плоскости должны приниматься в расчет
трафаретной функцией.</p>

<h2>10.2 Тестирование и операции над фрагментами</h2>

<p class=text align=left style='text-align:left'>Когда вы рисуете
геометрические фигуры, текст или изображения на экране, OpenGLпроизводит
определенные расчеты для поворотов, масштабирования, расчета освещенности,
перспективного проецирования объектов, вычисления затрагиваемых пикселей и
определения цвета, которым они должны быть нарисованы. После того, как
OpenGLопределит, что нужно сгенерировать отдельный фрагмент, а также определит
его цвет, остается выполнить еще несколько этапов обработки, которые управляют
тем, как должен отображаться фрагмент, и должен ли он вообще быть отображен в
виде пикселя в буфере кадра. Например, если он лежит за пределами прямоугольной
области или находится дальше от точки наблюдения, чем пиксель, уже находящийся
в буфере кадра, он нарисован не будет. На другом этапе цвет фрагмента
накладывается на цвет пикселя, находящегося в буфере кадра.</p>

<p class=text align=left style='text-align:left'>В этом разделе описывается
полный набор тестов, которые фрагмент должен пройти, чтобы попасть в буфер
кадра, и все возможные финальные операции, которые совершаются над фрагментом
во время его записи в буфер. Тесты и операции выполняются в следующем порядке;
если фрагмент не проходит один из ранних тестов, никакие более поздние тесты и
операции над ним не производятся.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l62 level1 lfo46;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>1.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Тест отреза (scissor test) </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l62 level1 lfo46;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>2.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Альфа тест (alpha test) </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l62 level1 lfo46;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>3.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Тест трафарета (stencil test) </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l62 level1 lfo46;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>4.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Тест глубины (depth test) </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l62 level1 lfo46;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>5.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Цветовое наложение (blending) </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l62 level1 lfo46;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>6.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Цветовое микширование (dithering) </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l62 level1 lfo46;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>7.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Логические операции (logical operations) </p>

<p class=text align=left style='text-align:left'>Все эти тесты и операции
подробно описаны в следующих подразделах.</p>

<h2>10.2.1 Тест отреза</h2>

<p class=text align=left style='text-align:left'>С помощью команды <b>glScissor()</b>
вы можете задать прямоугольную область окна и ограничить рисование только этой
областью. Фрагмент проходит тест, если он лежит внутри заданного
прямоугольника.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glScissor</b>
  (GLint <i>x</i>, GLint <i>y</i>, GLsizei <i>width</i>, GLsizei <i>height</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Устанавливает положение и размер
прямоугольника отреза (также известного как scissorbox). Аргументы задают
положение левого нижнего угла (<i>x</i>, <i>y</i>) и размеры прямоугольника (<i>width</i>,
<i>height</i>). (Измерение производится в пикселях экрана.) Тест проходят
пиксели, которые лежат внутри прямоугольника. Тест отреза активизируется и
деактивируется с помощью аргумента GL_SCISSOR_TEST команд <b>glEnable()</b> и <b>glDisable()</b>.
По умолчанию тест деактивирован, а прямоугольник отреза совпадает с размерами
окна.</p>

<p class=text align=left style='text-align:left'>Тест отреза – это просто
версия теста трафарета, использующая прямоугольную область экрана. Очень просто
создать ошеломляюще быструю аппаратную реализацию отреза, тогда как та же
система может намного медленнее работать с трафаретами – может быть потому, что
трафареты реализуются программно.</p>

<p class=text align=left style='text-align:left'><b>Дополнительно:</b> Более
сложное назначение отрезов заключается в возможности нелинейного проецирования.
Сначала разделите окно на сетку областей, задавая такие параметры порта
просмотра и отреза, которые в каждый конкретный момент ограничивают область
рисования одним регионом. Затем проецируйте всю сцену в каждый регион с
использованием различных проекционных матриц.</p>

<p class=text align=left style='text-align:left'>Чтобы выяснить, активизирован
ли тест отреза, и получить значения, определяющие прямоугольник отреза,
используйте GL_SCISSOR_TEST с командой <b>glIsEnabled()</b> и GL_SCISSOR_BOX с
командой <b>glGetIntegerv()</b> соответственно.</p>

<h2>10.2.2 Альфа тест</h2>

<p class=text align=left style='text-align:left'>Альфа тест в RGBA режиме
позволяет вам принимать или отвергать фрагмент в зависимости от его значения
альфа. Альфа тест активизируется и деактивируется с помощью аргумента
GL_ALPHA_TEST команд <b>glEnable()</b> и <b>glDisable()</b>. Чтобы выяснить,
активизирован ли альфа тест, используйте аргумент GL_ALPHA_TEST с командой <b>glIsEnabled()</b>.</p>

<p class=text align=left style='text-align:left'>Если тест активизирован, он
сравнивает входящую величину альфа с некоторым заданным значением. Фрагмент
принимается или отвергается в зависимости от результата этого сравнения. И
сравниваемое значение, и функция сравнения устанавливаются командой <b>glAlphaFunc()</b>.
По умолчанию сравниваемое значение равно 0, функция сравнения – GL_ALWAYS, а
сам тест деактивирован. Чтобы выяснить текущую функцию сравнения или
сравниваемое значение, используйте аргумент GL_ALPHA_FUNC или GL_ALPHA_TEST_REF
с командой <b>glGetIntegerv()</b>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glAlphaFunc</b>
  (GLenum <i>func</i>, GLclampf <i>ref</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Устанавливает сравниваемое
значение и функцию сравнения для альфа теста. Сравниваемое значение <i>ref </i>усекается
до диапазона [0; 1]. Возможные значения для функции сравнения <i>func </i>и их
смысл приводятся в таблице 10-2.</p>

<p class=text align=left style='text-align:left'>&nbsp;Таблица 10-2. Значения
параметров glAlphaFunc()</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Параметр</span></b><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Значение</span></b><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_NEVER<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>фрагмент никогда не принимается<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_ALWAYS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>фрагмент принимается всегда<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_LESS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>фрагмент принимается, если его альфа &lt;&nbsp;заданного
  значения<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_LEQUAL<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>фрагмент принимается, если его альфа &lt;= заданного значения<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:5'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_EQUAL<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>фрагмент принимается, если его альфа = заданному значению<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:6'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_GEQUAL<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>фрагмент принимается, если его альфа &gt;= заданного значения<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:7'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_GREATER<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>фрагмент принимается, если его альфа &gt; заданного значения<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:8;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_NOTEQUAL<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>фрагмент принимается, если его альфа ! = заданному значению<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Одним из предназначений альфа
теста является реализация алгоритма прозрачности. Визуализируйте всю вашу сцену
дважды, первый раз принимая только фрагменты с альфа величиной равной 1, а
второй раз – только с альфа величиной не равной 1. Включите буфер глубины для
обоих проходов, но при втором проходе запретите запись в него.</p>

<p class=text align=left style='text-align:left'>Кроме того, альфа тест, как и
цветовое микширование, позволяет реализовать биллбоардинг.</p>

<h2>10.2.3 Тест трафарета</h2>

<p class=text align=left style='text-align:left'>Тест трафарета может
производиться, только если имеется буфер трафарета. (Если буфера нет, фрагмент
всегда проходит тест успешно.) Тест трафарета сравнивает некоторое заданное
значение со значением, сохраненным для пикселя в буфере трафарета. В
зависимости от результата сравнения величина в буфере трафарета изменяется. Вы
можете выбрать функцию сравнения, сравниваемое значение и метод модификации с
помощью команд <b>glStencilFunc()</b> и <b>glStencilOp()</b>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glStencilFunc</b>
  (GLenum func, GLint ref, GLuint mask);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Устанавливает функцию
сравнения (<i>func</i>), сравниваемое значение (<i>ref</i>) и маску (<i>mask</i>)
для использования тестом трафарета. Значение <i>ref </i>сравнивается с
величиной в буфере трафарета с использованием функции сравнения, однако
сравнение применяется только к тем битам, которые остаются после маскирования
маской <i>mask</i>. В качестве функции сравнения могут быть выбраны GL_NEVER,
GL_ALWAYS, GL_LESS, GL_LEQUAL, GL_GEQUAL, GL_GREATER, GL_EQUAL или GL_NOTEQUAL.
Например, если выбрана GL_LESS, фрагмент проходит тест только в случае, если <i>ref
</i>меньше, чем величина в буфере трафарета. Если буфер трафарета содержит <i>s</i>битовых
плоскостей, то над величиной в буфере трафарета и сравниваемым значением <i>ref
</i>производится логическое И с <i>s </i>младших битов <i>mask</i>.
Маскирование производится до сравнения. Все маскированные величины
интерпретируются как неотрицательные. </p>

<p class=text align=left style='text-align:left'>Тест трафарета активизируется
и деактивируется с помощью аргумента GL_STENCIL_TEST команд <b>glEnable()</b> и
<b>glDisable()</b>. По умолчанию тест деактивирован, <i>func </i>равно
GL_ALWAYS, <i>mask</i> – всем единицам, а <i>ref</i> -- 0.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glStencilOp</b>
  (GLenum <i>fail</i>, GLenum <i>zfail</i>, GLenum <i>zpass</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Задает, как данные в буфере
трафарета должны измениться в случае прохождения или непрохождения теста
трафарета. Три функции <i>fail</i>, <i>zfail </i>и <i>zpass </i>могут принимать
значения GL_KEEP, GL_ZERO, GL_REPLACE, GL_INCR, GL_DECR или GL_INVERT. Эти
функции соответствуют (по порядку) сохранению предыдущего значения, замене его
0, замене его сравниваемой величиной, увеличению величины в буфере на 1,
уменьшению величины на 1 и побитовой инверсии. Результат функций инкремента и
декремента усекается до отрезка между 0 и максимальным беззнаковым целым
значением, которое может быть сохранено в буфере трафарета (если буфер
трафарета содержит <i>s </i>битовых плоскостей, это значение равно <!--[if gte vml 1]><v:shape
 id="_x0000_i1461" type="#_x0000_t75" alt="" style='width:37.5pt;height:15.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image322.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов10.mht!http://www.progz.ru/images/opengl/chapter10/form001.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=50 height=21
src="OpenGL%20Red%20Book.files/image322.jpg" v:shapes="_x0000_i1461"><![endif]>).
Функция <i>fail </i>применяется, если фрагмент не проходит тест трафарета,
функция <i>zfail</i>– если фрагмент прошел тест трафарета, но не прошел тест
глубины, а <i>zpass</i>– если фрагмент прошел и тест трафарета, и тест глубины
(или если тест глубины деактивирован).</p>

<h2>10.2.3.1 Опрос трафарета</h2>

<p class=text align=left style='text-align:left'>Вы можете получить значения
всех 6 параметров, связанных с тестом трафарета, используя команду <b>glGetIntegerv()</b>
и одну из констант, перечисленных в таблице 10-3. Выяснить, активизирован ли
тест трафарета, вы можете с помощью аргумента GL_STENCIL_TEST команды <b>glIsEnabled()</b>.</p>

<p class=text align=left style='text-align:left'>Таблице 10-3. Константы для
запросов состояния теста трафарета</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Константаb&gt;</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Значение</span></b><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_STENCIL_FUNC<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>функция сравнения<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_STENCIL_REF<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>сравниваемое значение<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_STENCIL_VALUE_MASK<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>маска трафарета<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_STENCIL_FAIL<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>действие при непрохождении теста трафарета<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:5'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_STENCIL_PASS_DEPTH_FAIL<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>действие при прохождении тест трафарета и провале теста глубины<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:6;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_STENCIL_PASS_DEPTH_PASS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>действие при прохождении тест трафарета и прохождении теста
  глубины<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<h2>10.2.3.2 Примеры применения трафарета</h2>

<p class=text align=left style='text-align:left'>Наверное, самое типичное
использование теста трафарета заключается в маскировании экранной области
необычной формы для ограничения области рисования этой формой. Чтобы это
сделать, заполните трафарет нулями, а затем нарисуйте в буфере трафарета нужную
форму единицами. Вы не можете рисовать геометрию непосредственно в буфер
трафарета, но вы можете добиться того же результата, рисуя в цветовой буфер и
выбрав подходящее значение для функции <i>zpass</i> (например, GL_REPLACE).
(Кроме того, для рисования пикселей непосредственно в буфер трафарета, вы
можете использовать <b>glDrawPixels()</b>.) Во время рисования величина (в
данном случае сравниваемая) записывается и в буфер трафарета. Чтобы избежать
воздействия рисования в буфере трафарета на содержимое цветового буфера,
установите цветовую маску в 0 (или GL_FALSE). Возможно, вы также захотите
запретить запись в буфер глубины.</p>

<p class=text align=left style='text-align:left'>После того, как вы определили
область трафарета, установите сравниваемое значение в 1, а функцию сравнения в
GL_EQUAL. Не модифицируйте содержимое буфера трафарета во время рисования.</p>

<p class=text align=left style='text-align:left'>Пример 10-1 демонстрирует
подобное использование теста трафарета. Рисуются два торуса и вырез в середине
сцены. Внутри выреза рисуется сфера. В этом примере рисование в буфер трафарета
осуществляется только во время перерисовки окна, так что после создания формы
трафарета цветовой буфер очищается.</p>

<p class=text align=left style='text-align:left'>Пример 10-1. Использование
теста трафарета: файл stencil.cpp</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#include &lt;glut.h&gt;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#define YELLOWMAT 1<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#define BLUEMAT 2<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void init()<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>GLfloat yellow_diffuse[]={0.7,0.7,0.0,1.0};<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>GLfloat yellow_specular[]={1.0,1.0,1.0,1.0};<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>GLfloat blue_diffuse[]={0.1,0.1,0.7,1.0};<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>GLfloat blue_specular[]={0.1,1.0,1.0,1.0};<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>GLfloat position_one[]={1.0,1.0,1.0,0.0};<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glNewList(YELLOWMAT,GL_COMPILE);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>glMaterialfv(GL_FRONT,GL_DIFFUSE,yellow_diffuse);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>glMaterialfv(GL_FRONT,GL_SPECULAR,yellow_specular);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>glMaterialf(GL_FRONT,GL_SHININESS,64.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glEndList();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glNewList(BLUEMAT,GL_COMPILE);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>        </span><span style='mso-spacerun:yes'>    </span>glMaterialfv(GL_FRONT,GL_DIFFUSE,blue_diffuse);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>glMaterialfv(GL_FRONT,GL_SPECULAR,blue_specular);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>glMaterialf(GL_FRONT,GL_SHININESS,45.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glEndList();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glLightfv(GL_LIGHT0,GL_POSITION,position_one);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glEnable(GL_LIGHT0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glEnable(GL_LIGHTING);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glEnable(GL_DEPTH_TEST);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glClearStencil(0x0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glEnable(GL_STENCIL_TEST);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void display()<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>//</span><span
  style='color:black'>Синяя</span><span style='color:black;mso-ansi-language:
  EN-US'> </span><span style='color:black'>сфера</span><span lang=EN-US
  style='color:black;mso-ansi-language:EN-US'>, </span><span style='color:black'>где</span><span
  style='color:black;mso-ansi-language:EN-US'> </span><span style='color:black'>трафарет</span><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'> =1<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glStencilFunc(GL_EQUAL,0x1,0x1);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glStencilOp(GL_KEEP,GL_KEEP,GL_KEEP);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glCallList(BLUEMAT);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutSolidSphere(0.5,15,15);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>//</span><span
  style='color:black'>Желтый</span><span style='color:black;mso-ansi-language:
  EN-US'> </span><span style='color:black'>бублик</span><span lang=EN-US
  style='color:black;mso-ansi-language:EN-US'>, </span><span style='color:black'>где</span><span
  style='color:black;mso-ansi-language:EN-US'> </span><span style='color:black'>трафарет</span><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'> &lt;&gt;1<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glStencilFunc(GL_NOTEQUAL,0x1,0x1);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glPushMatrix();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glRotatef(45,0.0,0.0,1.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glRotatef(45,0.0,1.0,0.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glCallList(YELLOWMAT);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutSolidTorus(0.275,0.85,15,15);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glPushMatrix();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>glRotatef(90.0,1.0,0.0,0.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>glutSolidTorus(0.275,0.85,15,15);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glPopMatrix();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glPopMatrix();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void reshape(int w,int h)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glViewport(0,0,(GLsizei)w,(GLsizei)h);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>//</span><span
  style='color:black'>Создать</span><span style='color:black;mso-ansi-language:
  EN-US'> </span><span style='color:black'>алмазоподобную</span><span
  style='color:black;mso-ansi-language:EN-US'> </span><span style='color:black'>область</span><span
  style='color:black;mso-ansi-language:EN-US'> </span><span style='color:black'>трафарета</span><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glMatrixMode(GL_PROJECTION);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glLoadIdentity();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>if (w&lt;=h)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>gluOrtho2D(-3.0,3.0,-3.0*(GLfloat)h/(GLfloat)w,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                        </span>3.0*(GLfloat)h/(GLfloat)w);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>else<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>gluOrtho2D(-3.0*(GLfloat)w/(GLfloat)h,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                        </span>3.0*(GLfloat)w/(GLfloat)h,-3.0,3.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glMatrixMode(GL_MODELVIEW);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glLoadIdentity();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>  </span><span style='mso-spacerun:yes'>    </span>glClear(GL_STENCIL_BUFFER_BIT);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glStencilFunc(GL_ALWAYS,0x1,0x1);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glStencilOp(GL_REPLACE,GL_REPLACE,GL_REPLACE);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glBegin(GL_QUADS);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>glVertex2f(-1.0,0.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>glVertex2f(0.0,1.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>glVertex2f(1.0,0.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>  </span><span style='mso-spacerun:yes'>          </span>glVertex2f(0.0,-1.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glEnd();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glMatrixMode(GL_PROJECTION);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glLoadIdentity();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>gluPerspective(45.0,(GLfloat)w/(GLfloat)h,3.0,7.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glMatrixMode(GL_MODELVIEW);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glLoadIdentity();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glTranslatef(0.0,0.0,-5.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>int main(int argc, char **argv)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutInit(&amp;argc,argv);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB|GLUT_DEPTH|GLUT_STENCIL);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutInitWindowSize(400,400);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutCreateWindow(&quot;Using the Stencil Test&quot;);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>init();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutDisplayFunc(display);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutReshapeFunc(reshape);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span></span><span
  style='color:black'>glutMainLoop();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>return 0;<span style='mso-spacerun:yes'>         </span><o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Далее приводятся другие
примеры использования теста трафарета.</p>

<p class=text align=left style='text-align:left'>Предположим, что вы рисуете
закрытый выпуклый объект (или несколько подобных объектов, при условии, что они
не пересекают и не включают друг друга), созданный из нескольких полигонов, и у
вас есть отсекающая плоскость, которая может отсекать или не отсекать часть
этого объекта. Предположим, что в случае, когда плоскость пересекает объект, вы
хотите закрыть его поверхностью постоянного цвета, а не рассматривать его
внутренности. Чтобы это сделать, установите буфер трафарета в нули и начинайте
рисование, активизировав тест трафарета и установив функцию сравнения в
GL_ALWAYS. Инвертируйте значения в битовых плоскостях буфера трафарета каждый
раз, когда фрагмент принимается. После того, как все объекты нарисованы,
областям, не требующим закрытия, в буфере трафарета будут соответствовать 0, а
областям, где оно требуется – 1. Установите трафаретную функцию таким образом,
чтобы рисование совершалось только так, где индекс трафарета не равен 0 и
нарисуйте большой полигон закрывающего цвета размером с экран.</p>

<p class=text align=left style='text-align:left'>Предположим, что у вас есть
полупрозрачная поверхность, состоящая из нескольких, слегка перекрывающихся полигонов.
Если вы просто используете цветовое наложение, части нижележащих объектов будут
закрываться более чем одной прозрачной поверхностью, что неправильно. Чтобы
каждый фрагмент накрывался только одной частью поверхности, используйте буфер
трафарета. Установите буфер трафарета в нули, рисуйте, только если плоскость
трафарета имеет значение 0, и при рисовании инкрементируйте значение в
плоскости трафарета.</p>

<p class=text align=left style='text-align:left'>Предположим, что вам нужно
отобразить шаблонированное изображение. Вы можете сделать это, записав рисунок
шаблона в буфер трафарета, и производя рисование с учетом содержимого буфера
трафарета. После того, как рисунок шаблона записан, во время рисования
изображения буфер трафарета не изменяется.</p>

<h2>10.2.4 Тест глубины</h2>

<p class=text align=left style='text-align:left'>Для каждого пикселя на экране,
буфер глубины следит за дистанцией между точкой наблюдения и объектом,
занимающим этот пиксель. Затем, если тест глубины проходит, входящая величина
глубины заменяет ту, что уже находится в буфере.</p>

<p class=text align=left style='text-align:left'>В общем случае буфер глубины
используется для удаления невидимых поверхностей. Новый цвет для пикселя,
рисуется только в том случае, если соответствующий объект ближе, чем
предыдущий. Таким образом, после визуализации всей сцены на экране остаются
только ничем не загороженные объекты. В самом начале очищающее значение для
буфера глубины, это величина, равная наибольшей возможной дистанции от точки
наблюдения, то есть любой объект ближе, чем эта величина. Если вы собираетесь
использовать буфер глубины именно так, все, что вам нужно сделать, это
активизировать тест глубины командой <b>glEnable()</b> с аргументом
GL_DEPTH_TEST и не забывать очищать буфер глубины перед перерисовкой каждого
кадра. Вы также можете выбрать иную функцию сравнения для теста на глубину.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>glDepthFunc</b>
  (GLenum <i>func</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Устанавливает функцию
сравнения для теста глубины. Возможными значениями для <i>func </i>являются
GL_NEVER, GL_ALWAYS, GL_LESS, GL_LEQUAL, GL_EQUAL, GL_GEQUAL, GL_GREATER и
GL_NOTEQUAL. Входящий фрагмент проходит тест глубины в том случае, если его <i>z
</i>координата относится к значению, хранимому в буфере глубины, указанным
образом. Функция по умолчанию – это GL_LESS, что означает прохождение
фрагментом теста в том случае, если его глубина меньше хранимой в буфере. В
этом случае величина <i>z</i> представляет собой дистанцию от объекта до точки
наблюдения, и меньшие величины означают, что соответствующий объект находится
ближе к наблюдателю.</p>

<h2>10.2.5 Цветовое наложение, цветовое микширование и логические операции</h2>

<p class=text align=left style='text-align:left'>Как только входящий фрагмент
прошел все тесты, его можно комбинировать с содержимым цветового буфера одним
из нескольких методов. Простейшим методом является перезапись уже существующих
значений. Альтернативно, если вы работаете в RGBA режиме и хотите сделать,
чтобы фрагмент был полупрозрачным или сглаженным, вы можете усреднить его
значение со значением, уже находящимся в буфере (цветовой наложение). В
системах с ограниченным количеством доступных цветов вам может понадобиться
микшировать цветовые величины для увеличения числа доступных цветов, ценой
потери разрешения. На финальном этапе вы можете использовать простые логические
операции для комбинирования цвета входящего фрагмента с цветом пикселя, уже
записанного в цветовой буфер.</p>

<h2>10.2.5.1 Цветовое наложение</h2>

<p class=text align=left style='text-align:left'>Цветовое наложение комбинирует
R, G, B и A величины фрагмента с компонентами пикселя, уже сохраненного в
соответствующем месте цветового буфера. Могут применяться различные операции
наложения, а результат зависит от альфа входящего фрагмента и альфа уже
сохраненного пикселя.</p>

<h2>10.2.5.2 Цветовое микширование</h2>

<p class=text align=left style='text-align:left'>В системах с небольшим
количеством цветовых битовых плоскостей, вы можете увеличить цветовое
разрешение за счет пространственного разрешения, микшируя цвета в изображении.
Микширование похоже на полутонирование в газетах. Несмотря на то, что
практически в любой газете 2 цвета – черный и белый – в ней могут появляться
фотографии, напечатанные оттенками серого цвета, полученного путем чередования
белых и черных точек. Сравнение газетного изображения фотографии (без реальных
оттенков серого) с оригинальной фотографией (с оттенками серого)
свидетельствует об очевидных потерях пространственного разрешения. Похожим
образом системы с малым количеством цветовых битовых поверхностей могут
смешивать величины красного, зеленого и синего в соседних пикселях для
получения более широкого диапазона цветов.</p>

<p class=text align=left style='text-align:left'>Операция микширования
полностью зависит от аппаратуры; все, что позволяет вам сделать OpenGL– это
активизировать или деактивировать эту операцию. На некоторых системах, однако,
это может вообще ни к чему не приводить, что имеет смысл, если цветовых
плоскостей и так достаточно. Чтобы активизировать и деактивировать микширование
передайте аргумент GL_DITHER командt<b>glEnable()</b> или <b>glDisable()</b>
соответственно. Микширование по умолчанию активизировано.</p>

<p class=text align=left style='text-align:left'>Микширование работает и в
RGBA, и в индексном режиме. Цвета или цветовые индексы изменяются каким-либо
аппаратно-зависимым методом между двумя соседними значениями. Например, если
микширование включено, и индекс, который нужно нарисовать, равен 4.4, то 60%
пикселей могут быть нарисованы с индексом 4, а 40% -- с индексом 5. (Может
существовать множество алгоритмов микширования, но результат любого алгоритма
должен зависеть только от цвета входящего фрагмента и его координат (<i>x</i>, <i>y</i>).)
В RGBA режиме микширование производится отдельно для каждого компонента
(включая альфа). Чтобы использовать микширование в индексном режиме, вы, как
правило, должны должным образом подготовить цветовую карту (чтобы цвета с
соседними индексами выглядели близкими), в противном случае могут получаться
очень странные изображения.</p>

<h2>10.2.5.3 Логические операции</h2>

<p class=text align=left style='text-align:left'>Последняя операция, которая
применяется к фрагменту – это логическая операция, такая как OR, XOR или
INVERT, которая применяется к значениям входящего фрагмента (источнику) и/или
тем значениям, которые уже хранятся в цветовом буфере (приемнике). Такие логические
операции особенно полезны в машинах, на которых первостепенной графической
операцией является копирование прямоугольников данных из одной части окна в
другую, из окна в процессорную память или из памяти в окно. Обычно копирование
не записывает данные в память непосредственно, а позволяет вам производить
логические операции на входящих данных и тех, что уже присутствуют; уже затем
копирование замещает старые данные результатом этих операций.</p>

<p class=text align=left style='text-align:left'>Поскольку этот процесс может
быть легко реализован аппаратно, имеется множество подобных систем. В качестве
примера использования логической операции, можно рассмотреть использование XOR
для рисования поверх изображения с восстановлением – просто нарисуйте то же
изображение с помощью XOR второй раз, и исходная картинка восстановлена. В
качестве другого примера, рассмотрим использование цветовых индексов в качестве
битовых рисунков в индексном режиме. Вы можете составлять изображение в виде
комбинации рисунков на разных слоях, использовать ограничение на рисование в
определенном наборе слоев и производить логические операции для изменения
различных слоев.</p>

<p class=text align=left style='text-align:left'>Вы включаете и выключаете
логические операции с помощью аргументов GL_INDEX_LOGIC и GL_COLOR_LOGIC команд
<b>glEnable()</b> и <b>glDisable()</b> для индексного и RGBA режимов соответственно.
Вы также должны выбрать одну из поддерживаемых логических операций командой <b>glLogicOp()</b>.
В противном случае вы получите результат по умолчанию – GL_COPY. (Для обратной
совместимости с OpenGL версии 1.0, <b>glEnable(</b>GL_LOGIC_OP<b>)</b> также
включает логические операции в индексном режиме.)</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>glLogicOp</b> (GLenum
  <i>opcode</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Выбирает производимую
логическую операцию, выполняемую над входящим фрагментом (источником) и
пикселем, находящимся в цветовом буфере (приемником). Все возможные значения
для <i>opcode </i>и их значения перечислены в таблице 10-4. <i>s</i>означает
источник (source), а <i>d</i>– приемник (destination). Значение по умолчанию –
GL_COPY.</p>

<p class=text align=left style='text-align:left'>Таблица 10-4. Логические
операции</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Параметр</span></b><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Операция</span></b><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Параметр</span></b><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Операция</span></b><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_CLEAR<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_AND<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1462" type="#_x0000_t75"
   alt="" style='width:39pt;height:13.5pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image324.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов10.mht!http://www.progz.ru/images/opengl/chapter10/form006.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=52 height=18
  src="OpenGL%20Red%20Book.files/image324.jpg" v:shapes="_x0000_i1462"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_COPY<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><i><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>s</span></i><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_OR<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1463" type="#_x0000_t75"
   alt="" style='width:39.75pt;height:13.5pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image325.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов10.mht!http://www.progz.ru/images/opengl/chapter10/form007.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=53 height=18
  src="OpenGL%20Red%20Book.files/image325.jpg" v:shapes="_x0000_i1463"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_NOOP<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><i><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>d</span></i><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_NAND<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1464" type="#_x0000_t75"
   alt="" style='width:66.75pt;height:16.5pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image326.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов10.mht!http://www.progz.ru/images/opengl/chapter10/form008.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=89 height=22
  src="OpenGL%20Red%20Book.files/image326.jpg" v:shapes="_x0000_i1464"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_SET<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_NOR<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1465" type="#_x0000_t75"
   alt="" style='width:65.25pt;height:16.5pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image327.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов10.mht!http://www.progz.ru/images/opengl/chapter10/form009.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=87 height=22
  src="OpenGL%20Red%20Book.files/image327.jpg" v:shapes="_x0000_i1465"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:5'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_COPY_INVERTED<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1466" type="#_x0000_t75"
   alt="" style='width:24pt;height:12pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image328.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов10.mht!http://www.progz.ru/images/opengl/chapter10/form002.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=32 height=16
  src="OpenGL%20Red%20Book.files/image328.jpg" v:shapes="_x0000_i1466"><![endif]><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_XOR<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1467" type="#_x0000_t75"
   alt="" style='width:60.75pt;height:13.5pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image329.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов10.mht!http://www.progz.ru/images/opengl/chapter10/form010.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=81 height=18
  src="OpenGL%20Red%20Book.files/image329.jpg" v:shapes="_x0000_i1467"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:6'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_INVERT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1468" type="#_x0000_t75"
   alt="" style='width:25.5pt;height:15pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image330.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов10.mht!http://www.progz.ru/images/opengl/chapter10/form003.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=34 height=20
  src="OpenGL%20Red%20Book.files/image330.jpg" v:shapes="_x0000_i1468"><![endif]><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_EQUIV<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1469" type="#_x0000_t75"
   alt="" style='width:86.25pt;height:16.5pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image331.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов10.mht!http://www.progz.ru/images/opengl/chapter10/form011.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=115 height=22
  src="OpenGL%20Red%20Book.files/image331.jpg" v:shapes="_x0000_i1469"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:7'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_AND_REVERSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1470" type="#_x0000_t75"
   alt="" style='width:54.75pt;height:14.25pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image332.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов10.mht!http://www.progz.ru/images/opengl/chapter10/form004.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=73 height=19
  src="OpenGL%20Red%20Book.files/image332.jpg" v:shapes="_x0000_i1470"><![endif]><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_AND_INVERTED<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1471" type="#_x0000_t75"
   alt="" style='width:51.75pt;height:15pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image333.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов10.mht!http://www.progz.ru/images/opengl/chapter10/form012.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=69 height=20
  src="OpenGL%20Red%20Book.files/image333.jpg" v:shapes="_x0000_i1471"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:8;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_OR_REVERSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1472" type="#_x0000_t75"
   alt="" style='width:53.25pt;height:13.5pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image334.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов10.mht!http://www.progz.ru/images/opengl/chapter10/form005.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=71 height=18
  src="OpenGL%20Red%20Book.files/image334.jpg" v:shapes="_x0000_i1472"><![endif]><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_OR_INVERTED <o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1473" type="#_x0000_t75"
   alt="" style='width:52.5pt;height:12.75pt'>
   <v:imagedata src="OpenGL%20Red%20Book.files/image335.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов10.mht!http://www.progz.ru/images/opengl/chapter10/form013.jpg"/>
  </v:shape><![endif]--><![if !vml]><img border=0 width=70 height=17
  src="OpenGL%20Red%20Book.files/image335.jpg" v:shapes="_x0000_i1473"><![endif]><o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<h2><i>10.3&nbsp;&nbsp;&nbsp; </i>Аккумуляторный буфер</h2>

<p class=text align=left style='text-align:left'><b>Дополнительно:</b>
Аккумуляторный буфер может использоваться для таких техник, как сглаживание
всей сцены, размытое движение, симуляции фотографической глубины поля и вычисление
мягких теней, получающихся от нескольких источников света. Можно применять и
другие с техники, особенно если использовать еще и другие буферы.</p>

<p class=text align=left style='text-align:left'>Графические операции OpenGL не
пишут в буфер аккумулятора непосредственно. Обычно в одном из цветовых буферов
генерируется серия изображений, и эти изображения аккумулируются в буфере
аккумулятора по одному за раз. Когда аккумуляция завершена, результат
копируется обратно в цветовой буфер для просмотра. Во избежание ошибок
округления буфер аккумуляции может иметь большее цветовое разрешение (больше
бит на цвет), чем цветовые буферы. Визуализация сцены несколько раз, очевидно,
занимает больше времени, но результат имеет более высокое качество.
Следовательно, вы должны решать, что важнее для вашего приложения – качество
или скорость.</p>

<p class=text align=left style='text-align:left'>Вы можете использовать буфер
аккумуляции так же, как фотограф использует один кадр для нескольких снимков
одной и той же сцены. Если какой-либо объект сцены перемещается – он будет
выглядеть размытым. Не является сюрпризом тот факт, что компьютер может делать
с изображением намного больше трюков, чем фотограф с камерой. Например,
компьютер может управлять точкой наблюдения в отличие от фотографа, который не
может встряхнуть камеру предсказуемым образом.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>glAccum</b> (GLenum <i>op</i>,
  GLfloat <i>value</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Управляет буфером аккумуляции.
Аргумент <i>op</i>выбирает операцию, а <i>value</i>– число, которое будет
использоваться в этой операции. Возможными операциями являются GL_ACCUM,
GL_LOAD, GL_RETURN, GL_ADD и GL_MULT.</p>

<p class=text align=left style='text-align:left'>GL_ACCUM считывает каждый
пиксель из буфера выбранного для чтения командой <b>glReadBuffer()</b>,
умножает R, G, B и A величины на число <i>value</i> и добавляет результаты в
буфер аккумуляции.</p>

<p class=text align=left style='text-align:left'>GL_LOAD работает так же как
GL_ACCUM за тем исключением, что результирующие значения заменяют уже хранимые
в буфере, а не добавляются к ним.</p>

<p class=text align=left style='text-align:left'>GL_RETURN забирает величины из
буфера аккумуляции, умножает их на <i>value</i>и помещает результат в цветовой
буфер, выбранный для записи.</p>

<p class=text align=left style='text-align:left'>GL_ADD и GL_MULT просто
добавляют или умножают значения каждого пикселя в буфере аккумуляции к или на
величину <i>value</i>. Для GL_MULT<i> value </i>усекается до диапазона [-1.0,
1.0]. Для GL_ADD усечение не производится.</p>

<h2>10.3.1 Сглаживание всей сцены</h2>

<p class=text align=left style='text-align:left'>Чтобы произвести сглаживание
сцены, сначала очистите аккумулятор и активизируйте передний цветовой буфер для
записи и чтения. Затем несколько раз (скажем <i>n</i>) выполните код, который
сдвигает изображение (<i>jittering</i>– это перемещение изображения в слегка
иную позицию) и рисует его, аккумулируя данные командой</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>glAccum(GL_ACCUM,1.0/n);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>а затем в конце вызовите</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>glAccum(GL_RETURN,1.0);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Заметьте, что этот метод
работает несколько быстрее, если при первом проходе вместо GL_ACCUM применить
GL_LOAD, а не делать предварительную очистку аккумулятора. С помощью этого кода
изображение нужно нарисовать nраз, а затем нарисовать результирующее изображение.
Если вы не хотите, чтобы наблюдатель видел промежуточные изображения,
считывайте из невидимого цветового буфера, а результат записывайте в видимый
(или в задний буфер, впоследствии переключив его с передним).</p>

<p class=text align=left style='text-align:left'>Вы также можете создать
пользовательский интерфейс, который показывает, как рассматриваемое изображение
улучшается с каждым шагом и позволяет пользователю остановить процесс, когда
ему кажется, что изображение достигло нужного качества. Чтобы сделать это, в
цикле, рисующем последовательные изображения, вызывайте <b>glAccum()</b> с
первым аргументом GL_RETURN, а вторым равным 16.0/1.0, 16.0/2.0, 16.0/3.0, ...
В данной технике после одного прохода показывается 1/16 часть финального
изображения, после двух проходов – 2/16 и так далее. После GL_RETURN программа
должна проверять, не остановил ли пользователь процесс. Такой метод будет
работать несколько медленнее, поскольку после каждого шага изображение должно
быть скопировано в цветовой буфер.</p>

<p class=text align=left style='text-align:left'>Чтобы решить, каким должно
быть <i>n</i>, вы должны сделать выбор между скоростью (чем больше проходов вы
сделаете, тем больше времени понадобится для получения финального изображения)
и качеством (чем больше проходов вы сделаете, тем выше будет качество
финального изображения). На рисунке 10-2 слева показано исходное изображение,
справа то же изображение после 16 аккумулирующих итераций, а в нижней части
увеличенные фрагменты первого и второго изображений соответственно.</p>

<p class=text align=left style='text-align:left'>Рисунок 10-2. Сглаживание
сцены с помощью буфера аккумулятора </p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1474" type="#_x0000_t75" alt="" style='width:465pt;height:461.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image336.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов10.mht!http://www.progz.ru/images/opengl/chapter10/10-2.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=620 height=615
src="OpenGL%20Red%20Book.files/image336.jpg" v:shapes="_x0000_i1474"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Пример 10-2. Функции для
сдвига объема видимости</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  style='color:black'>#include &lt;math.h&gt;<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>#define PI_20 3.14159265358979323846<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>void accFrustum(GLdouble left,GLdouble right,<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                </span>GLdouble bottom,GLdouble top,<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                </span>GLdouble zNear,GLdouble zFar,<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                </span>GLdouble pixdx,GLdouble pixdy,<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                </span>GLdouble eyedx, GLdouble eyedy,<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                </span>GLdouble focus)<o:p></o:p></span></pre><pre><span
  style='color:black'>{<o:p></o:p></span></pre><pre><span style='color:black'><span style='mso-spacerun:yes'>      </span>GLdouble xwsize, ywsize;<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>GLdouble dx, dy;<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>GLint viewport[4];<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glGetIntegerv(GL_VIEWPORT,viewport);<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>xwsize=right-left;<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>ywsize=top-bottom;<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>dx=-(pixdx*xwsize/(GLdouble)viewport[2] + eyedx*zNear/focus);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>dy=-(pixdy*ywsize/(GLdouble)viewport[3] + eyedy*zNear/focus);<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glMatrixMode(GL_PROJECTION);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glLoadIdentity();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glFrustum(left+dx,right+dx,bottom+dy,top+dy,zNear,zFar);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glMatrixMode(GL_MODELVIEW);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glTranslatef(-eyedx,-eyedy,0.0);<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre><pre><span style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>void accPerspective(GLdouble fovy,GLdouble aspect,<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                    </span>GLdouble zNear,GLdouble zFar,<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                    </span>GLdouble pixdx,GLdouble pixdy,<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                    </span>GLdouble eyedx,GLdouble eyedy,<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                    </span>GLdouble focus)<o:p></o:p></span></pre><pre><span
  style='color:black'>{<o:p></o:p></span></pre><pre><span style='color:black'><span style='mso-spacerun:yes'>      </span>GLdouble fov2,left,right,bottom,top;<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>fov2=((fovy*PI_20)/180.0)/2.0;<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>top=zNear/(cos(fov2)/sin(fov2));<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>bottom=-top;<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>right=top*aspect;<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>left=-right;<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>accFrustum(left,right,bottom,top,zNear,zFar,<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                 </span>pixdx,pixdy,eyedx,eyedy,focus);<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Пример 10-3 использует две
функции из примера 10-2 для выполнения сглаживания сцены.</p>

<p class=text align=left style='text-align:left'>Пример 10-3. Сглаживание
сцены: файл accpersp.cpp</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  style='color:black'>#include &lt;glut.h&gt;<o:p></o:p></span></pre><pre><span
  style='color:black'>#include &quot;jitter.h&quot;<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>#define ACSIZE 16<o:p></o:p></span></pre><pre><span
  style='color:black'>#define SPHERE_FACES 32<o:p></o:p></span></pre><pre><span
  style='color:black'>#define JIT j16<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>void init()<o:p></o:p></span></pre><pre><span
  style='color:black'>{<o:p></o:p></span></pre><pre><span style='color:black'><span style='mso-spacerun:yes'>      </span>GLfloat mat_ambient[]={1.0,1.0,1.0,1.0};<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>GLfloat mat_specular[]={1.0,1.0,1.0,1.0};<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>GLfloat light_position[]={0.0,0.0,10.0,1.0};<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>GLfloat lm_ambient[]={0.2,0.2,0.2,1.0};<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glMaterialfv(GL_FRONT,GL_AMBIENT,mat_ambient);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glMaterialfv(GL_FRONT,GL_SPECULAR,mat_specular);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glMaterialf(GL_FRONT,GL_SHININESS,50.0);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glLightfv(GL_LIGHT0,GL_POSITION,light_position);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glLightModelfv(GL_LIGHT_MODEL_AMBIENT,lm_ambient);<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glEnable(GL_LIGHTING);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glEnable(GL_LIGHT0);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glEnable(GL_DEPTH_TEST);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glShadeModel(GL_FLAT);<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glClearColor(0.0,0.0,0.0,0.0);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glClearAccum(0.0,0.0,0.0,0.0);<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre><pre><span style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>void displayObjects()<o:p></o:p></span></pre><pre><span
  style='color:black'>{<o:p></o:p></span></pre><pre><span style='color:black'><span style='mso-spacerun:yes'>      </span>GLfloat torus_diffuse[]={0.7,0.7,0.0,1.0};<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>GLfloat cube_diffuse[]={0.0,0.7,0.7,1.0};<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>   </span><span style='mso-spacerun:yes'>   </span>GLfloat sphere_diffuse[]={0.7,0.0,0.7,1.0};<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>GLfloat octa_diffuse[]={0.7,0.4,0.4,1.0};<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glPushMatrix();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glTranslatef(0.0,0.0,-5.0);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glRotatef(30.0,1.0,0.0,0.0);<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glPushMatrix();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glTranslatef(-0.80,0.35,0.0);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glRotatef(100.0,1.0,0.0,0.0);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glMaterialfv(GL_FRONT,GL_DIFFUSE,torus_diffuse);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glutSolidTorus(0.275,0.85,SPHERE_FACES,SPHERE_FACES);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glPopMatrix();<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glPushMatrix();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glTranslatef(-0.75,-0.50,0.0);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glRotatef(45.0,0.0,0.0,1.0);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glRotatef(45.0,1.0,0.0,0.0);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glMaterialfv(GL_FRONT,GL_DIFFUSE,cube_diffuse);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glutSolidCube(1.5);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glPopMatrix();<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glPushMatrix();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glTranslatef(0.75,0.60,0.0);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glRotatef(30.0,1.0,0.0,0.0);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glMaterialfv(GL_FRONT,GL_DIFFUSE,sphere_diffuse);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glutSolidSphere(1.0,SPHERE_FACES,SPHERE_FACES);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glPopMatrix();<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glPushMatrix();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glTranslatef(0.70,-0.90,0.25);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glMaterialfv(GL_FRONT,GL_DIFFUSE,octa_diffuse);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glutSolidCube(1.5);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glPopMatrix();<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glPopMatrix();<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre><pre><span style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>void display()<o:p></o:p></span></pre><pre><span
  style='color:black'>{<o:p></o:p></span></pre><pre><span style='color:black'><span style='mso-spacerun:yes'>      </span>GLint viewport[4];<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>int jitter;<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glGetIntegerv(GL_VIEWPORT,viewport);<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glClear(GL_ACCUM_BUFFER_BIT);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>for (jitter=0;jitter&lt;ACSIZE;jitter++)<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>{<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>accPerspective(50.0,(GLdouble)viewport[2]/(GLdouble)viewport[3],<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                           </span>1.0,15.0,JIT[jitter].x,JIT[jitter].y,<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                           </span>0.0,0.0,1.0);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>displayObjects();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>         </span><span style='mso-spacerun:yes'>   </span>glAccum(GL_ACCUM,1.0/ACSIZE);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>}<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glAccum(GL_RETURN,1.0);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glFlush();<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre><pre><span style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>void reshape(int w,int h)<o:p></o:p></span></pre><pre><span
  style='color:black'>{<o:p></o:p></span></pre><pre><span style='color:black'><span style='mso-spacerun:yes'>      </span>glViewport(0,0,(GLsizei)w,(GLsizei)h);<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre><pre><span style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>int main (int argc, char **argv)<o:p></o:p></span></pre><pre><span
  style='color:black'>{<o:p></o:p></span></pre><pre><span style='color:black'><span style='mso-spacerun:yes'>      </span>glutInit(&amp;argc,argv);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB|GLUT_DEPTH|GLUT_ACCUM);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glutInitWindowSize(310,310);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glutInitWindowPosition(100,100);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glutCreateWindow(&quot;Scene Antialiasing&quot;);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>init();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glutDisplayFunc(display);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glutReshapeFunc(reshape);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glutMainLoop();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>return 0;<span style='mso-spacerun:yes'>   </span><o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Для того, чтобы производить
сглаживание сцены, вы не обязательно должны использовать перспективную
проекцию. Если вы работаете с ортографической проекцией, для сдвига сцены вам
достаточно использовать <b>glTranslate*()</b>. Имейте в виду, что <b>glTranslate*()</b>
работает в мировых координатах, а вам нужно сдвигать сцену менее чем на 1
пиксель в оконных координатах. Таким образом, вам нужно обратить процесс
преобразования мировых координат, вычислив величины сдвигающего переноса с
использованием его ширины и высоты в мировых координатах, деленных на размер
порта просмотра. Затем умножьте получившуюся величину в мировых координатах на
количество сдвига, вычислив, таким образом, на сколько сцена должна быть
перемещена в мировых координатах, чтобы получить предсказуемый сдвиг менее чем
в 1 пиксель. Пример 10-4 показывает, как должны выглядеть функции <b>display()</b>
и <b>reshape()</b>, если ширина и высота в мировых координатах равны 4.5.</p>

<p class=text align=left style='text-align:left'>Пример 10-4. Сдвиг в
ортографической проекции: файл accanti.cpp</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  style='color:black'>void display()<o:p></o:p></span></pre><pre><span
  style='color:black'>{<o:p></o:p></span></pre><pre><span style='color:black'><span style='mso-spacerun:yes'>      </span>GLint viewport[4];<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>int jitter;<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glGetIntegerv(GL_VIEWPORT,viewport);<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glClear(GL_ACCUM_BUFFER_BIT);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>for (jitter=0;jitter&lt;ACSIZE;jitter++)<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>{<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span><span style='mso-spacerun:yes'>      </span>glPushMatrix();<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>//Обратите внимание, что 4.5 - это дистанция в мировых координатах<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>//между левой и правой, а также нижней и верхней границами.<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>//Формула преобразует сдвиг на часть пикселя в мировые координаты.<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>   </span><span style='mso-spacerun:yes'>         </span>glTranslatef(JIT[jitter].x*4.5/viewport[2],<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                         </span>JIT[jitter].y*4.5/viewport[3],0.0);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>displayObjects();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>glPopMatrix();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>glAccum(GL_ACCUM,1.0/ACSIZE);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>}<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glAccum(GL_RETURN,1.0);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>     </span><span style='mso-spacerun:yes'> </span>glFlush();<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre><pre><span style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>void reshape(int w,int h)<o:p></o:p></span></pre><pre><span
  style='color:black'>{<o:p></o:p></span></pre><pre><span style='color:black'><span style='mso-spacerun:yes'>      </span>glViewport(0,0,(GLsizei)w,(GLsizei)h);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glMatrixMode(GL_PROJECTION);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>if(w&lt;=h)<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>glOrtho(-2.25,2.25,-2.25*h/w,2.25*h/w,-10.0,10.0);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>else<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>glOrtho(-2.25*w/h,2.25*w/h,-2.25,2.25,-10.0,10.0);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glMatrixMode(GL_MODELVIEW);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glLoadIdentity();<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<h2>10.3.2 Размытое движение</h2>

<p class=text align=left style='text-align:left'>Похожие методы могут быть
использованы для симуляции размытого движения, как показано на рисунке 10-3.
предположим, что в вашей сцене есть несколько стационарных и несколько
движущихся объектов, и вы хотите показать движение размытием. Настройте буфер
аккумуляции таким же образом, как и раньше, но вместо пространственного сдвига
изображений, сдвигайте их по времени. Вся сцена может быть сделана более тусклой,
если в процессе рисования в буфер аккумуляции вызывать</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>glAccum(GL_MULT,
  decayFactor);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>где <i>decayFactor</i> – это
число от 0.0 до 1.0. Меньшие значения для <i>decayFactor </i>как бы заставляют
объект двигаться быстрее. Вы можете перенести результирующее изображение с
текущей позицией движущегося объекта и хвостом от его предыдущих позиций из
аккумулятора в цветовой буфер, вызвав</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>glAccum(GL_RETURN,1.0);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Verdana;
color:black'>&nbsp; <o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Изображение выглядит правильно
даже если объекты движутся с разными скоростями или если часть из них движется
с ускорением. как и раньше, чем больше точек сдвига (в данном случае временных)
&nbsp;вы используете, тем качественнее будет финальное изображение. Это верно
как минимум до той точки, когда вы начнете терять разрешение, поскольку буфер
аккумуляции имеет конечную точность. Вы можете комбинировать размытое движение
и сглаживание, производя сдвиг и в пространстве и во времени, однако за более
высокое качество изображения вы заплатите низкой скоростью работы программы. </p>

<p class=text align=left style='text-align:left'>Описанная техника отображения
размытого изображения с помощью буфера аккумуляции, конечно, не является
единственной. Альтернативно, вы можете после отрисовки каждого кадра сохранять
получившееся изображение в буфере аккумулятора (с ослаблением) и затем сразу же
восстанавливать его (уже без ослабления). Это можно сделать, например, с
помощью следующих команд:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>glAccum(GL_LOAD, 0.9);<br>
  glAccum(GL_RETURN, 1.0);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>После этого нужно переместить
модель, нарисовать ее поверх уже имеющегося изображения, загрузить его в
аккумулятор, восстановить и так далее. Этот метод применяется в примере 10-5,
который использовался для получения рисунка 10-3. &nbsp;&nbsp;&nbsp;&nbsp;
Имейте в виду, что вы в любом случае должны согласовывать коэффициент
итеративного ослабления и число шагов сдвига. Например, если коэффициент мал, а
число шагов велико, то к последней итерации след от первой итерации может быть
невидим на экране (поскольку будет слишком ослаблен). Если же коэффициент велик
(близок к 1.0), а число шагов небольшое – разница между изображением первой и
последней итераций может быть настолько мала, что невозможно будет понять, где
начало движения, а где его конец.</p>

<p class=text align=left style='text-align:left'>Рисунок 10-3. Размытое
движение </p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1475" type="#_x0000_t75" alt="" style='width:396.75pt;height:185.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image337.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов10.mht!http://www.progz.ru/images/opengl/chapter10/10-3.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=529 height=247
src="OpenGL%20Red%20Book.files/image337.jpg" v:shapes="_x0000_i1475"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Пример 10-5. Размытие движения
с помощью буфера аккумулятора: файл motiblur.cpp</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  style='color:black'>#include &lt;glut.h&gt;<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>#define SPHERE_FACES 64<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>//Горизонтальный размер проекции<o:p></o:p></span></pre><pre><span
  style='color:black'>#define PROJ_SIZE 8<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>//Количество шагов сдвига/поворота<o:p></o:p></span></pre><pre><span
  style='color:black'>#define TIME_JITTER_STEPS 10<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>//Угол на который за время сдвигов<o:p></o:p></span></pre><pre><span
  style='color:black'>//должна повернуться модель<o:p></o:p></span></pre><pre><span
  style='color:black'>#define FULL_ROT 0<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>//Фактор сжатия модели <o:p></o:p></span></pre><pre><span
  style='color:black'>#define SCALE_FACTOR 1.0<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>void init()<o:p></o:p></span></pre><pre><span
  style='color:black'>{<o:p></o:p></span></pre><pre><span style='color:black'><span style='mso-spacerun:yes'>      </span>GLfloat mat_ambient[]={0.8,0.8,0.8,1.0};<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>GLfloat mat_specular[]={1.0,1.0,1.0,1.0};<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>GLfloat light_position[]={0.0,0.0,10.0,1.0};<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>GLfloat lm_ambient[]={0.2,0.2,0.2,1.0};<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glMaterialfv(GL_FRONT,GL_AMBIENT,mat_ambient);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glMaterialfv(GL_FRONT,GL_SPECULAR,mat_specular);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glMaterialf(GL_FRONT,GL_SHININESS,50.0);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glLightfv(GL_LIGHT0,GL_POSITION,light_position);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glLightModelfv(GL_LIGHT_MODEL_AMBIENT,lm_ambient);<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glEnable(GL_LIGHTING);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glEnable(GL_LIGHT0);<span style='mso-spacerun:yes'>    </span><o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glEnable(GL_RESCALE_NORMAL);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glEnable(GL_DEPTH_TEST);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glShadeModel(GL_SMOOTH);<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glClearColor(0.0,0.0,0.0,0.0);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glClearAccum(0.0,0.0,0.0,0.0);<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre><pre><span style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>void displayObjects(GLfloat xoffset,GLfloat yrot)<o:p></o:p></span></pre><pre><span
  style='color:black'>{<o:p></o:p></span></pre><pre><span style='color:black'><span style='mso-spacerun:yes'>      </span>GLfloat torus1_diffuse[]={1.0,0.0,0.0,1.0};<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>GLfloat torus2_diffuse[]={1.0,0.7,0.7,1.0};<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>GLfloat sphere_diffuse[]={1.0,1.0,1.0,1.0};<span style='mso-spacerun:yes'>    </span><o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glLoadIdentity();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glTranslatef(xoffset,0.0,0.0);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glRotatef(yrot,0.0,1.0,0.0);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glScalef(SCALE_FACTOR,SCALE_FACTOR,SCALE_FACTOR);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glMaterialfv(GL_FRONT,GL_DIFFUSE,torus1_diffuse);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glutSolidTorus(0.3,0.55,SPHERE_FACES,SPHERE_FACES);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glMaterialfv(GL_FRONT,GL_DIFFUSE,torus2_diffuse);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glutSolidTorus(0.35,0.45,SPHERE_FACES,SPHERE_FACES);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glMaterialfv(GL_FRONT,GL_DIFFUSE,sphere_diffuse);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glutSolidSphere(0.4,SPHERE_FACES,SPHERE_FACES);<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre><pre><span style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>void display()<o:p></o:p></span></pre><pre><span
  style='color:black'>{<o:p></o:p></span></pre><pre><span style='color:black'><span style='mso-spacerun:yes'>      </span>GLfloat correctedProjSize=PROJ_SIZE-3;<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>int step;<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>GLfloat oneStepTrans=correctedProjSize/TIME_JITTER_STEPS;<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>GLfloat oneStepRot=FULL_ROT/TIME_JITTER_STEPS;<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glClear(GL_COLOR_BUFFER_BIT|GL_ACCUM_BUFFER_BIT);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>for(step=0;step&lt;=TIME_JITTER_STEPS;step++)<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>{<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>glClear(GL_DEPTH_BUFFER_BIT);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>displayObjects(-correctedProjSize/2+oneStepTrans*step,<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                           </span>oneStepRot*step);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>if(step!=TIME_JITTER_STEPS)<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>glAccum(GL_LOAD,0.9);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>else<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>glAccum(GL_LOAD,1.0);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>glAccum(GL_RETURN,1.0);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>}<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glAccum(GL_RETURN,1.0);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glFlush();<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre><pre><span style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>void reshape(int w,int h)<o:p></o:p></span></pre><pre><span
  style='color:black'>{<o:p></o:p></span></pre><pre><span style='color:black'><span style='mso-spacerun:yes'>      </span>glViewport(0,0,(GLsizei)w,(GLsizei)h);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glMatrixMode(GL_PROJECTION);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>if(w&lt;=h)<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>glOrtho(-PROJ_SIZE/2,PROJ_SIZE/2,<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                    </span>-(PROJ_SIZE/2)*h/w,(PROJ_SIZE/2)*h/w,-10.0,10.0);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>else<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>glOrtho(-PROJ_SIZE/2*w/h,(PROJ_SIZE/2)*w/h,<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span><span style='mso-spacerun:yes'>        </span>-(PROJ_SIZE/2),PROJ_SIZE/2,-10.0,10.0);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glMatrixMode(GL_MODELVIEW);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glLoadIdentity();<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre><pre><span style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>int main (int argc, char **argv)<o:p></o:p></span></pre><pre><span
  style='color:black'>{<o:p></o:p></span></pre><pre><span style='color:black'><span style='mso-spacerun:yes'>      </span>glutInit(&amp;argc,argv);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB|GLUT_DEPTH|GLUT_ACCUM);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glutInitWindowSize(620,620);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glutInitWindowPosition(100,100);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glutCreateWindow(&quot;Motion blur with Accumulator&quot;);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>init();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glutDisplayFunc(display);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glutReshapeFunc(reshape);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glutMainLoop();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>return 0;<span style='mso-spacerun:yes'>   </span><o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<h2>10.3.3 Глубина поля</h2>

<p class=text align=left style='text-align:left'>Фотографии, сделанные с
помощью камеры, имеют превосходный фокус только для объектов, лежащих в одной
плоскости параллельной фотопленке на определенном расстоянии. Чем дальше объект
от этой плоскости, тем более он размыт. Глубина поля для камеры – это область
вокруг плоскости фокуса, где объекты сравнительно слабо выпадают из фокуса.</p>

<p class=text align=left style='text-align:left'>При обычных условиях, все, что
вы рисуете с помощью OpenGL, находится в фокусе (если только у вас хороший
монитор – в противном случае абсолютно все выглядит размытым). Буфер
аккумуляции может быть использован для приближения к виду реальной фотографии,
где объекты выглядят все более и более размытыми по мере удаления от плоскости
фокуса. Это (как и во многих других случаях) не точная имитация того, что
происходит внутри камеры, но результат похож на тот, который получается при
помощи камеры.</p>

<p class=text align=left style='text-align:left'>Чтобы достигнуть этого
результата, нарисуйте сцену несколько раз, вызывая <b>glFrustum()</b> с разными
аргументами. Выбирайте аргументы таким образом, чтобы точка наблюдения
перемещалась (на незначительное расстояние) вокруг своей оригинальной позиции,
и, чтобы прямоугольник, лежащий в плоскости фокуса, был одинаковым для всех
проекций (как показано на рисунке 10-4). Результаты всех визуализаций должны
быть усреднены обычным путем с помощью буфера аккумуляции.</p>

<p class=text align=left style='text-align:left'>Рисунок 10-4. Перемещение
объема видимости для эффекта глубины поля </p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1476" type="#_x0000_t75" alt="" style='width:328.5pt;height:711.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image338.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов10.mht!http://www.progz.ru/images/opengl/chapter10/10-4.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=438 height=949
src="OpenGL%20Red%20Book.files/image338.jpg" v:shapes="_x0000_i1476"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>На рисунке 10-5 изображено 5
чайников, нарисованных с применением эффекта глубины поля. Золотой чайник
(второй слева) находится в фокусе, а остальные размываются в разной степени в
зависимости от дистанции до плоскости фокуса (золотого чайника). Код,
используемый для рисования этого изображения, приводится в примере 10-6. Сцена
рисуется 8 раз, каждый раз со слегка сдвинутым объемом видимости (сдвиг
осуществляется с помощью функции <b>accPerspective()</b>). Как вы можете
помнить, из метода сглаживании сцены, 5-ый и 6-ой аргументы сдвигают объем
видимости в направлениях <i>x</i>и <i>y</i> соответственно. Однако для эффекта
глубины поля нам нужно сдвигать объем видимости таким образом, чтобы он
оставался на плоскости фокуса. Плоскость фокуса – это величина глубины,
определяемая 9-ым (последним) аргументом <b>accPerspective()</b> (например <i>z</i>=5.0).
Количество размытия определяется умножением величин сдвига по <i>x</i>и <i>y</i>(7-го
и 8-го аргументов) на константу. Определение такой константы не представляет
сложности – экспериментируйте с ней до тех пор, пока изображение не будет иметь
тот вид, который вам нужен. (Обратите внимание на то, что в примере 10-6 4-ый и
5-ый аргументы <b>accPerspective()</b> установлены в 0.0. Таким образом,
сглаживание сцены не производится.)</p>

<p class=text align=left style='text-align:left'>Рисунок 10-5. Чайники с
эффектом глубины поля </p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1477" type="#_x0000_t75" alt="" style='width:462.75pt;height:127.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image339.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов10.mht!http://www.progz.ru/images/opengl/chapter10/10-5.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=617 height=170
src="OpenGL%20Red%20Book.files/image339.jpg" v:shapes="_x0000_i1477"><![endif]></p>

<p class=text align=left style='text-align:left'>Пример 10-6. Эффект глубины
поля: файл dof.cpp</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  style='color:black'>#include &lt;glut.h&gt;<o:p></o:p></span></pre><pre><span
  style='color:black'>#include &quot;jitter.h&quot;<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>#define ACSIZE 8<o:p></o:p></span></pre><pre><span
  style='color:black'>#define JIT j8<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>GLint teapotList;<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>void init()<o:p></o:p></span></pre><pre><span
  style='color:black'>{<o:p></o:p></span></pre><pre><span style='color:black'><span style='mso-spacerun:yes'>      </span>GLfloat ambient[]={0.0,0.0,0.0,1.0};<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>GLfloat diffuse[]={1.0,1.0,1.0,1.0};<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>GLfloat specular[]={1.0,1.0,1.0,1.0};<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>GLfloat position[]={0.0,3.0,3.0,0.0};<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>GLfloat lmodel_ambient[]={0.2,0.2,0.2,1.0};<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>GLfloat local_view[]={0.0};<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glLightfv(GL_LIGHT0,GL_AMBIENT,ambient);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glLightfv(GL_LIGHT0,GL_DIFFUSE,diffuse);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glLightfv(GL_LIGHT0,GL_POSITION,position);<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glLightModelfv(GL_LIGHT_MODEL_AMBIENT,lmodel_ambient);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glLightModelfv(GL_LIGHT_MODEL_LOCAL_VIEWER,local_view);<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glFrontFace(GL_CW);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glEnable(GL_LIGHTING);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glEnable(GL_LIGHT0);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glEnable(GL_AUTO_NORMAL);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glEnable(GL_NORMALIZE);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glEnable(GL_DEPTH_TEST);<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glClearColor(0.0,0.0,0.0,0.0);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glClearAccum(0.0,0.0,0.0,0.0);<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>teapotList=glGenLists(1);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glNewList(teapotList,GL_COMPILE);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glutSolidTeapot(0.5);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glEndList();<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre><pre><span style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>void renderTeapot(GLfloat x,GLfloat y,GLfloat z,<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>GLfloat ambr,GLfloat ambg,GLfloat ambb,<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>GLfloat difr,GLfloat difg,GLfloat difb,<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>GLfloat specr,GLfloat specg,GLfloat specb,<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>GLfloat shine)<o:p></o:p></span></pre><pre><span
  style='color:black'>{<o:p></o:p></span></pre><pre><span style='color:black'><span style='mso-spacerun:yes'>      </span>GLfloat mat[4];<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glPushMatrix();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glTranslatef(x,y,z);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>mat[0]=ambr;mat[1]=ambg;mat[2]=ambb;mat[3]=1.0;<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glMaterialfv(GL_FRONT,GL_AMBIENT,mat);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>mat[0]=difr;mat[1]=difg;mat[2]=difb;<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glMaterialfv(GL_FRONT,GL_DIFFUSE,mat);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>mat[0]=specr;mat[1]=specg;mat[2]=specb;<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glMaterialfv(GL_FRONT,GL_SPECULAR,mat);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glMaterialf(GL_FRONT,GL_SHININESS,shine);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glCallList(teapotList);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glPopMatrix();<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre><pre><span style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>void display()<o:p></o:p></span></pre><pre><span
  style='color:black'>{<o:p></o:p></span></pre><pre><span style='color:black'><span style='mso-spacerun:yes'>      </span>GLint viewport[4];<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>int jitter;<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glGetIntegerv(GL_VIEWPORT,viewport);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glClear(GL_ACCUM_BUFFER_BIT);<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>for (jitter=0;jitter&lt;ACSIZE;jitter++)<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>{<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>glPushMatrix();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>accPerspective(45.0,(GLdouble)viewport[2]/(GLdouble)viewport[3],<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                   </span><span style='mso-spacerun:yes'>        </span>1.0,15.0,0.0,0.0,<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                           </span>0.33*JIT[jitter].x,0.33*JIT[jitter].y,5.0);<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>//Рубиновый, золотой, серебряный, изумрудный и голубой чайники<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>renderTeapot(-1.1,-0.5,-4.5,<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                         </span>0.1745,0.01175,0.01175,<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                         </span>0.61424,0.04136,0.04136,<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                         </span>0.727811,0.626959,0.626959,<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                         </span>0.6);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>renderTeapot(-0.5,-0.5,-5.0,<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                         </span>0.24725,0.1995,0.0745,<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                         </span>0.75164,0.60648,0.22648,<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                         </span>0.628281,0.555802,0.366065,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                         </span>0.4);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>renderTeapot(0.2,-0.5,-5.5,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                         </span>0.19225,0.19225,0.19225,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                         </span>0.50754,0.50754,0.50754,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>        </span><span style='mso-spacerun:yes'>                 </span>0.508273,0.508273,0.508273,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                         </span>0.4);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>renderTeapot(1.0,-0.5,-6.0,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                         </span>0.0215,0.1745,0.0215,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                         </span>0.07568,0.61424,0.07568,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                         </span>0.633,0.727811,0.633,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                         </span>0.6);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>renderTeapot(1.8,-0.5,-6.5,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                         </span>0.0,1.0,0.06,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                         </span>0.0,0.50980392,0.50980392,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                         </span>0.50196078,0.50196078,0.50196078,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                         </span>0.25);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>glAccum(GL_ACCUM,0.125);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>glPopMatrix();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glAccum(GL_RETURN,1.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glFlush();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void reshape(int w,int h)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glViewport(0,0,(GLsizei)w,(GLsizei)h);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>int main(int argc, char **argv)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutInit(&amp;argc,argv);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB|GLUT_DEPTH|GLUT_ACCUM);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutInitWindowSize(620,620);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutInitWindowPosition(100,100);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutCreateWindow(&quot;Depth-of-Field Effect&quot;);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>init();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutDisplayFunc(display);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutReshapeFunc(reshape);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span></span><span
  style='color:black'>glutMainLoop();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>return 0;<span style='mso-spacerun:yes'>   </span><o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<h2>10.3.4 Мягкие тени</h2>

<p class=text align=left style='text-align:left'>Чтобы аккумулировать мягкие
тени, получающиеся от нескольких источников света, визуализируйте их с одним
включенным источником за раз и аккумулируйте вместе. Этот процесс можно
комбинировать с пространственным сдвигом для одновременного сглаживания сцены.</p>

<h2>10.3.5 Сдвиг</h2>

<p class=text align=left style='text-align:left'>Если вам нужно снять 9 или 16
кадров для сглаживания изображения, вы возможно решите, что лучшие решение –
это взять точки, распределенные по пикселю с равными промежутками. Удивительно,
но это не обязательно так. По правде говоря, иногда является хорошей идеей
взять точки на соседних пикселях. Иногда вам потребуется равномерное
распределение точек, а иногда – нормальное, уплотняющееся вблизи центра
пикселя. Кроме того, в таблице 10-5 приводится несколько наборов разумных
величин сдвига, которые могут использоваться в некоторых случаях. Все величины
в этой таблице лежат внутри пикселя, а большинство из них еще и равномерно
распределены.</p>

<p class=text align=left style='text-align:left'>Таблица 10-5. Примеры величин
сдвига</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Число</span></b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Величины</span></b><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1;height:19.5pt'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt;height:19.5pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>2<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt;height:19.5pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>[0.25,0.75],[0.75,0.25]<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2;height:27.0pt'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt;height:27.0pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>3<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt;height:27.0pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>[0.5033922635,0.8317967229],[0.7806016275,0.2504380877],
  [0.2261828938,0.4131553612]<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3;height:18.0pt'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt;height:18.0pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>4<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt;height:18.0pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>[0.375,0.25],[0.125,0.75],[0.875,0.25],[0.625,0.75]<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4;height:18.0pt'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt;height:18.0pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>5<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt;height:18.0pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>[0.5,0.5],[0.3,0.1],[0.7,0.9],[0.9,0.3],[0.1,0.7]<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:5;height:44.25pt'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt;height:44.25pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>6<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt;height:44.25pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>[0.4646464646,0.4646464646],[0.1313131313,0.7979797979],
  [0.5353535353,0.8686868686],<br>
  [0.8686868686,0.5353535353],
  [0.7979797979,0.1313131313],[0.2020202020,0.2020202020]<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:6;height:27.0pt'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt;height:27.0pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>8<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt;height:27.0pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>[0.5625,0.4375],[0.0625,0.9375],[0.3125,0.6875],[0.6875,0.8125],
  [0.8125,0.1875],<br>
  [0.9375,0.5625],[0.4275,0.0625],[0.1875,0.3125]<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:7;height:63.0pt'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt;height:63.0pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>9<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt;height:63.0pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>[0.5,0.5],[0.1666666666,0.9444444444],
  [0.5,0.1666666666],[0.5,0.8333333333],<br>
  [0.1666666666,0.2777777777],[0.8333333333,0.3888888888],
  [0.1666666666,0.6111111111],<br>
  [0.8333333333,0.7222222222], [0.8333333333,0.0555555555]<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:8;height:54.0pt'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt;height:54.0pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>12<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt;height:54.0pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>[0.4166666666,0.625],[0.9166666666,0.875],[0.25,0.375],
  [0.4166666666,0.125],[0.75,0.125],<br>
  [0.0833333333,0.125], [0.75,0.625],[0.25,0.875],[0.5833333333,0.375],
  [0.9166666666,0.375],<br>
  [0.0833333333,0.625],[0.5833333333,0.875]<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:9;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>16<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>[0.375,0.4375],[0.625,0.0625],[0.875,0.1875],[0.125,0.0625],
  [0.375,0.6875],[0.875,0.4375],<br>
  [0.625,0.5625],[0.375,0.9375],
  [0.625,0.3125],[0.125,0.5625],[0.125,0.8125],[0.375,0.1875],<br>
  [0.875,0.9375],[0.875,0.6875],[0.125,0.3125],[0.625,0.8125]<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:Verdana;
mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><a name=Глава11><span style='display:none;mso-hide:all'><o:p>&nbsp;</o:p></span></a></p>

<h1 align=left style='text-align:left'><span style='mso-bookmark:Глава11'>Глава
11. Тесселяция и квадрические поверхности</span></h1>

<span style='mso-bookmark:Глава11'></span>

<p class=MsoNormal><a href="mailto:ahinar@list.ru"></a><span style='font-size:
10.0pt;font-family:Verdana'>Библиотека OpenGL (GL) разработана для
низкоуровневых операций, одновременно являющихся конвейерными и имеющими доступ
к аппаратному ускорению. Библиотека утилит OpenGL (GLU) дополняет OpenGL,
предоставляя высокоуровневые операции. Некоторые из операций GLU (такие как
мипмаппинг функцией <b>gluBuild*DMipmaps()</b>, масштабирование изображений
функцией <b>gluScaleImage()</b>, операции матричных преобразований функциями <b>gluOrtho2D()</b>,
<b>gluPerspective()</b>, <b>gluLookAt()</b>, <b>gluProject()</b>, <b>gluUnProject()</b>
и <b>gluUnProject4()</b>) рассматриваются в других главах. Некоторые будут
рассмотрены далее.<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Для оптимизации
быстродействия, ядро OpenGL визуализирует только выпуклые полигоны, однако GLU
содержит функции для тесселяции (разбиения) вогнутых полигонов на выпуклые,
которые могут обрабатываться OpenGL. Там, где OpenGL оперирует простыми
примитивами, такими как точки, линии и закрашенные полигоны, GLU может
создавать объекты более высокого уровня, такие, как поверхности сфер, цилиндры
или конусы.</p>

<h2>11.1&nbsp;Тесселяция полигонов</h2>

<p class=text align=left style='text-align:left'>OpenGL может непосредственно
отображать только простые выпуклые полигоны. Полигон является простым, если его
ребра пересекаются только в вершинах, если в каждой точке находится только одна
вершина, и в каждой вершине соединяются только два ребра. Если вашему
приложению требуется отображение вогнутых полигонов, полигонов с дырами или
полигонов с пересекающимися ребрами, такие полигоны должны быть предварительно
разделены на простые выпуклые полигоны до того, как их можно будет отобразить.
Такое разбиение называется <i>тесселяцией</i>, и GLU предоставляет ряд функций
для осуществления тесселяции. Эти функции принимают информацию о контурах,
описывающих трудный для отображения полигон, в качестве аргумента и возвращают
комбинацию треугольников, фигур из треугольников, треугольных вееров или линий.</p>

<p class=text align=left style='text-align:left'>На рисунке 11-1 показаны
контуры нескольких полигонов, нуждающихся в тесселяции: слева – направо
показаны вогнутый полигон, полигон с дырой и полигон с пересекающимися ребрами.</p>

<p class=text align=left style='text-align:left'>Рисунок 11-1. Контуры,
нуждающиеся в тесселяции </p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1478" type="#_x0000_t75" alt="" style='width:465pt;height:142.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image340.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов11.mht!http://www.progz.ru/images/opengl/chapter11/11-1.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=620 height=190
src="OpenGL%20Red%20Book.files/image340.jpg" v:shapes="_x0000_i1478"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Если вы считаете, что полигон
нуждается в тесселяции, выполните следующие шаги:</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l47 level1 lfo47;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>1.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Создайте новый объект тесселяции с помощью
функции <b>gluNewTess()</b>. </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l47 level1 lfo47;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>2.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Несколько раз используйте <b>gluTessCallback()</b>
для регистрации функций обратного вызова, производящих операции во время
тесселяции. Самый сложный случай при работе с возвратно-вызываемыми функция
возникает, когда алгоритм тесселяции обнаруживает пересечение и должен вызвать
функцию, зарегистрированную для события GLU_TESS_COMBINE. </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l47 level1 lfo47;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>3.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Задайте свойства тесселяции с помощью функции <b>gluTessProperty()</b>.
Наиболее важным свойством является правило оборота, определяющее какие регионы
должны быть закрашены, а какие – остаться незакрашенными. </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l47 level1 lfo47;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>4.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Создайте и визуализируйте тесселированные
полигоны, задав контуры одного или более закрытых полигонов. Если данные
объекта являются статическими, инкапсулируйте тесселированные полигоны в списке
отображения. (Если вам не нужно пересчитывать тесселяцию снова и снова,
использование списков отображения более эффективно.) </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l47 level1 lfo47;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>5.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Если вам требуется тесселировать что-либо еще,
вы можете использовать существующий объект тесселяции. Если вы закончили с
тесселяцией, вы можете удалить объект функцией <b>gluDeleteTess()</b>. </p>

<p class=warning>Замечание: Тесселяция, описанная здесь, появилась в GLU версии
1.2. Если у вас более старая версия GLU, вы должны использовать функции,
описанные в разделе «Описание ошибок GLU». Чтобы запросить версию используемой
GLU, используйте функцию <b>gluGetString(GLU_VERSION)</b>, которая возвращает
строку с номером версии GLU. Если в вашей GLU нет функции <b>gluGetString()</b>,
значит это GLU версии 1.0 – в этой версии такая функция отсутствует.</p>

<h2>11.1.1 Создание объекта тесселяции</h2>

<p class=text align=left style='text-align:left'>Во время описания и тесселяции
сложного полигона с ним ассоциируются некоторые данные, например, вершины,
ребра и функции обратного вызова. Для выполнения тесселяции, ваша программа
сначала должна создать объект тесселяции с помощью функции <b>gluNewTess()</b>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>GLUtesselator* <b>gluNewTess</b>
  (void);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Создает новый объект
тесселяции и возвращает указатель на него. Если создать объект не удается,
возвращается нулевой указатель.</p>

<p class=text align=left style='text-align:left'>Для всех тесселяций может использоваться
один и тот же объект. Сам объект необходим исключительно потому, что функциям
библиотеки могут потребоваться собственные тесселяции, и они должны иметь
возможность выполнять их, не вмешиваясь в какие-либо тесселяции, выполняемые
вашей программой. Несколько объектов полезно иметь также и в случае, если вы
используете разные наборы возвратно вызываемых функций для разных тесселяций.
Однако типичная программа создает только один объект и использует его для всех
тесселяций. Освобождать объект, в общем-то, не имеет смысла, так как он требует
очень небольшого объема памяти. С другой стороны, аккуратность еще никому не
вредила.</p>

<h2>11.1.2 Возвратно-вызываемые функции тесселяции</h2>

<p class=text align=left style='text-align:left'>После того, как вы создали
объект тесселяции, вы должны предоставить серию возвратно-вызываемых функций,
которые будут вызываться в определенные моменты во время тесселяции. После
определения этих функций, вы задаете контуры одного или нескольких полигонов с
использованием функций GLU. После передачи описания контуров, механизм тесселяции
вызывает ваши функции по необходимости.</p>

<p class=text align=left style='text-align:left'>Любые опущенные
возвратно-вызываемые функции просто не вызываются в процессе тесселяции, и
любая информация, которую они могут возвращать в вашу программу будет потеряна.
Все возвратные функции задаются с помощью <b>gluTessCallback()</b>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>gluTessCallback</b>
  (GLUtesselator *<i>tessobj</i>, GLenum <i>type</i>, void (*<i>fn</i>)());<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Ассоциирует
возвратно-вызываемую функцию <i>fn</i> с объектом тесселяции <i>tessobj</i>.
Тип возвратной функции определяется аргументом <i>type</i>, который может быть
равен GLU_TESS_BEGIN, GLU_TESS_BEGIN_DATA, GLU_TESS_EDGE_FLAG,
GLU_TESS_EDGE_FLAG_DATA, GLU_TESS_VERTEX, GLU_TESS_VERTEX_DATA, GLU_TESS_END,
GLU_TESS_END_DATA, GLU_TESS_COMBINE, GLU_TESS_COMBINE_DATA, GLU_TESS_ERROR или
GLU_TESS_ERROR_DATA. 12 возможных возвратно-вызываемых функций имеют следующие
прототипы:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLU_TESS_BEGIN<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>void <b>begin</b> (GLenum <i>type</i>);<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLU_TESS_BEGIN_DATA<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>void <b>begin</b> (GLenum <i>type</i>,
  void* <i>user_data</i>);<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLU_TESS_EDGE_FLAG<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>void <b>edgeFlag</b> (GLboolean <i>flag</i>);<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GLU_TESS_EDGE_FLAG_DATA<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>void <b>edgeFlag</b> (GLboolean <i>flag</i>,
  void* <i>user_data</i>);<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLU_TESS_VERTEX<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>void <b>vertex</b> (void* <i>vertex_data</i>);<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:5'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLU_TESS_VERTEX_DATA<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>void <b>vertex</b> (void* <i>vertex_data</i>,
  void* <i>user_data</i>);<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:6'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLU_TESS_END<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>void <b>end</b> (void);<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:7'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLU_TESS_END_DATA<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>void <b>end</b> (void* <i>user_data</i>);<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:8'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLU_TESS_COMBINE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>void <b>combine</b> (GLdouble <i>coords[3]</i>,
  void* <i>vertex_data[4]</i>, GLfloat <i>weight[4]</i>,&nbsp;void** <i>outData</i>);<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:9'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLU_TESS_COMBINE_DATA<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>void <b>combine</b> (GLdouble <i>coords[3]</i>,
  void* <i>vertex_data[4]</i>, GLfloat <i>weight[4]</i>, void** <i>outData</i>,
  void* <i>user_data</i>);<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:10'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLU_TESS_ERROR<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>void <b>error</b> (GLenum <i>errno</i>);<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:11;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLU_TESS_ERROR_DATA<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>void <b>error</b> (GLenum <i>errno</i>,
  void* <i>user_data</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>&nbsp;</span>Чтобы изменить
возвратно-вызываемую функцию, просто вызовите <b>gluTessCallback()</b> с
адресом новой функции. Чтобы устранить возвратную функцию без замещения ее
новой, передайте <b>gluTessCallback()</b> нулевой указатель для
соответствующего типа функции.</p>

<p class=text align=left style='text-align:left'>В течение тесселяции,
возвратные функции вызываются в манере, похожей на ту, в которой вы используете
команды OpenGL <b>glBegin()</b>, <b>glEdgeFlag*()</b>, <b>glVertex*()</b> и <b>glEnd()</b>.
Функция комбинирования (combine) используется для создания новых вершин в
точках пересечения ребер. Функция ошибок (error) вызывается в процессе
тесселяции только тогда, когда что-то идет не так, как должно.</p>

<p class=text align=left style='text-align:left'>Для каждого созданного объекта
тесселяции функция GLU_TESS_BEGIN вызывается с одним из 4 возможных параметров:
GL_TRIANGLE_FAN, GL_TRIANGLE_STRIP, GL_TRIANGLES или GL_LINE_LOOP. Когда
тесселятор декомпозирует (разбивает) полигоны, алгоритм тесселяции решает,
какой тип треугольного примитива более эффективен для использования. (Если
активизировано свойство GLU_TESS_BOUNDARY_ONLY, для визуализации используется
GL_LINE_LOOP.)</p>

<p class=text align=left style='text-align:left'>Поскольку флаг ребра не имеет
смысла в случаях GL_TRIANGLE_FAN или GL_TRIANGLE_STRIP, то, если существует
заданная возвратная функция GLU_TESS_EDGE_FLAG, активизирующая флаги ребра,
функция GLU_TESS_BEGIN вызывается только с аргументом GL_TRIANGLES. Функция
GLU_TESS_EDGE_FLAG работает абсолютно аналогично вызову команды OpenGL <b>glEdgeFlag*()</b>.</p>

<p class=text align=left style='text-align:left'>После вызова функции,
ассоциированной с GLU_TESS_BEGIN и до вызова функции, ассоциированной с
GLU_TESS_END, вызывается некоторая комбинация функций GLU_TESS_VERTEX и
GLU_TESS_EDGE_FLAG (обычно из-за обращений к функции <b>gluTessVertex()</b>).
Ассоциированные флаги ребра и вершины интерпретируются точно таким же образом,
как если бы они задавались между командами OpenGL <b>glBegin()</b> и <b>glEnd()</b>.</p>

<p class=text align=left style='text-align:left'>Если что-то идет не так,
возвратной функции ошибки передается номер ошибки GLU. Символьная строка,
описывающая ошибку, извлекается с использованием функции <b>gluErrorString()</b>.</p>

<p class=text align=left style='text-align:left'>Пример 11-1 демонстрирует
часть кода файла tess.cpp, в котором создается объект тесселяции и
регистрируется несколько функций обратного вызова.</p>

<p class=text align=left style='text-align:left'>Пример 11-1. Регистрация
возвратных функций тесселяции: файл tess.cpp</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#ifndef CALLBACK<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#define CALLBACK<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#endif<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>/* </span><span
  style='color:black'>часть</span><span style='color:black;mso-ansi-language:
  EN-US'> </span><span style='color:black'>функции</span><span lang=EN-US
  style='color:black;mso-ansi-language:EN-US'> init() */<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>tobj=gluNewTess();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>gluTessCallback(tobj,GLU_TESS_VERTEX,glVertex3dv);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>gluTessCallback(tobj,GLU_TESS_BEGIN,beginCallback);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>gluTessCallback(tobj,GLU_TESS_END,endCallback);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>gluTessCallback(tobj,GLU_TESS_ERROR,errorCallback);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>/* возвратно вызываемые функции, зарегистрированные с помощью gluTessCallback() */<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void CALLBACK beginCallback(GLenum which)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glBegin(which);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void CALLBACK endCallback(void)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glEnd();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void CALLBACK errorCallback(GLenum errorCode)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>const GLubyte *estring;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>estring=gluErrorString(errorCode);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>fprintf(stderr, &quot;Tesselation error: %s\n&quot;,estring);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span></span><span
  style='color:black'>exit(0);<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<p class=warning>Замечание: Приведение типов возвратно вызываемых функций
довольно сложно, особенно, если вы хотите создать код, который будет одинаково
работать на платформах Microsoft Windows (95/98/NT) и UNIX. Чтобы верно
работать на платформах Microsoft Windows, программам, использующим
возвратно-вызываемые функции, таким как tess.cpp требуется наличие символа
CALLBACK в объявлении функции. Трюк с использованием пустого определения для
CALLBACK (как показано ниже) позволяет коду запускаться как на Microsoft
Windows, так и в UNIX.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#ifndef CALLBACK<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#define CALLBACK<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#endif<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void CALLBACK callbackFunction(..)<o:p></o:p></span></pre><pre><span
  style='color:black'>{<o:p></o:p></span></pre><pre><span style='color:black'>}<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>В примере 11-1,
зарегистрированная функция для GLU_TESS_VERTEX, представляет собой просто
команду <b>glVertex3dv()</b>, в которую передаются только координаты каждой
вершины. Однако, если вы желаете задавать больше информации в каждой вершине,
например, цветовые величины, вектор нормали или координаты текстуры, вам
следует создать более сложную функцию обратного вызова. Пример 11-2
демонстрирует начало другого тесселируемого объекта далее в программе tess.cpp.
Зарегистрированная функция <b>vertexCallback()</b> ожидает параметра,
являющегося указателем на 6 чисел с плавающей точкой двойной точности:
координаты <i>x</i>, <i>y</i> и <i>z</i>, а также значения цветовых компонент
красного, зеленого и синего для каждой вершины.</p>

<p class=text align=left style='text-align:left'>Пример 11-2.
Возвратно-вызываемые функции GLU_TESS_VERTEX и GLU_TESS_COMBINE</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  style='color:black'>/* другая часть функции init() */<o:p></o:p></span></pre><pre><span
  style='color:black'>gluTessCallback(tobj,GLU_TESS_VERTEX,vertexCallback);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>gluTessCallback(tobj,GLU_TESS_BEGIN,beginCallback);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>gluTessCallback(tobj,GLU_TESS_END,endCallback);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>gluTessCallback(tobj,GLU_TESS_ERROR,errorCallback);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>gluTessCallback(tobj,GLU_TESS_COMBINE,combineCallback);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>/* </span><span
  style='color:black'>новые</span><span style='color:black;mso-ansi-language:
  EN-US'> </span><span style='color:black'>возвратно</span><span lang=EN-US
  style='color:black;mso-ansi-language:EN-US'>-</span><span style='color:black'>вызываемые</span><span
  style='color:black;mso-ansi-language:EN-US'> </span><span style='color:black'>функции</span><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'> */<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void CALLBACK vertexCallback(GLvoid* vertex)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>const GLdouble* pointer;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>pointer=(GLdouble*)vertex;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glColor3dv(pointer+3);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glVertex3dv(vertex);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void CALLBACK combineCallback(GLdouble coords[3], <o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>             </span><span style='mso-spacerun:yes'>                 </span>GLdouble* vertex_data[4],<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                              </span>GLfloat weight[4], GLdouble** dataOut)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>GLdouble *vertex;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>int i;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>vertex=(GLdouble*) malloc(6*sizeof(GLdouble));<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>vertex[0]=coords[0];<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>vertex[1]=coords[1];<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>vertex[2]=coords[2];<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>for(i=3;i&lt;6;i++)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>vertex[i]=weight[0]*vertex_data[0][i]+<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                      </span>weight[1]*vertex_data[1][i]+<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                      </span>weight[2]*vertex_data[2][i]+<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                      </span>weight[3]*vertex_data[3][i];<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>*dataOut=vertex;<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Пример 11-2 также
демонстрирует использование функции GLU_TESS_CALLBACK. Каждый раз, когда
алгоритм тесселяции, анализирующий входящий контур, обнаруживает пересечение и
решает, что должна быть создана новая вершина, вызывается функция обратного
вызова зарегистрированная для GLU_TESS_COMBINE. Эта функция также вызывается в
случае, если алгоритм решает объединить две вершины, которые очень близки друг
к другу. Новая вершина является линейной комбинацией до четырех существующих вершин,
на которые в примере 11-2 ссылаются как на <i>vertex_data[0..3]</i>.
Коэффициенты линейной комбинации передаются в <i>weight[0..3]</i> (чья сумма
составляет <i>1.0</i>). Аргумент <i>coords</i> задает положение новой вершины.</p>

<p class=text align=left style='text-align:left'>Зарегистрированная функция
обратного вызова должна зарезервировать память для новой вершины, произвести
взвешенную интерполяцию данных с использованием <i>vertex_data</i> и <i>weight</i>
и возвратить указатель на новую вершину в аргументе <i>data_out</i>. <b>combineCallback()</b>
в примере 11-2 интерполирует цветовую величину. Функция резервирует массив из
6-ти элементов, помещает <i>x</i>, <i>y</i> и <i>z</i> в первые три элемента, а
взвешенное среднее цветовых величин RGB в следующие три элемента.</p>

<h2>11.1.2.1 Данные, определенные пользователем</h2>

<p class=text align=left style='text-align:left'>Может быть зарегистрировано
шесть типов возвратно-вызываемых функций. Поскольку существует два варианта
каждой возвратной функции, существует всего 12 функций. Для каждой функции
существует один вариант с данными, определенными пользователем, и один вариант
без них. Данные, определенные пользователем передаются приложением в функцию <b>gluTessBeginPolygon()</b>,&nbsp;
а затем без изменений передаются всем возвратным функциям *DATA. С функцией
GLU_TESS_BEGIN_DATA данные, определенные пользователем могут использоваться в
качестве данных для одного полигона. Если для определенного типа возвратно-вызываемой
функции вы зададите оба варианта, будет использоваться вариант с аргументом <i>user_data</i>.
Таким образом, несмотря на то, что существует 12 возвратных функций, в каждый
момент времени активными могут быть только 6.</p>

<p class=text align=left style='text-align:left'>Например, в примере 11-2 используется
плавная закраска, и <b>vertexCallback()</b> задает RGB цвет для каждой вершины.
Если вы хотите использовать плавную заливку и освещение, функция обратного
вызова должна задавать вектор нормали для каждой вершины. Однако, если вы
хотите использовать освещение и плоскую закраску, вы можете задать только одни
вектор нормали для каждого полигона, а не для каждой вершины. В таком случае вы
можете использовать функцию GLU_TESS_BEGIN_DATA и передать координаты вершины и
нормаль к поверхности в аргументе <i>user_data</i>.</p>

<h2>11.1.3&nbsp;Свойства тесселяции</h2>

<p class=text align=left style='text-align:left'>Перед тесселяцией и
визуализацией вы можете использовать функцию <b>gluTessProperty()</b> для
настройки некоторых свойств, влияющих на алгоритм тесселяции. Наиболее важное и
сложное из этих свойств – правило оборота, определяющее, что считается
«внутренним», а что «внешним».</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>gluTessProperty</b>
  (GLUtesselator* <i>tessobj</i>, GLenum <i>property</i>, GLdouble <i>value</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Значение свойства property
объекта тесселяции <i>tessobj </i>устанавливается в значение value. Аргумент<span
style='mso-ansi-language:EN-US'> <i><span lang=EN-US>property </span></i></span>может<span
style='mso-ansi-language:EN-US'> </span>принимать<span style='mso-ansi-language:
EN-US'> </span>значения<span lang=EN-US style='mso-ansi-language:EN-US'>
GLU_TESS_BOUNDARY_ONLY, GLU_TESS_TOLERANCE </span>или<span lang=EN-US
style='mso-ansi-language:EN-US'> GLU_TESS_WINDING_RULE. </span>Если<span
style='mso-ansi-language:EN-US'> <i><span lang=EN-US>property </span></i></span>равно<span
lang=EN-US style='mso-ansi-language:EN-US'> GLU_TESS_BOUNDARY_ONLY, <i>value </i></span>может<span
style='mso-ansi-language:EN-US'> </span>принимать<span style='mso-ansi-language:
EN-US'> </span>значения<span lang=EN-US style='mso-ansi-language:EN-US'>
GL_TRUE </span>или<span lang=EN-US style='mso-ansi-language:EN-US'> GL_FALSE. </span>Если
оно равно GL_TRUE полигоны не тесселируются на закрашенные полигоны – рисуются
только замкнутые ломаные, показывающие границу контуров, разделяющих интерьер и
экстерьер полигона. Значение по умолчанию – GL_FALSE. (Смотрите описание <b>gluTessNormal()</b>
для понимания того, как управлять направлением перекрытия контуров.) Если <i>property</i>
равно GLU_TESS_TOLERANCE, <i>value</i> представляет собой дистанцию,
используемую при вычислении того, являются ли две вершины близкими в
достаточной степени, чтобы их можно было объединить с помощью возвратной
функции GLU_TESS_COMBINE. Величина толерантности умножается на максимальную
разницу в координатах входящих вершин для определения максимальной дистанции,
на которую может сместиться какой-либо фрагмент вследствие одной операции
совмещения. Совмещение может не поддерживаться вашей реализацией OpenGL, а
величина толерантности (терпимости) имеет только рекомендательный характер.
Величина толерантности имеет нулевое значение по умолчанию. Свойство
GLU_TESS_WINDING_RULE определяет, какие части полигона находятся внутри, а
какие снаружи и не должны быть закрашены. <i>value</i> может принимать значения
GLU_TESS_WINDING_ODD (значение по умолчанию), GLU_TESS_WINDING_NONZERO,
GLU_TESS_WINDING_POSITIVE, GLU_TESS_WINDING_NEGATIVE или
GLU_TESS_WINDING_ABS_GEQ_TWO.</p>

<h2>11.1.3.1 Число оборотов и правило оборота</h2>

<p class=text align=left style='text-align:left'>Для отдельного контура, число
оборотов точки представляет собой знаковое целое число полных оборотов, которые
мы совершаем вокруг этой точки, проходя вдоль контура (обороты против часовой
стрелки добавляют 1 к этому числу, а обороты по часовой стрелке вычитают 1) .
Когда существует несколько контуров, индивидуальные числа оборотов суммируются.
Данная процедура ассоциирует знаковое число со знаком с каждой точкой
плоскости. Отметьте, что число оборотов является одним и тем же для всех точек
одной ограниченной области.</p>

<p class=text align=left style='text-align:left'>На рисунке 11-2 показано три
набора контуров и числа оборотов для точек внутри контуров. В наборе слева все
три контура идут против часовой стрелки, так что каждый контур добавляет
единицу к числам оборотов точек, находящихся внутри него. В наборе посередине
два внутренних контура имеют направление по часовой стрелке, так что число
оборотов уменьшается и в итоге становится меньше 0.</p>

<p class=text align=left style='text-align:left'>Рисунок 11-2. Числа оборотов
для простых контуров </p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1479" type="#_x0000_t75" alt="" style='width:465pt;height:144.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image341.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов11.mht!http://www.progz.ru/images/opengl/chapter11/11-2.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=620 height=193
src="OpenGL%20Red%20Book.files/image341.jpg" v:shapes="_x0000_i1479"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Правило оборота классифицирует
регион, как внутренний, если его число оборотов принадлежит к определенной
категории (odd – нечетное, nonzero – ненулевое, positive – положительное,
negative – отрицательное или abs – «абсолютная величина больше или равная 2»).
Правила&nbsp; GLU_TESS_WINDING_ODD и GLU_TESS_WINDING_NONZERO часто
используются для определения интерьера. Правила позитивное, негативное и
«абсолютная величина» имеют ограниченное применение при выполнении операций над
CSG (computational solid geometry – плоская вычисляемая геометрия).</p>

<p class=text align=left style='text-align:left'>Рисунок 11-3 демонстрирует
влияние различных правил оборота на визуализацию контуров. Темные области на
рисунке являются внутренними.</p>

<p class=text align=left style='text-align:left'>Рисунок 11-3. Как правила
оборота определяют интерьер </p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1480" type="#_x0000_t75" alt="" style='width:465pt;height:654pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image342.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов11.mht!http://www.progz.ru/images/opengl/chapter11/11-3.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=620 height=872
src="OpenGL%20Red%20Book.files/image342.jpg" v:shapes="_x0000_i1480"><![endif]></p>

<h2>11.1.3.2 Использование правил оборота с CSG</h2>

<p class=text align=left style='text-align:left'>Правила оборота GLU_TESS_WINDING_ODD
и GLU_TESS_WINDING_NONZERO являются наиболее часто используемыми. Они работают
в большинстве типичных случаев заливки.</p>

<p class=text align=left style='text-align:left'>Правила оборота были
разработаны и для операций с CSG и позволяют легко находить объединение,
разницу или пересечение (Булевские операции) нескольких контуров.</p>

<p class=text align=left style='text-align:left'>Вначале предположим, что
каждый контур определен таким образом, что число оборотов для каждого внешнего
региона равно 0, а для каждого внутреннего – 1. (То есть ни один из контуров не
пересекает сам себя.) Далее считаем, что контуры, проходящие против часовой
стрелки, обозначают границы полигонов, а контуры, идущие по часовой стрелке, –
дыры. Контуры могут быть вложенными, но внутренний контур должен иметь
направление противоположное направлению содержащего его контура.</p>

<p class=text align=left style='text-align:left'>Если изначальные полигоны не
удовлетворяют данным условиям, их можно привести к ним, выполним
предварительную тесселяцию с активизированным параметром
GLU_TESS_BOUNDARY_ONLY. Эта тесселяция возвратит список полигонов,
удовлетворяющих описанным ограничениям. Если создать два объекта тесселяции, то
возвратные функции первого из них могут направлять информацию непосредственно
на вход второго.</p>

<p class=text align=left style='text-align:left'>При наличии двух или более
полигонов в описанной форме, операции CSG могут быть реализованы следующим
образом:</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l40 level1 lfo48;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>UNION (объединение) – чтобы вычислить
объединение нескольких контуров, нарисуйте все входящие контуры в виде одного
полигона. Число оборотов каждой результирующей области – это сумма чисел
оборотов входящих полигонов, которые ее покрывают. Объединение может быть
получено с помощью правил GLU_TESS_WINDING_NONZERO или
GLU_TESS_WINDING_POSITIVE. Заметьте, что в случае ненулевого правила, мы
получим тот же результат, даже если обратим направление всех контуров. </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l40 level1 lfo48;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>INTERSECTION (пересечение) – его можно получить
только для двух контуров за один раз. Нарисуйте один полигон с использованием
двух контуров. Результат получается с помощью правила
GLU_TESS_WINDING_ABS_GEQ_TWO. </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l40 level1 lfo48;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>DIFFERENCE (разница) – предположим, что вы
хотите вычислить A diff (B union C union D). Нарисуйте единственный полигон,
состоящий из неизмененного контура A, за которым следуют контуры B, C и D с
обратным порядком вершин. Для получения результата используйте правило
GL_TESS_WINDING_POSITIVE. (Если B, C и D являются результатом операции
GLU_TESS_BOUNDARY_ONLY, то можно не изменять порядок вершин, а воспользоваться
функцией <b>gluTessNormal()</b> для изменения знака поставляемой нормали.) </p>

<h2>11.1.3.3 Другие функции для работы со свойствами тесселяции</h2>

<p class=text align=left style='text-align:left'>Существует две функции,
работающие совместно с <b>gluTessProperty()</b>. <b>gluTessGetProperty()</b>
позволяет получать текущие значения свойств тесселяции. Если тесселятор
используется для генерирования проволочных каркасов, а не закрашенных
полигонов, функция <b>gluTessNormal()</b> позволяет определить направление
оборота для тесселируемых полигонов.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>gluTessGetProperty</b>
  (GLUtesselator* <i>tessobj</i>, GLenum <i>property</i>, GLdouble* <i>value</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Возвращает текущее значение
свойства <i>property </i>объекта тесселяции <i>tessobj </i>в переменной <i>value</i>.
Возможные значения для аргументов <i>property </i>и <i>value </i>те же самые,
что и в функции <b>gluTessGetProperty()</b>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>gluTessNormal</b>
  (GLUtesselator* <i>tessobj</i>, GLdouble <i>x</i>, GLdouble <i>y</i>,
  GLdouble <i>z</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Задает вектор нормали для
объекта тесселяции <i>tessobj</i>. Вектор нормали задает направление оборота
для генерируемых полигонов. Перед тесселяцией все входные данные проецируются
на плоскость перпендикулярную вектору нормали. После все результирующие
треугольники ориентируются против часовой стрелки с учетом нормали.
(Направление по часовой стрелке может быть получено путем изменения знака задаваемой
нормали.) Вектор нормали по умолчанию – (<i>0</i>, <i>0</i>, <i>0</i>).</p>

<p class=text align=left style='text-align:left'>Если у вас есть данные о
положении и ориентации входных данных, использование <b>gluTessNormal()</b>
может увеличить скорость тесселяции. Например, если вы знаете, что все полигоны
лежат в плоскости <i>xy</i>, вызовите <b>gluTessNormal(</b><i>tessobj</i>,<i>0</i>,<i>0</i>,<i>1</i><b>)</b>.</p>

<p class=text align=left style='text-align:left'>Вектор нормали по умолчанию (<i>0</i>,
<i>0</i>, <i>0</i>), и его влияние не всегда очевидны. В подобном случае
ожидается, что все входные данные лежат примерно в одной плоскости и плоскость
охватывает все вершины независимо от того, как они на самом деле соединены.
Знак нормали выбирается таким образом, чтобы сумма всех знаковых областей всех
входных контуров была неотрицательной (там, где контур против часовой стрелки
окружает положительную область). Заметьте, что если входные данные не лежат
примерно в одной плоскости, проецирование перпендикулярно вычисленной нормали
может существенно изменить геометрию.</p>

<h2>11.1.4 Определение полигона</h2>

<p class=text align=left style='text-align:left'>После того, как установлены
все свойства тесселяции и зарегистрированы все функции обратного вызова, наступает
время описывать вершины, составляющие входящие контуры, и тесселировать
полигоны.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>gluTessBeginPolygon </b>(GLUtesselator*
  <i>tessobj</i>, void* <i>user_data</i>);<br>
  void <b>gluTessEndPolygon </b>(GLUtesselator* <i>tessobj</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Открывают и завершают
спецификацию полигона, который нужно тесселировать и ассоциируют с ним объект
тесселяции <i>tessobj</i>. <i>user_data</i> указывает на данные определяемые
пользователем, которые передаются всем связанным возвратным функциям
GLU_TESS_*_DATA.</p>

<p class=text align=left style='text-align:left'>Вызовы <b>gluTessBeginPolygon()</b>
и <b>gluTessEndPolygon()</b> обрамляют определение одного или более контуров.
Когда вызывается <b>gluTessEndPolygon()</b>, выполняется алгоритм тесселяции,
генерируются и визуализируются тесселированные полигоны. В течение этого
алгоритма используются связанные функции обратного вызова и установленные
свойства тесселяции.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>gluTessBeginContour </b>(GLUtesselator*
  <i>tessobj</i>);<br>
  void <b>gluTessEndContour </b>(GLUtesselator* <i>tessobj</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Открывают и завершают
спецификацию замкнутого контура, являющегося частью полигона. Замкнутый контур
определяется нулем или более обращениями к функции <b>gluTessVertex()</b>,
задающей вершину. Последняя вершина каждого контура автоматически соединяется с
первой.</p>

<p class=text align=left style='text-align:left'>На практике для осмысленного
контура требуется как минимум 3 вершины.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>gluTessVertex</b>
  (GLUtesselator* <i>tessobj</i>, GLdouble <i>coords[3]</i>, void* <i>vertex_data</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Задает одну вершину в текущем
контуре для объекта тесселяции <i>tessobj</i>. <i>coords</i> содержит
трехмерные координаты вершины, а <i>vertex_data</i> – это указатель, отсылаемые
функции обратного вызова GLU_TESS_VERTEX или GLU_TESS_VERTEX_DATA. Обычно, <i>vertex_data</i>
содержит координаты вершины, нормали к поверхности, координаты текстуры,
информацию о цвете или что-либо другое, нужное приложению.</p>

<p class=text align=left style='text-align:left'>В программе tess.cpp, часть
которой приводится в примере 11-3, определяются два полигона. Первый полигон
состоит из прямоугольного контура с треугольной дырой внутри, а второй
представляет собой плавно закрашенную самопересекающуюся пятиконечную звезду.
Для большей эффективности оба полигона сохраняются в списке отображения. Первый
полигон состоит из двух контуров, причем внешний ориентирован против часовой
стрелки, а внутренний («дыра») – по часовой стрелке. Для второго полигона
массив <i>star</i> содержит и координаты вершин и информацию о цвете, и функция
обратного вызова <b>vertexCallback()</b> использует и то, и другое. Результат
работы программы tess.cpp изображен на рисунке 11-4.</p>

<p class=text align=left style='text-align:left'>Рисунок 11-4. Результат работы
тесселятора </p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1481" type="#_x0000_t75" alt="" style='width:407.25pt;height:180.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image343.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов11.mht!http://www.progz.ru/images/opengl/chapter11/11-4.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=543 height=241
src="OpenGL%20Red%20Book.files/image343.jpg" v:shapes="_x0000_i1481"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Важно, чтобы каждая вершина
находилась в своей области памяти, так как вершинные данные не копируются
функцией <b>gluTessVertex()</b> – сохраняется только указатель (<i>vertex_data</i>).
Программа, которая использует одну и ту же память для нескольких вершин, может
не получить ожидаемого результата.</p>

<p class=text align=left style='text-align:left'>Замечание: Может показаться,
что в функции <b>gluTessVertex()</b> бессмысленно задавать координаты вершин
дважды – в аргументах <i>coords</i> и <i>vertex_data</i>. Однако иногда это
необходимо – <i>coords</i> ссылается только на координаты вершины, а <i>vertex_data</i>
также хранит координаты, но может содержать и другую информацию для каждой
вершины.</p>

<p class=text align=left style='text-align:left'>Пример 11-3. Определение
полигона: файл tess.cpp</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  style='color:black'>GLdouble rect[4][3]= { 50.0, 50.0, 0.0,<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                       </span>200.0,50.0,0.0,<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                      </span><span style='mso-spacerun:yes'> </span>200.0,200.0,0.0,<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                       </span>50.0,200.0,0.0 };<o:p></o:p></span></pre><pre><span
  style='color:black'>GLdouble tri[3][3]={ 75.0,75.0,0.0,<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                     </span>125.0,175.0,0.0,<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                     </span>175.0,75.0,0.0 };<o:p></o:p></span></pre><pre><span
  style='color:black'>GLdouble star[5][6]={ 250.0,50.0,0.0,1.0,0.0,1.0,<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                      </span>325.0,200.0,0.0,1.0,1.0,0.0,<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                      </span>400.0,50.0,0.0,0.0,1.0,1.0,<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                      </span>250.0,150.0,0.0,1.0,0.0,0.0,<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                      </span>400.0,150.0,0.0,0.0,1.0,0.0 };<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>startList=glGenLists(2);<o:p></o:p></span></pre><pre><span
  style='color:black'>tobj=gluNewTess();<o:p></o:p></span></pre><pre><span
  style='color:black'>gluTessCallback(tobj,GLU_TESS_VERTEX,glVertex3dv);<o:p></o:p></span></pre><pre><span
  style='color:black'>gluTessCallback(tobj,GLU_TESS_BEGIN,beginCallback);<o:p></o:p></span></pre><pre><span
  style='color:black'>gluTessCallback(tobj,GLU_TESS_END,endCallback);<o:p></o:p></span></pre><pre><span
  style='color:black'>gluTessCallback(tobj,GLU_TESS_ERROR,errorCallback);<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>glNewList(startList,GL_COMPILE);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glShadeModel(GL_FLAT);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>gluTessBeginPolygon(tobj,NULL);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>gluTessBeginContour(tobj);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>gluTessVertex(tobj,rect[0],rect[0]);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>gluTessVertex(tobj,rect[1],rect[1]);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>gluTessVertex(tobj,rect[2],rect[2]);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>gluTessVertex(tobj,rect[3],rect[3]);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>gluTessEndContour(tobj);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>gluTessBeginContour(tobj);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>gluTessVertex(tobj,tri[0],tri[0]);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>gluTessVertex(tobj,tri[1],tri[1]);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>gluTessVertex(tobj,tri[2],tri[2]);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>          </span><span style='mso-spacerun:yes'>  </span>gluTessEndContour(tobj);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>gluTessEndPolygon(tobj);<o:p></o:p></span></pre><pre><span
  style='color:black'>glEndList();<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>gluTessCallback(tobj,GLU_TESS_VERTEX,vertexCallback);<o:p></o:p></span></pre><pre><span
  style='color:black'>gluTessCallback(tobj,GLU_TESS_BEGIN,beginCallback);<o:p></o:p></span></pre><pre><span
  style='color:black'>gluTessCallback(tobj,GLU_TESS_END,endCallback);<o:p></o:p></span></pre><pre><span
  style='color:black'>gluTessCallback(tobj,GLU_TESS_ERROR,errorCallback);<o:p></o:p></span></pre><pre><span
  style='color:black'>gluTessCallback(tobj,GLU_TESS_COMBINE,combineCallback);<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>glNewList(startList+1,GL_COMPILE);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glShadeModel(GL_SMOOTH);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>gluTessProperty(tobj,GLU_TESS_WINDING_RULE, GLU_TESS_WINDING_POSITIVE);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>gluTessBeginPolygon(tobj,NULL);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>gluTessBeginContour(tobj);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>gluTessVertex(tobj,star[0],star[0]);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>gluTessVertex(tobj,star[1],star[1]);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>gluTessVertex(tobj,star[2],star[2]);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>gluTessVertex(tobj,star[3],star[3]);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>gluTessVertex(tobj,star[4],star[4]);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>gluTessEndContour(tobj);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>gluTessEndPolygon(tobj);<o:p></o:p></span></pre><pre><span
  style='color:black'>glEndList();<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<h2>11.1.5 Удаление объекта тесселяции</h2>

<p class=text align=left style='text-align:left'>Если вы более не нуждаетесь в
объекте тесселяции, вы можете удалить его и освободить всю связанную с ним
память с помощью функции <b>gluDeleteTess()</b>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>gluDeleteTess</b>
  (GLUtesselator* <i>tessobj</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Удаляет указанный объект
тесселяции <i>tessobj</i> и освобождает всю связанную с ним память.</p>

<h3><span style='font-family:Verdana;color:black'>11.1.6 Советы по увеличению
быстродействия тесселяции<o:p></o:p></span></h3>

<p class=text align=left style='text-align:left'>Для наилучшего быстродействия
соблюдайте следующие правила.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l39 level1 lfo49;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>1.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Кэшируйте результаты тесселяции в списке
отображения или другой пользовательской структуре. Чтобы получить пост –
тесселяционные координаты вершин, тесселируйте полигон, находясь в режиме
отклика. </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l39 level1 lfo49;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>2.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Используйте <b>gluTessNormal()</b>, чтобы
задавать нормаль полигона. </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l39 level1 lfo49;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>3.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Используйте для нескольких полигонов один и тот
же объект тесселяции, а не создавайте каждый раз новый. (В многопоточном
многопроцессорном окружении вы можете получить большее быстродействие за счет
использования нескольких тесселяторов.) </p>

<h2>11.1.7 Описание ошибок GLU</h2>

<p class=text align=left style='text-align:left'>GLU предоставляет функцию для
получения описательной строки кода ошибки. Эта функция не ограничена
использованием только с тесселяторами, она также используется при работе с
NURBS и квадрическими объектами, а также для описания ошибок GL.</p>

<h2>11.1.8 Обратная совместимость</h2>

<p class=text align=left style='text-align:left'>Если вы используете GLU версий
1.0 или 1.1, в вашем распоряжении намного менее мощный тесселятор. Тесселятор
версий 1.0/1.1 обрабатывает только простые невыпуклые полигоны или простые
полигоны с дырами. Он не может правильно тесселировать пересекающиеся контуры
(в нем отсутствует возвратная функция COMBINE) или обрабатывать по-полигонные
данные. Тесселятор версий 1.0/1.1 все еще работает в GLU версий 1.2/1.3, но его
использование не рекомендуется.</p>

<p class=text align=left style='text-align:left'>В тесселяторе версии 1.0/1.1
есть несколько похожих черт с новым тесселятором. Функции <b>gluNewTess()</b> и
<b>gluDeleteTess()</b> используются в обоих тесселятора. Главной функцией,
задающей вершины, также является <b>gluTessVertex()</b>. Механизм
возвратно-вызываемых функций также контролируется функцией <b>gluTessCallback()</b>,
однако старый тесселятор работает только с 5 типами возвратных функций –
подмножеством текущих 12.</p>

<p class=text align=left style='text-align:left'>Вот прототипы функций для
тесселятора версии 1.0/1.1:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>gluBeginPolygon</b> (GLUtriangulatorObj*
  <i>tessobj</i>);<br>
  void <b>gluNextContour</b> (GLUtriangulatorObj* <i>tessobj</i>, GLenum <i>type</i>);<br>
  void <b>gluEndPolygon</b> (GLUtriangulatorObj* <i>tessobj</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Самый внешний контур должен
быть задан первым, и эта процедура не требует предварительного вызова <b>gluNextContour()</b>.
Для полигонов без дыр задается только один контур, а функция <b>gluNextContour()</b>
не используется. Если полигон состоит из нескольких контуров (то есть в нем
есть дыры или дыры внутри дыр), эти контуры задаются один за другим, причем
каждому должен предшествовать вызов функции <b>gluNextContour()</b>. Функция <b>gluTessVertex()</b>
вызывается для каждой вершины каждого контура. Значениями для аргумента <i>type</i>
функции <b>gluNextContour()</b> могут быть GLU_EXTERIOR, GLU_INTERIOR, GLU_CCW,
GLU_CW или GLU_UNKNOWN. Этот аргумент служит только в качестве рекомендации для
тесселятора. Если вы выберете для него правильное значение, тесселяция может
завершиться быстрее. Если же выбранное значение неверно, аргумент будет
проигнорирован, тесселяция пройдет медленнее, но по-прежнему успешно. Для
полигонов с дырами один контур является внешним (GLU_EXTERIOR), а все остальные
– внутренними (GLU_INTERIOR). Предполагается, что первый контур будет иметь тип
GLU_EXTERIOR. Выбор ориентации по или против часовой стрелки (GLU_CW или
GLU_CCW) может быть произвольным в трехмерном пространстве. Однако на любой
плоскости существует две различных ориентации, поэтому GLU_CCW и GLU_CW должно
быть последовательным. Если вы не знаете, к какому типу относится контур,
используйте GLU_UNKNOWN.</p>

<p class=text align=left style='text-align:left'>Строго рекомендуется приводить
код для GLU 1.0/1.1 к коду, использующему новый интерфейс тесселяции. Это можно
сделать, выполнив следующие шаги.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l65 level1 lfo50;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>1.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Измените тип ссылок на объекты тесселяции с
GLUtriangulatorObj на GLUtesselator. В GLU версии 1.2 эти типы определены
одинаковым образом. </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l65 level1 lfo50;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>2.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Конвертируйте <b>gluBeginPolygon()</b> в две
команды: <b>gluTessBeginPolygon()</b> и <b>gluTessBeginContour()</b>. Все
контуры должны быть заданы внутри, включая самый первый. </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l65 level1 lfo50;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>3.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Конвертируйте <b>gluTessContour()</b> на <b>gluTessEndContour()</b>
и <b>gluTessBeginContour()</b>. Вы должны завершить предыдущий контур до того,
как начать следующий. </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l65 level1 lfo50;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>4.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Замените <b>gluEndPolygon()</b> на <b>gluTessEndContour()</b>
и <b>gluTessEndPolygon()</b>. Этим вы закроете последний контур. </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l65 level1 lfo50;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>5.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>В вызовах функции <b>gluTessCallback()</b>
измените ссылки на константы. В GLU 1.2 GLU_BEGIN, GLU_VERTEX, GLU_END,
GLU_ERROR и GLU_EDGE_FLAG определены как синонимы для GLU_TESS_BEGIN,
GLU_TESS_VERTEX, GLU_TESS_END, GLU_TESS_ERROR и GLU_TESS_EDGE_FLAG. </p>

<h2>11.2 Квадрические объекты: визуализация сфер, цилиндров и дисков</h2>

<p class=text align=left style='text-align:left'>Базовая библиотека OpenGL
предоставляет поддержку только для моделирования и визуализации простых точек,
линий и выпуклых закрашенных полигонов. Ни 3D объекты, ни часто используемые 2D
объекты, такие как круги, непосредственно недоступны.</p>

<p class=text align=left style='text-align:left'>GLU предоставляет функции для
моделирования и визуализации тесселированных полигональных аппроксимаций
различных 2D и 3D фигур (сфер, цилиндров, дисков и частей дисков), которые
могут быть вычислены с помощью квадратных уравнений (именно поэтому такие
объекты иногда называют квадрическими). Предоставляемая поддержка включает
функции для отображения квадрических поверхностей различными стилями и с
различной ориентацией. Квадрические поверхности в общем виде определяются
следующим квадратным уравнением: </p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1482" type="#_x0000_t75" alt="" style='width:378pt;height:23.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image344.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов11.mht!http://www.progz.ru/images/opengl/chapter11/form001.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=504 height=31
src="OpenGL%20Red%20Book.files/image344.jpg" v:shapes="_x0000_i1482"><![endif]></p>

<p class=text align=left style='text-align:left'>Процесс создания и
визуализации квадрической поверхности похож на процесс использования
тесселятора. Чтобы использовать квадрический объект, выполните следующие шаги:</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l54 level1 lfo51;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>1.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Чтобы создать новый квадрический объект,
используйте функцию <b>gluNewQuadric()</b>. </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l54 level1 lfo51;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>2.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Задайте атрибуты визуализации для квадрического
объекта (если, конечно, вы не удовлетворены атрибутами по умолчанию): </p>

<p class=text align=left style='margin-left:72.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l54 level2 lfo51;tab-stops:list 72.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>a.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Используйте <b>gluQuadricOrientation()</b> для
настройки правила оборота и отделения интерьера от экстерьера. </p>

<p class=text align=left style='margin-left:72.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l54 level2 lfo51;tab-stops:list 72.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>b.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Используйте <b>gluQuadricDrawStyle()</b>, чтобы
выбрать стиль визуализации – в виде точек, линий или закрашенных полигонов. </p>

<p class=text align=left style='margin-left:72.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l54 level2 lfo51;tab-stops:list 72.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>c.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Если объекты предполагается освещать,
используйте <b>gluQuadricNormals()</b>, задавая по одной нормали на вершину или
по одной нормали на грань. По умолчанию нормали вообще не генерируются. </p>

<p class=text align=left style='margin-left:72.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l54 level2 lfo51;tab-stops:list 72.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>d.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Если объекты предполагается текстурировать,
используйте <b>gluQuadricTexture()</b>, чтобы настроить механизм автоматической
генерации координат текстуры. </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l54 level1 lfo51;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>3.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Зарегистрируйте возвратно-вызываемую функцию
обработки ошибок с помощью <b>gluQuadricCallback()</b>. Возвратная функция
будет вызвана, если в процессе визуализации возникнет ошибка. </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l54 level1 lfo51;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>4.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Вызовите функцию визуализации желаемого
квадрического объекта: <b>gluSphere()</b>, <b>gluCylinder()</b>, <b>gluDisk()</b>
или <b>gluPartialDisk()</b>. Для увеличения скорости работы со статическими
данными, инкапсулируйте квадрический объект в списке отображения. </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l54 level1 lfo51;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>5.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>После полного завершения работы с квадрическим
объектом удалите его функцией <b>gluDeleteQuadric()</b>. Если вам нужно
несколько фигур, лучше использовать для них всех один и тот же квадрический
объект. </p>

<h2>11.2.1&nbsp;Управление квадрическими объектами</h2>

<p class=text align=left style='text-align:left'>Квадрический объект состоит из
параметров, аттрибутов и возвратно-вызываемых функций, сохраняемых в структуре
данных типа GLUquadricObj. Квадрический объект может генерировать вершины,
нормали, координаты текстуры и другие данные, которые могут использоваться либо
непосредственно, либо сохраняться в списке отображения для более позднего
использования. Следующие функции создают и уничтожают квадрический объект, а
также устанавливают возвратную функцию обработки ошибок.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>GLUquadricObj* <b>gluNewQuadric</b>
  (void);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Создает новый квадрический
объект и возвращает указатель на него. В случае неудачи функция возвращает
нулевой указатель.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>gluDeleteQuadric</b>
  (GLUquadricObj* qobj);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Уничтожает квадрический объект
<i>gobj</i> и освобождает всю память, используемую им.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>gluQuadricCallback</b>
  (GLUquadricObj* q<i>obj</i>, GLenum <i>which</i>, void (*<i>fn</i>)());<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Устанавливает, что функция <i>fn</i>
будет вызвана в определенных ситуациях. Единственным допустимым значением для
аргумента <i>which</i> является GLU_ERROR, то есть функция <i>fn</i> вызывается
в случае ошибки. Если аргумент <i>fn</i> равен NULL, удаляется ссылка на
текущую возвратную функцию.</p>

<p class=text align=left style='text-align:left'>В случае GLU_ERROR <i>fn</i>
вызывается с одним аргументом, равным коду ошибки. Функция <b>gluErrorString()</b>
может быть полезна для конверсии этого кода в ASCII строку.</p>

<h2>11.2.2 Управление атрибутами квадрических объектов</h2>

<p class=text align=left style='text-align:left'>Следующие функции воздействуют
на то, какие данные генерируются квадрическими функциями. Эти функции следует
использовать до создания примитивов.</p>

<p class=text align=left style='text-align:left'>Пример 11-4, <b>quadric.cpp</b>
демонстрирует изменение стиля рисования и характера генерируемых нормалей, а
также создание квадрических объектов, обработку ошибок и рисование примитивов.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>gluQuadricDrawStyle</b>
  (GLUquadricObj* <i>qobj</i>, GLenum <i>drawStyle</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Аргумент <i>drawStyle</i>
управляет стилем визуализации для объекта <i>qobj</i>. Допустимыми значениями <i>drawStyle</i>
могут быть GLU_POINT, GLU_LINE, GLU_SILHOUETTE и GLU_FILL.</p>

<p class=text align=left style='text-align:left'>GLU_POINT и GLU_LINE задают,
что примитивы должны визуализироваться в виде точки в каждой вершине или в виде
линий между парами соединяющихся вершин.</p>

<p class=text align=left style='text-align:left'>GLU_SILHOUETTE также задает
режим отображения в виде линий, но ребра, разделяющие соседние грани, не
рисуются. Этот режим чаще всего используется для дисков или их частей.</p>

<p class=text align=left style='text-align:left'>GLU_FILL задает визуализацию
закрашенных полигонов там, где полигоны рисуются с ориентацией против часовой
стрелки с учетом их нормалей. Данный параметр учитывает установки команды <b>gluQuadricOrientation()</b>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>gluQuadricOrientation</b>
  (GLUquadricObj* <i>qobj</i>, GLenum <i>orientation</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Для объекта <i>qobj</i>
аргумент <i>orientation</i> может принимать значения GLU_OUTSIDE (наружу,
значение по умолчанию) или GLU_INSIDE (вовнутрь) и управляет направлением
нормалей.</p>

<p class=text align=left style='text-align:left'>Для сфер и цилиндров
определение понятий наружу и вовнутрь очевидно. Для дисков и их частей сторона
диска с положительным <i>z</i> считается находящейся снаружи.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>gluQuadricNormals</b>
  (GLUquadricObj* <i>qobj</i>, GLenum <i>normals</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Для объекта <i>qobj</i>,
аргумент <i>normals</i> может принимать значения GLU_NONE (нормали не
генерируются, значение по умолчанию), GLU_FLAT (генерация полигональных
нормалей) или GLU_SMOOTH (генерация истинных нормалей).</p>

<p class=text align=left style='text-align:left'><b>gluQuadricNormals()</b>
используется для указания того, как генерировать нормали. GLU_NONE означает,
что нормали вообще не генерируются, этот режим используется при работе без
освещения. GLU_FLAT означает, что нормаль будет сгенерирована для каждой грани,
что обычно используется при работе с освещением в режиме плоской заливки.
GLU_SMOOTH означает, что нормаль будет сгенерирована для каждой вершины, этот
режим дает наилучшие результаты при работе с освещением и плавной заливкой.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>gluQuadricNormals</b>
  (GLUquadricObj* <i>qobj</i>, GLenum <i>normals</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Для объекта <i>qobj</i>
аргумент <i>textureCoords</i> может принимать значения GL_TRUE или GL_FALSE
(значение по умолчанию) и управляет тем, следует ли генерировать для
квадрического объекта координаты текстуры. Способ генерации текстурных
координат зависит от типа квадрического объекта.</p>

<h2>11.2.3 Квадрические примитивы</h2>

<p class=text align=left style='text-align:left'>Следующие функции
непосредственно генерируют вершины и другие данные, составляющие квадрический
объект. В каждом случае <i>qobj </i>представляет собой указатель, созданный с
помощью <b>gluNewQuadric().<o:p></o:p></b></p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>gluSphere</b>
  (GLUquadricObj* <i>qobj</i>, GLdouble <i>radius</i>, GLint <i>slices</i>,
  GLint <i>stacks</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Рисует сферу с радиусом равным
аргументу <i>radius</i>, центр которой находится в начале координат. Вокруг оси
<i>z</i> сфера состоит из частей, количеством <i>slices</i> (что-то вроде
географической долготы), а вдоль <i>z</i> – из частей количеством <i>stacks (</i>что-то
вроде географической широты<i>).<o:p></o:p></i></p>

<p class=text align=left style='text-align:left'>Если требуется генерировать
координаты текстуры, то координата <i>t</i> меняется от 0.0 на плоскости <i>z</i>=-<i>radius</i>
до 1.0 на плоскости <i>z</i>=<i>radius</i>, то есть <i>t</i> линейно
увеличивается вдоль линий долготы. В то же время <i>s</i> изменяется от 0.0 на
оси +<i>y</i>, к 0.25 на оси +<i>x</i>, к 0.5 на оси –<i>y</i>, к 0.75 на оси –<i>x</i>
до 1.0 снова на оси +<i>y</i>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=prototype><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>gluCylinder</b>
  (GLUquadricObj* <i>qobj</i>, GLdouble <i>baseRadius</i>, GLdouble <i>topRadius</i>,GLdouble
  <i>height</i>, GLint <i>slices</i>, GLint <i>stacks</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Рисует цилиндр,
ориентированный вдоль <i>z</i> оси, с основанием цилиндра на плоскости <i>z</i>=0,
а вершиной на плоскости <i>z</i>=<i>height</i>. Также как и сфера, цилиндр
разделяется вокруг <i>z</i> оси на <i>slices</i> частей, а вдоль <i>z</i> оси
на <i>stacks</i> частей. <i>baseRadius</i> задает радиус цилиндра у основания,
а <i>topRadius</i> – радиус в вершине (то есть с помощью этой функции рисуются
не только цилиндры в классически геометрическом понимании, но и конусы и части
конусов). Если <i>topRadius</i> установлен в 0.0, будет сгенерирован конус.</p>

<p class=text align=left style='text-align:left'>Если требуется генерировать
координаты текстуры, то координата <i>t </i>линейно изменяется от 0.0 на
плоскости <i>z</i>=0 до 1.0 на плоскости <i>z</i>=<i>height</i>. Координата <i>s</i>
генерируется также как для сферы. </p>

<p class=warning>Замечание: У цилиндра не закрыты ни основание, ни вершина.
Диски, представляющие собой основание и вершину, не рисуются.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=prototype><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>gluDisk</b>
  (GLUquadricObj* <i>qobj</i>, GLdouble <i>innerRadius</i>, GLdouble <i>outerRadius</i>,
  GLint <i>slices</i>, GLint <i>rings</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Рисует диск на плоскости <i>z</i>=0,
с радиусом <i>outerRadius</i> и концентрической дырой в центре радиусом <i>innerRadius</i>.
Если <i>innerRadius</i> равен 0, никакой дыры в центре нет. Вокруг оси <i>z</i>
диск разделяется на <i>slices</i> частей (что похоже на нарезку пиццы). Кроме
того, в плоскости <i>z</i> диск разделяется на <i>rings</i> концентрических
кругов.</p>

<p class=text align=left style='text-align:left'>С учетом ориентации <i>+z</i>
сторона диска считается находящейся снаружи: то есть все генерируемые нормали
указывают вдоль положительного направления оси <i>z</i>.</p>

<p class=text align=left style='text-align:left'>Если следует генерировать
координаты текстуры, то они генерируются линейно следующим образом. Если R=<i>outerRadius</i>,
то значения <i>s</i> и <i>t</i> в точке (R, 0, 0) равны (1, 0.5), в точке (0,
R, 0) – (0.5, 1), в точке (-R, 0, 0) – (0, 0.5), и, наконец, в точке (0, -R, 0)
– (0.5, 0).</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=prototype><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>gluPartialDisk</b>
  (GLUquadricObj* <i>qobj</i>, GLdouble <i>innerRadius</i>, GLdouble <i>outerRadius</i>,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  GLint <i>slices</i>, GLint <i>rings</i>, GLdouble <i>startAngle</i>, GLdouble
  <i>sweepAngle</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Рисует часть диска на
плоскости <i>z</i>=0. В терминах <i>outerRadius</i>, <i>innerRadius</i>, <i>slices</i>
и <i>rings</i> часть диска похожа на целый диск. Разница в том, что рисуется
только часть диска, начинающаяся с угла <i>startAngle</i> до угла <i>startAngle</i>+<i>sweepAngle</i>
(где <i>startAngle</i> и <i>sweepAngle</i> измеряются в градусах, и угол 0
соответствует положительному направлению оси <i>y</i>, угол 90 – положительному
направлению оси <i>x</i>, 180 – отрицательному направлению оси <i>y</i>, а 270
– отрицательному направлению оси <i>x</i>). </p>

<p class=text align=left style='text-align:left'>Ориентация и координаты
текстуры для части диска обрабатываются так же как для целого.</p>

<p class=warning>Замечание: Для всех квадрических объектов в случае
необходимости изменить их размер лучше использовать аргументы функций
построения квадрических примитивов (*Radius, height и так далее) вместо команды
<b>glScale()</b>, так как в последнем случае нормали единичной длины должны
быть повторно нормализованы. Устанавливайте аргументы <i>rings</i> и <i>stacks</i>
в значения отличные от 1, чтобы расчеты освещенности производится с большей
гранулярностью. Это особенно важно, если материал имеет высокий зеркальный
коэффициент.</p>

<p class=text align=left style='text-align:left'>Пример 11-4 демонстрирует все
типы квадрических примитивов, а также различные стили рисования. Результат
работы программы приводится на рисунке 11-5.</p>

<p class=text align=left style='text-align:left'>Рисунок 11-5. Квадрические
примитивы </p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1483" type="#_x0000_t75" alt="" style='width:378pt;height:403.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image345.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов11.mht!http://www.progz.ru/images/opengl/chapter11/11-5.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=504 height=538
src="OpenGL%20Red%20Book.files/image345.jpg" v:shapes="_x0000_i1483"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Пример 11-4. Квадрические
объекты: файл quadric.cpp</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#include <o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#include <o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#include <o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#ifndef CALLBACK<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#define CALLBACK<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#endif<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>GLuint startList;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void CALLBACK errorCallback(GLenum errorCode)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'> <span style='mso-spacerun:yes'>     </span>printf(&quot;Quadric error: %s\n&quot;,gluErrorString(errorCode));<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>exit(0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>//</span><span
  style='color:black'>Инициализация</span><span lang=EN-US style='color:black;
  mso-ansi-language:EN-US'><o:p></o:p></span></pre><pre><span lang=EN-US
  style='color:black;mso-ansi-language:EN-US'>void init(void)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>GLUquadricObj *qobj;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>GLfloat mat_ambient[]={0.5,0.5,0.5,1.0};<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>GLfloat mat_specular[]={1.0,1.0,1.0,1.0};<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>GLfloat mat_shininess[]={50.0};<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>GLfloat light_position[4]={1.0,1.0,1.0,0.0};<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>GLfloat model_ambient[]={0.5,0.5,0.5,1.0};<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glClearColor(0.0,0.0,0.0,0.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glMaterialfv(GL_FRONT,GL_AMBIENT,mat_ambient);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glMaterialfv(GL_FRONT,GL_SPECULAR,mat_specular);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glMaterialfv(GL_FRONT,GL_SHININESS,mat_shininess);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glLightfv(GL_LIGHT0,GL_POSITION,light_position);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glLightModelfv(GL_LIGHT_MODEL_AMBIENT,model_ambient);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glEnable(GL_LIGHT0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glEnable(GL_DEPTH_TEST);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span></span><span
  style='color:black'>//Создать 4 списка каждый с разным квадрик-объектом.<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>//Используются различные стили и параметры нормалей<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span></span><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>startList=glGenLists(4);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>qobj=gluNewQuadric();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>gluQuadricCallback(qobj,GLU_ERROR,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                        </span>(void(__stdcall*)(void))errorCallback);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>//</span><span
  style='color:black'>Плавно</span><span style='color:black;mso-ansi-language:
  EN-US'> </span><span style='color:black'>закрашенный</span><span lang=EN-US
  style='color:black;mso-ansi-language:EN-US'><o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>gluQuadricDrawStyle(qobj,GLU_FILL);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>gluQuadricNormals(qobj,GLU_SMOOTH);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glNewList(startList,GL_COMPILE);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>gluSphere(qobj,0.75,15,10);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glEndList();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>//</span><span
  style='color:black'>Плоско</span><span style='color:black;mso-ansi-language:
  EN-US'> </span><span style='color:black'>закрашенный</span><span lang=EN-US
  style='color:black;mso-ansi-language:EN-US'><o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>gluQuadricDrawStyle(qobj,GLU_FILL);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>gluQuadricNormals(qobj,GLU_FLAT);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glNewList(startList+1,GL_COMPILE);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>gluCylinder(qobj,0.5,0.3,1.0,15,5);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glEndList();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>//</span><span
  style='color:black'>Каркасный</span><span lang=EN-US style='color:black;
  mso-ansi-language:EN-US'><o:p></o:p></span></pre><pre><span lang=EN-US
  style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>gluQuadricDrawStyle(qobj,GLU_LINE);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>gluQuadricNormals(qobj,GLU_NONE);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glNewList(startList+2,GL_COMPILE);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>gluDisk(qobj,0.25,1.0,20,4);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glEndList();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>//</span><span
  style='color:black'>Силуэт</span><span lang=EN-US style='color:black;
  mso-ansi-language:EN-US'><o:p></o:p></span></pre><pre><span lang=EN-US
  style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>gluQuadricDrawStyle(qobj,GLU_SILHOUETTE);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>gluQuadricNormals(qobj,GLU_NONE);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glNewList(startList+3,GL_COMPILE);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>gluPartialDisk(qobj,0.0,1.0,20,4,0.0,225.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glEndList();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>//</span><span
  style='color:black'>Отображение</span><span lang=EN-US style='color:black;
  mso-ansi-language:EN-US'><o:p></o:p></span></pre><pre><span lang=EN-US
  style='color:black;mso-ansi-language:EN-US'>void display(void)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glPushMatrix();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glEnable(GL_LIGHTING);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glShadeModel(GL_SMOOTH);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glTranslatef(-1.0,-1.0,0.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glCallList(startList);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glShadeModel(GL_FLAT);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glTranslatef(0.0,2.0,0.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glPushMatrix();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glRotatef(300.0,1.0,0.0,0.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glCallList(startList+1);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glPopMatrix();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>    </span><span style='mso-spacerun:yes'>  </span>glDisable(GL_LIGHTING);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glColor3f(0.0,1.0,1.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glTranslatef(2.0,-2.0,0.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glCallList(startList+2);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glColor3f(1.0,1.0,0.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glTranslatef(0.0,2.0,0.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glCallList(startList+3);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glPopMatrix();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glFlush();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>//</span><span
  style='color:black'>Изменение</span><span style='color:black;mso-ansi-language:
  EN-US'> </span><span style='color:black'>размеров</span><span
  style='color:black;mso-ansi-language:EN-US'> </span><span style='color:black'>окна</span><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void reshape(int w, int h)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glViewport(0,0,(GLsizei) w, (GLsizei) h);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glMatrixMode(GL_PROJECTION);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glLoadIdentity();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>if (w&lt;=h)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>glOrtho(-2.5,2.5,-2.5*(GLfloat)h/(GLfloat)w,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                   </span><span style='mso-spacerun:yes'>  </span>2.5*(GLfloat)h/(GLfloat)w,-10.0,10.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>else<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>glOrtho(-2.5*(GLfloat)w/(GLfloat)h,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                     </span>2.5*(GLfloat)w/(GLfloat)h,-2.5,2.5,-10.0,10.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glMatrixMode(GL_MODELVIEW);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span></span><span
  style='color:black'>glLoadIdentity();<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre><pre><span style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void keyboard(unsigned char key,int x,int y)<o:p></o:p></span></pre><pre><span
  style='color:black'>{<o:p></o:p></span></pre><pre><span style='color:black'><span style='mso-spacerun:yes'>      </span>switch(key)<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>{<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>case 27:<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>exit(0);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>break;<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>}<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre><pre><span style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>int main (int argc, char** argv)<o:p></o:p></span></pre><pre><span
  style='color:black'>{<o:p></o:p></span></pre><pre><span style='color:black'><span style='mso-spacerun:yes'>      </span>glutInit(&amp;argc,argv);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB|GLUT_DEPTH);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>  </span><span style='mso-spacerun:yes'>    </span>glutInitWindowSize(500,500);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glutInitWindowPosition(100,100);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glutCreateWindow(&quot;Quadrics Objects&quot;);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>init();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glutDisplayFunc(display);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glutReshapeFunc(reshape);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glutKeyboardFunc(keyboard);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glutMainLoop();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>return 0;<span style='mso-spacerun:yes'>   </span><o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:Verdana;
mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><a name=Глава12><span style='display:none;mso-hide:all'><o:p>&nbsp;</o:p></span></a></p>

<h1 align=left style='text-align:left'><span style='mso-bookmark:Глава12'>Глава
12. Вычислители и NURBS</span></h1>

<span style='mso-bookmark:Глава12'></span>

<p class=MsoNormal><a href="mailto:ahinar@list.ru"></a><span style='font-size:
10.0pt;font-family:Verdana'>Дополнительно: На самом низком уровне графическая
аппаратура рисует только точки, сегменты линий и полигоны, которые обычно
являются треугольниками или четырехугольниками. Плавные кривые и поверхности
рисуются с помощью аппроксимаций большим число маленьких сегментов линий или
полигонов. Однако множество полезных кривых и поверхностей могут быть
математически описаны небольшим числом параметров, например, несколькими <i>контрольными
точками</i>. Сохранение 16 контрольных точек для поверхности требует
значительно меньше места в памяти, чем сохранение 1000 треугольников вместе с
вектором нормали для каждой вершины. Кроме того, 1000 треугольников всего лишь
аппроксимирует поверхность, а контрольные точки определяют ее истинную форму.<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Вычислители (evaluators)
предоставляют возможность задать точки кривой или поверхности (или их частей)
используя только контрольные точки. Затем кривая или поверхность может быть
визуализирована с любой точностью. Вдобавок, вектора нормалей для поверхностей
могут быть вычислены автоматически. Точки, сгенерированные вычислителем вы
можете использовать по-разному – чтобы нарисовать часть точек поверхности,
чтобы нарисовать ее каркасный вариант или чтобы отобразить полностью
освещенную, закрашенную и даже текстурированную поверхность.</p>

<p class=text align=left style='text-align:left'>Вы можете использовать
вычислители для описания любых полиномиальных или рациональных полиномиальных
сплайнов или поверхностей. Допустимое множество включает все сплайны и сплайновые
поверхности, используемые в наши дни: B– сплайны, NURBS
(Non-UniformRationalB-Spline– рациональные B&nbsp;- сплайны, заданные на
неравномерной сетке), кривые и поверхности Безье и сплайны Эрмита. Поскольку
вычислители обеспечивают только низкоуровневое описание точек кривой или
поверхности, они обычно используются в качестве фундамента библиотеками утилит,
предоставляющими программисту высокоуровневый интерфейс. Один из таких
высокоуровневых интерфейсов предоставляется механизмом NURBS из состава GLU –
этот механизм инкапсулирует в себе большой объем сложного кода. Большая часть
финальной визуализации реализуется с помощью вычислителей, но для некоторых
случаев (например, для отделки кривых) функции NURBS используют плоские
полигоны.</p>

<h2>12.1 Предварительные требования</h2>

<p class=text align=left style='text-align:left'>Вычислители создают кривые и
поверхности на базе кривых Безье. Определяющие формулы основных функций
приведены в этой главе, однако в ней не приводятся выводы этих формул, также
как и все их интересные математические свойства. Если вы хотите использовать
вычислители для рисования кривых и поверхностей в другом базисе, вам нужно
знать, как конвертировать ваш базис к базису Безье. Кроме того, когда вы
визуализируете поверхность Безье или ее часть, вам следует определиться с
гранулярностью поверхности. При принятии решения нужно принимать в расчет
вечную сделку между качеством (малая гранулярность) и высокой скоростью.
Определение нужной стратегии может быть достаточно сложным – слишком сложным,
чтобы обсуждаться здесь.</p>

<p class=text align=left style='text-align:left'>Подобным же образом, в этой
книге не обсуждаются все детали, касающиеся NURBS. Для программистов, которые
уже разбираются в этом предмете в данной главе описывается интерфейс GLU
NURBS&nbsp;и приводятся примеры его использования. Вы уже должны знать что
такое контрольные точки, узловые последовательности и декорирующие кривые.</p>

<p class=text align=left style='text-align:left'>Если вам не хватает знаний в
одной из описанных областей, попробуйте обратиться к следующим источникам:</p>

<p class=text align=left style='margin-left:54.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l34 level1 lfo52;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]><span lang=EN-US style='mso-ansi-language:EN-US'>Farin,
Gerald E., <i>Curves and Surfaces for Computer – Aided Geometric Design, Fourth
Edition</i>. </span>San Diego, CA: Academic Press, 1996. </p>

<p class=text align=left style='margin-left:54.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l34 level1 lfo52;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]><span lang=EN-US style='mso-ansi-language:EN-US'>Farin,
Gerald E., NURB <i>Curves and Surfaces: from Projective Geometry to Practical
Use</i>. </span>Wellesley, MA: A. K. Peters Ltd., 1995. </p>

<p class=text align=left style='margin-left:54.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l34 level1 lfo52;tab-stops:list 36.0pt'><![if !supportLists]><span
lang=EN-US style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol;mso-ansi-language:EN-US'><span style='mso-list:Ignore'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]><span lang=EN-US style='mso-ansi-language:EN-US'>Farin,
Gerald E., editor, <i>NURBS for Curve and Surface Design</i>. Society for
Industrial and Applied Mathematics, </span><st1:place><st1:City><span
  lang=EN-US style='mso-ansi-language:EN-US'>Philadelphia</span></st1:City><span
 lang=EN-US style='mso-ansi-language:EN-US'>, </span><st1:State><span
  lang=EN-US style='mso-ansi-language:EN-US'>PA</span></st1:State></st1:place><span
lang=EN-US style='mso-ansi-language:EN-US'>, 1991. <o:p></o:p></span></p>

<p class=text align=left style='margin-left:54.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l34 level1 lfo52;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]><span lang=EN-US style='mso-ansi-language:EN-US'>Hoschek,
Josef and Dieter Lasserm <i>Fundamentals of Computer Aided Geometric Design</i>.
</span>Wellesley, MA: A. K. Peters Ltd., 1993. </p>

<p class=text align=left style='margin-left:54.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l34 level1 lfo52;tab-stops:list 36.0pt'><![if !supportLists]><span
lang=EN-US style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol;mso-ansi-language:EN-US'><span style='mso-list:Ignore'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]><span lang=EN-US style='mso-ansi-language:EN-US'>Piegl,
Les and Wayne Tiller, <i>The NURBS Book</i>. </span><st1:place><st1:City><span
  lang=EN-US style='mso-ansi-language:EN-US'>New York</span></st1:City><span
 lang=EN-US style='mso-ansi-language:EN-US'>, </span><st1:State><span
  lang=EN-US style='mso-ansi-language:EN-US'>NY</span></st1:State></st1:place><span
lang=EN-US style='mso-ansi-language:EN-US'>: Springer – Verlag, 1995. <o:p></o:p></span></p>

<p class=warning>Замечание: Российским читателям можно порекомендовать книгу Е.
В. Шикин, А. И. Плис «Кривые и поверхности на экране компьютера. Руководство по
сплайнам для пользователя» -- М.: ДИАЛОГ – МИФИ, 1996.</p>

<p class=warning>Замечание: Некоторые термины в этой главе могут иметь
несколько иной смысл, чем в других книгах, поскольку между практикующими в этой
области не существует четкого соглашения. В общем, смысл терминов в OpenGL
более четок и конкретен. Например, вычислители OpenGL всегда используют базис
Безье, а в других источниках на вычислители могут ссылаться как на ту же
концепцию, но использующую произвольный базис.</p>

<h2>12.1 Вычислители</h2>

<p class=text align=left style='text-align:left'>Кривая Безье – это векторная
функция одной переменной </p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1484" type="#_x0000_t75" alt="" style='width:197.25pt;height:21.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image346.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов12.mht!http://www.progz.ru/images/opengl/chapter12/form001.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=263 height=29
src="OpenGL%20Red%20Book.files/image346.jpg" v:shapes="_x0000_i1484"><![endif]>,
</p>

<p class=text align=left style='text-align:left'>где <i>u </i>изменяется в
некотором диапазоне (скажем [<i>0</i>, <i>1</i>]). Поверхность Безье – это
векторная функция двух переменных </p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1485" type="#_x0000_t75" alt="" style='width:252.75pt;height:20.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image347.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов12.mht!http://www.progz.ru/images/opengl/chapter12/form002.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=337 height=27
src="OpenGL%20Red%20Book.files/image347.jpg" v:shapes="_x0000_i1485"><![endif]>.<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>где обе переменные <i>u </i>и <i>v</i>
изменяются в некотором диапазоне. Результирующий диапазон не обязательно должен
быть трехмерным, как показано здесь. Возможно, вам понадобится двумерный вывод
для кривых на плоскости или координат текстуры, или четырехмерный вывод для
того, чтобы можно было задавать с помощью него RGBA информацию. Даже одномерный
вывод имеет смысл при работе с оттенками серого цвета.</p>

<p class=text align=left style='text-align:left'>Для каждого <i>u</i> (или <i>u</i>
и <i>v</i>, в случае поверхности), формула <b>C()</b> (или <b>S()</b>)
вычисляет тоску на кривой (или поверхности). Чтобы использовать вычислитель,
сначала определите функцию <b>C()</b> или <b>S()</b>, активизируйте ее, а затем
используйте команду <b>glEvalCoord1()</b> или <b>glEvalCoord2()</b> вместо <b>glVertex*()</b>.
Таким образом, вершины кривой или поверхности могут использоваться также как и
любые другие вершины – например, для формирования точек или линий. Кроме того,
другие команды могут генерировать серии вершин, образующих фигуру, равномерно
распределенную по <i>u</i> (или по <i>u</i> и <i>v</i>). Одномерные и двумерные
вычислители похожи, но одномерный случай проще для описания, поэтому начнем с
него.</p>

<h2>12.1.1 Одномерные вычислители</h2>

<p class=text align=left style='text-align:left'>В данном разделе представлен
пример использования одномерного вычислителя для рисования кривой. Далее
описаны команды и уравнения, контролирующие вычислитель.</p>

<h2>12.1.1.1 Одномерный пример: простая кривая Безье</h2>

<p class=text align=left style='text-align:left'>Программа, представленная в
примере 12-1 рисует кубическую кривую Безье с использованием 4 контрольных
точек, как показано на рисунке 12-1.</p>

<p class=text align=left style='text-align:left'>Рисунок 12-1. Кривая Безье </p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1486" type="#_x0000_t75" alt="" style='width:232.5pt;height:232.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image348.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов12.mht!http://www.progz.ru/images/opengl/chapter12/12-1.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=310 height=310
src="OpenGL%20Red%20Book.files/image348.jpg" v:shapes="_x0000_i1486"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Пример 12-1. Кривая Безье с 4
контрольными точками: файл bezcurve.cpp</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#include <o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>GLfloat ctrlpoints[4][3]={<span style='mso-spacerun:yes'>   </span>{-4.0,-4.0,0.0},<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                             </span>{-2.0,4.0,0.0},<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                             </span>{2.0,-4.0,0.0},<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                             </span>{4.0,4.0,0.0}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                          </span>};<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void init()<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glClearColor(0.0,0.0,0.0,0.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>  </span><span style='mso-spacerun:yes'>    </span>glShadeModel(GL_FLAT);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glMap1f(GL_MAP1_VERTEX_3,0.0,1.0,3,4,&amp;ctrlpoints[0][0]);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glEnable(GL_MAP1_VERTEX_3);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void display()<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>int i;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glClear(GL_COLOR_BUFFER_BIT);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glColor3f(0.0,1.0,0.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glBegin(GL_LINE_STRIP);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>  </span><span style='mso-spacerun:yes'>          </span>for(i=0;i&lt;=30;i++)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>glEvalCoord1f((GLfloat)i/30.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glEnd();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>//</span><span
  style='color:black'>Контрольные</span><span style='color:black;mso-ansi-language:
  EN-US'> </span><span style='color:black'>точки</span><span lang=EN-US
  style='color:black;mso-ansi-language:EN-US'> <o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glPointSize(5.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glColor3f(1.0,1.0,0.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glBegin(GL_POINTS);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>for(i=0;i&lt;4;i++)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>glVertex3fv(&amp;ctrlpoints[i][0]);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glEnd();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glFlush();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void reshape(int w, int h)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glViewport(0,0,(GLsizei) w, (GLsizei) h);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glMatrixMode(GL_PROJECTION);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glLoadIdentity();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>if (w&lt;=h)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>glOrtho(-5.0,5.0,-5.0*(GLfloat)h/(GLfloat)w,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                     </span>5.0*(GLfloat)h/(GLfloat)w,-5.0,5.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>else<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>glOrtho(-5.0*(GLfloat)w/(GLfloat)h,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                     </span>5.0*(GLfloat)w/(GLfloat)h,-5.0,5.0,-5.0,5.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glMatrixMode(GL_MODELVIEW);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glLoadIdentity();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>int main(int argc, char** argv)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutInit(&amp;argc,argv);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutInitWindowSize(500,500);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutInitWindowPosition(100,100);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutCreateWindow(&quot;Bezier Curve with Four Control Points&quot;);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>    </span><span style='mso-spacerun:yes'>  </span>init();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutDisplayFunc(display);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutReshapeFunc(reshape);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span></span><span
  style='color:black'>glutMainLoop();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>return 0;<span style='mso-spacerun:yes'>   </span><o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Кубическая кривая Безье
описывается 4 точками, которые фигурируют в примере в виде массива <i>ctrlpoints[][]</i>.
Этот массив является одним из аргументов для команды <b>glMap1f()</b>. Полный
список аргументов для этой команды следующий:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_MAP1_VERTEX3<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Предоставлены трехмерные точки и должны быть сгенерированы
  трехмерные вершины<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><i><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0.0</span></i><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Нижняя граница для <i>u</i> <o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><i><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1.0</span></i><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Верхняя граница для <i>u</i> <o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><i><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>3</span></i><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Число величин с плавающей точкой между началом данных для одной
  контрольной точки и началом данных для другой в массиве<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><i><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>4</span></i><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Порядок сплайна, равный его степени плюс 1. В данном случае
  степень равна 3 (поскольку это кубический сплайн)<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:5;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><i><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>&amp;ctrlpoints[][]</span></i><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Указатель на данные первой контрольной точки<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Обратите внимание на то, что
второй и третий аргументы команды управляют параметризацией кривой – в то время
как <i>u</i>меняется от 0.0 до 1.0, кривая проходит от своего начала до своего
конца. Вызов команды <b>glEnable() </b>активизирует одномерный вычислитель для
трехмерных вершин.</p>

<p class=text align=left style='text-align:left'>Сама кривая рисуется в функции
<b>display()</b> между вызовами <b>glBegin()</b> и <b>glEnd()</b>. поскольку
вычислитель активизирован, вызов команды <b>glEvalCoord1f()</b> аналогичен
выполнению команды <b>glVertex()</b> с координатами вершины на кривой,
соответствующими заданному параметру <i>u</i>.</p>

<h2>12.1.1.2 Определение и вычисление одномерного вычислителя</h2>

<p class=text align=left style='text-align:left'>Многочлен Бернштейна степени <i>n</i>(или
порядка <i>n+1</i>) вычисляется по формуле </p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1487" type="#_x0000_t75" alt="" style='width:164.25pt;height:48pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image349.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов12.mht!http://www.progz.ru/images/opengl/chapter12/form003.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=219 height=64
src="OpenGL%20Red%20Book.files/image349.jpg" v:shapes="_x0000_i1487"><![endif]></p>

<p class=text align=left style='text-align:left'>Если <!--[if gte vml 1]><v:shape
 id="_x0000_i1488" type="#_x0000_t75" alt="" style='width:15.75pt;height:20.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image350.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов12.mht!http://www.progz.ru/images/opengl/chapter12/form004.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=21 height=27
src="OpenGL%20Red%20Book.files/image350.jpg" v:shapes="_x0000_i1488"><![endif]>&nbsp;представляет
набор контрольных точек (одно-, двух-, трех- или даже четырехмерных), то
уравнение</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1489" type="#_x0000_t75" alt="" style='width:130.5pt;height:46.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image351.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов12.mht!http://www.progz.ru/images/opengl/chapter12/form005.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=174 height=62
src="OpenGL%20Red%20Book.files/image351.jpg" v:shapes="_x0000_i1489"><![endif]></p>

<p class=text align=left style='text-align:left'>представляет кривую Безье в
процессе изменения <i>u</i>от <i>0.0</i> до <i>1.0</i>. Чтобы представить ту же
кривую, позволяя u меняться от <!--[if gte vml 1]><v:shape id="_x0000_i1490"
 type="#_x0000_t75" alt="" style='width:14.25pt;height:15.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image352.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов12.mht!http://www.progz.ru/images/opengl/chapter12/form006.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=19 height=21
src="OpenGL%20Red%20Book.files/image352.jpg" v:shapes="_x0000_i1490"><![endif]>&nbsp;до
<!--[if gte vml 1]><v:shape id="_x0000_i1491" type="#_x0000_t75" alt=""
 style='width:15.75pt;height:16.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image353.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов12.mht!http://www.progz.ru/images/opengl/chapter12/form007.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=21 height=22
src="OpenGL%20Red%20Book.files/image353.jpg" v:shapes="_x0000_i1491"><![endif]>,
а не между <i>0.0</i> и <i>1.0</i>, вычислите</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1492" type="#_x0000_t75" alt="" style='width:67.5pt;height:42pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image354.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов12.mht!http://www.progz.ru/images/opengl/chapter12/form008.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=90 height=56
src="OpenGL%20Red%20Book.files/image354.jpg" v:shapes="_x0000_i1492"><![endif]>.</p>

<p class=text align=left style='text-align:left'>Команда <b>glMap1()</b>
определяет одномерный вычислитель, использующий данные уравнения.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glMap1</b>{fd}
  (GLenum <i>target</i>, TYPE <i>u1</i>, TYPE <i>u2</i>, GLint <i>stride</i>,
  GLint <i>order</i>, const TYPE *<i>points</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Определяет одномерный
вычислитель. Аргумент <i>target </i>определяет, что именно задается
контрольными точками (смотрите таблицу 12-1) и, как следствие, сколько величин
должно быть задано в аргументе <i>points</i>. Точки могут представлять вершины,
цветовые данные RGBA, вектора нормалей или координаты текстуры. Например, если
задать для target значение GL_MAP1_COLOR_4, вычислитель генерирует цветовые
данные в четырехмерном RGBA пространстве вдоль кривой. Величины параметров,
перечисленные в таблице 12-1, также используются для активизации конкретного
вычислителя до его вызова. Чтобы активизировать или деактивировать нужный
вычислитель, передайте соответствующий аргумент командам <b>glEnable()</b> или <b>glDisable()</b>
соответственно.</p>

<p class=text align=left style='text-align:left'>Следующие два параметра <b>glMap1*()</b>
– <i>u1</i> и <i>u2</i> задают диапазон изменения переменной <i>u</i>. Аргумент
<i>stride</i>– это количество величин с плавающей точкой одинарной или двойной
точности в каждом блоке хранилища, то есть это величина смещения между началом предыдущей
контрольной точки и началом следующей.</p>

<p class=text align=left style='text-align:left'>Аргумент <i>order</i> – это
степень кривой плюс 1, и это число должно согласовываться с количеством
поставляемых контрольных точек. Аргумент <i>points </i>должен указывать на
первую координату первой контрольной точки.</p>

<p class=text align=left style='text-align:left'>Таблица 12-1. Типы контрольных
точек для glMap1*() </p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Параметр</span></b><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Смысл параметра</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_MAP1_VERTEX_3<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>координаты вершины <i>x</i>, <i>y</i>и <i>z</i> <o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_MAP1_VERTEX_4 <o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>координаты вершины <i>x</i>, <i>y</i>, <i>z</i> и <i>w</i> <o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_MAP1_INDEX <o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>цветовой индекс<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_MAP1_COLOR_4 <o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>R, G, B, A<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:5'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_MAP1_NORMAL <o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>координаты нормали<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:6'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_MAP1_TEXTURE_COORD_1 <o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>координата текстуры <i>s</i> <o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:7'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_MAP1_TEXTURE_COORD_2 <o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>координаты текстуры <i>s</i> и <i>t</i> <o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:8'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_MAP1_TEXTURE_COORD_3 <o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>координаты текстуры <i>s</i>, <i>t</i>и <i>r</i> <o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:9;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_MAP1_TEXTURE_COORD_4<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>координаты текстуры <i>s</i>, <i>t</i>, <i>r</i> и <i>q</i> <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Одновременно может быть включено
более одного вычислителя. Если у вас определены, например, два вычислителя
GL_MAP1_VERTEX_3 и GL_MAP1_COLOR_4, то вызов команды <b>glEvalCoord1()</b>
сгенерирует и позицию и цвет. Одновременно может быть активизирован только один
вершинный вычислитель, даже если определены оба. Также одновременно может быть
включен только один текстурный вычислитель. В других случаях, однако,
вычислители могут использоваться для генерирования любой комбинации вершин,
нормалей, цветов и координат текстуры. Если вы определите и активизируете два
или более вычислителей одного и того же типа, будет использован тот из них, в
котором наибольшее число измерений.</p>

<p class=text align=left style='text-align:left'>Для вычисления заданной и
активизированной одномерной таблицы используйте команду <b>glEvalCoord1*()</b>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glEvalCoord1</b>{fd}
  (TYPE <i>u</i>);<br>
  void <b>glEvalCoord1</b>{fd}<b>v</b> (TYPE* <i>u</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Вызывает к исполнению процесс
вычисления одномерных таблиц. Аргумент <i>u</i>задает одномерную координату на
кривой.</p>

<p class=text align=left style='text-align:left'>Обращения к <b>glEvalCoord*()</b>
не используют текущие величины цвета, цветового индекса, вектора нормали и
координат текстуры. <b>glEvalCoord*()</b> оставляет эти величины неизмененными.</p>

<h2>12.1.1.3 Определение одномерных доменных координат на кривой с равными
промежутками</h2>

<p class=text align=left style='text-align:left'>Вы можете использовать <b>glEvalCoord1()</b>
с любыми значениями <i>u</i>, но наиболее частой практикой является
использование сетки величин с равными промежутками между ними, как показано
ранее в примере 12-1. Чтобы получить такие величины, определите сетку командой <b>glMapGrid1*()</b>
и примените ее, используя <b>glEvalMesh1()</b>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glMapGrid1</b>{fd}
  (GLint <i>n</i>, TYPE <i>u1</i>, TYPE <i>u2</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Определяет сетку величин
изменяющихся от <i>u1</i> до <i>u2</i> за <i>n </i>равных шагов.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glEvalMesh1</b>
  (GLenum <i>mode</i>, GLint <i>p1</i>, GLint <i>p2</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Применяет определенную в
текущий момент одномерную сетку величин ко всем активизированным вычислителям.
Аргумент <i>mode </i>может принимать значения GL_POINT или GL_LINE в
зависимости от того, как вы хотите изобразить кривую – точками вдоль нее или
соединяющимися линиями. Вызов данной команды полностью эквивалентен вызовам <b>glEvalCoord1()</b>
для каждого шага от <i>p1</i> до <i>p2</i> включительно, где 0&lt;=p1,
p2&lt;=n. С точки зрения кода, это эквивалентно следующему фрагменту:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glBegin(GL_POINTS);<span style='mso-spacerun:yes'>     </span>/* </span><span
  style='color:black'>или</span><span lang=EN-US style='color:black;mso-ansi-language:
  EN-US'> glBegin(GL_LINES); */<o:p></o:p></span></pre><pre><span lang=EN-US
  style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>for(i=p1;i&lt;=p2;i++)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>glEvalCoord1(u1+i*(u2-u1)/n);<o:p></o:p></span></pre><pre><span
  style='color:black'>glEnd();<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>за исключением того, что если <i>i=0</i>
или <i>i=n</i>, <b>glEvalCoord1()</b> вызывается непосредственно с параметрами <i>u1</i>
или <i>u2</i>.</p>

<h2>12.1.2 Двумерные вычислители</h2>

<p class=text align=left style='text-align:left'>Двумерный случай практически
идентичен одномерному за тем исключением, что все команды должны принимать в
расчет 2 параметра <i>u </i>и <i>v</i>. Точки, цвета, нормали и координаты
текстуры должны поставляться по поверхности, а не по кривой. Математически
описание поверхности Безье задается в виде</p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Verdana;
color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1493" type="#_x0000_t75"
 alt="" style='width:177pt;height:39pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image355.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов12.mht!http://www.progz.ru/images/opengl/chapter12/form009.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=236 height=52
src="OpenGL%20Red%20Book.files/image355.jpg" v:shapes="_x0000_i1493"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>где величины <!--[if gte vml 1]><v:shape
 id="_x0000_i1494" type="#_x0000_t75" alt="" style='width:15pt;height:18.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image356.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов12.mht!http://www.progz.ru/images/opengl/chapter12/form010.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=20 height=25
src="OpenGL%20Red%20Book.files/image356.jpg" v:shapes="_x0000_i1494"><![endif]>&nbsp;представляют
собой набор из <i>m*n </i>контрольных точек, а функции <b>B </b>– это те же
многочлены Бернштейна, что и в одномерном случае. Как и раньше величины <!--[if gte vml 1]><v:shape
 id="_x0000_i1495" type="#_x0000_t75" alt="" style='width:15pt;height:18.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image356.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов12.mht!http://www.progz.ru/images/opengl/chapter12/form010.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=20 height=25
src="OpenGL%20Red%20Book.files/image356.jpg" v:shapes="_x0000_i1495"><![endif]>&nbsp;могут
являться вершинами, нормалями, цветами или координатами текстуры.</p>

<p class=text align=left style='text-align:left'>Процедура использования
двумерного вычислителя идентична одномерному случаю.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l63 level1 lfo53;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>1.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Определите вычислитель (или вычислители) с
помощью <b>glMap2*()</b>. </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l63 level1 lfo53;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>2.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Активизируйте их, передав нужную величину (или
величины) команде <b>glEnable()</b>. </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l63 level1 lfo53;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>3.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Вызовите их к исполнению либо с помощью команд <b>glEvalCoord2()</b>
между <b>glBegin()</b> и <b>glEnd()</b>, либо определив и применив сетку
величин с помощью команд <b>glMapGrid2()</b> и <b>glEvalMesh2()</b>. </p>

<h2>12.1.2.1 Определение и вычисление двумерного вычислителя</h2>

<p class=text align=left style='text-align:left'>Используйте <b>glMap2*()</b> и
<b>glEvalCoord2*()</b> для определения и выполнения двумерного вычислителя.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glMap2</b>{fd}
  (GLenum <i>target</i>, TYPE <i>u1</i>, TYPE <i>u2</i>, GLint <i>ustride</i>,
  GLint <i>uorder</i>, TYPE <i>v1</i>, TYPE <i>v2</i>, <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  GLint <i>vstride</i>, GLint <i>vorder</i>, TYPE* <i>points</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Параметр <i>target </i>может
принимать любые значения из таблицы 12-1, но в данном случае MAP1 нужно
изменить на MAP2 в именах всех параметров. Как и раньше, эти же значения
используются в командах <b>glEnable()</b> и <b>glDisable()</b> для активизации
или деактивации нужных вычислителей. Минимальное и максимальное значения
аргументов <i>u </i>и <i>v</i>, задаются в виде аргументов <i>u1</i>, <i>u2</i>,
<i>v1</i> и <i>v2</i>, соответственно. Аргументы <i>ustride </i>и <i>vstride </i>задают
количество чисел однократной или двойной точности между независимыми
установками величин <i>u </i>и <i>v</i>, позволяя пользователю выбирать
подрегион контрольных точек из намного большего по размеру массива. Например,
если данные заданы в форме</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>GLfloat
  ctrlpoints[100][100][3];<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>и вы хотите использовать
только подмножество точек размером <i>4x4</i>, начинающееся с точки <i>ctrlpoints[20][30]</i>,
установите <i>ustride</i>в <i>100*3</i>, а <i>vstride</i> в <i>3</i>. Аргумент <i>points
</i>в этом случае должен быть задан как <i>&amp;ctrlpoints[20][30][0]</i>.
Наконец, аргументы, определяющие порядок – <i>uorder </i>и <i>vorder</i>, могут
иметь разные значения, позволяя создавать, например, поверхности квадратные в
одном направлении и кубические в другом.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glEvalCoord2</b>{fd}
  (TYPE <i>u</i>, TYPE <i>v</i>);<br>
  void <b>glEvalCoord2</b>{fd}<b>v</b> (TYPE* <i>u</i>, TYPE* <i>v</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Вызывает к исполнению заданные
и активизированные двумерные вычислители. Аргументы <i>u</i>и <i>v</i> являются
величинами (или указателями на величины в случае векторной версии команды)
доменных координат (координат на поверхности или кривой). Если активизирован
один из вершинных вычислителей (GL_MAP2_VERTEX_3 или GL_MAP2_VERTEX_4), то
координаты нормалей к поверхности вычисляются автоматически. Если активизирован
режим автоматической генерации нормалей (с помощью аргумента GL_AUTO_NORMAL в
команде <b>glEnable()</b>), эта нормаль ассоциируется с вычисленной вершиной.
Если этот режим выключен, для вычисления нормали используется текущий
активизированный вычислитель. Если же таковой отсутствует, используется текущий
вектор нормали.</p>

<h2>12.1.2.2 Двумерный пример: поверхность Безье</h2>

<p class=text align=left style='text-align:left'>Пример 12-2 отображает
каркасную поверхность Безье, показанную на рисунке 12-2, с использованием вычислителя.
В этом примере поверхность рисуется в виде 9 изогнутых линий в каждом
направлении. Каждая линия состоит из 30 сегментов. Для получения цельной
программы, добавьте функции <b>reshape()</b> и <b>main()</b> из примера 12-1.</p>

<p class=text align=left style='text-align:left'>Рисунок 12-2. Поверхность
Безье </p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1496" type="#_x0000_t75" alt="" style='width:232.5pt;height:201pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image357.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов12.mht!http://www.progz.ru/images/opengl/chapter12/12-2.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=310 height=268
src="OpenGL%20Red%20Book.files/image357.jpg" v:shapes="_x0000_i1496"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Пример 12-2. Поверхность
Безье: файл bezsurf.cpp</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  style='color:black'>GLfloat ctrlpoints[4][4][3]={<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>{{-1.5,-1.5,4.0},{-0.5,-1.5,2.0},{0.5,-1.5,-1.0},{1.5,-1.5,2.0}},<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>{{-1.5,-0.5,1.0},{-0.5,-0.5,3.0},{0.5,-0.5,0.0},{1.5,-0.5,-1.0}},<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>{{-1.5,0.5,4.0},{-0.5,0.5,0.0},{0.5,0.5,3.0},{1.5,0.5,4.0}},<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>{{-1.5,1.5,-2.0},{-0.5,1.5,-2.0},{0.5,1.5,0.0},{1.5,1.5,-1.0}}<o:p></o:p></span></pre><pre><span
  style='color:black'>};<o:p></o:p></span></pre><pre><span style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>  </span><o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>void display()<o:p></o:p></span></pre><pre><span
  style='color:black'>{<o:p></o:p></span></pre><pre><span style='color:black'><span style='mso-spacerun:yes'>      </span>int i,j;<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span></span><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glColor3f(0.0,0.0,0.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glLoadIdentity();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glRotatef(85.0,1.0,1.0,1.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>for(j=0;j&lt;=8;j++)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>glBegin(GL_LINE_STRIP);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>for(i=0;i&lt;=30;i++)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                        </span>glEvalCoord2f((GLfloat)i/30.0,(GLfloat)j/8.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>glEnd();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>glBegin(GL_LINE_STRIP);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>for(i=0;i&lt;=30;i++)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                        </span>glEvalCoord2f((GLfloat)j/8.0,(GLfloat)i/30.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>glEnd();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glFlush();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void init()<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glClearColor(1.0,1.0,1.0,0.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glLineWidth(2.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glMap2f(GL_MAP2_VERTEX_3,0,1,3,4,0,1,12,4,&amp;ctrlpoints[0][0][0]);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glEnable(GL_MAP2_VERTEX_3);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glMapGrid2f(20,0.0,1.0,20,0.0,1.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glEnable(GL_DEPTH_TEST);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glShadeModel(GL_FLAT);<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<h2>12.1.2.3 Определение двумерных доменных координат на поверхности с равными
промежутками</h2>

<p class=text align=left style='text-align:left'>В двух измерениях команды <b>glMapGrid2*()</b>
и <b>glEvalMesh2()</b> используются так же как их одномерные версии, за тем
исключением, что должна быть задана информация и о <i>u</i>, и о <i>v</i>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glMapGrid2</b>{fd}
  (GLint <i>nu</i>, TYPE <i>u1</i>, TYPE <i>u2</i>, GLint <i>vn</i>, TYPE <i>v1</i>,
  TYPE <i>v2</i>);<br>
  void <b>glEvalMesh2</b> (GLenum <i>mode</i>, GLint <i>i1</i>, GLint <i>i2</i>,
  GLint <i>j1</i>, GLint <i>j2</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Определяют двумерную сетку
величин, проходящих от <i>u1</i> до <i>u2</i> за <i>nu</i> шагов с равными
промежутками и от <i>v1</i> до <i>v2</i> за <i>nv</i> с равными промежутками (<b>glMapGrid2*()</b>)
и затем применяют эту сетку ко всем активизированным вычислителям (<b>glEvalMesh2()</b>).
Единственное существенное отличие от одномерного случая заключается в том, что
аргумент <i>mode </i>команды <b>glEvalMesh2()</b> помимо GL_POINT и GL_LINE
может принимать и значение GL_FILL. GL_FILL генерирует закрашенные полигоны с
помощью четырехугольников. Если говорить точно, вызов <b>glEvalMesh2()</b>
практически эквивалентен одному из трех следующих блоков кода. («Практически»
потому, что, когда <i>i=nu </i>или <i>j=nv</i>, параметры равны <i>u2 </i>или <i>v2</i>,
а не <i>u1+nu*(u2-u1)/nu </i>или <i>v1+nv*(v2-v1)/nv</i>– эти числа могут
различаться из-за ошибок округления.)</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glBegin(GL_POINTS);<span style='mso-spacerun:yes'>     </span>/* </span><span
  style='color:black'>режим</span><span lang=EN-US style='color:black;
  mso-ansi-language:EN-US'> GL_POINT */<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>for(i=nu1;i&lt;=nu2;i++)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>for(j=nv1;j&lt;=nv2;j++)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>glEvalCoord2(u1+i*(u2-u1)/nu, v1+j*(v2-v1)/nv);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glEnd();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>или</span><span lang=EN-US style='color:black;mso-ansi-language:
  EN-US'><o:p></o:p></span></pre><pre><span lang=EN-US style='color:black;
  mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span lang=EN-US
  style='color:black;mso-ansi-language:EN-US'>for(i=nu1;i&lt;=nu2;i++)<span style='mso-spacerun:yes'>   </span>/* </span><span
  style='color:black'>режим</span><span lang=EN-US style='color:black;
  mso-ansi-language:EN-US'> GL_LINE */<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glBegin(GL_LINES);<span style='mso-spacerun:yes'>      </span><o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>for(j=nv1;j&lt;=nv2;j++)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>glEvalCoord2(u1+i*(u2-u1)/nu, v1+j*(v2-v1)/nv);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glEnd();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>for(j=nv1;j&lt;=nv2;j++)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glBegin(GL_LINES);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>for(i=nu1;i&lt;=nu2;i++)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>glEvalCoord2(u1+i*(u2-u1)/nu, v1+j*(v2-v1)/nv);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glEnd();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>или</span><span lang=EN-US style='color:black;mso-ansi-language:
  EN-US'><o:p></o:p></span></pre><pre><span lang=EN-US style='color:black;
  mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span lang=EN-US
  style='color:black;mso-ansi-language:EN-US'>for(i=nu1;i&lt;=nu2;i++)<span style='mso-spacerun:yes'>   </span>/* </span><span
  style='color:black'>режим</span><span lang=EN-US style='color:black;
  mso-ansi-language:EN-US'> GL_FILL */<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glBegin(GL_QUAD_STRIP);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>for(j=nv1;j&lt;=nv2;j++)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>glEvalCoord2(u1+i*(u2-u1)/nu, v1+j*(v2-v1)/nv);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>glEvalCoord2(u1+(i+1)*(u2-u1)/nu, v1+j*(v2-v1)/nv);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span></span><span
  style='color:black'>glEnd();<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Пример 12-3 показывает
отличия, которые нужно сделать в примере 12-2, чтобы нарисовать ту же
поверхность, но с применением <b>glMapGrid2()</b> и <b>glEvalMesh2()</b> для
разделения квадрата доменных координат на сетку величин размерностью <i>8x8</i>.
Пример 12-3 также добавляет освещение и закраску, как показано на рисунке 12-3.</p>

<p class=text align=left style='text-align:left'>Рисунок 12-3. Освещенная и
закрашенная поверхность Безье, нарисованная по сетке доменных координат </p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1497" type="#_x0000_t75" alt="" style='width:232.5pt;height:213.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image358.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов12.mht!http://www.progz.ru/images/opengl/chapter12/12-3.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=310 height=285
src="OpenGL%20Red%20Book.files/image358.jpg" v:shapes="_x0000_i1497"><![endif]></p>

<p class=text align=left style='text-align:left'>Пример 12-3. Освещенная и
закрашенная поверхность Безье, нарисованная по сетке доменных координат: файл
bezmesh.cpp</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void display()<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glLoadIdentity();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glRotatef(85.0,1.0,1.0,1.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glEvalMesh2(GL_FILL,0,20,0,20);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glFlush();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void init()<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glClearColor(1.0,1.0,1.0,0.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glMap2f(GL_MAP2_VERTEX_3,0,1,3,4,0,1,12,4,&amp;ctrlpoints[0][0][0]);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>    </span><span style='mso-spacerun:yes'>  </span>glEnable(GL_MAP2_VERTEX_3);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glMapGrid2f(20,0.0,1.0,20,0.0,1.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glEnable(GL_DEPTH_TEST);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glEnable(GL_AUTO_NORMAL);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>//</span><span
  style='color:black'>Источники</span><span style='color:black;mso-ansi-language:
  EN-US'> </span><span style='color:black'>света</span><span lang=EN-US
  style='color:black;mso-ansi-language:EN-US'> <o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>GLfloat ambient[]={0.2,0.2,0.2,1.0};<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>GLfloat position[]={0.0,0.0,2.0,1.0};<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>GLfloat mat_diffuse[]={0.6,0.6,0.6,1.0};<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>GLfloat mat_specular[]={1.0,1.0,1.0,1.0};<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>GLfloat mat_shininess[]={50.0};<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glEnable(GL_LIGHTING);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glEnable(GL_LIGHT0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glLightfv(GL_LIGHT0,GL_AMBIENT,ambient);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glLightfv(GL_LIGHT0,GL_POSITION,position);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glMaterialfv(GL_FRONT,GL_DIFFUSE,mat_diffuse);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glMaterialfv(GL_FRONT,GL_SPECULAR,mat_specular);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glMaterialfv(GL_FRONT,GL_SHININESS,mat_shininess);<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<h2>12.1.3 Использование вычислителей для текстур</h2>

<p class=text align=left style='text-align:left'>Пример 12-3 активизирует
одновременно 2 вычислителя: первый генерирует трехмерные точки на той же
поверхности Безье, что и пример 12-3, а второй генерирует координаты текстуры.
В данном случае в качестве координат текстуры выступают те же значения <i>u</i>и
<i>v</i>, которые используются для вычисления вершин, но для того, чтобы
применить их к поверхности, требуется определить отдельный вычислитель.</p>

<p class=text align=left style='text-align:left'>Второй вычислитель
определяется на квадрате с углами в точках (0,0), (0, 1), (1,0) и (1,1); он
генерирует (0,0) в углу (0,0), (0,1) в углу (0,1) и так далее. Поскольку он
имеет порядок 2 (являясь линейным – первая степень плюс 1), вычисление этой
текстуры в точке (<i>u</i>,<i>v</i>) дает координаты текстуры (<i>s</i>,<i>t</i>).
Он активизируется в то же время, что и вершинный вычислитель, таким образом, на
рисуемую поверхность воздействуют оба, что можно увидеть на рисунке 12-4. Если
вы хотите, чтобы текстура повторилась 3 раза, измените каждую 1.0 в массиве <i>texpts[
][ ][ ]</i>.</p>

<p class=text align=left style='text-align:left'>Рисунок 12-4. Текстурированная
поверхность Безье </p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1498" type="#_x0000_t75" alt="" style='width:232.5pt;height:217.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image359.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов12.mht!http://www.progz.ru/images/opengl/chapter12/12-4.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=310 height=290
src="OpenGL%20Red%20Book.files/image359.jpg" v:shapes="_x0000_i1498"><![endif]></p>

<p class=text align=left style='text-align:left'>Пример 12-4. Использование
вычислителей для текстур: файл texturesurf.cpp</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  style='color:black'>#include <o:p></o:p></span></pre><pre><span
  style='color:black'>#include <o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>GLfloat ctrlpoints[4][4][3]={<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>{{-1.5,-1.5,4.0},{-0.5,-1.5,2.0},{0.5,-1.5,-1.0},{1.5,-1.5,2.0}},<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>{{-1.5,-0.5,1.0},{-0.5,-0.5,3.0},{0.5,-0.5,0.0},{1.5,-0.5,-1.0}},<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>{{-1.5,0.5,4.0},{-0.5,0.5,0.0},{0.5,0.5,3.0},{1.5,0.5,4.0}},<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>{{-1.5,1.5,-2.0},{-0.5,1.5,-2.0},{0.5,1.5,0.0},{1.5,1.5,-1.0}}<o:p></o:p></span></pre><pre><span
  style='color:black'>};<o:p></o:p></span></pre><pre><span style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>GLfloat texpts[2][2][2]={{{0.0,0.0},{0.0,1.0}},{{1.0,0.0},{1.0,1.0}}};<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span lang=EN-US
  style='color:black;mso-ansi-language:EN-US'>void display()<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glColor3f(1.0,1.0,1.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glEvalMesh2(GL_FILL,0,20,0,20);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glFlush();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#define imageWidth 64<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#define imageHeight 64<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>GLubyte image[3*imageWidth*imageHeight];<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void makeImage()<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>int i,j;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>float ti,tj;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>for(i=0;i&lt;=&quot;h)&quot; glOrtho(-4.0,4.0,-4.0*(GLfloat)h (GLfloat)w, 4.0*(GLfloat)h (GLfloat)w,-4.0,4.0); else glOrtho(-4.0*(GLfloat)w (GLfloat)h, 4.0*(GLfloat)w (GLfloat)h,-4.0,4.0,-4.0,4.0); glMatrixMode(GL_MODELVIEW); glLoadIdentity(); glRotatef(85.0,1.0,1.0,1.0); } int main(int argc, char** argv) { glutInit(&amp;argc,argv); glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB|GLUT_DEPTH); glutInitWindowSize(500,500); glutInitWindowPosition(100,100); glutCreateWindow(?Using Evaluators for Textures?); init(); glutDisplayFunc(display); glutReshapeFunc(reshape); glutMainLoop(); return 0; }&lt; pre&gt;<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<h2>12.2 Интерфейс GLU NURBS </h2>

<p class=text align=left style='text-align:left'>Хотя единственными непосредственно
доступными в OpenGL примитивами для рисования кривых и поверхностей являются
вычислители, и даже, несмотря на то, что они могут быть весьма эффективно
реализованы на аппаратном уровне, приложения часто обращаются к ним через
высокоуровневые библиотеки. Библиотека утилит GLU предоставляет интерфейс
NURBS, построенный поверх команд OpenGL для работы с вычислителями.</p>

<h2>12.2.1Простой пример NURBS </h2>

<p class=text align=left style='text-align:left'>Если вы разбираетесь в NURBS,
написать код для манипулирования NURBS в OpenGL относительно просто, даже если
вы хотите использовать освещение или текстурирование. Для того, чтобы
нарисовать кривую или поверхность NURBS выполните следующие шаги.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l36 level1 lfo54;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>1.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Если вы намереваетесь использовать освещение на
поверхности NURBS, вызовите <b>glEnable()</b> с аргументом GL_AUTO_NORMAL для
активизации режима автоматического вычисления нормалей (вы также можете
вычислить свои собственные). </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l36 level1 lfo54;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>2.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Используйте функцию <b>gluNewNurbsRenderer()</b>
для создания нового объекта NURBS и получения указателя на него. На этот объект
вы будете ссылаться при построении кривой или поверхности NURBS. </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l36 level1 lfo54;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>3.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Если хотите, вызовите <b>gluNurbsProperty()</b>
для установки значений различных свойств, например, максимального размера линий
или полигонов, используемых для визуализации кривой или поверхности. <b>gluNurbsProperty()</b>
также позволяет активизировать режим, в котором тесселированные геометрические
данные могут быть получены через интерфейс возвратно – вызываемых функций. </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l36 level1 lfo54;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>4.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Если вы хотите принимать уведомления об ошибках,
вызовите <b>gluNurbsCallback()</b>. (Проверка ошибок может снизить быстродействие
программы, но, тем не менее, ее наличие настойчиво рекомендуется.) <b>gluNurbsCallback()</b>
также позволяет задать возвратные функции, которые будут вызываться для
извлечения тесселированных геометрических данных. </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l36 level1 lfo54;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>5.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Начните описание вашей кривой или поверхности,
вызвав <b>gluBeginCurve()</b> или <b>gluBeginSurface()</b>. </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l36 level1 lfo54;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>6.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Сгенерируйте и визуализируйте вашу кривую или
поверхность. Вы должны хотя бы один раз вызвать функцию <b>gluNurbsCurve()</b>
или <b>gluNurbsSurface()</b>, передавая им&nbsp; контрольные точки
(рациональные или нерациональные), узловые последовательности и порядок
полиномиальной базисной функции для вашего объекта NURBS. Для указания нормалей
и/или координат текстуры вам могут понадобиться дополнительные вызовы этих
функций. </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l36 level1 lfo54;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>7.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Вызовите <b>gluEndCurve()</b> или <b>gluEndSurface()</b>,
завершая описание кривой или поверхности. </p>

<p class=text align=left style='text-align:left'>Пример 12-5 визуализирует
поверхность NURBS в форме симметричного холма с контрольными точками,
изменяющимися от <i>-3.0</i> до <i>3.0</i>. Базисная функция представляет собой
кубический B – сплайн, но узловая последовательность&nbsp; является
неравномерной, заставляя функцию вести себя в каждом направлении как кривая
Безье. Поверхность освещена, имеет темно-серое диффузное отражение и белый
зеркальный блик. Поверхность в каркасном и закрашенном виде можно увидеть на
рисунке 12-5.</p>

<p class=text align=left style='text-align:left'>Рисунок 12-5. Поверхность
NURBS </p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1499" type="#_x0000_t75" alt="" style='width:371.25pt;height:177pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image360.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов12.mht!http://www.progz.ru/images/opengl/chapter12/12-5.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=495 height=236
src="OpenGL%20Red%20Book.files/image360.jpg" v:shapes="_x0000_i1499"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Пример 12-5. Поверхность
NURBS: файл surface.cpp</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#include <o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#include <o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#ifndef CALLBACK<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#define CALLBACK<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#endif<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>GLfloat ctrlpoints[4][4][3];<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>int showPoints=0;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>GLUnurbsObj *theNurb;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void init_surface()<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>int u,v;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>for (u=0;u&lt;4;u++)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>for(v=0;v&lt;4;v++)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>ctrlpoints[u][v][0]=2.0*((GLfloat)u-1.5);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>ctrlpoints[u][v][1]=2.0*((GLfloat)v-1.5);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>if((u==1||u==2)&amp;&amp;(v==1||v==2))<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                        </span>ctrlpoints[u][v][2]=3.0;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>else<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                        </span>ctrlpoints[u][v][2]=-3.0;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void CALLBACK nurbsError(GLenum errorCode)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>char message[100];<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>sprintf(message,&quot;NURBS error: %s\n&quot;,gluErrorString(errorCode));<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>MessageBox(NULL,message,&quot;NURBS surface&quot;,MB_OK);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>exit(0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void display()<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>GLfloat knots[8]={0.0,0.0,0.0,0.0,1.0,1.0,1.0,1.0};<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>int i,j;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glPushMatrix();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glRotatef(330.0,1.0,0.0,0.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glScalef(0.5,0.5,0.5);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>gluBeginSurface(theNurb);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'> <span style='mso-spacerun:yes'>     </span>gluNurbsSurface(theNurb,8,knots,8,knots,4*3,3,<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                      </span>&amp;ctrlpoints[0][0][0],4,4,GL_MAP2_VERTEX_3);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>gluEndSurface(theNurb);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>if(showPoints)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>glPointSize(5.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>glDisable(GL_LIGHTING);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>glColor3f(1.0,1.0,0.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>glBegin(GL_POINTS);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>for(i=0;i&lt;4;i++)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                        </span>for(j=0;j&lt;4;j++)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                             </span>glVertex3fv(&amp;ctrlpoints[i][j][0]);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>glEnd();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>glEnable(GL_LIGHTING);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>    </span><span style='mso-spacerun:yes'>  </span>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glPopMatrix();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glFlush();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void init()<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>GLfloat mat_diffuse[]={0.7,0.7,0.7,1.0};<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>GLfloat mat_specular[]={1.0,1.0,1.0,1.0};<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>GLfloat mat_shininess[]={100.0};<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glClearColor(0.0,0.0,0.0,0.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glMaterialfv(GL_FRONT,GL_DIFFUSE,mat_diffuse);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glMaterialfv(GL_FRONT,GL_SPECULAR,mat_specular);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glMaterialfv(GL_FRONT,GL_SHININESS,mat_shininess);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glEnable(GL_LIGHTING);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glEnable(GL_LIGHT0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glEnable(GL_DEPTH_TEST);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glEnable(GL_AUTO_NORMAL);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glEnable(GL_NORMALIZE);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>init_surface();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>theNurb=gluNewNurbsRenderer();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>gluNurbsProperty(theNurb,GLU_SAMPLING_TOLERANCE,2.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>gluNurbsProperty(theNurb,GLU_DISPLAY_MODE,GLU_FILL);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>gluNurbsCallback(theNurb,GLU_ERROR,(void(__stdcall *)(void))nurbsError);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void reshape(int w, int h)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glViewport(0,0,(GLsizei) w, (GLsizei) h);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glMatrixMode(GL_PROJECTION);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glLoadIdentity();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>gluPerspective(45.0,(GLdouble)w/(GLdouble)h,3.0,8.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glMatrixMode(GL_MODELVIEW);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glLoadIdentity();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glTranslatef(0.0,0.0,-5.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void keyboard(unsigned char key,int x,int y)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>switch(key)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>case 'c':<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>case 'C':<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>showPoints=!showPoints;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>glutPostRedisplay();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>break;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>int main(int argc, char** argv)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutInit(&amp;argc,argv);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB|GLUT_DEPTH);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutInitWindowSize(500,500);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutInitWindowPosition(100,100);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutCreateWindow(&quot;NURBS surface&quot;);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>init();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutDisplayFunc(display);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glutReshapeFunc(reshape);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span></span><span
  style='color:black'>glutKeyboardFunc(keyboard);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glutMainLoop();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>return 0;<span style='mso-spacerun:yes'>   </span><o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<h2>12.2.2 Управление объектом NURBS </h2>

<p class=text align=left style='text-align:left'>Как показано в примере 12-5,
функция <b>gluNewNurbsRenderer()</b> возвращает новый объект NURBS, чей тип
определен в виде указателя на структуру <b>GLUnurbsObj</b>. Вы должны создать
этот объект до вызова любой функции, связанной с NURBS. Когда вы завершите
работу с объектом NURBS, вы можете использовать функцию <b>gluDeleteNurbsRenderer()</b>
для освобождения всей используемой памяти.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>GLUnurbsObj* <b>gluNewNurbsRenderer</b>
  (void);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Создает новый объект NURBS – <i>nobj</i>
и возвращает указатель на него или ноль, если OpenGL не может выделить память
для нового объекта NURBS.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>gluDeleteNurbsRenderer</b>
  (GLUnurbsObj* <i>nobj</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Уничтожает объект NURBS <i>nobj</i>.</p>

<h2>12.2.2.1 Управление свойствами визуализации NURBS </h2>

<p class=text align=left style='text-align:left'>Набор свойств, ассоциированных
с объектом NURBS, влияет на то, как визуализируется объект. Эти свойства
задают, как визуализируется поверхность (например, закрашенной или каркасной),
должны ли тесселированные вершины отображаться или возвращаться в программу, а
также точность тесселяции.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>gluNurbsProperty</b>
  (GLUnurbsObj* <i>nobj</i>, GLenum <i>property</i>, GLfloat <i>value</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Управляет атрибутами NURBS
объекта <i>nobj</i>. Аргумент <i>property </i>задает конфигурируемое свойство и
может принимать значения GLU_DISPLAY_MODE, GLU_NURBS_MODE, GLU_CULLING,
GLU_SAMPLING_METHOD, GLU_SAMPLING_TOLERANCE, GLU_PARAMETRIC_TOLERANCE,
GLU_U_STEP, GLU_V_STEP или GLU_AUTO_LOAD_MATRIX. Аргумент <i>value </i>задает
величину, в которую должно быть установлено свойство.</p>

<p class=text align=left style='text-align:left'>Для свойства GLU_DISPLAY_MODE,
значение по умолчанию – GLU_FILL, в результате чего поверхность визуализируется
с помощью полигонов. Если для свойства используется значение
GLU_OUTLINE_POLYGON, тесселяцией создаются и отображаются только полигоны,
окантовывающие поверхность. Если же используется GLU_OUTLINE_PATCH,
визуализируется только полигон, обозначающий участок, занимаемый поверхностью и
декорирующие кривые.</p>

<p class=text align=left style='text-align:left'>Свойство GLU_NURBS_MODE
управляет тем, должны ли тесселированные вершины выводиться на экран (значение
по умолчанию, GLU_NURBS_RENDERER) или тесселированные вершины должны быть
возвращены в программу через интерфейс возвратно – вызываемых функций (если
значение свойства – GLU_NURBS_TESSELATOR). </p>

<p class=text align=left style='text-align:left'>Параметр GLU_CULLING может
значительно повысить быстродействие, если задать ему значение GL_TRUE (значение
по умолчанию – GL_FALSE). В этом случае, расчет поверхности не будет
производиться, если она целиком выпадает из объема видимости.</p>

<p class=text align=left style='text-align:left'>Поскольку объект NURBS
визуализируется в виде примитивов, он строится по различным величинам своих
параметров (<i>u</i>и <i>v</i>) и разбивается на небольшие сегменты линий или
полигоны. Если аргумент <i>property </i>равен GLU_SAMPLING_METHOD, <i>value </i>может
принимать значения GLU_PATH_LENGTH (значение по умолчанию),
GLU_PARAMETRIC_ERROR, GL_DOMAIN_DISTANCE, GLU_OBJECT_PATH_LENGTH или
GLU_OBJECT_PARAMETRIC_ERROR, что определяет способ тесселяции поверхности.
Когда <i>value </i>установлено в значение GLU_PATH_LENGTH, поверхность
визуализируется таким образом, что максимальная длина ребер полигонов в
пикселях не больше, чем значение, заданное для свойства GLU_SAMPLING_TOLERANCE.
Когда <i>value </i>установлено в GLU_PARAMETRIC_ERROR, величина, заданная для
свойства GLU_PARAMETRIC_TOLERANCE представляет максимально допустимое
расстояние в пикселях между аппроксимирующими полигонами и реальной
поверхностью. Значение <i>value </i>равное GLU_OBJECT_PATH_LENGTH похоже на
GLU_PATH_LENGTH за тем исключением, что величина, заданная для GLU_SAMPLING_TOLERANCE
считается измеряемой в объектном пространстве, а не в пикселях. Точно так же
GLU_OBJECT_PARAMETRIC_ERROR отличается от GLU_PARAMETRIC_ERROR тем, что
значение GLU_SAMPLING_TOLERANCE измеряется в объектном пространстве, а не в
пикселях.</p>

<p class=text align=left style='text-align:left'>Когда <i>value </i>установлено
в значение GLU_DOMAIN_DISTANCE, приложение задает в параметрических
координатах, сколько точек должно быть взято на единицу длины в направлениях <i>u</i>и
<i>v</i>с помощью величин GLU_U_STEP и GLU_V_STEP.</p>

<p class=text align=left style='text-align:left'>Если <i>property </i>установлено
в GLU_SAMPLING_TOLERANCE и режим построения равен GLU_PATH_LENGTH или
GLU_OBJECT_PATH_LENGTH, <i>value </i>управляет максимальной длиной в пикселях
или объектных координатах, соответственно, которая используется для
результирующих полигонов. Например, значение по умолчанию 50.0 ограничивает
максимальную длину сегмента линии или ребра полигона 50.0 пикселями или 50.0
единицами в объектном пространстве. Если <i>property </i>равно
GLU_PARAMETRIC_ERROR и режим построения установлен в GLU_PARAMETRIC_ERROR или
GLU_OBJECT_PARAMETRIC_ERROR, <i>value </i>управляет максимальной дистанцией в
пикселях или объектных координатах между результирующими полигонами и исходной
поверхностью. Для обоих режимов построения значение GLU_PARAMETRIC_ERROR по
умолчанию равно 0.5. Для GLU_PARAMETRIC_ERROR эта величина означает, что
результирующие полигоны должны иметь такой размер и положение, чтобы отстоять
от исходной аналитической поверхности не более, чем на 0.5 пикселя. (Смысл
этого значения для GLU_OBJECT_PARAMETRIC_ERROR вовсе не очевиден.)</p>

<p class=text align=left style='text-align:left'>Если режим построения установлен
в GLU_DOMAIN_DISTANCE, а <i>property </i>равно GLU_U_STEP или GLU_V_STEP, <i>value
</i>является числом точек поверхности, которые нужно вычислить в направлениях <i>u</i>или
<i>v</i> на единицу длины в параметрических координатах. Значениями по
умолчанию для этих параметров является 100.</p>

<p class=text align=left style='text-align:left'>Свойство GLU_AUTO_LOAD_MATRIX
определяет, должны ли видовая и проекционная матрица, а также размеры порта
просмотра извлекаться из сервера OpenGL (в случае значения GL_TRUE – значение
по умолчанию) или приложение должно загрузить эти матрицы с помощью функции <b>gluLoadSamplingMatrices()</b>
(GL_FALSE). </p>

<p class=warning>Замечание:<b> </b>Некоторые свойства NURBS, такие как
GLU_NURBS_MODE и его значение GLU_NURBS_TESSELATOR, а также режимы построения
на основе объектных координат GLU_OBJECT_PATH_LENGTH и
GLU_OBJECT_PARAMETRIC_ERROR появились только в GLU версии 1.3. До версии 1.3
эти режимы и свойства существовали только в качестве расширений отдельных
производителей (если вообще существовали). Перед попыткой использовать эти
свойства обязательно проверьте свою версию GLU.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>gluLoadSamplingMatrices</b>
  (GLUnurbsObj* <i>nobj</i>, const GLfloat <i>modelMatrix[16]</i>, const
  GLfloat <i>projMatrix[16]</i>, const GLint <i>viewport[4]</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Если режим
GLU_AUTO_LOAD_MATRIX выключен, порт просмотра, видовая и проекционная матрицы,
заданные в <b>gluLoadSamplingMatrices()</b> используется для создания расчетной
и отсекающей матриц для каждой кривой или поверхности NURBS.</p>

<p class=text align=left style='text-align:left'>Если вам нужно выяснить
текущую величину одного из свойств NURBS, используйте функцию <b>gluGetNurbsProperty()</b>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>gluGetNurbsProperty</b>
  (GLUnurbsObj* <i>nobj</i>, GLenum <i>property</i>, GLfloat* <i>value</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Возвращает текущее значение
свойства <i>property </i>объекта <i>nobj </i>в переменной <i>value</i>.</p>

<h2>12.2.2.2 Обработка ошибок NURBS </h2>

<p class=text align=left style='text-align:left'>Поскольку насчитывается 37
ошибок, специфических для работы с функциями NURBS, неплохой идеей является
регистрация функции обратного вызова для обработки ошибок. Эта функция будет
вызвана в случае, если вы наткнетесь на одну из специфических ошибок. В примере
12-5 функция обратного вызова регистрируется с помощью строки</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>gluNurbsCallback(theNurb,
  GLU_ERROR, (GLvoid (*)()) nurbsError);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Verdana;
color:black;display:none;mso-hide:all'><o:p>&nbsp;</o:p></span></p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>gluNurbsCallback</b>
  (GLUnurbsObj* <i>nobj</i>, GLenum <i>which</i>, void (* <i>fn</i>)(GLenum <i>errorCode</i>));<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'><i>which </i>задает тип
возвратно вызываемой функции, для функции проверки ошибок <i>which </i>должно
иметь значение GLU_ERROR. Когда механизм работы с NURBS сталкивается с одной из
ошибок, он вызывает функцию <i>fn</i>, передавая ей код ошибки в качестве
единственного аргумента. <i>errorCode </i>представляет собой одно из 37
значений кода ошибки, имеющих символические имена от GLU_NURBS_ERROR1 до
GLU_NURBS_ERROR37. Для получения строки с описание ошибки используйте функцию <b>gluErrorString()</b>.</p>

<p class=text align=left style='text-align:left'>В примере 12-5 в качестве
возвратной функции обработки ошибок была зарегистрирована функция <b>nurbsErrorr()</b>:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void CALLBACK nurbsError(GLenum errorCode)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>char message[100];<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>sprintf(message,&quot;NURBS error: %s\n&quot;,gluErrorString(errorCode));<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>MessageBox(NULL,message,&quot;**NURBS surface&quot;,MB_OK);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span></span><span
  style='color:black'>exit(0);<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>В GLU версии 1.3 были
добавлены дополнительные функции обратного вызова, которые позволяют программе
получать результирующие данные обратно, а не визуализировать их.</p>

<h2>12.2.3 Создание кривой или поверхности NURBS </h2>

<p class=text align=left style='text-align:left'>Чтобы визуализировать
поверхность NURBS, функции <b>gluNurbsSurface()</b> обрамляются вызовами <b>gluBeginSurface()</b>
и <b>gluEndSurface()</b>. Обрамляющие функции сохраняют и восстанавливают
состояние вычислителя.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>gluBeginSurface</b>
  (GLUnurbsObj* <i>nobj</i>);<br>
  void <b>gluEndSurface</b> (GLUnurbsObj* <i>nobj</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>После<span style='mso-ansi-language:
EN-US'> </span>вызова<span style='mso-ansi-language:EN-US'> <b><span
lang=EN-US>gluBeginSurface()</span></b><span lang=EN-US> </span></span>один<span
style='mso-ansi-language:EN-US'> </span>или<span style='mso-ansi-language:EN-US'>
</span>более<span style='mso-ansi-language:EN-US'> </span>вызовов<span
style='mso-ansi-language:EN-US'> </span>функции<span style='mso-ansi-language:
EN-US'> <b><span lang=EN-US>gluNurbsSurface()</span></b><span lang=EN-US> </span></span>задает<span
style='mso-ansi-language:EN-US'> </span>атрибуты<span style='mso-ansi-language:
EN-US'> </span>поверхности<span lang=EN-US style='mso-ansi-language:EN-US'>. </span>Для
генерирования вершин поверхности типа GL_MAP2_VERTEX_3 или GL_MAP2_VERTEX_4
требуется один и только один такой вызов. Функция <b>gluEndSurface()</b>
используется в качестве маркера конца определения поверхности. Декорирование
NURBS также происходит в обрамлении указанных функций.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>gluNurbsSurface</b>
  (GLUnurbsObj* <i>nobj</i>, GLint <i>uknot_count</i>, GLfloat* <i>uknot</i>,
  GLint <i>vknot_count</i>, GLfloat* <i>vkno</i>t, <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  GLint <i>u_stride</i>, GLint <i>v_stride</i>, GLfloat* <i>ctlarray</i>, GLint
  <i>uorder</i>, GLint <i>vorder</i>, GLenum <i>type</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Описывает вершины (или
нормали, или координаты текстуры) поверхности NURBS <i>nobj</i>. Часть величин
должна быть задана для обоих параметрических направлений <i>u</i>и <i>v</i>,
например, узловые последовательности (<i>uknot </i>и <i>vknot</i>), число узлов
(<i>uknot_count </i>и <i>vknot_count</i>) и порядок полинома (<i>uorder </i>и <i>vorder</i>).
Заметьте, что число контрольных точек не задается. Вместо этого число точек
вдоль каждого параметрического направления вычисляется как количество узлов
минус порядок полинома. Далее общее число контрольных точек получается как
произведение двух найденных величин. Аргумент <i>ctlarray </i>указывает на
массив контрольных точек.</p>

<p class=text align=left style='text-align:left'>Последний параметр <i>type </i>должен
быть равен одной из констант, обозначающих тип двумерного вычислителя. Чаще
всего используются GL_MAP2_VERTEX_3 (для нерациональных вершин) и
GL_MAP2_VERTEX_4 (для рациональных). Вы также можете использовать другие типы,
такие как GL_MAP2_TEXTURE_COORD_* или GL_MAP2_NORMAL для вычисления и
ассоциирования координат текстуры и вектора нормали. Например, чтобы создать
освещенную (с вычисленными векторами нормали) и текстурированную поверхность
NURBS, вам может понадобиться выполнить следующую последовательность команд:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>gluBeginSurface(nobj);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>gluNurbsSurface(nobj, ..., GL_MAP2_TEXTURE_COORD_2);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>gluNurbsSurface(nobj, ..., GL_MAP2_NORMAL);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>gluNurbsSurface(nobj, ..., GL_MAP2_VERTEX_3);<o:p></o:p></span></pre><pre><span
  style='color:black'>glEndSurface();<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Аргументы <i>u_stride </i>и <i>v_stride</i>
представляют количество дробных величин между контрольными точками в каждом
параметрическом направлении. На значение аргументов <i>u_stride </i>и <i>v_stride
</i>влияют&nbsp; тип вычислителя и его порядок. Так в примере 12-5 <i>u_stride </i>равен
12 (4*3), поскольку задаются 3 координаты для каждой вершины (GL_MAP2_VERTEX_3)
и четыре контрольные точки в параметрическом направлении <i>v</i>, <i>v_stride </i>равен
3, поскольку каждая вершина имеет 3 координаты и точки <i>v </i>расположены в
памяти плотно одна за одной.</p>

<p class=text align=left style='text-align:left'>Рисование кривой NURBS похоже
на рисование поверхности, за тем исключением, что вычисления производятся по
одному параметру – <i>u</i>, а не по двум. Кроме того, для кривых используются
обрамляющие функции <b>gluBeginCurve()</b> и <b>gluEndCurve()</b>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>gluBeginCurve</b>
  (GLUnurbsObj* <i>nobj</i>);<br>
  void <b>gluEndCurve</b> (GLUnurbsObj* <i>nobj</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>После вызова <b>gluBeginCurve()</b>,
один или несколько вызовов <b>gluNurbsCurve()</b> определяют атрибуты кривой.
Для генерирования вершин кривой типа GL_MAP1_VERTEX_3 или GL_MAP1_VERTEX_4
требуется один и только один такой вызов. Для завершения определения кривой,
используйте функцию <b>gluEndCurve()</b>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>gluNurbsCurve</b>
  (GLUnurbsObj* <i>nobj</i>, GLint <i>uknot_count</i>, GLfloat* <i>uknot</i>,
  GLint <i>u_stride</i>, GLfloat* <i>ctlarray</i>, GLint <i>uorder</i>, GLenum <i>type</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Определяет кривую NURBS для
объекта <i>nobj</i>. Аргументы имеют тот же смысл, что и для <b>gluNurbsSurface()</b>.
Заметьте, что эта функция требует только одной узловой последовательности и
одного объявления порядка для объекта NURBS. Если эта кривая определяется
внутри блока <b>gluBeginCurve()</b> / <b>gluEndCurve()</b>, аргумент <i>type</i>может
иметь любое значение, допустимое для типа одномерного вычислителя (например,
GL_MAP1_VERTEX_3 или GL_MAP1_VERTEX_4). </p>

<h2>12.2.3.1 Получение примитивов из тесселятора NURBS обратно</h2>

<p class=text align=left style='text-align:left'>По умолчанию тесселятор NURBS
разбивает объект NURBS на геометрические линии и полигоны, и визуализирует их.
В GLU версии 1.3 были добавлены дополнительные возвратные функции, так что
вместо визуализации пост – тесселяционных величин, они могут быть возвращены
для использования программе.</p>

<p class=text align=left style='text-align:left'>Чтобы это сделать, первым
шагом является вызов функции <b>gluNurbsProperty()</b> для установки свойства
GLU_NURBS_MODE в режим GLU_NURBS_TESSELATOR. Следующие шагом является
выполнение нескольких вызовов функции <b>gluNurbsCallback()</b> для регистрации
функций обратного вызова, которые будут вызываться тесселятором NURBS.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>gluNurbsCallback</b>
  (GLUnurbsObj* <i>nobj</i>, GLenum <i>which</i>, void (*<i>fn</i>)());<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'><i>nobj </i>представляет собой
тесселируемый объект NURBS. <i>which </i>– это перечислимое значение,
идентифицирующее тип возвратной функции. Если свойство GLU_NURBS_MODE
установлено в режим GLU_NURBS_TESSELATOR, то помимо функции GLU_ERROR можно
зарегистрировать еще 12 функций. (В противном случае, активна только функция
GLU_ERROR.) 12 возвратных функций идентифицируются следующими константами и
имеют следующие прототипы:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLU_NURBS_BEGINtd&gt; <o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>void <b>begin</b> (GLenum <i>type</i>);<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLU_NURBS_BEGIN_DATA<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>void <b>begin</b> (GLenum <i>type</i>, void* <i>userData</i>);<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLU_NURBS_TEXTURE_COORD<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>void <b>texCoord</b> (GLfloat* <i>tCrd</i>);<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLU_NURBS_TEXTURE_COORD_DATA<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>void <b>texCoord</b> (GLfloat* <i>tCrd</i>, void* <i>userData</i>);<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLU_NURBS_COLOR<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>void <b>color</b> (GLfloat* <i>color</i>);<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:5'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLU_NURBS_COLOR_DATA<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>void <b>color</b> (GLfloat* <i>color</i>, void* <i>userData</i>);<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:6'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLU_NURBS_NORMAL<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>void <b>normal</b> (GLfloat* <i>nml</i>);<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:7'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLU_NURBS_NORMAL_DATA<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>void <b>normal</b> (GLfloat* <i>nml</i>, void* <i>userData</i>);<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:8'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLU_NURBS_VERTEX<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>void <b>vertex</b> (GLfloat* <i>vertex</i>);<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:9'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLU_NURBS_VERTEX_DATA<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>void <b>vertex</b> (GLfloat* <i>vertex</i>, void* <i>userData</i>);<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:10'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLU_NURBS_END<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>void <b>end</b> (void);<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:11;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GLU_NURBS_END_DATA<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>void <b>end</b> (void* <i>userData</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Чтобы изменить возвратную
функцию, зарегистрируйте новую с тем же типом. Чтобы отменить регистрацию
функции вообще, вызовите <b>gluNurbsCallback()</b> с нулевым указателем для
соответствующего типа функции.</p>

<p class=text align=left style='text-align:left'>6 возвратных функций позволяют
пользователю передавать в них некоторые данные. Чтобы задать пользовательские
данные, вызовите <b>gluNurbsCallbackData()</b>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>gluNurbsCallbackData</b>
  (GLUnurbsObj* <i>nobj</i>, void* <i>userData</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'><i>nobj </i>представляет собой
тесселируемый объект NURBS. <i>userData </i>это данные, которые должны быть
переданы функции обратного вызова.</p>

<p class=text align=left style='text-align:left'>В течение тесселяции возвратно
– вызываемые функции вызываются в той же манере, к какой вы используете команды
<b>glBegin()</b>, <b>glTexCoord*()</b>, <b>glColor*()</b>, <b>glNormal*()</b>, <b>glVertex*()</b>
и <b>glEnd()</b>. В режиме GLU_NURBS_TESSELATOR кривая или поверхность не
визуализируются на экране, но вы можете захватить вершинные данные,
передаваемые в качестве параметров возвратным функциям.</p>

<p class=text align=left style='text-align:left'>Чтобы продемонстрировать эти
новые возвратные функции, обратимся к примерам 12-6 и 12-7. В примере 12-6
показана часть функции <b>init()</b>, где создается объект NURBS, устанавливается
режим GLU_NURBS_TESSELATOR для свойства GLU_NURBS_MODE и регистрируются функции
обратного вызова.</p>

<p class=text align=left style='text-align:left'>Пример 12-6. Регистрация
возвратных функций тесселяции NURBS: файл surfpoints.cpp</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  style='color:black'>void init(void)<o:p></o:p></span></pre><pre><span
  style='color:black'>{<o:p></o:p></span></pre><pre><span style='color:black'><span style='mso-spacerun:yes'>      </span>/* часть функции init() */<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>theNurb=gluNewNurbsRenderer();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>gluNurbsProperty(theNurb, GLU_NURBS_MODE, GLU_NURBS_TESSELATOR);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>gluNurbsProperty(theNurb,GLU_SAMPLING_TOLERANCE,100.0);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>gluNurbsProperty(theNurb,GLU_DISPLAY_MODE,GLU_FILL);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>gluNurbsCallback(theNurb,GLU_ERROR,nurbsError);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>gluNurbsCallback(theNurb,GLU_NURBS_BEGIN,beginCallback);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>gluNurbsCallback(theNurb,GLU_NURBS_VERTEX,vertexCallback);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>gluNurbsCallback(theNurb,GLU_NURBS_NORMAL,normalCallback);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>gluNurbsCallback(theNurb,GLU_NURBS_END,endCallback);<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Пример 12-7 демонстрирует сами
функции обратного вызова. В этих функциях <b>printf()</b> выступает в качестве
инструмента диагностики, показывающего директивы и вершинные данные,
возвращаемые из тесселятора. Кроме того, пост – тесселяционные данные посылаются
на конвейер для обычной визуализации.</p>

<p class=text align=left style='text-align:left'>Пример 12-7. Возвратно
вызываемые функции тесселятора NURBS: файл surfpoints.cpp</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  style='color:black'>void CALLBACK beginCallback(GLenum whichType)<o:p></o:p></span></pre><pre><span
  style='color:black'>{<o:p></o:p></span></pre><pre><span style='color:black'><span style='mso-spacerun:yes'>      </span>glBegin(whichType);<span style='mso-spacerun:yes'>     </span>//Посылаем данные на конвейер<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>printf(&quot;glBegin(&quot;);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>switch(whichType)//Вывести диагностическое сообщение<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>{<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>case GL_LINES:<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>printf(“GL_LINES)\n”);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>break;<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>case GL_LINE_LOOP:<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>printf(“GL_LINE_LOOP)\n”);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>           </span><span style='mso-spacerun:yes'>       </span>break;<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>case GL_LINE_STRIP:<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>printf(“GL_LINE_STRIP)\n”);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>break;<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>case GL_TRIANGLES:<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>printf(“GL_TRIANGLES)\n”);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>break;<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>case GL_TRIANGLE_STRIP:<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>  </span><span style='mso-spacerun:yes'>                </span>printf(“GL_TRIANGLE_STRIP)\n”);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>break;<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>case GL_TRIANGLE_FAN:<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>printf(“GL_TRIANGLE_FUN)\n”);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>break;<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>case GL_QUADS:<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>printf(“GL_QUADS)\n”);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>        </span><span style='mso-spacerun:yes'>          </span>break;<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>case GL_QUAD_STRIP:<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>printf(“GL_QUAD_STRIP)\n”);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>break;<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>case GL_POLYGON:<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>printf(“GL_POLYGON)\n”);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>break;<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>default:<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>break;<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>}<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre><pre><span style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>void CALLBACK endCallback()<o:p></o:p></span></pre><pre><span
  style='color:black'>{<o:p></o:p></span></pre><pre><span style='color:black'><span style='mso-spacerun:yes'>      </span>glEnd();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>printf(“glEnd()\n”);<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre><pre><span style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>void CALLBACK vertexCallback(GLfloat* vertex)<o:p></o:p></span></pre><pre><span
  style='color:black'>{<o:p></o:p></span></pre><pre><span style='color:black'><span style='mso-spacerun:yes'>      </span>glVertex3fv(vertex);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>printf(&quot;glVertex3f (%5.3f, %5.3f, %5.3f)\n&quot;,<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>              </span>vertex[0],vertex[1],vertex[2]);<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre><pre><span style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>void CALLBACK normalCallback(GLfloat* normal)<o:p></o:p></span></pre><pre><span
  style='color:black'>{<o:p></o:p></span></pre><pre><span style='color:black'><span style='mso-spacerun:yes'>      </span>glNormal3fv(normal);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>printf(“glNormal3f (%5.3f, %5.3f, %5.3f)\n”, <o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>             </span>normal[0], normal[1], normal[2]);<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<h2>12.2.4 Декорирование поверхностей NURBS </h2>

<p class=text align=left style='text-align:left'>Чтобы создать декорированную
поверхность NURBS с помощью OpenGL, начните так же как и при создании обычной
поверхности. После вызовов <b>gluBeginSurface()</b> и <b>gluNurbsSurface()</b>,
но до вызова <b>gluEndSurface()</b> начните декорирование с вызова <b>gluBeginTrim()</b>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>gluBeginTrim</b>
  (GLUnurbsObj* <i>nobj</i>);<br>
  void <b>gluEndTrim</b> (GLUnurbsObj* <i>nobj</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Маркируют начало и конец
определения декорирующих кривых и поверхностей. Декорирующий круг – это набор
ориентированных декорирующих сегментов кривой (формирующих замкнутую кривую),
определяющих границы поверхности NURBS.</p>

<p class=text align=left style='text-align:left'>Вы можете создавать два вида
декорирующих кривых: кусочную линейную кривую с помощью <b>gluPwlCurve()</b>
или кривую NURBS с помощью <b>gluNurbsCurve()</b>. Кусочная линейная кривая не
выглядит как то, что обычно называют кривой, поскольку состоит она из прямых
линий. Кривая NURBS для декорирования должна лежать в единичном параметрическом
пространстве (<i>u</i>, <i>v</i>). Типом для декорирующей кривой NURBS обычно
является GLU_MAP1_TRIM_2. Реже, типом является GLU_MAP1_TRIM_3, где кривая
описывается в двумерном однородном пространстве (<i>u’</i>, <i>v’</i>, <i>w’</i>)
как (<i>u</i>, <i>v</i>)=(<i>u’/w’</i>, <i>v’/w’</i>).</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>gluPwlCurve</b>
  (GLUnurbsObj* <i>nobj</i>, GLint <i>count</i>, GLfloat* <i>array</i>, GLint <i>stride</i>,
  GLenum <i>type</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Описывает кусочную линейную
декорирующую кривую для NURBS Объекта <i>nobj</i>. На кривой <i>count </i>точек,
задаваемых в массиве <i>array</i>. Аргумент <i>type </i>может принимать
значения GLU_MAP1_TRIM_2 (более часто) или GLU_MAP1_TRIM_3 (однородное
параметрическое пространство (<i>u</i>, <i>v</i>, <i>w</i>)). Значение <i>type </i>определяет
значение <i>stride</i>, которое может быть равно 2 или 3. <i>stride </i>должен
быть равен количеству величин между соседними вершинами в <i>array</i>.</p>

<p class=text align=left style='text-align:left'>Вы должны определиться с
ориентацией обрамляющих кривых – будет ли она против часовой стрелки или по
часовой стрелке – чтобы быть уверенными в том, что вы включите нужную часть
поверхности. Если вы представите себя идущим вдоль кривой, все, что находится
слева от вас, будет нарисовано, а все, что справа, будет отброшено. Например,
если ваша кривая состоит из одного цикла против часовой стрелки, все что
находится внутри кривой, будет включено. Если декорирующая кривая состоит из
двух непересекающихся циклов против часовой стрелки, имеющих непересекающиеся
границы, будет включено все, что находится в обоих циклах. Если она состоит из
одного цикла против часовой стрелки с двумя циклами по часовой стрелке внутри
него, включаемая область будет иметь 2 дыры в ней. Самая внешняя кривая должна
иметь ориентацию против часовой стрелки. Часто, вы запускаете декорирующую
кривую по всему параметрическому пространству, чтобы включить все, что
находится внутри. Этот результат соответствует тому, что вы получаете без
декорирования вообще.</p>

<p class=text align=left style='text-align:left'>Декорирующие кривые должны
быть закрытыми и непересекающимися. Вы можете комбинировать кривые, если
конечные точки кривых формируют закрытую кривую. Вы можете вкладывать кривые
одну в другую, создавая острова, плавающие в пространстве. Убедитесь в
правильности ориентации кривой. Например, если вы зададите два декорирующих
региона против часовой стрелки, причем так, что один находится внутри другого,
произойдет ошибка, поскольку регион, находящийся между ними, находится слева от
одной кривой и справа от другой, то есть он одновременно должен быть и включен
и исключен. Рисунок 12-6 демонстрирует несколько допустимых случаев.</p>

<p class=text align=left style='text-align:left'>Рисунок 12-6. Параметрические
декорирующие кривые </p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1500" type="#_x0000_t75" alt="" style='width:465pt;height:275.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image361.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов12.mht!http://www.progz.ru/images/opengl/chapter12/12-6.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=620 height=367
src="OpenGL%20Red%20Book.files/image361.jpg" v:shapes="_x0000_i1500"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>На рисунке 12-7 показан тот же
холм, что и на рисунке 12-5, но к нему добавлена декорирующая кривая, состоящая
из кусочной кривой и кривой NURBS. Программа, которая создает это изображение
аналогично примеру 12-5 за исключение фрагмента, показанного в примере 12-8.</p>

<p class=text align=left style='text-align:left'>Рисунок 12-7. Декорированная
поверхность NURBS </p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1501" type="#_x0000_t75" alt="" style='width:387.75pt;height:183.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image362.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов12.mht!http://www.progz.ru/images/opengl/chapter12/12-7.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=517 height=245
src="OpenGL%20Red%20Book.files/image362.jpg" v:shapes="_x0000_i1501"><![endif]></p>

<p class=text align=left style='text-align:left'>Пример 12-7. Декорирование
поверхности NURBS: файл trim.cpp</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  style='color:black'>void display()<o:p></o:p></span></pre><pre><span
  style='color:black'>{<o:p></o:p></span></pre><pre><span style='color:black'><span style='mso-spacerun:yes'>      </span>GLfloat knots[8]={0.0,0.0,0.0,0.0,1.0,1.0,1.0,1.0};<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>GLfloat edgePt[5][2]= /* против часовой стрелки */<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>{{0.0,0.0},{1.0,0.0},{1.0,1.0},{0.0,1.0},<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>             </span>{0.0,0.0}};<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>GLfloat curvePt[4][2]= /* по часовой стрелке */<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>{{0.25,0.5}, {0.25,0.75}, {0.75,0.75}, {0.75,0.5}};<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>GLfloat curveKnots[8]={0.0,0.0,0.0,0.0,1.0,1.0,1.0,1.0};<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>GLfloat pwlPt[3][2]= /* по часовой стрелке */<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>{{0.75,0.5}, {0.5,0.25}, {0.25,0.5}};<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glPushMatrix();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glRotatef(330.0,1.0,0.0,0.0);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glScalef(0.5,0.5,0.5);<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>gluBeginSurface(theNurb);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>gluNurbsSurface(theNurb,8,knots,8,knots,4*3,3,<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                            </span>&amp;ctrlpoints[0][0][0],4,4,GL_MAP2_VERTEX_3);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>gluBeginTrim(theNurb);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>              </span><span style='mso-spacerun:yes'>    </span>gluPwlCurve(theNurb,5,&amp;edgePt[0][0],2,GLU_MAP1_TRIM_2);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span></span><span
  style='color:black'>gluEndTrim(theNurb);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>gluBeginTrim(theNurb);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>gluNurbsCurve(theNurb,8,curveKnots,2,<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                               </span>&amp;curvePt[0][0],4,GLU_MAP1_TRIM_2);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span><span style='mso-spacerun:yes'>            </span>gluPwlCurve(theNurb,3,&amp;pwlPt[0][0],2,GLU_MAP1_TRIM_2);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>gluEndTrim(theNurb);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>gluEndSurface(theNurb);<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glPopMatrix();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glFlush();<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>В примере 12-8 вызовы <b>gluBeginTrim()</b>
и <b>gluEndTrim()</b> обрамляют каждую декорирующую кривую. Первая из них с
вершинами, определенными в массиве <i>edgePt[ ][ ]</i>, проходит против часовой
стрелки вокруг всего единичного квадрата параметрического пространства. Это
позволяет быть уверенным в том, что будет нарисовано все (если, конечно, часть
поверхности не будет удалена внутренней кривой с ориентацией по часовой
стрелке). Вторая кривая – это комбинация кривой NURBS и кусочной линейной
кривой. Кривая NURBS заканчивается в точках (<i>0.9</i>, <i>0.5</i>) и (<i>0.1</i>,
<i>0.5</i>), где она соединяется с линейной кривой, формируя замкнутую кривую.</p>

<p class=MsoNormal><a name=Глава13><span style='display:none;mso-hide:all'><o:p>&nbsp;</o:p></span></a></p>

<h1 align=left style='text-align:left'><span style='mso-bookmark:Глава13'>Глава
13. Режим выбора и обратный режим</span></h1>

<span style='mso-bookmark:Глава13'></span>

<p class=MsoNormal><a href="mailto:ahinar@list.ru"></a><span style='font-size:
10.0pt;font-family:Verdana'>Некоторые графические приложения просто рисуют
статические изображения двумерных или трехмерных объектов. Другие приложения
позволяют пользователю выбирать объект на экране, а затем двигать, изменять,
удалять или как-либо еще манипулировать этим объектом. OpenGL разработана для
поддержки именно таких интерактивных приложений. Поскольку объекты, рисуемые на
экране обычно претерпевают множественные повороты, переносы и перспективные
преобразования, для вас может быть достаточно сложно определить, какой объект в
трехмерной сцене выбрал пользователь. Чтобы помочь вам, OpenGL предоставляет
механизм выбора (selection mechanism), который автоматически вычисляет и сообщает
вам, какие объекты нарисованы внутри заданного региона окна. Вы можете
использовать этот механизм совместно со специальной утилитарной функцией,
определяющей внутри региона конкретный объект, который пользователь <i>указал</i>
(<i>picking</i>) с помощью курсора.<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>На самом деле выбор – это один
из режимов выполнения операций OpenGL; отклик (feedback) является еще одним
таким режимом. В режиме отклика ваша графическая аппаратура и OpenGL
используются для выполнения обычных расчетов для визуализации. Однако вместо
того, чтобы использовать вычисленные величины для рисования изображения на
экране, OpenGL возвращает информацию о рисовании вам. Например, если вы хотите
отобразить трехмерную сцену на плоттере, а не на экране, вы можете нарисовать
объекты в режиме отклика, собрать инструкции, необходимые для рисования и
преобразовать их в команды, которые плоттер может понять и выполнить.</p>

<p class=text align=left style='text-align:left'>И в режиме выбора, и в режиме
отклика информация о рисовании возвращается приложению, а не отсылается в буфер
кадра, как происходит в режиме визуализации. Таким образом, изображение на
экране не меняется – ничего не рисуется, пока OpenGL находится в режимах выбора
или отклика. В этих режимах цветовой буфер, буфер глубины, буфер трафарета и
аккумуляторный буфер не используются. В данной главе каждый из указанных
режимов описан в отдельном разделе.</p>

<h2>13.1 Выбор</h2>

<p class=text align=left style='text-align:left'>Обычно, когда вы планируете
использовать механизм выбора OpenGL, вы сначала рисуете вашу сцену в буфере
кадра, а затем переходите в режим выбора и перерисовываете сцену. Однако после
того, как вы вошли в режим выбора, содержимое буфера кадра не меняется до тех
пор, пока вы не покинете этот режим. Когда вы выходите из режима выбора, OpenGL
возвращает список примитивов, пересекающих объем видимости (помните, что объем
видимости определяется текущими видовой и проекционной матрицами, а также
дополнительными плоскостями отсечения). Каждый примитив, имеющий пересечение с
объемом видимости вызывает то, что называется <i>попаданием</i> (<i>hit</i>).
На самом деле список примитивов возвращается в виде массива целочисленных <i>имен</i>
и связанных данных – <i>записей о попаданиях</i> (<i>hitrecords</i>) –
соответствующих текущему содержимому <i>стека имен</i>. Находясь в режиме
выбора, вы конструируете стек имен, загружая в него имена одновременно с
выполнением команд для рисования примитивов. Таким образом, когда список имен
возвращается в программу, вы можете использовать его для определения тех
примитивов, которые пользователь мог выбрать на экране.</p>

<p class=text align=left style='text-align:left'>Вдобавок к этому механизму
выбора OpenGL предоставляет утилитарную функцию, разработанную для упрощения
процесса выбора в некоторых случаях, путем ограничения рисования небольшой
областью порта просмотра. Обычно эта функция используется для обнаружения
объектов, нарисованных вблизи курсора, чтобы вы могли идентифицировать каждый
объект, который указал пользователь. (Вы также можете ограничить область выбора
за счет добавления дополнительных плоскостей отсечения. Помните, что эти
плоскости действуют в мировом пространстве, а не в экранном.) Поскольку
указание объектов (picking) это специальный случай выбора как такового, в
данной главе выбор описывается первым, а указание за ним.</p>

<h2>13.1.1 Основные шаги</h2>

<p class=text align=left style='text-align:left'>Чтобы использовать механизм
выбора, вам нужно выполнить следующие шаги.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l20 level1 lfo55;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>1.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>С помощью команды <b>glSelectBuffer()</b>
задайте массив, который будет использоваться для возвращения записей о
попаданиях. </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l20 level1 lfo55;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>2.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Перейдите в режим выбора, передав аргумент
GL_SELECT команде <b>glRenderMode()</b>. </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l20 level1 lfo55;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>3.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Инициализируйте стек имен с помощью команд <b>glInitNames()</b>
и <b>glPushName()</b>. </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l20 level1 lfo55;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>4.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Определите объем видимости, который вы хотите
использовать для режима выбора. Обычно этот объем отличается от того, который
изначально использовался для рисования сцены, так что, скорее всего, вам нужно
будет сохранить и позже восстановить состояние преобразований с помощью команд <b>glPushMatrix()</b>
и <b>glPopMatrix()</b>. </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l20 level1 lfo55;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>5.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Чередуйте выполнение команд для рисования
примитивов с командами для манипуляций со стеком имен, дабы быть уверенными в
том, что каждый интересующий вас полигон получил соответствующее имя. </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l20 level1 lfo55;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>6.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Выйдите из режима выбора и обработайте
возвращенные данные о выборе (записи о попаданиях). </p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glSelectBuffer</b>
  (GLsizei <i>size</i>, GLuint* <i>buffer</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Задает массив, который будет
использоваться для возвращения информации о выбранных примитивах. Аргумент <i>buffer
</i>должен быть указателем на массив беззнаковых целых, в который будут помещаться
данные, а аргумент <i>size</i>– задает максимальное количество величин, которые
могут быть записаны в этот массив. Вы должны вызвать команду <b>glSelectBuffer()</b>
до перехода в режим выбора.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>GLint <b>glRenderMode</b>
  (GLenum<i>mode</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Управляет тем, в каком режиме
приложение находится в текущий момент. Аргумент <i>mode </i>может принимать
значения GL_RENDER (режим визуализации, значение по умолчанию), GL_SELECTION
(режим выбора) или GL_FEEDBACK (режим отклика). Приложение остается в заданном
режиме до того, как команда <b>glRenderMode()</b> не будет вызвана снова с
другим аргументом. До перехода в режим выбора вы должны задать буфер выбора с
помощью команды <b>glSelectBuffer()</b>. Похожим образом, до перехода в режим
отклика с помощью команды <b>glFeedbackBuffer()</b> должен быть задан массив
отклика. Возвращаемое значение команды <b>glRenderMode()</b> имеет смысл,
только если текущим режимом визуализации (именно текущим, а не заданным в
аргументе) является GL_SELECT или GL_FEEDBACK. Возвращаемое значение
представляет собой число записей о попаданиях или число величин, занесенных в
массив отклика при выходе из режимов GL_SELECT или GL_FEEDBACK соответственно;
отрицательная величина означает, что буфер выбора или отклика переполнен. Для
выяснения того, в каком режиме вы находитесь в данный момент, используйте аргумент
GL_RENDER_MODE в команде <b>glGetIntegerv()</b>.</p>

<h2>13.1.2 Создание стека имен</h2>

<p class=text align=left style='text-align:left'>Как было указано ранее, стек
имен формирует базис для информации о выборе, которая к вам возвращается. Чтобы
создать стек имен, сначала инициализируйте его командой <b>glInitNames()</b>,
которая просто очищает стек, а затем добавляйте в него целочисленные имена в
процессе исполнения соответствующих команд рисования. Как вы можете ожидать,
команды манипулирования стеком имен позволяют поместить имя на вершину стека с
продвижением всех, содержащихся в нем, глубже (<b>glPushName()</b>), поднять
имя из стека на вершину, потеряв при этом предыдущее имя на вершине (<b>glPopName()</b>)
и заменить имя на вершине стека каким-либо другим (<b>glLoadName()</b>). Пример
кода, манипулирующего стеком имен, продемонстрирован в примере 13-1.</p>

<p class=text align=left style='text-align:left'>Пример 13-1. Создание стека
имен</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  style='color:black'>glInitStack();<o:p></o:p></span></pre><pre><span
  style='color:black'>glPushName(0);<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>glPushMatrix();<span style='mso-spacerun:yes'>   </span>/* сохраняем текущее состояние преобразований */<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>/* здесь создается требуемый объем видимости */<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glLoadName(1);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>нарисовать_Какой_либо_Объект();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glLoadName(2);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>нарисовать_Другой_Объект();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glLoadName(3);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>нарисовать_Еще_Один_Объект();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>нарисовать_Последний_Объект();<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>glPopMatrix();<span style='mso-spacerun:yes'>    </span>/* восстанавливаем предыдущее состояние преобразований */<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>В этом примере первые два рисуемых
объекта имеют свои собственные имена, а третий и четвертый объекты разделяют
одно общее имя. При такой настройке, если третий или четвертый объект или оба
сразу вызовут попадание, вам будет возвращена только одна запись о попадании.
Вы можете заставить несколько объектов разделять одно общее имя, если вам не
нужно разделять их при обработке записей.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>glInitNames</b>
  (void);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Полностью очищает стек имен.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>glPushName</b>
  (GLuint <i>name</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Помещает name на вершину
стека. Помещение имени, в полный стек генерирует ошибку GL_STACK_OVERFLOW.
Размер стека имен может быть разным в разных реализациях OpenGL, но в любой
реализации стек должен иметь вместимость, как минимум, для 64 имен. Для
выяснения реальной глубины стека имен вы можете использовать аргумент GL_NAME_STACK_DEPTH
в команде <b>glGetIntegerv()</b>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>glPopName</b> (void);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Поднимает имя из стека на
вершину. Извлечение имени из пустого стека генерирует ошибку
GL_STACK_UNDERFLOW.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>glLoadName</b>
  (GLuint <i>name</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Заменяет имя на вершине стека
величиной <i>name</i>. Если стек пуст, что вполне нормально после вызова <b>glInitNames()</b>,
вызов команды <b>glLoadName()</b> сгенерирует ошибку GL_INVALID_OPERATION.
Чтобы этого избежать, сразу после инициализации стека поместите что-либо на его
вершину командой <b>glPushName()</b> до вызова <b>glLoadName()</b>.</p>

<p class=text align=left style='text-align:left'>Обращения к <b>glPushName()</b>,
<b>glPopName()</b> и <b>glLoadName()</b> игнорируются, если программа не
находится в режиме выбора. Вы можете обнаружить, что этот факт упрощает
смешивание этих команд с командами рисования – вы можете использовать такой
смешанный код для отображения объектов на экране, а затем использовать его же
для получения информации о выборе.</p>

<h2>13.1.3 Запись о попадании</h2>

<p class=text align=left style='text-align:left'>В режиме выбора примитивы,
имеющие пересечения с объемом видимости, вызывают попадание. Каждый раз, когда
выполняется команда манипулирования стеком имен или команда <b>glRenderMode()</b>,
OpenGL записывает запись о попадании в буфер выбора, если попадание было
зафиксировано после последней манипуляции со стеком или выполнения команды <b>glRenderMode()</b>.
В течение этого процесса объекты, разделяющие общее имя – например, объекты,
состояние из нескольких примитивов – не генерируют множественных записей о
попаданиях. Кроме того, не гарантируется, что записи о попаданиях будут
записаны в буфер выбора до вызова команды <b>glRenderMode()</b>.</p>

<p class=warning>Замечание: Помимо примитивов попадание могут вызвать
допустимые координаты, обозначенные в команде <b>glRasterPos()</b>. Кроме того,
в случае полигонов попадания не происходит, если полигон отбрасывается
механизмом удаления нелицевых граней.</p>

<p class=text align=left style='text-align:left'>Каждая запись о попадании
состоит из 4 элементов (они перечислены по порядку):</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l25 level1 lfo56;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Количество имен в стеке в момент попадания. </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l25 level1 lfo56;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Минимальная и максимальная координата <i>z </i>(оконная)
всех вершин примитивов, пересекающих объем видимости с момента последнего
попадания. Эти две величины, лежащие в диапазоне [<i>0</i>, <i>1</i>]
умножаются на <!--[if gte vml 1]><v:shape id="_x0000_i1502" type="#_x0000_t75"
 alt="" style='width:41.25pt;height:18.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image363.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов13.mht!http://www.progz.ru/images/opengl/chapter13/form001.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=55 height=25
src="OpenGL%20Red%20Book.files/image363.jpg" v:shapes="_x0000_i1502"><![endif]>&nbsp;и
округляются до ближайшего беззнакового целого.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l25 level1 lfo56;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Содержимое стека имен на момент попадания. При
этом первым элементом стоит элемент со дна стека.</p>

<p class=text align=left style='text-align:left'>Когда вы переходите в режим
выбора, OpenGL инициализирует указатель на начало массива выбора. Каждый раз,
когда запись о попадании записывается в массив, значение указателя обновляется.
Если занесение записи о попадании должно привести к тому, что общее количество
величин превысит аргумент size указанный в команде <b>glSelectBuffer()</b>,
OpenGL записывает в буфер допустимую часть записи и устанавливает флаг
переполнения. Когда вы выходите из режима выбора командой <b>glRenderMode()</b>,
эта команда возвращает общее количество записей о попаданиях, занесенных в
массив выбора (включая и частично записанную запись, если таковая была),
очищает стек имен, сбрасывает флаг переполнения и сбрасывает указатель стека.
Если флаг переполнения был установлен, возвращаемое значение равно -1.</p>

<h2>13.1.4 Пример реализации выбора</h2>

<p class=text align=left style='text-align:left'>В примере 13-2 на экране с
помощью функции <b>drawTriangle()</b> рисуются 4 треугольника: зеленый, красный
и два желтых, а также каркасный параллепипед, представляющий объем видимости
(функция <b>drawViewVolume()</b>). Затем треугольники визуализируются еще раз,
но на этот раз в режиме выбора (функция <b>selectObjects()</b>).
Соответствующие записи о попаданиях обрабатываются в функции <b>processHits()</b>
и массив выбора распечатывается в консольном окне. Первый треугольник
генерирует попадание, второй не генерирует его, а третий и четвертый вместе
генерируют одно попадание. Результат работы программы показан на рисунке 13-1.</p>

<p class=text align=left style='text-align:left'>Рисунок 13-1. Пример
реализации выбора </p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1503" type="#_x0000_t75" alt="" style='width:210pt;height:210pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image364.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов13.mht!http://www.progz.ru/images/opengl/chapter13/13-1.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=280 height=280
src="OpenGL%20Red%20Book.files/image364.jpg" v:shapes="_x0000_i1503"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Пример 13-2. Пример реализации
выбора: файл select.cpp</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#include <o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#include <o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>#include <o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void drawTriangle(GLfloat x1,GLfloat y1,GLfloat x2,GLfloat y2,GLfloat x3,GLfloat y3,GLfloat z)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glBegin(GL_TRIANGLES);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>glVertex3f(x1,y1,z);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>glVertex3f(x2,y2,z);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>glVertex3f(x3,y3,z);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glEnd();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void drawViewVolume(GLfloat x1,GLfloat x2,GLfloat y1,GLfloat y2,GLfloat z1,GLfloat z2)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glColor3f(1.0,1.0,1.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glBegin(GL_LINE_LOOP);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>glVertex3f(x1,y1,-z1);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>glVertex3f(x2,y1,-z1);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>glVertex3f(x2,y2,-z1);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>glVertex3f(x1,y2,-z1);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glEnd();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glBegin(GL_LINE_LOOP);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>glVertex3f(x1,y1,-z2);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>glVertex3f(x2,y1,-z2);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>glVertex3f(x2,y2,-z2);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>glVertex3f(x1,y2,-z2);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glEnd();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glBegin(GL_LINES);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>glVertex3f(x1,y1,-z1);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>glVertex3f(x1,y1,-z2);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>glVertex3f(x1,y2,-z1);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>glVertex3f(x1,y2,-z2);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>glVertex3f(x2,y1,-z1);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>glVertex3f(x2,y1,-z2);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>glVertex3f(x2,y2,-z1);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>glVertex3f(x2,y2,-z2);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glEnd();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void drawScene()<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glMatrixMode(GL_PROJECTION);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glLoadIdentity();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>gluPerspective(40.0,4.0/3.0,1.0,100.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glMatrixMode(GL_MODELVIEW);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glLoadIdentity();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>gluLookAt(7.5,7.5,12.5,2.5,2.5,-5.0,0.0,1.0,0.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glColor3f(0.0,1.0,0.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>drawTriangle(2.0,2.0,3.0,2.0,2.5,3.0,-5.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glColor3f(1.0,0.0,0.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>drawTriangle(2.0,7.0,3.0,7.0,2.5,9.0,-5.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glColor3f(1.0,1.0,0.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>drawTriangle(2.0,2.0,3.0,2.0,2.5,3.0,0.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>drawTriangle(2.0,2.0,3.0,2.0,2.5,3.0,-10.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>drawViewVolume(0.0,5.0,0.0,5.0,0.0,10.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void processHits(GLint hits,GLuint buffer[])<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>int i,j;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>GLuint names, *ptr;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>printf(&quot;hits=%d\n&quot;,hits);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>ptr=(GLuint*)buffer;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>for (i=0;i&lt; pre&gt;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span
  style='mso-tab-count:1'>        </span><o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Эта программа генерирует
следующий вывод:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>Green triangle name is 1<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>Red triangle name is 2<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>Yellow triangles name are 3<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>hits=2<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'> number of names for hit=1<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'> z1 is 0.999999; z2 is 0.999999;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'> the names are 1 <o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'> </span>number of names for hit=1<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>  </span>z1 is 0; z2 is 2;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'> the names are 3<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<h2>13.1.5 Указание</h2>

<p class=text align=left style='text-align:left'>В качестве расширения
процесса, описанного в предыдущем разделе, вы можете использовать механизм
выбора для определения того, какие объекты указаны пользователем. Чтобы это
сделать, в сочетании с проекционной матрицей вы используете специальную матрицу
указания, ограничивающую область рисования малым регионом порта просмотра,
который обычно находится вблизи курсора. Затем вы выбираете какую-либо форму
ввода, например, щелчок мышью, которая будет активизировать режим выбора. В
режиме выбора с использованием матрицы указания попадание генерируют только
объекты, которые нарисованы вблизи курсора. Таким образом, по время указания вы
обычно определяете объекты, нарисованные вблизи курсора.</p>

<p class=text align=left style='text-align:left'>Указание настраивается
практически так же, как и обычный выбор, но присутствуют и важные отличия:</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l57 level1 lfo57;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Указание обычно активизируется с помощью
устройства ввода. В следующих примерах кода нажатие левой кнопки мыши запускает
функцию, производящую указание.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l57 level1 lfo57;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Вы используете функцию <b>gluPickMatrix()</b>
для умножения текущей проекционной матрицы на специальную матрицу указания. Эта
функция должна быть вызвана до установления стандартной проекционной матрицы
(например, командами <b>glOrtho()</b> или <b>glFrustum()</b>). Вероятно перед
этим процессом вам потребуется сохранить предыдущую матрицу проекции, так что
ваш код будет похож на следующий:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glMatrixMode(GL_PROJECTION);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glPushMatrix();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glLoadIdentity();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>gluPickMatrix(...);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>gluPerspective, glOrtho, gluOrtho2D </span><span
  style='color:black'>или</span><span lang=EN-US style='color:black;mso-ansi-language:
  EN-US'> glFrustum<o:p></o:p></span></pre><pre><span lang=EN-US
  style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span></span><span
  style='color:black'>/* ... нарисовать сцену для указания, произвести указание ... */<o:p></o:p></span></pre><pre><span
  style='color:black'>glPopMatrix();<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Verdana;
color:black;display:none;mso-hide:all'><o:p>&nbsp;</o:p></span></p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>gluPickMatrix</b>
  (GLdouble <i>x</i>, GLdouble <i>y</i>, GLdouble <i>width</i>, GLdouble <i>height</i>,
  GLint <i>viewport[4]</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Создает проекционную матрицу,
ограничивающую область рисования малым регионом порта просмотра и умножает
текущую проекционную матрицу на нее. Центром региона указания становится точка
(<i>x</i>, <i>y</i>) в оконных координатах (обычно в это время там находится
курсор). Аргументы <i>width </i>и <i>height </i>задают размеры (ширину и
высоту) региона указания в экранных координатах. (Вы можете считать ширину и
высоту области указания чувствительностью устройства ввода.) Аргумент <i>viewport[]</i>
должен содержать текущие границы порта просмотра, которые могут быть получены с
помощью следующего вызова</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>glGetIntegerv(GL_VIEWPORT,
  GLint *viewport);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'><b>Дополнительно:</b> Действие
матрицы, созданной с помощью <b>gluPickMatrix()</b> заключается в
преобразовании отсекающего региона к единичному кубу -1&lt;=(<i>x</i>,<i>y</i>,<i>z</i>)&lt;=1&nbsp;(или
-<i>w</i>&lt;=(<i>wx</i>,<i>wy</i>,<i>wz</i>)&lt;=<i>w</i>). Матрица указания
производит ортогональное преобразование, отображающее регион отсечения на единичный
куб. Поскольку преобразование может быть произвольным, вы можете заставить
указание работать с различными регионами – например, с вращающимися
прямоугольными областями окна. Однако в некоторых случаях для определения
области указания может быть проще создавать дополнительные плоскости
отсечения.&nbsp;</p>

<p class=text align=left style='text-align:left'>Пример 13-3 иллюстрирует
простое указание. Он также демонстрирует&nbsp; технику использования
множественных имен для идентификации различных компонентов примитива, в данном
случае – строки и столбца выбранного объекта. На экране рисуется сетка размером
33x3, состоящая из квадратов разного размера. Массив <i>board[3][3]</i> хранит
текущее количество синего в цвете каждого квадрата. Когда нажимается левая
кнопка мыши, вызывается функция <b>pickSquares()</b>, определяющая квадраты,
которые были указаны мышью. Каждый квадрат в сетке идентифицируется двумя
именами – одно имя для строки и одно для столбца. Кроме того, когда нажимается
левая кнопка мыши, изменяется цвет всех квадратов, находящихся вблизи курсора.
Начальное изображение, генерируемое примером, показано на рисунке 13-2.</p>

<p class=text align=left style='text-align:left'>Рисунок 13-2. Простой пример
указания </p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1504" type="#_x0000_t75" alt="" style='width:225pt;height:225pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image365.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов13.mht!http://www.progz.ru/images/opengl/chapter13/13-2.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=300 height=300
src="OpenGL%20Red%20Book.files/image365.jpg" v:shapes="_x0000_i1504"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Пример 13-3. Пример указания:
файл picksquares.cpp</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  style='color:black'>#include <o:p></o:p></span></pre><pre><span
  style='color:black'>#include <o:p></o:p></span></pre><pre><span
  style='color:black'>#include <o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>int board[3][3]; //количество синего в цвете каждого квадрата<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span lang=EN-US
  style='color:black;mso-ansi-language:EN-US'>void init()<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>int i,j;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>for(i=0;i&lt;3;i++)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>for(j=0;j&lt;3;j++)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>board[i][j]=0;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>   </span><span style='mso-spacerun:yes'>   </span>glClearColor(0.0,0.0,0.0,0.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void drawSquares(GLenum mode)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>GLuint i,j;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>for (i=0;i&lt;3;i++)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>if (mode==GL_SELECT)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>glLoadName(i);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>for(j=0;j&lt;3;j++)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            </span>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>if(mode==GL_SELECT)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                        </span>glPushName(j);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>glColor3f((GLfloat)i/3.0,(GLfloat)j/3.0,(GLfloat)board[i][j]/3.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>glRecti(i,j,i+1,j+1);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>if (mode==GL_SELECT)<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                        </span>glPopName();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span><span style='mso-spacerun:yes'>      </span>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>}<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void processHits(GLint hits,GLuint buffer[])<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>int i,j;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>GLuint ii, jj, names, *ptr;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>printf(&quot;hits=%d\n&quot;,hits);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>ptr=(GLuint*)buffer;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>for (i=0;i&lt; pre this if(j=&quot;=0)&quot; ii=&quot;*ptr;&quot; else if (j=&quot;=1)&quot; jj=&quot;*ptr;&quot; board[ii][jj]=&quot;(board[ii][jj]+1)%3;&quot; pickSquares(int button,int state,int x,int y) viewport[4]; if(button!=&quot;GLUT_LEFT_BUTTON&quot; || state!=&quot;GLUT_DOWN)&quot; return; glGetIntegerv(GL_VIEWPORT,viewport); Create 5x5 pixel picking region near cursor location gluPickMatrix((GLdouble)x,(GLdouble)(viewport[3]-y),5.0,5.0,viewport); drawSquares(GL_SELECT); glutPostRedisplay(); glClear(GL_COLOR_BUFFER_BIT); drawSquares(GL_RENDER); reshape(int w, h) glViewport(0,0,w,h); gluOrtho2D(0.0,3.0,0.0,3.0); glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB); glutInitWindowSize(300,300); glutCreateWindow(?Picking glutMouseFunc(pickSquares); glutReshapeFunc(reshape);&gt;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span
  style='mso-tab-count:1'>        </span><o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<h2>13.1.5.1 Указание с использованием множественных имен в иерархической
модели</h2>

<p class=text align=left style='text-align:left'>Множественные имена могут
также использоваться для выбора частей иерархического объекта сцены. Например,
если бы вы визуализировали сборочную линию автомобилей, вам могла бы
потребоваться возможность, с помощью которой пользователь мог бы выбрать третий
болт переднего левого колеса второй машины на линии. На каждом уровне иерархии
можно было бы применить свой набор имен для идентификации конкретного объекта
на этом уровне. В качестве другого примера, одно имя могло бы идентифицировать
всю молекулу среди других молекул, а другое – атомы внутри молекулы.</p>

<p class=text align=left style='text-align:left'>Пример 13-4 рисует автомобиль
с четырьмя колесами, параллельно манипулируя стеком имен согласно объектной
иерархии.</p>

<p class=text align=left style='text-align:left'>Пример 13-4. Создание
множественных имен</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  style='color:black'>нарисовать_колесо_и_болты()<o:p></o:p></span></pre><pre><span
  style='color:black'>{<o:p></o:p></span></pre><pre><span style='color:black'><span style='mso-spacerun:yes'>      </span>long i;<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>нарисовать_колесо();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>for(i=0;i&lt;5;i++)<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span></span><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>  </span><span style='mso-spacerun:yes'>          </span>glPushMatrix();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>glRotate(72.0*i,0.0,0.0,1.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>glTranslate(3.0,0.0,0.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                  </span>glPushName(i);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>                        </span></span><span
  style='color:black'>нарисовать_болт();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>glPopName();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>glPopMatrix();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>    </span><span style='mso-spacerun:yes'>  </span>}<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre><pre><span style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>нарисовать_корпус_колеса_и_болты()<o:p></o:p></span></pre><pre><span
  style='color:black'>{<o:p></o:p></span></pre><pre><span style='color:black'><span style='mso-spacerun:yes'>      </span>нарисовать_корпус();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glPushMatrix();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>glTranslate(40,0,20);<span style='mso-spacerun:yes'>   </span>/* позиция первого колеса */<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>glPushName(1);<span style='mso-spacerun:yes'>          </span>/* имя колеса №1 */<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>нарисовать_колесо_и_болты();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>glPopName();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glPopMatrix();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glPushMatrix();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>glTranslate(40,0,-20);<span style='mso-spacerun:yes'>  </span>/* позиция второго колеса */<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>glPushName(1);<span style='mso-spacerun:yes'>          </span>/* имя колеса №2 */<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>нарисовать_колесо_и_болты();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>glPopName();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glPopMatrix();<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>/* нарисовать два последних колеса */<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Пример 13-5 использует функции
примера 13-4 для рисования трех разных автомобилей, пронумерованных 1, 2 и 3.</p>

<p class=text align=left style='text-align:left'>Пример 13-5. Использование
множественных имен</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  style='color:black'>нарисовать_три_автомобиля()<o:p></o:p></span></pre><pre><span
  style='color:black'>{<o:p></o:p></span></pre><pre><span style='color:black'><span style='mso-spacerun:yes'>      </span>glInitNames();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glPushMatrix();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>выполнить_перенос_к_позиции_первой_машины();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>glPushName(1);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>нарисовать_корпус_колеса_и_болты();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>glPopName();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glPopMatrix();<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glPushMatrix();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>выполнить_перенос_к_позиции_второй_машины();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>glPushName(2);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>нарисовать_корпус_колеса_и_болты();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>glPopName();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glPopMatrix();<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glPushMatrix();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>выполнить_перенос_к_позиции_третьей_машины();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>glPushName(3);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>нарисовать_корпус_колеса_и_болты();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>glPopName();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glPopMatrix();<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Если предположить, что
производится указание, далее приводятся несколько примеров величин, которые
могут быть возвращены, а также их интерпретация. В этих примерах возвращается
максимум одна запись о попадании; <i>d1</i> и <i>d2</i> представляют значения
глубины.</p>

<p class=text align=left style='text-align:left'>2&nbsp;&nbsp; <i>d1</i>&nbsp;&nbsp;
<i>d2</i>&nbsp;&nbsp; 2&nbsp;&nbsp;
1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Машина 1, колесо 1</p>

<p class=text align=left style='text-align:left'>1&nbsp;&nbsp; <i>d1</i>&nbsp;&nbsp;
<i>d2</i>&nbsp;&nbsp;
3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Корпус
машины 3</p>

<p class=text align=left style='text-align:left'>3&nbsp;&nbsp; <i>d1</i>&nbsp;&nbsp;
<i>d2</i>&nbsp;&nbsp; 1&nbsp;&nbsp; 1&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Болт 0 на колесе 1
машины 1</p>

<p class=text align=left style='text-align:left'>пусто&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Указание не коснулось ни одной из машин</p>

<p class=text align=left style='text-align:left'>В этих интерпретациях
предполагается, что болт и колесо не оккупируют один и тот же регион указания.
Пользователь же может легко выбрать и колесо и болт одновременно, в результате
чего вы получите 2 попадания. Если вы получили несколько записей о попаданиях,
вы должны решить, какую из них обрабатывать, базируясь, возможно, на величинах
глубины, чтобы определить какое из попаданий находится ближе к точке
наблюдения. Использование величин глубины исследуется в следующем разделе.</p>

<h2>13.1.5.2 Указание и величина глубины</h2>

<p class=text align=left style='text-align:left'>Пример 13-6 демонстрирует, как
при указании использовать величины глубины для определения указанного объекта.
В режиме визуализации эта программа рисует три перекрывающихся прямоугольника.
При нажатии левой кнопки мыши, вызывается функция <b>pickRects()</b>. Эта
функция получает позицию курсора, переходит в режим выбора, инициализирует стек
имен и умножает матрицу указания на текущую матрицу ортографического
проецирования. Попадание возникает для каждого треугольника, который находится
под курсором мыши в момент нажатия левой кнопки. В конце, изучается содержимое
буфера выбора для определения тех именованных объектов, которые находились внутри
региона выбора вблизи курсора. Изображение, генерируемое программой, показано
на рисунке 13-3.</p>

<p class=text align=left style='text-align:left'>Рисунок 13-3. Указание и
величина глубины </p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1505" type="#_x0000_t75" alt="" style='width:300pt;height:300pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image366.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов13.mht!http://www.progz.ru/images/opengl/chapter13/13-3.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=400 height=400
src="OpenGL%20Red%20Book.files/image366.jpg" v:shapes="_x0000_i1505"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>В этой программе
прямоугольники рисуются на разной глубине, то есть с разными величинами z.
Поскольку для идентификации всех прямоугольников используется одно имя, может
быть записано только одно попадание. Однако, в зависимости от того, сколько
треугольников было указано и какие именно, это попадание имеет разные значения
минимальной и максимальной координаты z.</p>

<p class=text align=left style='text-align:left'>Пример 13-6. Указание и
величина глубины: файл pickdepth.cpp</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  style='color:black'>#include <o:p></o:p></span></pre><pre><span
  style='color:black'>#include <o:p></o:p></span></pre><pre><span
  style='color:black'>#include <o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>void init()<o:p></o:p></span></pre><pre><span
  style='color:black'>{<o:p></o:p></span></pre><pre><span style='color:black'><span style='mso-spacerun:yes'>      </span>glClearColor(0.0,0.0,0.0,0.0);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glEnable(GL_DEPTH_TEST);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glShadeModel(GL_FLAT);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glDepthRange(0.0,1.0);<span style='mso-spacerun:yes'>             </span>/* отображение z по умолчанию */<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre><pre><span style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>void drawRects(GLenum mode)<o:p></o:p></span></pre><pre><span
  style='color:black'>{<o:p></o:p></span></pre><pre><span style='color:black'><span style='mso-spacerun:yes'>      </span>if (mode==GL_SELECT)<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>glLoadName(1);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glBegin(GL_QUADS);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>glColor3f(1.0,1.0,0.0);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>glVertex3i(2,0,0);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>glVertex3i(2,6,0);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>glVertex3i(6,6,0);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>glVertex3i(6,0,0);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glEnd();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>if (mode==GL_SELECT)<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>glLoadName(2);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glBegin(GL_QUADS);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>glColor3f(0.0,1.0,1.0);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>glVertex3i(3,2,-1);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>glVertex3i(3,8,-1);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>glVertex3i(8,8,-1);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>glVertex3i(8,2,-1);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glEnd();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>if (mode==GL_SELECT)<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>glLoadName(3);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glBegin(GL_QUADS);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>glColor3f(1.0,0.0,1.0);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>glVertex3i(0,2,-2);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>glVertex3i(0,7,-2);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>glVertex3i(5,7,-2);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>glVertex3i(5,2,-2);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glEnd();<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre><pre><span style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>void processHits(GLint hits,GLuint buffer[])<o:p></o:p></span></pre><pre><span
  style='color:black'>{<o:p></o:p></span></pre><pre><span style='color:black'><span style='mso-spacerun:yes'>      </span>int i,j;<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>GLuint names, *ptr;<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>printf(&quot;hits=%d\n&quot;,hits);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>ptr=(GLuint*)buffer;<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>for (i=0;i&lt; pre this pickSquares(int button,int state,int x,int y) viewport[4]; if(button!=&quot;GLUT_LEFT_BUTTON&quot; || state!=&quot;GLUT_DOWN)&quot; return; glGetIntegerv(GL_VIEWPORT,viewport); Create 5x5 pixel picking region near cursor location gluPickMatrix((GLdouble)x,(GLdouble)(viewport[3]-y),5.0,5.0,viewport); reshape(int w, h) glViewport(0,0,w,h); glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB); glutCreateWindow(?Picking glutMouseFunc(pickSquares); glutReshapeFunc(reshape); drawRects(GL_SELECT); drawRects(GL_RENDER); glOrtho(0.0,8.0,0.0,8.0,-0.5,2.5); glutInitWindowSize(400,400); with Depth Values?);&gt;<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-tab-count:1'>        </span><o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<h2>13.1.6 Советы по написанию программ с использованием механизма выбора</h2>

<p class=text align=left style='text-align:left'>Большинство программ,
позволяющих пользователю интерактивно редактировать геометрические объекты,
предоставляют механизм, позволяющий пользователю указать элемент или группу
элементов для редактирования. Для программ двумерного рисования (вроде текстовых
редакторов или программ форматирования страниц) может быть проще создать свой
собственный механизм для обнаружения указанных объектов, чем использовать
механизм выбора OpenGL. Часто, проще найти ограничивающие прямоугольники
двумерных объектов и организовать их в подобие иерархии для ускорения поиска.
Например, указание в стиле OpenGL может работать довольно медленно в программе,
содержащей миллионы прямоугольников. Однако, если выравнивать прямоугольники на
экране каким-либо образом и использовать только информацию об их границах,
указание должно работать достаточно быстро. Кроме того, код для такого
механизма проще писать и понимать.</p>

<p class=text align=left style='text-align:left'>Рассмотрим другой пример.
Поскольку попадания происходят только для геометрических объектов, вам,
возможно, понадобится собственная функция для указания символов текста.
Установление текущей позиции растра является геометрической операцией, но
создает только одну точку, которую можно выбрать. Эта точка находится, как
правило, в нижнем левом углу текста. Если вашему редактору требуется
возможность манипуляции с индивидуальными символами внутри текстовой строки,
нужно использовать какой-либо другой механизм указания. Конечно, вы можете
нарисовать небольшой прямоугольник вокруг каждого символа в режиме выбора, но,
скорее всего, будет проще обрабатывать текст каким-либо специальным образом.</p>

<p class=text align=left style='text-align:left'>Если вы решите использовать
механизм указания OpenGL, организуйте программу и ее данные таким образом,
чтобы рисовать списки объектов в режимах визуализации и выбора было достаточно
просто. При таком подходе, когда пользователь выберет что-либо на экране, вы
сможете использовать в режиме выбора тот же код, который использовался для
фактического рисования сцены. Кроме того, заранее определитесь с тем, позволять
ли пользователю выбирать несколько объектов одновременно. Одним из способов
сделать это является хранение для каждого объекта бита информации,
показывающего выбран объект или нет (однако при таком методе вам нужно пройти
через весь массив битов для выявления выбранных объектов). Вы хранить список
указателей на объекты для ускорения этого поиска. Хранение бита выбора может
быть полезно и в случае, если вы хотите отображать выбранные объекты как-либо
иначе (другим цветом или внутри параллепипеда выбора). Наконец, определитесь с
пользовательским интерфейсом для выбора. Вы можете позволить пользователю:</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l24 level1 lfo58;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>выбирать элемент</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l24 level1 lfo58;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>выбирать группу элементов с помощью резинового
контура</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l24 level1 lfo58;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>добавлять элемент к группе выбранных</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l24 level1 lfo58;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>&nbsp;добавлять группу элементов к выбранным</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l24 level1 lfo58;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>удалить элемент из выбранных</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l24 level1 lfo58;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>выбирать один элемент из группы перекрывающихся
элементов</p>

<p class=text align=left style='text-align:left'>Типичное решение для двумерной
программы может заключаться в следующем:</p>

<ol start=1 type=1>
 <li class=MsoNormal style='color:black;mso-margin-top-alt:auto;mso-margin-bottom-alt:
     auto;mso-list:l2 level1 lfo59;tab-stops:list 36.0pt'><span
     style='font-size:10.0pt;font-family:Verdana'>Весь выбор осуществляется с
     помощью курсора мыши и ее левой кнопки. В дальнейшем описании «курсор»
     всегда означает курсор мыши, а «кнопка» – левую кнопку мыши. <o:p></o:p></span></li>
 <li class=MsoNormal style='color:black;mso-margin-top-alt:auto;mso-margin-bottom-alt:
     auto;mso-list:l2 level1 lfo59;tab-stops:list 36.0pt'><span
     style='font-size:10.0pt;font-family:Verdana'>Кликанье на элементе выбирает
     его и отменяет выбор всех остальных выбранных в данный момент элементов.
     Если курсор находится поверх нескольких элементов, выбирает наименьший из
     них. (В трех измерения существует множество других стратегий для
     устранения неоднозначности выбора.) <o:p></o:p></span></li>
 <li class=MsoNormal style='color:black;mso-margin-top-alt:auto;mso-margin-bottom-alt:
     auto;mso-list:l2 level1 lfo59;tab-stops:list 36.0pt'><span
     style='font-size:10.0pt;font-family:Verdana'>Кликанье в точке экрана, где
     нет объектов, перемещение мыши с нажатой кнопкой и отпускание кнопки
     приводит к выбору всех объектов, находящихся внутри экранного
     прямоугольника, чьими углами являются точка, где кнопка была нажата, и
     точка, где кнопка была отпущена. Это называется выбором с помощью <i>резинового
     контура</i>. При этом отменяется выбор всех элементов находящихся вне
     прямоугольника резинового контура. (Вы должны решить, должен ли элемент
     быть выбран, только если он целиком попадает в прямоугольник или если
     любая его часть попадает в прямоугольник контура. Обычно первый вариант
     работает наилучшим образом.) <o:p></o:p></span></li>
 <li class=MsoNormal style='color:black;mso-margin-top-alt:auto;mso-margin-bottom-alt:
     auto;mso-list:l2 level1 lfo59;tab-stops:list 36.0pt'><span
     style='font-size:10.0pt;font-family:Verdana'>Если пользователь кликнул в
     объект, который не выбран, и одновременно держал нажатой кнопку Shift,
     объект добавляется к списку выбранных. Если указанный объект был
     выбранным, его следует удалить из списка выбранных. <o:p></o:p></span></li>
 <li class=MsoNormal style='color:black;mso-margin-top-alt:auto;mso-margin-bottom-alt:
     auto;mso-list:l2 level1 lfo59;tab-stops:list 36.0pt'><span
     style='font-size:10.0pt;font-family:Verdana'>Если резиновый контур
     растягивается при нажатой кнопке Shift, объекты внутри контура добавляются
     к выбранным. <o:p></o:p></span></li>
 <li class=MsoNormal style='color:black;mso-margin-top-alt:auto;mso-margin-bottom-alt:
     auto;mso-list:l2 level1 lfo59;tab-stops:list 36.0pt'><span
     style='font-size:10.0pt;font-family:Verdana'>Часто бывает трудно
     использовать резиновый конур в сильно загроможденных областях экрана.
     Когда нажимается кнопка (то есть происходит кликанье) курсор может
     находиться над каким-либо элементом, и в принципе, должен быть выбран этот
     элемент. Однако типичный интерфейс пользователя интерпретирует нажатие
     кнопки и перемещение мыши как растягивание резинового контура. Чтобы
     разрешить эту проблему, вы можете реализовать возможность принудительного
     запуска резинового контура с помощью удержания какой-либо кнопки
     (например, Alt). При таком подходе, для растягивания контура нужно
     выполнить следующие операции: нажать кнопку Alt, растянуть контур,
     отпустить кнопку Alt. В течение удержания Alt следует игнорировать
     элемент, на котором непосредственно произошел щелчок. <o:p></o:p></span></li>
 <li class=MsoNormal style='color:black;mso-margin-top-alt:auto;mso-margin-bottom-alt:
     auto;mso-list:l2 level1 lfo59;tab-stops:list 36.0pt'><span
     style='font-size:10.0pt;font-family:Verdana'>Если кнопка Shift нажата в
     течение выделения элементов резиновым контуром, эти элементы должны быть
     добавлены к уже выбранным. <o:p></o:p></span></li>
 <li class=MsoNormal style='color:black;mso-margin-top-alt:auto;mso-margin-bottom-alt:
     auto;mso-list:l2 level1 lfo59;tab-stops:list 36.0pt'><span
     style='font-size:10.0pt;font-family:Verdana'>и, наконец, если пользователь
     кликает на нескольких объектах, выделяйте только один из них. Если курсор
     не двигался (или сдвигался не более, чем на один пиксель), и пользователь
     кликает снова, в том же месте, отмените выбор первоначально выбранного
     элемента и выберите другой, из находящихся под курсором. Используйте
     повторные клики в одной точке для циклического перехода по всем
     возможностям. <o:p></o:p></span></li>
</ol>

<p class=text align=left style='text-align:left'>В определенных ситуациях могут
применяться разные правила. В текстовом редакторе вам, вероятно, не придется
волноваться о том, что символы находятся один поверх другого, а выбор
нескольких символов предусматривает только соседние символы в документе. Таким
образом, вам нужно определить только первый и последний символы для
идентификации всей выборки. Кроме того, в случае текста иногда легче
идентифицировать промежутки между символами, а не сами символы. Такой подход
позволяет вам реализовать пустую выборку, когда ее начало и конец находятся в
одном и том же месте; он также позволяет вам поместить курсор перед первым
символом текста и после последнего символа без дополнительного кодирования.</p>

<p class=text align=left style='text-align:left'>В трехмерном редакторе вы
можете предоставить возможность поворачивать и перемещать выборки, так что нет
смысла циклически проходить через их возможные варианты. С другой стороны выбор
в трехмерном пространстве довольно сложен, поскольку координаты курсора на
экране не предоставляют информации о глубине.</p>

<h2>13.2 Отклик</h2>

<p class=text align=left style='text-align:left'>Откат похож на выбор в том,
что, когда вы находитесь в обоих режимах, реальный вывод пикселей не
осуществляется, и изображение на экране остается неизменным. Рисования не
происходит, вместо этого информация о примитивах, которые должны быть
нарисованы, возвращается приложению. Ключевое отличие между режимами выбора и
отката заключается в типе информации, которая отсылается приложению. В режиме
выбора возвращают ассоциированные имена в виде массива целочисленных величин. В
режиме отката информация о преобразованных примитивах возвращается в виде
массива чисел с плавающей точкой. Величины, отсылаемые приложению в массиве
отката, состоят из элемента, идентифицирующего тип обработанного и
преобразованного примитива (точка, линия, полигон, изображение или битовая
карта), за которым следуют вершины, цвета и другая информация об этом
примитиве. Величины возвращаются после того, как они были преобразованы
освещением и видовыми операциями. Режим отклика инициализируется вызовом
команды <b>glRenderMode()</b> с аргументом GL_FEEDBACK. </p>

<p class=text align=left style='text-align:left'>Далее приводится процедура
входа и выхода из режима отклика.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l22 level1 lfo60;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>1.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Вызовите <b>glFeedbackBuffer()</b>, чтобы задать
массив, в котором будут сохраняться данные отклика. Аргументы этой команды
задают тип и количество информации, которые будут сохраняться в массиве. </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l22 level1 lfo60;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>2.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Вызовите <b>glRenderMode()</b>, чтобы войти в
режим отклика. (На данный момент вы можете игнорировать значение, возвращенное <b>glRenderMode()</b>.)
После этого шага примитивы не будут растеризоваться в пиксели, и содержимое
буфера кадра не изменяется до тех пор, пока вы не выйдите из режима отклика. </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l22 level1 lfo60;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>3.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Нарисуйте ваши примитивы. Между вызовами команд
рисования вы можете один или несколько раз вызвать команду <b>glPassThrough()</b>
для добавления маркеров к данным отклика, чтобы упростить дальнейший разбор. </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l22 level1 lfo60;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>4.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Выйдите из режима отклика, вызвав <b>glRenderMode()</b>
с аргументом GL_RENDER, если вы хотите вернуться к режиму визуализации.
Целочисленная величина, возвращенная <b>glRenderMode()</b>, соответствует числу
записей, занесенных в буфер отклика. </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l22 level1 lfo60;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>5.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Обработайте данные в массиве отклика. </p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>glFeedbackBuffer</b>
  (GLsizei <i>size</i>, GLenum <i>type</i>, GLfloat* <i>buffer</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Устанавливает буфер для данных
отклика: <i>buffer </i>должен быть указателем на массив, где будут сохраняться
данные. Аргумент <i>size </i>индицирует максимальное число величин, которые
могут быть сохранены в массиве. Аргумент <i>type </i>задает тип информации,
которая будет сохраняться в массиве для каждой вершины; его возможные значения
и их смысл показаны в таблице 13-1. <b>glFeedbackBuffer()</b> должна быть
вызвана до входа в режим отклика. В таблице 13-1 <i>k </i>равно 1 в индексном
режиме и 4 – в режиме RGBA.</p>

<p class=text align=left style='text-align:left'>Таблица 13-1. Значения
аргумента type команды glFeedbackBuffer()</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Аргумент <i>type</i> </span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Координаты</span></b><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Цвет</span></b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Текстура</span></b><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Всего величин</span></b><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_2D<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><i><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>x</span></i><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>, <i>y</i><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>2<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_3D<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><i><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>x</span></i><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>, <i>y</i>, <i>z</i><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>3<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_3D_COLOR<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><i><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>x</span></i><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>, <i>y</i>, <i>z</i> <o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><i><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>k</span></i><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>3+<i>k</i> <o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_3D_COLOR_TEXTURE <o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><i><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>x</span></i><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>, <i>y</i>, <i>z</i> <o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><i><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>k</span></i><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>4<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>7+<i>k</i> <o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:5;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_4D_COLOR_TEXTURE <o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><i><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>x</span></i><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>, <i>y</i>, <i>z</i>, <i>w</i> <o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><i><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>k</span></i><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>4<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>8+<i>k</i> <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=warning>Замечание: Если поддерживается мультитекстурирование, режим
отклика возвращает координаты текстуры только для текстурного блока 0.</p>

<h2>13.2.1 Массив отклика</h2>

<p class=text align=left style='text-align:left'>В режиме отклика каждый
примитив, который должен быть растеризован (а также каждое обращение к командам
<b>glBitmap()</b>, <b>glDrawPixels()</b> и <b>glCopyPixels()</b> в том случае
если текущая позиция растра допустима) генерирует блок величин, которые
копируются в буфер отклика. Количество величин определяется аргументом <i>type</i>команды
<b>glFeedbackBuffer()</b>. Используйте значение этого аргумента,
соответствующее тому, что вы рисуете: GL_2D или GL_3D для освещенных двумерных
или трехмерных примитивов, GL_3D_COLOR для освещенных трехмерных примитивов,
GL_3D_COLOR_TEXTURE или GL_4D_COLOR_TEXTURE для освещенных, тектурированных
трехмерных или четырехмерных примитивов.</p>

<p class=text align=left style='text-align:left'>Каждый блок величин отклика
начинается с кода, позволяющего идентифицировать тип примитива. За этим кодом
следуют величины, описывающие вершины примитива и ассоциированные с ними
данные. Могут также присутствовать записи о прямоугольниках пикселей. Кроме
того, в массиве могут возвращаться сквозные маркеры, созданные вами (эти
маркеры описаны в следующем разделе). В таблице 13-2 приводится синтаксис
массива отклика. Помните, что данные, ассоциированные с каждой возвращаемой
вершиной, описаны в таблице 13-1. Заметьте, что для полигона может быть
возвращено <i>n</i>вершин. Координаты <i>x</i>, <i>y</i>и <i>z</i>,
возвращаемые в массиве, являются оконными. Если же возвращается еще и <i>w</i>,
то координаты являются усеченными. Для битовых карт и изображений возвращаемые
координаты являются текущей позицией растра на момент вывода соответствующего
примитива. Обратите внимание, что GL_LINE_RESET_TOKEN возвращается только,
когда ломаная прерывается.</p>

<p class=text align=left style='text-align:left'>Таблица 13-2. Синтаксис
массива отклика</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Тип примитива</span></b><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Код</span></b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Ассоциированные данные</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Точка<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_POINT_TOKEN<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>вершина<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Линия<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_LINE_TOKEN или GL_LINE_RESET_TOKEN<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>вершина вершина<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Полигон<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_POLYGON_TOKEN<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>n вершинавершина ... вершина<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Битоваякарта <o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_BITMAP_TOKEN<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>вершина <o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:5'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Пиксельныйпрямоугольник <o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_DRAW_PIXEL_TOKEN или GL_COPY_PIXEL_TOKEN<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>вершина<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:6;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Сквозной маркер<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_PASS_THROUGH_TOKEN<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>число с плавающей точкой<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<h2>13.2.2 Использование маркеров в режиме отклика</h2>

<p class=text align=left style='text-align:left'>Отклик происходит после
преобразований, расчета освещенности, удаления обратных граней и интерпретации
полигонов в зависимости от команды <b>glPolygonMode()</b>. Также он происходит
после того, как полигоны, имеющие более трех ребер, разбиваются на треугольники
(если ваша реализация OpenGL визуализирует полигоны, производя такую
декомпозицию). Таким образом, вам может быть сложно опознать те примитивы, что
вы рисуете, в тех данных, которые были возвращены. Чтобы упростить процесс
разбора данных отклика, в своем коде вставляйте маркеры с помощью команды <b>glPassThrough()</b>.
Вы можете использовать маркеры для разделения величин отклика, относящихся к
разным примитивам. Эта команда приводит к тому, что в массив отклика
записывается код GL_PASS_THROUGH_TOKEN, за которым следует число с плавающей
точкой, которое вы передали в качестве аргумента команды.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>glPassThrough</b>
  (GLfloat <i>token</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Если вызывается в режиме
отклика, вставляет маркер в поток величин, записываемых в массив отклика.
Маркер состоит из кода GL_PASS_THROUGH_TOKEN, за которым следует величина с
плавающей точкой <i>token</i>. Если команда вызывается не в режиме отклика, она
ничего не делает. Вызов команды <b>glPassThrough()</b> между командами <b>glBegin()</b>
и <b>glEnd()</b> генерирует ошибку GL_INVALID_OPERATION.</p>

<h2>13.2.3 Пример использования отклика</h2>

<p class=text align=left style='text-align:left'>Пример 13-7 демонстрирует
использование режима отклика. Эта программа рисует освещенную трехмерную сцену
в нормальном режиме визуализации. Затем она входит в режим отклика и
перерисовывает сцену. Поскольку программа рисует освещенную нетекстурированную
трехмерную сцену, типом данных отклика является GL_3D_COLOR, а поскольку она работает
в режиме RGBA, каждая неотсеченная вершина генерирует 7 величин в массиве
отклика: <i>x</i>, <i>y</i>, <i>z</i>, <i>r</i>, <i>g</i>, <i>b </i>и <i>a</i>.</p>

<p class=text align=left style='text-align:left'>В режиме отклика программа
рисует две линии как часть ломаной, а затем вставляет сквозной маркер. Далее
рисуется точка с координатами <i>(-100.0</i>, <i>-100.0</i>, <i>-100.0</i>),
выпадающая из ортографического объема видимости и, таким образом, не
генерирующая записей в массиве отклика. Наконец, вставляется еще один маркер и
рисуется еще одна точка. Изображение, генерируемое программой, изображено на
рисунке 13-4.</p>

<p class=text align=left style='text-align:left'>Рисунок 13-4. Пример
использования режима отклика </p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1506" type="#_x0000_t75" alt="" style='width:134.25pt;height:124.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image367.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов13.mht!http://www.progz.ru/images/opengl/chapter13/13-4.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=179 height=166
src="OpenGL%20Red%20Book.files/image367.jpg" v:shapes="_x0000_i1506"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Пример 13-7. Режим отклика:
файл feedback.cpp</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  style='color:black'>#include <o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>#include <o:p></o:p></span></pre><pre><span
  style='color:black'>#include <o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>void init()<o:p></o:p></span></pre><pre><span
  style='color:black'>{<o:p></o:p></span></pre><pre><span style='color:black'><span style='mso-spacerun:yes'>      </span>glEnable(GL_LIGHTING);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glEnable(GL_LIGHT0);<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre><pre><span style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>void drawGeometry(GLenum mode)<o:p></o:p></span></pre><pre><span
  style='color:black'>{<o:p></o:p></span></pre><pre><span style='color:black'><span style='mso-spacerun:yes'>      </span>glBegin(GL_LINE_STRIP);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>glNormal3f(0.0,0.0,1.0);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>glVertex3f(30.0,30.0,0.0);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>          </span><span style='mso-spacerun:yes'>  </span>glVertex3f(50.0,60.0,0.0);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>glVertex3f(70.0,40.0,0.0);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glEnd();<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>if(mode==GL_FEEDBACK)<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>glPassThrough(1.0);<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glBegin(GL_POINTS);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>glVertex3f(-100.0,-100.0,-100.0); //Будетотсечена <o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glEnd();<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>if(mode==GL_FEEDBACK)<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>glPassThrough(2.0);<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glBegin(GL_POINTS);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>glNormal3f(0.0,0.0,1.0);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>glVertex3f(50.0,50.0,0.0);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glEnd();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glFlush();<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre><pre><span style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>void print3DcolorVertex(GLint size,GLint *count,GLfloat *buffer)<o:p></o:p></span></pre><pre><span
  style='color:black'>{<o:p></o:p></span></pre><pre><span style='color:black'><span style='mso-spacerun:yes'>      </span>int i;<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>printf(&quot;<span style='mso-spacerun:yes'>   </span>&quot;);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>for(i=0;i&lt;7;i++)<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>{<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>printf(&quot;%4.2f &quot;,buffer[size-(*count)]);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>*count=*count-1;<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>}<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>printf(&quot;\n&quot;);<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre><pre><span style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>void printBuffer(GLint size,GLfloat *buffer)<o:p></o:p></span></pre><pre><span
  style='color:black'>{<o:p></o:p></span></pre><pre><span style='color:black'><span style='mso-spacerun:yes'>      </span>GLint count;<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>GLfloat token;<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>count=size;<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>while(count)<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>{<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>token=buffer[size-count];<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>count--;<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>if(token==GL_PASS_THROUGH_TOKEN)<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>{<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>printf(&quot;GL_PASS_THROUGH_TOKEN\n&quot;);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>printf(&quot; <span style='mso-spacerun:yes'>  </span>%4.2f\n&quot;,buffer[size-count]);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>count--;<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>}<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>else<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>if(token==GL_POINT_TOKEN)<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>{<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                        </span>printf(&quot;GL_POINT_TOKEN\n&quot;);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                        </span>print3DcolorVertex(size,&amp;count,buffer);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>}<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>else<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                        </span>if(token==GL_LINE_TOKEN)<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                        </span>{<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                             </span>printf(&quot;GL_LINE_TOKEN\n&quot;);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                             </span>print3DcolorVertex(size,&amp;count,buffer);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                             </span>print3DcolorVertex(size,&amp;count,buffer);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                        </span>}<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                        </span>else<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                             </span>if(token==GL_LINE_RESET_TOKEN)<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                             </span>{<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                                   </span>printf(&quot;GL_LINE_RESET_TOKEN\n&quot;);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                                   </span>print3DcolorVertex(size,&amp;count,buffer);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                                   </span>print3DcolorVertex(size,&amp;count,buffer);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                             </span>}<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>}<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre><pre><span style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>void display()<o:p></o:p></span></pre><pre><span
  style='color:black'>{<o:p></o:p></span></pre><pre><span style='color:black'><span style='mso-spacerun:yes'>      </span>GLfloat feedBuffer[1024];<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>GLint size;<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glMatrixMode(GL_PROJECTION);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glLoadIdentity();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glOrtho(0.0,100.0,0.0,100.0,0.0,1.0);<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glClearColor(0.0,0.0,0.0,0.0);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glClear(GL_COLOR_BUFFER_BIT);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>drawGeometry(GL_RENDER);<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glFeedbackBuffer(1024,GL_3D_COLOR,feedBuffer);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glRenderMode(GL_FEEDBACK);<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>drawGeometry(GL_FEEDBACK);<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>size=glRenderMode(GL_RENDER);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>printBuffer(size,feedBuffer);<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre><pre><span style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>int main(int argc, char* argv[])<o:p></o:p></span></pre><pre><span
  style='color:black'>{<o:p></o:p></span></pre><pre><span style='color:black'><span style='mso-spacerun:yes'>      </span>glutInit(&amp;argc,argv);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glutInitWindowSize(100,100);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glutInitWindowPosition(100,100);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glutCreateWindow(&quot;Feedback Mode&quot;);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>init();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glutDisplayFunc(display);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glutMainLoop();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>return 0;<span style='mso-spacerun:yes'>   </span><o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Запуск программы генерирует
следующий вывод:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  style='color:black'>GL_LINE_RESET_TOKEN<o:p></o:p></span></pre><pre><span
  style='color:black'>30.00 30.00 0.00 0.84 0.84 0.84 1.0<o:p></o:p></span></pre><pre><span
  style='color:black'>50.00 60.00 0.00 0.84 0.84 0.84 1.0<o:p></o:p></span></pre><pre><span
  style='color:black'>GL_LINE_RESET_TOKEN<o:p></o:p></span></pre><pre><span
  style='color:black'>50.00 60.00 0.00 0.84 0.84 0.84 1.0<o:p></o:p></span></pre><pre><span
  style='color:black'>70.00 40.00 0.00 0.84 0.84 0.84 1.0<o:p></o:p></span></pre><pre><span
  style='color:black'>GL_PASS_THROUGH_TOKEN<o:p></o:p></span></pre><pre><span
  style='color:black'>1.00<o:p></o:p></span></pre><pre><span style='color:black'>GL_PASS_THROUGH_TOKEN<o:p></o:p></span></pre><pre><span
  style='color:black'>2.00<o:p></o:p></span></pre><pre><span style='color:black'>GL_POINT_TOKEN<o:p></o:p></span></pre><pre><span
  style='color:black'>50.00 50.00 0.00 0.84 0.84 0.84 1.0<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Таким образом, ломаная,
рисуемая следующими командами, отображается в два примитива:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glBegin(GL_LINE_STRIP);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>glNormal3f(0.0,0.0,1.0);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span></span><span
  style='color:black'>glVertex3f(30.0,30.0,0.0);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glVertex3f(50.0,60.0,0.0);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glVertex3f(70.0,40.0,0.0);<o:p></o:p></span></pre><pre><span
  style='color:black'>glEnd();<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Первый примитив начинается с
кода GL_LINE_RESET_TOKEN. Это означает, что первым примитивом является сегмент
линии, и что шаблон для линий сброшен. Второй примитив начинается с
GL_LINE_TOKEN, то есть это тоже сегмент линии, но ломаная не прерывается и,
следовательно, продолжается из той точки, где закончился предыдущий сегмент.
Каждая из двух вершин этих линий генерирует по 7 величин в массиве отклика.
Заметьте, что RGBA величины для всех четырех точек этих двух линий равны (<i>0.84</i>,
<i>0.84</i>, <i>0.84</i>, <i>1.0</i>), что является очень светлым оттенком
серого цвета с максимальным значением альфа. Эти цветовые величины – результат
взаимодействия вектора нормали и параметров освещения.</p>

<p class=text align=left style='text-align:left'>Поскольку между первым и
вторым сквозными маркерами не было сгенерировано данных отклика, вы можете
сделать вывод о том, что примитивы, нарисованные между первыми двумя вызовами <b>glPassThrough()</b>
были отсечены по объему видимости. Наконец, рисуется точка с координатами (<i>50.0</i>,
<i>50.0</i>, <i>0.0</i>), и ассоциированные с ней данные заносятся в буфер
отклика.</p>

<p class=warning>Замечание: И в режиме отклика, и в режиме выбора информация
возвращается до выполнения всех тестов над фрагментами. Таким образом, данные
об объектах, которые не были бы нарисованы из-за неудачи во время теста отреза,
альфа, глубины или трафарета, тем не менее, обрабатываются и возвращаются в
обоих режимах (выбора и отклика).</p>

<p class=MsoNormal><a name=Глава14><span style='display:none;mso-hide:all'><o:p>&nbsp;</o:p></span></a></p>

<h1 align=left style='text-align:left'><span style='mso-bookmark:Глава14'>Глава
14. Трюки и советы</span></h1>

<span style='mso-bookmark:Глава14'></span>

<p class=MsoNormal><a href="mailto:ahinar@list.ru"></a><span style='font-size:
10.0pt;font-family:Verdana'>В этой главе обсуждаются различные техники,
базирующиеся на командах OpenGL, которые иллюстрируют не очевидные примеры
применения этих команд. Расположение этих примеров не имеет никакой
закономерности, а сами примеры не связаны один с другим.<o:p></o:p></span></p>

<h2>14.1 Обработка ошибок</h2>

<p class=text align=left style='text-align:left'>Правда заключается в том, что
ваша программа будет совершать ошибки. Использование функций обработки ошибок
просто необходимо во время разработки и настоятельно рекомендуется для
коммерческих приложений. (Если только вы не можете дать 100 процентной
гарантии, что ваша программа не сгенерирует ошибку OpenGL, но кто может это
гарантировать?) OpenGL предоставляет простые функции обработки ошибок для
базовой библиотеки OpenGL и библиотеки GLU.</p>

<p class=text align=left style='text-align:left'>Когда OpenGL обнаруживает
ошибку, она записывает код текущей ошибки. Команда, сгенерировавшая ошибку
игнорируется, так что она не оказывает никакого воздействия на состояние OpenGL
или содержимое буфера кадра. (Однако, если записанной ошибкой была
GL_OUT_OF_MEMORY, результат выполнения команды не определен.) После записи код
текущей ошибки не изменяется, то есть в него другие ошибки не записываются до
тех пор, пока вы&nbsp; не вызовите команду <b>glGetError()</b>, возвращающую
код текущей ошибки. После того, как вы запросили и очистили код текущей ошибки
или если ни одной ошибки не было, <b>glGetError()</b> будет возвращать значение
GL_NO_ERROR.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>GLenum <b>glGetError</b>
  (void);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Возвращает текущее значение
флага ошибки. Когда ошибка происходит в GL или GLU, ее код записывается в флаг
ошибки. Если возвращаемое значение равно GL_NO_ERROR, значит, ошибок не
происходило с момента последнего вызова <b>glGetError()</b> или с момента
инициализации OpenGL. Никакие другие ошибки не записываются до тех пор, пока не
будет произведен вызов <b>glGetError()</b>, не вернется код ошибки, и флаг не
будет сброшен в значение GL_NO_ERROR.</p>

<p class=text align=left style='text-align:left'>Настоятельно рекомендуется
вызывать <b>glGetError()</b> хотя бы один раз в каждой функции <b>display()</b>
вашего приложения. Основные коды ошибок OpenGL перечислены в таблице 14-1.</p>

<p class=text align=left style='text-align:left'>Таблица 14-1. Коды ошибок
OpenGL</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Код ошибкии</span></b><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Описание</span></b><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_INVALID_ENUM<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>аргумент типа GLenum вне допустимого диапазона<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_INVALID_VALUE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>численный аргумент вне допустимого диапазона<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_INVALID_OPERATION<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>недопустимая операция для текущего состояния<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_STACK_OVERFLOW<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>команда вызовет переполнение стека<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:5'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_STACK_UNDERFLOW<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>команда вызовет извлечение или изменение значения в пустом стеке<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:6;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_OUT_OF_MEMORY<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>недостаточно памяти для выполнения команды<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Существует также 37 ошибок
связанных с интерфейсом GLU NURBS (имеющих не описательные константные имена
GL_NURBS_ERROR1, GLU_NURBS_ERROR2 и так далее); 14 ошибок тесселяции
(GLU_TESS_MISSING_BEGIN_POLYGON, GLU_TESS_MISSING_END_POLYGON,
GLU_TESS_MISSING_BEGIN_CONTOUR, GLU_TESS_MISSING_END_CONTOUR,
GLU_TESS_COORD_TOO_LARGE, GLU_TESS_NEED_COMBINE_CALLBACK, а также еще 8 ошибок,
начинающихся с префикса GLU_TESS_ERROR*); и GLU_INCOMPATIBLE_GL_VERSION. GLU
также определяет коды ошибок GLU_INVALID_ENUM, GLU_INVALID_VALUE и
GLU_OUT_OF_MEMORY, имеющие тот же смысл, что и связанные коды ошибок OpenGL.</p>

<p class=text align=left style='text-align:left'>Чтобы получить описательную
строку, соответствующую коду ошибки GL или GLU, используйте функцию GLU <b>gluErrorString()</b>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>const
  GLubyte* <b>gluErrorString</b> (GLenum <i>errorCode</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Возвращает указатель на
описательную строку, соответствующую коду ошибки GL или GLU, переданному в
качестве аргумента <i>errorCode</i>.</p>

<p class=text align=left style='text-align:left'>В примере 14-1 показана
простая функция обработки ошибок.</p>

<p class=text align=left style='text-align:left'>Пример 14-1. Опрос и
распечатка ошибки</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>GLenum errCode;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>const GLubyte *errString;<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>if ((errCode=glGetError())!=GL_NO_ERROR<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>{<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>errString=gluErrorString(errCode);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>      </span>fsprintf(stderr,”OpenGL error: %s\n”, errString);<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<p class=warning>Замечание: Приложение не должно изменять или удалять из памяти
строку, возвращенную <b>gluErrorString()</b>.</p>

<h2>14.2 Определение используемой версии</h2>

<p class=text align=left style='text-align:left'>Переносимость приложений с
использованием OpenGL является одним из привлекательнейших черт этого
стандарта. Однако новые версии OpenGL предоставляют новые возможности, и, если
вы используете эти возможности, у вас могут появиться проблемы с запуском вашей
программы на более ранних версиях OpenGL. Кроме того, вы захотите реализовать
ваше приложение таким образом, чтобы оно работало одинаково на различных
реализациях OpenGL. Вы можете сделать текстурирование режимом по умолчанию на
одной машине и ограничиться плоской закраской на другой. Для получения
информации о версии OpenGL вы можете использовать команду <b>glGetString()</b>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>const
  GLubyte* <b>glGetString</b> (GLenum <i>name</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Возвращает указатель на
строку, описывающий один из аспектов реализации OpenGL. Аргумент name может
принимать значения GL_VENDOR, GL_RENDERER, GL_VERSION или GL_EXTENSIONS.
GL_VENDOR возвращает название компании, ответственной за реализацию OpenGL,
например:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>NVIDIA Corporation<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>GL_RENDERER возвращает
идентификатор визуализатора, обычно совпадающий с аппаратной платформой,
например:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>Voodoo550/AGP<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>или</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>GeForce4 Ti 4600/AGP/SSE2<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>О результате GL_EXTENSIONS
можно подробно узнать в следующем разделе.</p>

<p class=text align=left style='text-align:left'>GL_VERSION возвращает строку,
идентифицирующую номер версии реализации OpenGL. Строка версии состоит из
следующих компонентов:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>&lt;номер
  версии&gt;&lt;пробел&gt;&lt;информация, зависящая от производителя&gt;<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Номер версии имеет форму</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>major_number.minor_number<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>или</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>major_number.minor_number.release_number<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>где каждое число может
состоять из одной или более цифр. Информация, зависящая от производителя,
является опциональной. Например, если реализация OpenGL создана компанией XYZ,
возвращенная строка может быть следующей:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>1.2.4 XYZ-OS 3.2<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>что означает, что это
четвертый выпуск реализации OpenGL компании XYZ, и что эта реализация
подчиняется спецификации OpenGL версии 1.2. Это также может означать, что
данный выпуск предназначен для какой-либо операционной системы версии 3.2.</p>

<p class=text align=left style='text-align:left'>Другой способ получения
информации о версии OpenGL заключается в использовании директивы препроцессора
#ifdef для обнаружения символических констант GL_VERSION_1_3, GL_VERSION_1_2 и
GL_VERSION_1_1. Отсутствие константы GL_VERSION_1_3 означает, что у вас версия
GL_VERSION_1_2, GL_VERSION_1_1 или GL_VERSION_1_0. Отсутствие константы
GL_VERSION_1_2 означает, что у вас версия GL_VERSION_1_1 или GL_VERSION_1_0 и
так далее. </p>

<p class=warning>Замечание: Однако стоит помнить, что реальная версия
используемой реализации OpenGL и версия, на которую рассчитан заголовочный файл
(а константы определяются именно в нем) могут различаться. Например, на момент
написания данного пособия в основном действовала спецификация OpenGL 1.3,
однако корпорация Microsoft продолжала поставлять вместе со своими средствами разработки
заголовочные файлы и библиотеки импорта, рассчитанные на OpenGL спецификации
1.1. Так что важно помнить, что команда <b>glGetString(GL_VERSION)</b> на этапе
выполнения программы возвращает номер версии реальной реализации OpenGL,
используемой в вашей системе, а метод с применением директивы #ifndef на этапе
разработки позволяет определить только версию, на которую рассчитан
заголовочный файл gl.h.</p>

<p class=warning>Замечание: При работе в клиент – серверной архитектуре
(например, с OpenGL расширением системы X Window) клиент и сервер могут иметь
разные версии. Если версия вашего клиента более поздняя, чем версия сервера,
клиент может запросить операцию, которая сервером не поддерживается. </p>

<h2>14.2.1 Номер версии GLU</h2>

<p class=text align=left style='text-align:left'>Функция <b>gluGetString()</b>
предназначена для опроса реализации GLU и похожа на команду <b>glGetString()</b>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>const
  GLubyte* <b>gluGetString</b> (GLenum <i>name</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Возвращает указатель на
строку, описывающий один из аспектов реализации GLU. Аргумент <i>name</i> может
принимать значения GLU_VERSION или GLU_EXTENSIONS.&nbsp;</p>

<p class=text align=left style='text-align:left'>Обратите внимание, что функции
<b>gluGetString()</b> не было в GLU версии 1.0. Другим способом получения
информации о GLU (точнее информации о версии, на которую рассчитан заголовочный
файл и библиотека импорта) заключается в использовании директивы препроцессора
#ifndef для поиска констант GLU_VERSION_1_3, GLU_VERSION_1_2, GLU_VERSION_1_1 и
GLU_VERSION_1_0 по аналогии с константами GL.</p>

<p class=text align=left style='text-align:left'>Имейте в виду, что расширения
GLU отличаются от расширений OpenGL.</p>

<h2>14.2.2 Версия расширений оконной системы</h2>

<p class=text align=left style='text-align:left'>Для расширений оконных систем,
предназначенных для работы с OpenGL, таких как GLX, WGL, PGL и AGL существуют
похожие функции (например, <b>glXQueryExtensionString()</b>), запрашивающие
информацию о версии.</p>

<p class=text align=left style='text-align:left'>(Упомянутая <b>glXQueryExtensionString()</b>
и связанные функции появились в GLX 1.1 и не поддерживаются в GLX1.0)</p>

<h2>14.3 Расширения стандарта</h2>

<p class=text align=left style='text-align:left'>OpenGL имеет свою формальную
напечатанную спецификацию, которая описывает операции, составляющие библиотеку.
Индивидуальный производитель или группа таковых могут принять решение о
добавлении к своим реализациям библиотеки дополнительной функциональности.</p>

<p class=text align=left style='text-align:left'>Имена функций и символических
констант четко показывают, является ли конкретная возможность частью стандарта
OpenGL, расширением специфичным для отдельного производителя или расширением
OpenGL принятым OpenGL ARB (Architecture Review Board – Совет по Пересмотру
Архитектуры).</p>

<p class=text align=left style='text-align:left'>Чтобы составить имя,
специфичное для производителя, сам производитель добавляет идентификатор
компании (заглавными буквами) и дополнительную информацию (например, тип
компьютера). Например, если компания XYZ хочет добавить новую функцию и
символическую константу, их имена могут быть в форме <b>glCommandXYZ()</b> и
GL_DEFINITION_XYZ, соответственно. Если компания XYZ хочет разработать
расширение доступное только на их «Специально Разработанной (Special
Developed)» видеокарте, именами могут быть <b>glCommandXYZsd()</b> и
GL_DEFINITION_XYZ_SD.</p>

<p class=text align=left style='text-align:left'>Если двое или более
производителей согласны реализовать то же расширение, то к именам функций и
констант добавляется более общий суффикс EXT (<b>glCommandEXT()</b> и
GL_DEFINITION_EXT).</p>

<p class=text align=left style='text-align:left'>Похожим образом, если
расширение было принято OpenGL ARB, к именам функций и констант добавляется
суффикс ARB (<b>glCommandARB()</b> и GL_DEFINITION_ARB).</p>

<p class=text align=left style='text-align:left'>Если вы хотите выяснить,
поддерживается ли конкретное расширение в вашей реализации, сначала вызовите <b>glGetString()</b>
с аргументом GL_EXTENSIONS, а затем – <b>gluGetString()</b> с аргументом
GLU_EXTENSIONS. Эти команды вернут полный список расширений, поддерживаемых
вашей реализацией. В обеих строках индивидуальные имена расширений разделяются
пробелами.</p>

<p class=text align=left style='text-align:left'>Первые расширения принятые ARB
появились в OpenGL версии 1.2. Если в реализации стандарта этой версии
поддерживалось подмножество команд обработки изображений (Imaging Subset), в
возвращенной строке расширений присутствовал фрагмент GL_ARB_imaging. Наличие
фрагмента GL_ARB_multitexture свидетельствовало о том, что реализация
поддерживает механизм мультитекстурирования, принятый ARB.</p>

<p class=text align=left style='text-align:left'>Если вы работаете с GLU версии
1.3 или выше, вы можете использовать функция <b>gluCheckExtension()</b> для
определения того, поддерживается ли конкретное расширение.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>GLboolean
  <b>gluCheckExtension</b> (char* <i>extName</i>, const GLubyte* <i>extString</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Возвращает GL_TRUE, если
строка <i>extName</i> обнаружена в <i>extString</i>, и GL_FALSE в ином случае.</p>

<p class=text align=left style='text-align:left'><b>gluCheckExtension()</b>
может проверять как расширения OpenGL, так и GLX, и GLU.</p>

<p class=text align=left style='text-align:left'>Чтобы обнаружить
поддерживается ли конкретное расширение при работе с GLU ранних версий, вы
можете использовать код из примера 14-2, который просматривает список
расширений в поисках нужного. Функция <b>QueryExtension()</b> возвращает
GL_TRUE, если расширение обнаружено и GL_FALSE в противном случае.</p>

<p class=text align=left style='text-align:left'>Пример 14-2. Выявление наличия
поддержки расширения (для кода с использованием GLU 1.0, 1.1 или 1.2)</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  style='color:black'>GLboolean QueryExtension(char *extName)<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>{<o:p></o:p></span></pre><pre><span style='color:black'><span style='mso-spacerun:yes'>      </span>char *p=(char*)glGetString(GL_EXTENSIONS);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>char *end;<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>if(p==NULL)<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>return GL_FALSE;<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>end=p+strlen(p);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>while(p&lt;end)<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>{<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>int n=strcspn(p,&quot; &quot;);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>if((strlen(extName)==n) &amp;&amp; (strncmp(extName,p,n)==0))<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>return GL_TRUE;<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>p+=(n+1);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>}<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>return GL_FALSE;<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<h2>14.3.1 Расширения к стандарту для Microsoft Windows (WGL)</h2>

<p class=text align=left style='text-align:left'>Если на платформе Microsoft
Windows вы хотите получить доступ к функциям расширений, вы должны:</p>

<p class=text align=left style='margin-left:54.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l10 level1 lfo61;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>создать условный код, базирующийся на
символической константе, идентифицирующей расширение </p>

<p class=text align=left style='margin-left:54.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l10 level1 lfo61;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>запросить обсуждаемую ранее строку расширений в
период выполнения программы </p>

<p class=text align=left style='margin-left:54.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l10 level1 lfo61;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>использовать функцию <b>wglProcAddress()</b> для
обнаружения указателя на функцию расширения. </p>

<p class=text align=left style='text-align:left'>Пример 14-3 демонстрирует
процесс обнаружения фиктивного расширения <b>glSpecialEXT()</b>. Заметьте, что
условный код (#ifndef) проверяет наличие определения GL_EXT_special. Если
расширение присутствует, то для указателя на функцию расширения определен
специальный тип PFNGLSPECIALEXTPROC. Наконец, <b>wglGetProcAddress()</b>
получает указатель на функцию.</p>

<p class=text align=left style='text-align:left'>Пример 14-3. Обнаружение
расширения OpenGL с помощью wglGetProcAddress()</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  style='color:black'>#ifdef GL_EXT_special<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>PFNGLSPECIALEXTPROC glSpecialEXT;<o:p></o:p></span></pre><pre><span
  style='color:black'>#endif<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>/* где-то в другом месте программы */<o:p></o:p></span></pre><pre><span
  style='color:black'>#ifdef GL_EXT_special<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glSpecialEXT=( PFNGLSPECIALEXTPROC)wglGetProcAddress(“glSpecialEXT”);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>assert(glSpecialEXT!=NULL);<o:p></o:p></span></pre><pre><span
  style='color:black'>#endif<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<h2>14.4 Пропускание света</h2>

<p class=text align=left style='text-align:left'>Вы можете использовать
шаблонирование полигонов для симуляции материала, пропускающего свет. Это
решение особенно полезно для систем, в которых отсутствует аппаратура для
цветового наложения. Поскольку размер рисунка шаблона полигона – 32 на 32 бита
или 1024 бита в целом, вы можете пройти от непрозрачного до прозрачного
материала за 1023 шага (на практике требуется значительно меньше шагов).
Например, если вы хотите, чтобы поверхность пропускала 29 процентов света,
создайте шаблон, в котором 29 процентов бит (это примерно 297 бит) будут
установлены в 0, а остальные в 1. Даже если все ваши поверхности должны
пропускать одинаковое количество света, не используйте один рисунок шаблона для
всех, поскольку они накроют те же самые биты на экране. Создавайте новый
рисунок для каждой поверхности, выбирая нужное количество бит, которые будут
установлены в 0, случайным образом.</p>

<p class=text align=left style='text-align:left'>Если вам не нравится эффект,
получающийся при случайном выборе бит, вы можете использовать определенные
рисунки, но они не работают так хорошо, в случае наложения прозрачных
поверхностей друг на друга. Часто это не является проблемой, поскольку
большинство сцен включают очень небольшое число прозрачных поверхностей. На
изображении автомобиля с прозрачными окнами линия вашего обзора может пройти
максимум через два окна, а чаще она проходит только через одно.</p>

<h2>14.5 Эффект исчезающего изображения</h2>

<p class=text align=left style='text-align:left'>Предположим, вы хотите, чтобы
изображение постепенно растворилось в цвете фона. Определите серию рисунков
полигональных шаблонов, в каждом из которых единице равно все больше и больше
бит (то есть рисунки шаблона должны быть все плотнее и плотнее). Затем
поочередно используйте эти шаблоны вместе с полигоном цвета фона достаточно
большим, чтобы закрыть ту область, которая должна раствориться. Например,
предположим, что вы хотите растворить изображение в черном цвете за 16 шагов.
Сначала определите 16 различных массивов с рисунками шаблонов:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>GLubyte stips[16][4*32];<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Затем загрузите их таким
образом, чтобы в первом рисунке в единицы была установлена 1/16 часть от 32x32
бит, а побитовое ИЛИ всех рисунков шаблона было равно всем единицам. Далее
нужно применить следующий код:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  style='color:black'>нарисовать_изображение();<o:p></o:p></span></pre><pre><span
  style='color:black'>glColor3f(0.0,0.0,0.0);<span style='mso-spacerun:yes'>      </span>/* установить текущий цвет в черный */<o:p></o:p></span></pre><pre><span
  style='color:black'>for(i=0;i&lt;16;i++)<o:p></o:p></span></pre><pre><span
  style='color:black'>{<o:p></o:p></span></pre><pre><span style='color:black'><span style='mso-spacerun:yes'>      </span>glPolygonStipple(&amp;stips[i][0]);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>нарисовать_большой_полигон_закрывающий_всю_область();<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>В некоторых реализациях OpenGL
вы получите большее быстродействие, если предварительно скомпилируете рисунки
шаблонов с списки отображения. Для этого во время инициализации сделайте нечто,
вроде этого:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  style='color:black'>#define STIP_OFFSET 100<o:p></o:p></span></pre><pre><span
  style='color:black'>for(i=0;i&lt;16;i++)<o:p></o:p></span></pre><pre><span
  style='color:black'>{<o:p></o:p></span></pre><pre><span style='color:black'><span style='mso-spacerun:yes'>      </span>glNewList(i+STIP_OFFSET,GL_COMPILE);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>glPolygonStipple(&amp;stips[i][0]);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glEndList();<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Затем в предыдущем фрагменте
кода замените строку</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>glPolygonStipple(&amp;stips[i][0]);
  <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>на</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>glCallList(i);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Скомпилировав команды
настройки рисунков шаблона в списки отображения, OpenGL может переработать
данные в <i>stips[ ][ ]</i> в аппаратно-зависимую форму, требуемую для
максимально быстрой работы с шаблонами.</p>

<p class=text align=left style='text-align:left'>Если и другое применение для
этой техники. Предположим, что вы рисуете изменяющуюся картинку и хотите, чтобы
предыдущие кадры не исчезали, а постепенно растворялись на фоне новых кадров.
Например, вы имитируете планетарную систему и хотите, чтобы за планетами
оставался постепенно исчезающий след, показывающий, где планета недавно
проходила. Предположим, что след должен исчезать опять-таки за 16 шагов и
используем те же рисунки шаблонов, что и в предыдущем примере (и те же списки
отображения). Тогда главный цикл может выглядеть следующим образом:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  style='color:black'>current_stipple=0;<o:p></o:p></span></pre><pre><span
  style='color:black'>while(1)<span style='mso-spacerun:yes'>                           </span>/* вечный цикл */<o:p></o:p></span></pre><pre><span
  style='color:black'>{<o:p></o:p></span></pre><pre><span style='color:black'><span style='mso-spacerun:yes'>      </span>нарисовать_следующий_кадр();<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glCallList(current_stipple)++;<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>if(current_stipple==16)<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>current_stipple=0;<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glColor3f(0.0,0.0,0.0);<span style='mso-spacerun:yes'>      </span>/* установить текущий цвет в черный */<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>нарисовать_большой_полигон_закрывающий_всю_область();<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>На каждой итерации цикла
очищается 1/16 часть пикселей. Все пиксели, на которых планеты не будет в
течение 16 итераций, будут закрашены черным цветом. Конечно, если в вашей
системе есть аппаратная поддержка цветового наложения, будет значительно проще
перед рисованием каждого кадра накладывать на изображение некоторое количество
цвета фона.</p>

<h2>14.6 Выбор объектов с помощью заднего буфера</h2>

<p class=text align=left style='text-align:left'>Хотя OpenGL предоставляет
мощный и гибкий механизм выбора, этот механизм иногда сложно использовать.
Часто ситуация достаточно проста: ваше приложение рисует сцену, состоящую из
некоторого количества объектов; пользователь указывает мышью на объект и
приложение должно найти объект под курсором.</p>

<p class=text align=left style='text-align:left'>Один из способов сделать это
требует, чтобы ваше приложение работало в режиме двойной буферизации. Когда
пользователь кликает на объекте, приложение перерисовывает всю сцену в заднем
буфере, но вместо использования обычных цветов объектов, оно кодирует
идентификаторы отдельных объекта с помощью разных цветов. Затем приложение
просто считывает пиксель под курсором и по значению цвета этого пикселя
определяет номер выбранного объекта. Если для каждого статического изображения
ожидается несколько кликов, вы можете считать все пиксели заднего буфера и
изучить нужные, вместо того, чтобы индивидуально проверять пиксель на месте
каждого клика.</p>

<p class=text align=left style='text-align:left'>Заметьте, что эта техника
имеет над механизмом выбора то преимущество, что всегда выбирается только
объект, находящийся ближе всего к наблюдателю, поскольку объекты рисуются один
поверх другого на тех же пикселях. Поскольку изображение с фальшивыми цветами
рисуется в заднем буфере, пользователь никогда его не увидит – вы можете снова
перерисовать его (или скопировать из переднего буфера) до переключения буферов.
В индексном цветовом режиме кодирование примитивно – передайте идентификатор
объекта в качестве индекса. В режиме RGBA закодируйте биты идентификатора в
компонентах R, G и B.</p>

<p class=text align=left style='text-align:left'>Имейте в виду, что если в
вашей сцене очень много объектов, уникальные идентификаторы могут закончиться.
Например, предположим, что вы работаете на системе с 4-ех битными буферами для
цветовых индексов (16 возможных индексов) в обоих – переднем и заднем буферах,
но в сцене присутствуют тысячи объектов. Чтобы решить такую проблему, можно
осуществлять выбор в несколько проходов. Чтобы поговорить об этом конкретнее,
предположим, что в вашей сцене менее 4096 объектов, то есть все идентификаторы
могут быть закодированы 12 битами. Во время первого прохода нарисуйте сцену с
использованием индексов, состоящих из 4-ех старших бит идентификаторов, затем,
во время второго и третьего проходов используйте индексы, состоящие из 4-ех
средних и младших битов идентификаторов. Во время каждого прохода, выясните
значение индекса под курсором и, в конце, упакуйте их вместе – это даст вам
идентификатор нужного объекта.</p>

<p class=text align=left style='text-align:left'>При таком подходе выбор
занимает в три раза больше времени, но иногда это приемлемо. Заметьте, что
после того, как вы получили 4 старших бита идентификатора, вы можете отбросить
15/16 всех объектов, так что на самом деле вам нужно нарисовать только 1/16 из
них на втором проходе. Похожим образом после второго прохода можно отбросить
255/256 возможных объектов. Таким образом, первый проход занимает столько же
времени, сколько рисование одного кадра, но второй и третий проходы могут
пройти в 16 и 256 быстрее, соответственно.</p>

<p class=text align=left style='text-align:left'>Если вы пытаетесь создать
переносимый код, работающий на различных системах, разбивайте ваши
идентификаторы на фрагменты, которые могут уместиться в наименьший общий
деноминатор этих систем (например, в байт). Также имейте в виду, что ваша
система в RGBA режиме может производить автоматическое цветовое микширование.
Если это так, вам придется его выключить.</p>

<h2>14.7 Простые преобразования изображений</h2>

<p class=text align=left style='text-align:left'>Если вы хотите нарисовать
измененную версию битового изображения (возможно, просто растянутую или
повернутую, а, возможно, значительно измененную с помощью математической
функции), существует множество возможностей. Вы можете использовать изображение
в качестве карты текстуры, позволяющей масштабировать, поворачивать и иначе
искажать изображение. Если вам просто нужно изменить масштаб изображения, вы можете
использовать команду <b>glPixelZoom()</b>.</p>

<p class=text align=left style='text-align:left'>Во многих случаях вы можете
добиться хороших результатов, нарисовав изображение каждого пикселя в виде
прямоугольника. Хотя эта методика не создает таких качественных изображений,
как те, что получаются с помощью алгоритмов фильтрации, но она работает
значительно быстрее.</p>

<p class=text align=left style='text-align:left'>Для конкретизации проблемы
предположим, что оригинальное изображение имеет размеры <i>m</i> на <i>n</i>
пикселей, с координатами между [<i>0,m-1</i>] и [<i>0,n-1</i>]. Пусть функциями
искажения будут <i>x(m,n)</i> и <i>y(m,n)</i>. Например, если искажение
представляет собой просто изменение масштаба с фактором 3.2, то <i>x(m,n)=3.2m</i>,
а <i>y(m,n)=3.2n</i>. Следующий код рисует искаженной изображение:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  style='color:black'>glShadeModel(GL_FLAT);<o:p></o:p></span></pre><pre><span
  style='color:black'>glScale(3.2,3.2,1.0);<o:p></o:p></span></pre><pre><span
  style='color:black'>for(j=0;j&lt;n;j++)<o:p></o:p></span></pre><pre><span
  style='color:black'>{<o:p></o:p></span></pre><pre><span style='color:black'><span style='mso-spacerun:yes'>      </span>glBegin(GL_QUAD_STRIP);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>          </span><span style='mso-spacerun:yes'>  </span>for(i=0;i&lt;=m;i++)<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>{<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>glVertex2i(i,j);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>glVertex2i(i,j+1);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>set_color(i,j);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>}<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glEnd();<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Этот код рисует каждый
трансформированный пиксель цветом, равным цвету этого пикселя и масштабирует
изображение на фактор 3.2. Функция <b>set_color()</b> представляет собой
функцию, устанавливающую цвет.</p>

<p class=text align=left style='text-align:left'>Далее приводится несколько
более обобщенная версия, которая искажает изображение с использованием функций <i>x(i,j)</i>
и <i>y(i,j)</i>:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  style='color:black'>glShadeModel(GL_FLAT);<o:p></o:p></span></pre><pre><span
  style='color:black'>glScale(3.2,3.2,1.0);<o:p></o:p></span></pre><pre><span
  style='color:black'>for(j=0;j&lt;n;j++)<o:p></o:p></span></pre><pre><span
  style='color:black'>{<o:p></o:p></span></pre><pre><span style='color:black'><span style='mso-spacerun:yes'>      </span>glBegin(GL_QUAD_STRIP);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>for(i=0;i&lt;=m;i++)<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>{<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>glVertex2i(x(i,j), y(i,j));<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>glVertex2i(x(i,j+1), y(i,j+1));<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>set_color(i,j);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>        </span><span style='mso-spacerun:yes'>    </span>}<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glEnd();<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>И даже еще лучшее искаженное
изображение может быть нарисовано с помощью следующего кода:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  style='color:black'>glShadeModel(GL_SMOOTH);<o:p></o:p></span></pre><pre><span
  style='color:black'>glScale(3.2,3.2,1.0);<o:p></o:p></span></pre><pre><span
  style='color:black'>for(j=0;j&lt;n-1;j++)<o:p></o:p></span></pre><pre><span
  style='color:black'>{<o:p></o:p></span></pre><pre><span style='color:black'><span style='mso-spacerun:yes'>      </span>glBegin(GL_QUAD_STRIP);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>for(i=0;i&lt;m;i++)<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>{<o:p></o:p></span></pre><pre><span
  style='color:black'> <span style='mso-spacerun:yes'>                 </span>set_color(i,j);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>glVertex2i(x(i,j), y(i,j));<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>set_color(i,j+1);<span style='mso-spacerun:yes'>            </span><o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>                  </span>glVertex2i(x(i,j+1), y(i,j+1));<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>            </span>}<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glEnd();<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Этот код плавно интерполирует
цвет по всему четырехугольнику. Заметьте, что последняя версия производи на
один четырехугольник меньше в каждом измерении, поскольку цвета изображения
используются в вершинах полигонов. Кроме того, вы можете сглаживать изображение
с помощью антиалиасинга и соответствующих факторов наложения (GL_SRC_ALPHA,
GL_ONE), чтобы еще больше улучшить качество изображения.</p>

<h2>14.8 Отображение слоев</h2>

<p class=text align=left style='text-align:left'>В некоторых приложениях
(например, в программах создания полупроводников) вам требуется отобразить
несколько слоев различных материалов и показать, где материалы пересекаются
между собой.</p>

<p class=text align=left style='text-align:left'>В качестве простого примера,
предположим, что у вас есть три различные субстанции, которые можно отобразить
в виде слоев. В любой точке может оказаться одна из восьми комбинаций слоев,
как показано в таблице 14-2.</p>

<p class=text align=left style='text-align:left'>Таблица 14-2. Восемь
комбинаций слоев </p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>&nbsp;<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Слой 1</span></b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Слой 2</span></b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Слой 3</span></b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Цвет</span></b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>отсутствует<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>отсутствует<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>отсутствует<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>черный<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>присутствует<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>отсутствует<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>отсутствует<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>красный<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>2<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>отсутствует<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>присутствует<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>отсутствует<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>зеленый<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>3<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>присутствует<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>присутствует<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>отсутствует<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>синий<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:5'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>4<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>отсутствует<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>отсутствует<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>присутствует<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>розовый<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:6'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>5<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>присутствует<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>отсутствует<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>присутствует<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>желтый<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:7'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>6<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>отсутствует<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>присутствует<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>присутствует<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>белый<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:8;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>7<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>присутствует<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>присутствует<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>присутствует<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>серый<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Вы хотите, чтобы ваша
программа отображала 8 разных цветов в зависимости от того, какие слои
присутствуют в определенной точке. Одна из возможных цветовых схем показана в
последней колонке таблицы 14-2. Чтобы применить этот метод, используйте
индексный цветовой режим и загрузите вхождения в палитру следующим образом: 0 –
черным цветом, 1 – красным, 2 – зеленым и так далее. Обратите внимание, что
если числа от 0 до 7 перевести в двоичную систему, то бит 4 будет установлен
везде, где присутствует слой 3, бит 2 – везде, где присутствует слой 2, а бит 1
– везде, где присутствует слой 1.</p>

<p class=text align=left style='text-align:left'>Для очистки окна, установите
маску записи в 7 (все три слоя), а очищающий цвет в 0. Чтобы нарисовать
изображение, установите цвет в 7, а маску записи в n, где n – это слой, в
котором вы хотите рисовать. В других типах приложений может появиться
необходимость удалить один из слоев. В этом случае вам нужно использовать маски
записи так, как было оговорено ранее, но цвет устанавливать не в 7, а в 0.</p>

<h2>14.9 Сглаженные символы</h2>

<p class=text align=left style='text-align:left'>Использование стандартной
техники отображения символов с помощью команды <b>glBitmap()</b> рисует каждый
пиксель символа по принципу «все или ничего» -- либо пиксель рисуется, либо
нет. Например, если вы рисуете черные символы на белом фоне, результирующие
символы либо черные, либо белые, без намека на оттенок серого. Плавные изображения
высокого качества могут быть получены при использовании промежуточных цветов (в
данном примере оттенков серого.)</p>

<p class=text align=left style='text-align:left'>В предположении, что вы
рисуете черные символы на белом фоне, представьте себе сильно увеличенное
изображение пикселей, на которое наложено изображение символа с высоким
разрешением, как показано на рисунке 14-1 слева.</p>

<p class=text align=left style='text-align:left'>Рисунок 14-1. Сглаженные
символы </p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1507" type="#_x0000_t75" alt="" style='width:465pt;height:232.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image368.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов14.mht!http://www.progz.ru/images/opengl/chapter14/14-1.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=620 height=310
src="OpenGL%20Red%20Book.files/image368.jpg" v:shapes="_x0000_i1507"><![endif]></p>

<p class=text align=left style='text-align:left'>Заметьте, что некоторые
пиксели полностью содержатся внутри границы символа и должны быть нарисованы
черным, некоторые полностью находятся вне границ символа и должны быть
нарисованы белым, но многие пиксели было бы идеально нарисовать одним из
оттенков серого, чтобы степень темноты оттенка соответствовала количеству
черного на пикселе. Если использовать эту технику, изображение на экране будет
иметь лучшее качество.</p>

<p class=text align=left style='text-align:left'>Если скорость и количество
памяти не дают поводов для беспокойства, каждый символ можно нарисовать в виде
небольшого изображения, а не битовой карты. Однако если вы работаете в&nbsp;
режиме RGBA, этот метод потребует до 32 бит на каждый пиксель символа вместо 1
для стандартного символа. Альтернативно вы можете использовать для каждого
пикселя 8-битовый индекс и конвертировать его в RGBA с помощью цветовой таблицы
во время переноса пикселей. Во многих случаях возможен компромисс, позволяющий
вам рисовать символы с помощью нескольких оттенков серого цвета, и
результирующее изображение при этом потребует всего 2 или 3 бита на пиксель.</p>

<p class=text align=left style='text-align:left'>Числа в правой части рисунка
14-1 показывают примерный проценты покрытия пикселя: 0 означает практическое
отсутствие такового, 1 означает одну треть покрытия, 2 – две трети и 3 – полное
покрытие пикселя символом. Если пиксели, отмеченные 0 рисовать белым, а
пиксели, отмеченные 3 рисовать черным, а пиксели с номерами 1 и 2 можно
рисовать оттенками 33% и 66% серого, соответственно, символы будут выглядеть
достаточно хорошо. Для сохранения чисел 0, 1, 2 и 3 требуется только 2 бита,
так что 2 бита позволяют сохранять 4 оттенка серого цвета.</p>

<p class=text align=left style='text-align:left'>Существует два основных метода
реализации сглаженных символов, применимость которых зависит от того, в каком
цветовом режиме вы работаете – в RGBA или в индексном.</p>

<p class=text align=left style='text-align:left'>В RGBA режиме создайте три
различных битовых карты символа, соответствующих пикселям с номерами 1, 2 и 3.
Установите цвет в белый и очистите экран. Установите цвет в 33% оттенок серого
(RGB=(0.666, 0.666, 0.666)) и нарисуйте все пиксели, отмеченные 1 (с помощью
одной из трех ранее подготовленных битовых карт). Затем установите RGB=(0.333,
0.333, 0.333) и нарисуйте вторую карту. Наконец, установите цвет в черный и
нарисуйте третью карту. В принципе вы создали три разных шрифта и перерисовали
строку символов три раза, причем каждый проход заполнил биты определенной
цветовой плотности.</p>

<p class=text align=left style='text-align:left'>В индексном режиме вы можете
сделать то же самое, но если вы решите использовать верно настроенную цветовую
карту и маску записи, вы можете обойтись всего двумя битовыми картами и двумя
проходами на строку. Вспомнив предыдущий пример, создайте первую битовую карту,
содержащую все пиксели, отмеченные 1 или 3. Создайте вторую битовую карту из
пикселей, отмеченных 2 или 3. Загрузите цветовую карту так, чтобы в 0
содержался белый, в 1 светло-серый, в 2 – темно-серый, а в 3 – черный.
Установите цвет в 3, а маску записи в 1 и нарисуйте первую карту. Затем
измените маску на 2 и нарисуйте вторую. В тех местах, где на рисунке 14-1 стоят
0, в буфере кадра ничего нарисовано не будет. Там, где стоят 1, 2 и 3, в буфере
окажутся 1, 2 и 3.</p>

<p class=text align=left style='text-align:left'>Для данного примера с 4-мя
оттенками серого экономия достаточно мала – два прохода вместо трех. Если бы
использовалось 8 оттенков вместо 4, метод RGBA потребовал бы 7 проходов, а
индексный только три. С 16 оттенками серого соотношение было бы 15 проходов к
4.</p>

<h2>14.10 Рисование круглых точек</h2>

<p class=text align=left style='text-align:left'>Чтобы нарисовать почти круглые
несглаженные точки, нужно активизировать сглаживание точек, выключить цветовое
наложение и использовать альфа функцию (в альфа – тесте), которая пропускает
только фрагменты со значением альфа большим 0.5.</p>

<h2>14.11 Интерполяция изображений</h2>

<p class=text align=left style='text-align:left'>Предположим, что у вас имеется
два изображения (загруженных из файла или сгенерированных с помощью геометрии
обычным путем), и вы хотите, чтобы одно изображение плавно перешло в другое.
Это можно легко сделать при помощи альфа компонента и соответствующих операций
наложения. Скажем, вы хотите достигнуть полного перехода за 10 шагов, при этом
изображение A будет полностью показано в кадре 0, а изображение B будет
полностью показано в кадре 9. Очевидный подход заключается в том, чтобы в i-ом
кадре рисовать изображение A с альфа равным (9-<i>i</i>)/9, а изображение B с
альфа равным i/9.</p>

<p class=text align=left style='text-align:left'>Проблема этого метода
заключается в том, что оба изображения должны рисовать в каждом кадре. Было бы
быстрее нарисовать изображение A в кадре 0. Затем для получения кадра 1 можно
совместить 1/9 изображения B и 8/9 того изображение, которое уже нарисовано на
экране. В кадре 2 нужно совместить 1/8 изображения B и 7/8 имеющегося
изображения. Для кадра 3 нужно совместить 1/7 изображения B с 6/7 имеющегося
изображения и так далее. На последнем шаге вам нужно нарисовать 1/1 изображения
B и 0/1 имеющегося изображения, то есть вам нужно вывести только изображение B.</p>

<p class=text align=left style='text-align:left'>Чтобы понять, как это
работает, предположим, что ваше изображение на кадре <i>i</i> представляет
собой </p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1508" type="#_x0000_t75" alt="" style='width:75pt;height:35.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image369.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов14.mht!http://www.progz.ru/images/opengl/chapter14/form001.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=100 height=47
src="OpenGL%20Red%20Book.files/image369.jpg" v:shapes="_x0000_i1508"><![endif]></p>

<p class=text align=left style='text-align:left'>и вы смешиваете B/(9-i) с
(8-i)/(9-i) этого изображения. Тогда вы получите следующее:</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1509" type="#_x0000_t75" alt="" style='width:291.75pt;height:34.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image370.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов14.mht!http://www.progz.ru/images/opengl/chapter14/form002.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=389 height=46
src="OpenGL%20Red%20Book.files/image370.jpg" v:shapes="_x0000_i1509"><![endif]>.</p>

<h2>14.12 Создание ярлыков</h2>

<p class=text align=left style='text-align:left'>Предположим, что вы рисуете
сложную трехмерную картинку с использованием буфера глубины для удаления
невидимых поверхностей. Кроме того, предположим, что одна из частей вашей
картинки состоит из двух объектов, лежащих на одной плоскости – A и B. При этом
B является чем-то вроде ярлыка, который всегда должен появляться поверх A.</p>

<p class=text align=left style='text-align:left'>Первым, приходящим на ум
подходом, является рисовать B после рисования A, установив функцию теста
глубины таким образом, чтобы тест проходили фрагменты с глубиной большей или
равной тому, что записано в буфере глубины (GL_GEQUAL). Однако благодаря
ограниченной точности дробного представления вершин, ошибки округления могут
приводить к тому, что объект B иногда будет появляться перед объектом A, а
иногда – за ним. Далее приводится одно из решений проблемы:</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l45 level1 lfo62;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>1.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Запретить запись в буфер глубины и вывести
объект A. </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l45 level1 lfo62;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>2.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Разрешить запись в буфер глубины и вывести
объект B. </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l45 level1 lfo62;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>3.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Запретить запись в цветовой буфер и вывести
объект A. </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l45 level1 lfo62;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>4.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Разрешить запись в цветовой буфер. </p>

<p class=text align=left style='text-align:left'>Обратите внимание на то, что
тест глубины активизирован и выполняется в течение всего процесса. На шаге <st1:metricconverter
ProductID="1 A">1 A</st1:metricconverter> отображается там, где должно, но
никакие величины не записываются в буфер глубины; следовательно, на шаге 2
гарантируется появление объекта B. Шаг 3 просто позволяет убедиться в том, что
все значения глубины под A установлены в правильные значения, но, поскольку
цветовой буфер закрыт для записи, пиксели на экране не изменяются. Наконец, шаг
4 возвращает системы к состоянию по умолчанию (оба буфера – цветовой и глубины
– открыты для записи).</p>

<p class=text align=left style='text-align:left'>Если имеется буфер трафарета,
можно использовать более простую технику.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l21 level1 lfo63;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>1.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Настройте буфер трафарета, чтобы он записывал 1
в случае прохождения фрагментом теста глубины и 0 в противном случае. Нарисуйте
A. </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l21 level1 lfo63;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>2.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Настройте буфер трафарета, запретив изменение
его величин и разрешив визуализацию только там, где значение в буфере трафарета
равно 1. Заблокируйте тест буфера глубины и изменение величин в нем. Нарисуйте
B. </p>

<p class=text align=left style='text-align:left'>При использовании этого метода
нет необходимости где-либо инициализировать содержимое буфера трафарета,
поскольку значения трафарета всех интересующих пикселей (то есть тех, на
которых будет отображаться A) будут установлены в процессе визуализации A. Не
забудьте активизировать тест буфера глубины и деактивировать тест трафарета до
того, как начнете рисовать остальные объекты сцены.</p>

<h2>14.13 Рисование закрашенных вогнутых полигонов с помощью буфера трафарета</h2>

<p class=text align=left style='text-align:left'>Возьмем вогнутый полигон <i>1234567</i>,
показанный на рисунке 14-2. Представьте, что он рисуется в виде серии
треугольников: <i>123</i>, <i>134</i>, <i>145</i>, <i>156 </i>и <i>167</i>.
Толстая линия показывает границу оригинального полигона. Рисование всех этих
треугольников разделяет буфер на 9 областей <i>A</i>, <i>B</i>, <i>C</i>, ..., <i>I</i>,
причем <i>I</i> находится вне всех треугольников.</p>

<p class=text align=left style='text-align:left'>Рисунок 14-2. Выпуклый полигон
</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1510" type="#_x0000_t75" alt="" style='width:465pt;height:265.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image371.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов14.mht!http://www.progz.ru/images/opengl/chapter14/14-2.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=620 height=354
src="OpenGL%20Red%20Book.files/image371.jpg" v:shapes="_x0000_i1510"><![endif]></p>

<p class=text align=left style='text-align:left'>В тексте к рисунку справа от
имени каждой области приводится список треугольников, которые его накрывают.
Области <i>A</i>, <i>D</i> и <i>F</i> составляют оригинальный полигон; обратите
внимание на то, что эти области накрыты нечетным количеством треугольников. Все
остальные области накрыты четным (возможно нулевым) числом треугольников. Таким
образом, чтобы отобразить вогнутый полигон, вам нужно вывести только области,
ограниченные нечетным числом треугольников. Это может быть сделано с помощью
буфера трафарета и двухпроходного алгоритма.</p>

<p class=text align=left style='text-align:left'>Сначала очистите буфер
трафарета и запретите запись в цветовой буфер. Далее, по очереди нарисуйте
каждый треугольник с использованием функции буфера трафарета GL_INVERT. (Для
большего быстродействия используйте примитив GL_TRIANGLE_FAN.) Каждый раз,
когда поверх пикселя буфет рисоваться треугольник, его значение трафарета буфет
переключаться то в нелулевое, то в нулевое. После того, как все треугольники
нарисованы, величина трафарета тех, пикселей, которые накрыты четным числом
треугольников будет нулевой. Величина же трафарета пикселей накрытых нечетным
числом треугольников будет не нулевой. Наконец, нарисуйте большой полигон над
всей областью (или перерисуйте треугольники), но разрешите рисование только
там, где значение в буфере трафарета не равно нулю.</p>

<p class=warning>Замечание: Существует обобщение приведенной техники, согласно
которому вы не обязаны начинать с вершины полигона. Пусть в примере <i>1234567 </i>точка
<i>P</i> – любая точка, принадлежащая или не принадлежащая полигону. Нарисуйте
треугольники <i>P12</i>, <i>P23</i>, <i>P34</i>, <i>P45</i>, <i>P56</i>, <i>P67
</i>и <i>P71</i>. Области, накрытые нечетным числом треугольников, находятся
внутри полигона, остальные области находятся снаружи полигона. Если <i>P</i>
находится на одном из ребер полигона, один из треугольников будет пустым.</p>

<p class=text align=left style='text-align:left'>Эта техника может
использоваться и для заполнения непростых полигонов (полигонов, чьи ребра
пересекаются) и для заполнения полигонов с дырами. Следующий пример
иллюстрирует обработку сложного полигона с двумя областями – одной
четырехсторонней и одной пятисторонней. Кроме того, предположим, что в полигоне
есть треугольная дыра и четырехугольная дыра (неважно в каких именно областях
находятся дыры). Назовем две области <i>abcd </i>и <i>efghi</i>, а дыры – <i>jkl
</i>и <i>mnop</i>. Пусть <i>z</i> – любая точка на плоскости. Нарисуем
следующие треугольники:</p>

<p class=text align=left style='text-align:left'><i>zab zbc zcd zda zef zfg zgh
zhi zie zjk zkl zlj zmn zno zop zpm</i></p>

<p class=text align=left style='text-align:left'>Пометьте области, накрытые
нечетным числом треугольников, как находящиеся внутри полигона, а остальные –
как находящиеся снаружи.</p>

<h2>14.14 Нахождение областей пересечения</h2>

<p class=text align=left style='text-align:left'>Если вы разрабатываете
какую-либо механическую деталь, сделанную из меньших по размеру трехмерных
частей, часто, вам необходимо отобразить те регионы, где части пересекаются. Во
многих случаях наличие таких областей свидетельствует об ошибках дизайна (части
машины соприкасаются там, где этого не должно быть). В случае движущихся частей
этот процесс может быть еще более полезен, так как поиск регионов пересечения
может производиться в течение всего цикла механической разработки. Метод,
позволяющий сделать это, довольно сложен, его описание здесь приводится
достаточно кратко.</p>

<p class=text align=left style='text-align:left'>Идея в том, чтобы пропустить
произвольную отсекающую плоскость между объектами, которые вы хотите
протестировать на пересечение, а далее определить те части этой плоскости,
которые находятся внутри более чем одного объекта одновременно. Для статических
изображений можно вручную сдвигать отсекающую плоскость для обнаружения
областей пересечения; для динамических может быть проще использовать сетку
отсекающих плоскостей для поиска всех возможных пересечений.</p>

<p class=text align=left style='text-align:left'>Нарисуйте каждый из
проверяемых объектов и отсеките их плоскостью. Запомните, какие пиксели
плоскости находятся внутри объекта, используя подсчет четное – нечетное в
буфере трафарета, как объяснено в разделе «Рисование закрашенных вогнутых
полигонов с помощью буфера трафарета». (Для правильно сформированных объектов
точка находится внутри, если луч из этой точки в сторону наблюдателя пересекает
нечетное число поверхностей объекта.) Чтобы найти пересечения, вам нужно найти
пиксели в буфере кадра, где отсекающая плоскость находится внутри двух или
более областей одновременно; другими словами на пересечении внутренних областей
любой пары объектов.</p>

<p class=text align=left style='text-align:left'>Если на пересечение нужно
протестировать множество объектов, сохраняйте один бит каждый раз, когда
появляется пересечение, а другой бит – когда отсекающий буфер находится внутри
любого из объектов (объединение внутренностей объектов). Для каждого нового
объекта определите его внутреннюю область, найдите пересечение этой области с
объединением внутренних областей уже протестированных объектов и учитывайте
точки пересечения. Затем добавьте внутренние точки нового объекта к объединению
внутренних областей других объектов.</p>

<p class=text align=left style='text-align:left'>Вы можете выполнить операции,
описанные в предыдущем параграфе, используя разные биты буфера трафарета,
совместно с разными операциями маскирования. На каждый пиксель требуется три
бита буфера трафарета – один для переключения, определяющего внутреннюю область
объекта; один для объединения всех внутренних областей, обнаруженных на данный
момент; и один для областей, в которых на данный момент обнаружено пересечение.
Чтобы сделать дискуссию более конкретной, предположим, что 1-ый бит буфера
трафарета используется для переключения между внутренними и внешними точками,
2-ой – для объединения и 4-ый – для пересечений. Для каждого выводимого
объекта, очистите 1-ый бит (используя маску трафарета 1 и очистив в 0), затем
переключайте 1-ый бит, оставляя маску в состоянии1 и, используя операцию трафарета
GL_INVERT.</p>

<p class=text align=left style='text-align:left'>Вы можете найти пересечения и
объединения битов в буфере трафарета, используя операции с трафаретом.
Например, чтобы поместить в буфер 2 объединение битов в буферах 1 и 2,
маскируйте трафарет на эти 2 бита и нарисуйте что-либо поверх всего объекта,
заставив функцию трафарета пропускать только фрагменты с ненулевым значением
трафарета в буфере. Это произойдет, если установлен бит в буфере 1, бит в
буфере 2 или биты в обоих буферах. Если сравнение удается, записывайте 1 в
буфер 2. Кроме того, убедитесь в том, что запись в цветовой буфер
заблокирована. Пересечения рассчитываются аналогично – установите функцию на
пропуск только тех фрагментов, чье значение в двух буферах трафарета равно 3
(биты установлены и в буфере 1, и в буфере 2). Запишите результат в нужный
буфер.</p>

<h2>14.15 Тени</h2>

<p class=text align=left style='text-align:left'>Любую возможную проекцию
трехмерного пространства на трехмерно пространство можно выполнить с помощью
подходящей инвертируемой матрицы 4x4 и однородных координат. Если матрица не
является инвертируемой, но имеет ранг 3, она проецирует трехмерное пространство
на двумерную плоскость. Любую проекцию такого типа можно выполнить с помощью
подходящей матрицы 4x4, имеющей ранг 3. Чтобы найти тень произвольного объекта
от произвольного источника света (возможно, лежащего в бесконечности) на
произвольную плоскость, вам нужно найти матрицу, представляющую такую проекцию,
умножить на нее матричный стек и нарисовать объект цветом тени. Имейте в виду,
что вы должны спроецировать объект на каждую плоскость, которую вы называете «землей».</p>

<p class=text align=left style='text-align:left'>В качестве простой
иллюстрации, предположим, что источник света находится в начале координат, а
плоскость «земли» представлена уравнением <i>ax+by+cz+d=0</i>. Возьмем вершину <i>S</i>=(<i>sx</i>,
<i>sy</i>, <i>sz</i>, <i>1</i>). Луч из источника света, проходящий через точку
<i>S</i>, содержит все точки&nbsp; <!--[if gte vml 1]><v:shape id="_x0000_i1511"
 type="#_x0000_t75" alt="" style='width:18pt;height:16.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image372.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов14.mht!http://www.progz.ru/images/opengl/chapter14/form003.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=24 height=22
src="OpenGL%20Red%20Book.files/image372.jpg" v:shapes="_x0000_i1511"><![endif]>,
где <!--[if gte vml 1]><v:shape id="_x0000_i1512" type="#_x0000_t75" alt=""
 style='width:12pt;height:15.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image373.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов14.mht!http://www.progz.ru/images/opengl/chapter14/form004.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=16 height=21
src="OpenGL%20Red%20Book.files/image373.jpg" v:shapes="_x0000_i1512"><![endif]>&nbsp;--
произвольное вещественное число. точка, где луч пересекает плоскость,
появляется тогда, когда: </p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1513" type="#_x0000_t75" alt="" style='width:173.25pt;height:16.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image374.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов14.mht!http://www.progz.ru/images/opengl/chapter14/form005.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=231 height=22
src="OpenGL%20Red%20Book.files/image374.jpg" v:shapes="_x0000_i1513"><![endif]></p>

<p class=text align=left style='text-align:left'>то есть</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1514" type="#_x0000_t75" alt="" style='width:134.25pt;height:36.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image375.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов14.mht!http://www.progz.ru/images/opengl/chapter14/form006.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=179 height=49
src="OpenGL%20Red%20Book.files/image375.jpg" v:shapes="_x0000_i1514"><![endif]>.</p>

<p class=text align=left style='text-align:left'>Помещая последнюю формулу в
уравнение линии, получаем:</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1515" type="#_x0000_t75" alt="" style='width:115.5pt;height:36pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image376.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов14.mht!http://www.progz.ru/images/opengl/chapter14/form007.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=154 height=48
src="OpenGL%20Red%20Book.files/image376.jpg" v:shapes="_x0000_i1515"><![endif]></p>

<p class=text align=left style='text-align:left'>или</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1516" type="#_x0000_t75" alt="" style='width:414pt;height:41.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image377.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов14.mht!http://www.progz.ru/images/opengl/chapter14/form008.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=552 height=55
src="OpenGL%20Red%20Book.files/image377.jpg" v:shapes="_x0000_i1516"><![endif]>где
I – точка пересечения описанного луча с плоскостью «земли», то есть одна из
точек, составляющих тень.</p>

<p class=text align=left style='text-align:left'>Матрица, которая отображает
точку S на точку I для любого S, равна:</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1517" type="#_x0000_t75" alt="" style='width:120pt;height:84pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image378.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов14.mht!http://www.progz.ru/images/opengl/chapter14/form009.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=160 height=112
src="OpenGL%20Red%20Book.files/image378.jpg" v:shapes="_x0000_i1517"><![endif]>.</p>

<p class=text align=left style='text-align:left'>Эту матрицу можно использовать,
если вы предварительно перенесете мировую систему координат, чтобы источник
света оказался в начале координат.</p>

<p class=text align=left style='text-align:left'>Если свет исходит от
источника, лежащего в бесконечности, все, что у вас есть – это точка S и
направление D=(<i>dx</i>, <i>dy</i>, <i>dz</i>). Точки вдоль луча получаются
как <!--[if gte vml 1]><v:shape id="_x0000_i1518" type="#_x0000_t75" alt=""
 style='width:42.75pt;height:18.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image379.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов14.mht!http://www.progz.ru/images/opengl/chapter14/form010.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=57 height=25
src="OpenGL%20Red%20Book.files/image379.jpg" v:shapes="_x0000_i1518"><![endif]>.</p>

<p class=text align=left style='text-align:left'>Действуя, как и прежде,
пересечение этого луча с плоскостью получается из уравнения</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1519" type="#_x0000_t75" alt="" style='width:287.25pt;height:18pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image380.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов14.mht!http://www.progz.ru/images/opengl/chapter14/form011.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=383 height=24
src="OpenGL%20Red%20Book.files/image380.jpg" v:shapes="_x0000_i1519"><![endif]>.</p>

<p class=text align=left style='text-align:left'>Разрешая это уравнение
относительно <!--[if gte vml 1]><v:shape id="_x0000_i1520" type="#_x0000_t75"
 alt="" style='width:12pt;height:15.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image373.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов14.mht!http://www.progz.ru/images/opengl/chapter14/form004.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=16 height=21
src="OpenGL%20Red%20Book.files/image373.jpg" v:shapes="_x0000_i1520"><![endif]>,
помещая получившуюся формулу в уравнение луча и, далее, определяем проекционную
матрицу</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1521" type="#_x0000_t75" alt="" style='width:418.5pt;height:85.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image381.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов14.mht!http://www.progz.ru/images/opengl/chapter14/form012.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=558 height=114
src="OpenGL%20Red%20Book.files/image381.jpg" v:shapes="_x0000_i1521"><![endif]>.</p>

<p class=text align=left style='text-align:left'>При наличии уравнения
плоскости и произвольного вектора направления, эта матрица работает без
предварительных переносов чего-либо куда-либо. </p>

<h2>14.16 Удаление невидимых линий</h2>

<p class=text align=left style='text-align:left'>Если вы хотите нарисовать
каркасный объект с удалением невидимых линий, один из подходов заключается в
том, чтобы сначала нарисовать границы в виде линий, а затем закрасить
внутренние области полигонов, приводя поверхности полигонов в соответствие с
цветом фона. С включенным буфером глубины эта закраска внутренних областей
накроет любые границы, которые должны быть загорожены гранями, находящимися
ближе к наблюдателю. Этот метод работает до тех пор, пока внутренние области
объекта полностью заключены в границы полигонов; на самом деле они могут
накладываться друг на друга в различных местах (в результате будут получаться
«прошитые полигоны»).</p>

<p class=text align=left style='text-align:left'>Существует простое
двухпроходное решение, использующее либо полигональное смещение, либо буфер
трафарета. Полигональное смещение обычно предпочтительнее, поскольку оно, как
правило, работает быстрее, чем буфер трафарета. Далее описаны оба метода, так
что вы можете увидеть, как работают оба подхода к решению проблемы.</p>

<h2>14.16.1 Удаление невидимых линий с помощью полигонального смещения</h2>

<p class=text align=left style='text-align:left'>Чтобы использовать
полигональное смещение для удаления невидимых линий, объект рисуется дважды.
Сначала выбранным цветом рисуются ребра полигонов с использованием
полигонального режима GL_LINE. Затем те же полигоны рисуются цветом фона в
режиме GL_FILL и с полигональным смещением, достаточным для того, чтобы
сдвинуть их дальше от наблюдателя.&nbsp; Полигональное смещение позволяет
избежать неприятных визуальных артефактов.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  style='color:black'>glEnable(GL_DEPTH_TEST);<o:p></o:p></span></pre><pre><span
  style='color:black'>glPolygonMode(GL_FRONT_AND_BACK,GL_LINE);<o:p></o:p></span></pre><pre><span
  style='color:black'>установить_цвет(передний_план);<o:p></o:p></span></pre><pre><span
  style='color:black'>нарисовать_объект_в_виде_закрашенных_полигонов();<o:p></o:p></span></pre><pre><span
  style='color:black'><o:p>&nbsp;</o:p></span></pre><pre><span
  style='color:black'>glPolygonMode(GL_FRONT_AND_BACK,GL_FILL);<o:p></o:p></span></pre><pre><span
  style='color:black'>glEnable(GL_POLYGON_OFFSET_FILL);<o:p></o:p></span></pre><pre><span
  style='color:black'>glPolygonOffset(1.0,1.0);<o:p></o:p></span></pre><pre><span
  style='color:black'>установить_цвет(фон);<o:p></o:p></span></pre><pre><span
  style='color:black'>нарисовать_объект_в_виде_закрашенных_полигонов();<o:p></o:p></span></pre><pre><span
  style='color:black'>glDisable(GL_POLYGON_OFFSET_FILL);<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Вам может понадобиться
изменить настройки смещения (для более толстых линий, например).</p>

<h2>14.16.2 Удаление невидимых линий с помощью буфера трафарета</h2>

<p class=text align=left style='text-align:left'>Использование буфера трафарета
для удаления невидимых линий – более сложная процедура. Для каждого полигона вы
должны очистить буфер трафарета, а затем нарисовать его границу и в буфере
кадра, и в буфере трафарета. Затем, при заполнении внутренних областей,
разрешите рисование только там, где буфер трафарета по-прежнему чист. Во
избежание очистки всего буфера трафарета для каждого полигона, можно записывать
в буфер 0 с помощью той же границы полигона. В этом случае полную очистку
буфера трафарета нужно будет произвести только один раз.</p>

<p class=text align=left style='text-align:left'>Например, следующий код
представляет собой внутренний цикл, который вы можете использовать для удаления
невидимых линий. Граница каждого полигона рисуется цветом переднего плана,
закрашивается цветом фона, и затем граница рисуется еще раз. Буфер трафарета
используется для предотвращения закрашивания границы цветом фона. Для
оптимизации быстродействия параметры трафарета и цвета изменяются только дважды
на итерацию оба раза с использованием одинаковых величин для рисования границ.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  style='color:black'>glEnable(GL_STENCIL_TEST);<o:p></o:p></span></pre><pre><span
  style='color:black'>glEnable(GL_DEPTH_TEST);<o:p></o:p></span></pre><pre><span
  style='color:black'>glClear(GL_STENCIL_BUFFER_BIT);<o:p></o:p></span></pre><pre><span
  style='color:black'>glStencilFunc(GL_ALWAYS,0,1);<o:p></o:p></span></pre><pre><span
  style='color:black'>glStencilOp(GL_INVERT,GL_INVERT,GL_INVERT);<o:p></o:p></span></pre><pre><span
  style='color:black'>установить_цвет(передний_план);<o:p></o:p></span></pre><pre><span
  style='color:black'>for(i=0;i&lt;max;i++)<o:p></o:p></span></pre><pre><span
  style='color:black'>{<o:p></o:p></span></pre><pre><span style='color:black'><span style='mso-spacerun:yes'>      </span>нарисовать_границу_полигона(i);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>установить_цвет(фон);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glStencilFunc(GL_EQUAL,0,1);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glStencilOp(GL_KEEP, GL_KEEP, GL_KEEP);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>нарисовать_закрашенный_полигон(i);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>установить_цвет(передний_план);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glStencilFunc(GL_ALWAYS,0,1);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>glStencilOp(GL_INVERT,GL_INVERT,GL_INVERT);<o:p></o:p></span></pre><pre><span
  style='color:black'><span style='mso-spacerun:yes'>      </span>нарисовать_границу_полигона(i);<o:p></o:p></span></pre><pre><span
  style='color:black'>}<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<h2>14.17 Варианты применения текстурирования</h2>

<p class=text align=left style='text-align:left'>Текстурирование является
мощной техникой, которая может быть использована различными интересными
способами. Вот несколько не очевидных вариантов применения текстурирования.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l55 level1 lfo64;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Сглаженный текст – Создайте для каждого символа
карту текстуры с относительно большим разрешением и наложите их на меньшие
области (полигоны) с использованием текстурной фильтрации. Такой метод
позволяет преобразовывать текст (поворачивать, масштабировать или искажать
другими способами).</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l55 level1 lfo64;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Сглаженные линии – Метод работает так же, как и
для текста: сделайте линии на текстуре шириной в несколько пикселей и
используйте фильтрацию.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l55 level1 lfo64;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Масштабирование и поворот изображений – Если вы
поместите изображение в текстуру, а текстуру – на полигон, преобразования
полигона будут отражаться и на изображении.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l55 level1 lfo64;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Изгибание изображений – Сохраните изображение в
карте текстуры, но наложите ее не на полигон, а на сплайновую поверхность
(используйте вычислители). Изменение контрольных точек поверхности приведет к
изменениям в изображении.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l55 level1 lfo64;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Проектирование изображений – Поместите
изображение в карту текстуры и спроецируйте его как прожектор, создав небольшой
прожекторный эффект.</p>

<h2>14.18 Рисование изображений, буферизованных по глубине</h2>

<p class=text align=left style='text-align:left'>Для сложных статических
изображений заднего плана время, требуемое на полную визуализацию из
геометрических данных, может значительно превосходить время, необходимое для
простого копирования того же плана, но в виде изображений. Если у вас
фиксированный задний план и относительно простой изменяющийся передний план, вы
можете решить, что стоит отобразить задний план и его величины глубины в виде
изображения, а не просчитывать его из геометрических данных. Передний план
также может состоять из элементов, которые долго просчитывать, но изображение и
величины глубины которых известны. Вы можете визуализировать эти элементы в
окружении с буфером глубины, используя двухпроходный алгоритм.</p>

<p class=text align=left style='text-align:left'>Например, если вы рисуете
молекулярную модель, созданную из сфер, у вас может быть припасено изображение
великолепно просчитанной сферы (и ассоциированные с ним значения глубины),
вычисленной с использованием закраски Фонга или трассировки лучей или с помощью
какого-либо другого метода не поддерживаемого OpenGL непосредственно. Чтобы
нарисовать сложную сцену, вам могут потребоваться сотни таких сфер, совместно
буферизуемых по глубине.</p>

<p class=text align=left style='text-align:left'>Чтобы добавить глубинированное
изображение к сцене, сначала запишите его значения глубины в буфер глубины с
помощью команды <b>glDrawPixels()</b>. Затем активизируйте тест глубины,
установите маску записи в 0, чтобы рисования не происходило, и активизируйте
трафарет таким образом, чтобы рисование в буфер трафарета происходило всегда,
когда происходит запись в буфер глубины.</p>

<p class=text align=left style='text-align:left'>Затем нарисуйте изображение в
цветовом буфере, маскированном буфером трафарета (в который вы только что
записали) таким образом, чтобы рисование происходило только в тех областях, где
в буфере трафарета стоит 1. Во время этого рисования установите функцию
трафарета на обнуление буфера трафарета, чтобы он автоматически очищался к
моменту добавления следующего изображения. Если объекты нужно придвинуть к
наблюдателю или отодвинуть от него, нужно использовать ортографическую
проекцию; в подобных случаях для перемещения глубинированного изображения
используйте GL_DEPTH_BIAS и команду <b>glPixelTransfer*()</b>.</p>

<h2>14.19 Многоугольники Вороного</h2>

<p class=text align=left style='text-align:left'>Если взять множество S точек
плоскости, многоугольником Вороного (или территорией Диричлета) для
произвольной точки A из S будет множество всех точек плоскости, находящихся
ближе к точке A, чем к любой другой точке из S. Множество получившихся точек
представляет собой решение многих проблем вычислительной геометрии.
Многоугольники Вороного для набора точек показаны на рисунке 14-3.</p>

<p class=text align=left style='text-align:left'>Рисунок 14-3. Многоугольники
Вороного </p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1522" type="#_x0000_t75" alt="" style='width:277.5pt;height:266.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image382.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов14.mht!http://www.progz.ru/images/opengl/chapter14/14-3.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=370 height=355
src="OpenGL%20Red%20Book.files/image382.jpg" v:shapes="_x0000_i1522"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Если для каждой точки из S вы
нарисуете глубинированный конус с вершиной в этой точке и цветом, отличающимся
от цвета каждой из точек в S, территория Диричлета буфет нарисована этим
цветом. Простейший путь сделать это заключается в предварительном расчете
глубины конуса в виде изображения и использование этого изображения в качестве
величин глубины, как описано в предыдущем разделе. Однако для рисования в буфер
кадра изображение (в отличие от случая со сферами) вам не требуется. Пока вы
рисуете в буфер глубины, используйте буфер трафарета для запоминания пикселей,
на которых нужно рисовать: сначала очистите буфер, а затем записывайте ненулевые
значения в тех местах, где тест глубины прошел. Чтобы нарисовать границы
территорий Диричлета нарисуйте полигон размером со все окно, но разрешите
рисование только там, где величины трафарета имеют ненулевое значение.</p>

<p class=text align=left style='text-align:left'>Вы можете сделать то же самое
значительно проще, визуализировав конусы одного и того же цвета с простым
буфером глубины, но хорошие конусы потребуют тысяч полигонов. Техника,
описанная в этом разделе, позволяет визуализировать изображения высокого
качества значительно быстрее.</p>

<h2>14.20 «Жизнь» в буфере трафарета</h2>

<p class=text align=left style='text-align:left'>«Игра в жизнь» («Game of
Life») изобретенная Джоном Конвейем, проходит на прямоугольной сетке, где
каждая клетка может быть «жива» или «мертва». Чтобы вычислить следующее
поколение из текущего, сосчитайте количество живых соседей для каждой клетки
(соседями каждой клетки являются 8 смежных клеток). Клетка жива в поколении <i>n+1</i>,
если она была жива в поколении <i>n</i> и имеет двух или трех живых соседей.
Клетка также жива в поколении <i>n+1</i>, если она была мертва в поколении <i>n</i>
и имеет точно живых соседей. Во всех остальных случаях клетка мертва в
поколении <i>n+1</i>. В зависимости от начальной конфигурации эта игра
генерирует потрясающе интересные рисунки. Рисунок 14-4 демонстрирует 6
поколений игры.</p>

<p class=text align=left style='text-align:left'>Рисунок 14-4. 6 поколений из
«Игры в жизнь» </p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1523" type="#_x0000_t75" alt="" style='width:465pt;height:375pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image383.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистов14.mht!http://www.progz.ru/images/opengl/chapter14/14-4.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=620 height=500
src="OpenGL%20Red%20Book.files/image383.jpg" v:shapes="_x0000_i1523"><![endif]></p>

<p class=text align=left style='text-align:left'>Одним из способов создания
этой игры с помощью OpenGL является использование многопроходного алгоритма.
Данные содержатся в цветовом буфере – по одному пикселю на клетку игровой
сетки. Предположим, что цвет фона – черный (все нули), и, что цвет всех живых
клеток – не черный (отличный от нуля). Очистите буферы глубины и трафарета в
нули, установите маску записи буфера глубины в 0, а функцию сравнения так,
чтобы тест глубины проходили пиксели, имеющие значение глубины не равное
хранимому в буфере. Для итерирования считайте изображение с экрана, разрешите
запись в буфер глубины и установите функцию сравнения, чтобы она увеличивала
значение в буфере трафарета везде, где проходит тест глубины, а иначе оставляла
содержимое буфера трафарета неизменным. Запретите рисование в цветовой буфер.</p>

<p class=text align=left style='text-align:left'>Далее, нарисуйте изображение 8
раз, смещая его на один пиксель в каждом вертикальном, горизонтальном и
диагональном направлениях. Когда вы закончите, буфер трафарета будет содержать
числа, равные количеству живых соседей для каждого пикселя. Разрешите рисование
в цветовой буфер, установите текущий цвет равным цвету живых клеток, а функцию
трафарета установите таким образом, чтобы рисование происходило только там, где
значение трафарета равно 3 (три живых соседа). Кроме того, если рисование
происходит, уменьшайте величину в буфере трафарета. Затем нарисуйте
прямоугольник, покрывающий все изображение – это окрасит каждую клетку, имеющую
точно 3 живых соседа «живым» цветом.</p>

<p class=text align=left style='text-align:left'>На данный момент буфер
трафарета содержит числа 0, 1, 2, 4, 5, 6, 7 и 8. Клетки со значениями
трафарета 0, 1, 4, 5, 6, 7 и 8 должны быть очищены «мертвым»&nbsp; цветом.
Установите функцию трафарета таким образом, чтобы рисование происходило только
там, где значение трафарета не равно 2, а операцию трафарета – на обнуление
значения в любом случае. Затем нарисуйте большой полигон «мертвого» цвета
размером со все изображение. Итерация окончена.</p>

<p class=text align=left style='text-align:left'>Для того, чтобы получить
пригодную версию такой программы, вам, возможно, стоит увеличить сетку, чтобы
каждая клетка имела размер больший, чем один пиксель, поскольку с одним
пикселем на клетку трудно различить рисунок.</p>

<h2>14.21 Альтернативные варианты использования <span lang=EN-US
style='mso-ansi-language:EN-US'>glDrawPixels</span>() и <span lang=EN-US
style='mso-ansi-language:EN-US'>glCopyPixels</span>()</h2>

<p class=text align=left style='text-align:left'>Вы можете считать, что <b>glDrawPixels()</b>
предназначена только для рисования прямоугольных областей пикселей. Несмотря на
то, что именно для этого команда применяется чаще всего, существуют и другие
интересные варианты использования.</p>

<p class=text align=left style='text-align:left'>Видео – даже если ваша машина
не обладает специальной видеоаппаратурой, вы можете отображать небольшие видео
клипы, по очереди рисуя кадры с помощью <b>glDrawPixels()</b> в одной и той же
области заднего буфера и затем переключая буферы. Размер кадра, при котором вы
можете выводить их с допустимой скоростью, зависит от того, как быстро ваша
аппаратура рисует, так что если вы хотите качественную картинку, вы можете быть
ограничены размером 100x100 (или меньше).</p>

<p class=text align=left style='text-align:left'>Кисть – в программе рисования
форма вашей кисти может быть сымитирована с помощью величин альфа. Цвет краски
представлен в виде цветовых величин. Чтобы нарисовать что-либо синей круглой
кистью, рисуйте синий квадрат с помощью <b>glDrawPixels()</b>. При этом центр
изображения квадрата должен иметь максимальное альфа, которое убывало бы с
удалением от центра. Рисуйте, установив функцию наложения на использование
значения альфа входящего цвета и (1-альфа) имеющегося в буфере цвета. Если все
значения альфа кисти намного меньше единицы, то для получения четкого синего
цвета вам придется проводить кистью по одному и тому же месту несколько раз.
Если же все альфа величины кисти близки к 1, первый же росчерк поглотит большую
часть имеющегося рисунка.</p>

<p class=text align=left style='text-align:left'>Фильтрованное масштабирование
– если вы изменяете размер пиксельного изображения с использованием дробного
фактора, фильтрация, которую применит OpenGL может привести к серьезным
визуальным неприятностям. Чтобы улучшить качество фильтрации, сдвигайте
получившееся изображение на расстояние меньшее пикселя и перерисовывайте его
несколько раз с использованием альфа – наложения для усреднения результирующих
пикселей. Результатом будет фильтрованное масштабирование.</p>

<p class=text align=left style='text-align:left'>Транспозиция изображений – вы
можете переключать изображения одинакового размера на месте с помощью <b>glCopyPixels()</b>
и операции XOR. Этот метод позволяет избежать необходимости считывать
изображения обратно в процессорную память. Если A и B представляют собой 2
изображения, операция выглядит так:</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l50 level1 lfo65;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>a.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>A=A XOR B </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l50 level1 lfo65;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>b.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>B=A XOR B </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l50 level1 lfo65;tab-stops:list 36.0pt'><![if !supportLists]><span
style='mso-fareast-font-family:Verdana;mso-bidi-font-family:Verdana'><span
style='mso-list:Ignore'>c.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>A=A XOR B </p>

<p class=MsoNormal><a name=ПриложениеA><span style='display:none;mso-hide:all'><o:p>&nbsp;</o:p></span></a></p>

<h1 align=left style='text-align:left'><span style='mso-bookmark:ПриложениеA'>Приложение
A. Переменные состояния</span></h1>

<span style='mso-bookmark:ПриложениеA'></span>

<p class=MsoNormal><a href="mailto:ahinar@list.ru"></a><span style='font-size:
10.0pt;font-family:Verdana'>В этом приложении перечисляются переменные
состояния OpenGL, их значения по умолчанию, их смысл и команды, с помощью
которых можно получить их текущее значение.<o:p></o:p></span></p>

<h2>Опросные команды</h2>

<p class=text align=left style='text-align:left'>В дополнение к основным
командам, позволяющим получить простые значения переменных состояния (таким как
<b>glGetIntegerv()</b> или <b>glIsEnabled()</b>), существуют более
специализированные команды для возврата более сложных значений. Ниже
перечислены прототипы этих команд.</p>

<p class=text align=left style='text-align:left'>Для выяснения того, когда вы
должны использовать эти команды и с какими константами, воспользуйтесь
таблицами в следующем разделе.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void <b>glGetClipPlane</b> (GLenum <i>plane</i>, GLdouble *<i>equation</i>);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void <b>glGetColorTable</b> (GLenum <i>target</i>, GLenum <i>pname</i>, GLenum <i>type</i>, GLvoid *<i>table</i>);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void <b>glGetColorTableParameter</b>{if}<b>v</b> (GLenum <i>target</i>, GLenum <i>pname</i>, TYPE *<i>params</i>);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void <b>glGetConvolutionFilter</b> (GLenum <i>target</i>, GLenum <i>format</i>, GLenum <i>type</i>, GLvoid *<i>image</i>);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void <b>glGetConvolutionParameter</b>{if}<b>v</b> (GLenum <i>target</i>, GLenum <i>pname</i>, TYPE *<i>params</i>);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>GLenum <b>glGetError</b> (void);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void <b>glGetHistogram</b> (GLenum <i>target</i>, GLboolean <i>reset</i>, GLenum <i>format</i>, GLenum <i>type</i>, GLvoid *<i>values</i>);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void <b>glGetHistogramParameter</b>{if}<b>v</b> (GLenum <i>target</i>, GLenum <i>pname</i>, TYPE *<i>params</i>);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void <b>glGetLight</b>{if}<b>v</b> (GLenum <i>light</i>, GLenum <i>pname</i>, TYPE *<i>params</i>);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void <b>glGetMap</b>{ifd}<b>v</b> (GLenum <i>target</i>, GLenum <i>query</i>, TYPE *<i>v</i>);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void <b>glGetMaterial</b>{if}<b>v</b> (GLenum <i>face</i>, GLenum <i>pname</i>, TYPE *<i>params</i>);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void <b>glGetMinmax</b> (GLenum <i>target</i>, GLboolean <i>reset</i>, GLenum <i>format</i>, GLenum <i>type</i>, GLvoid *<i>values</i>);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void <b>glGetMinmaxParameter</b>{if}<b>v</b> (GLenum <i>target</i>, GLenum <i>pname</i>, TYPE **<i>params</i>);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void <b>glGetPixelMap</b> {f ui us}<b>v</b> (GLenum <i>map</i>, TYPE *<i>values</i>);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void <b>glGetPolygonStipple</b> (GLubyte *<i>mask</i>);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void <b>glGetSeparableFilter</b> (GLenum <i>target</i>, GLenum <i>format</i>, GLenum <i>type</i>, GLvoid *<i>row</i>, GLvoid *<i>column</i>, GLvoid *<i>span</i>);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>const GLubyte* <b>glGetString</b> (GLenum <i>name</i>);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void <b>glGetTexEnv</b>{if}<b>v</b> (GLenum <i>target</i>, GLenum <i>pname</i>, TYPE *<i>params</i>);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void <b>glGetTexGen</b>{ifd}<b>v</b> (GLenum <i>coord</i>, GLenum <i>pname</i>, TYPE *<i>params</i>);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void <b>glGetTexImage</b> (GLenum <i>target</i>, GLint <i>level</i>, GLenum <i>format</i>, GLenum <i>type</i>, GLvoid *<i>pixels</i>);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void <b>glGetTexLevelParameter</b>{if}<b>v</b> (GLenum <i>target</i>, GLint <i>level</i>, GLenum <i>pname</i>, TYPE *<i>params</i>);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void <b>glGetTexParameter</b>{if}<b>v</b> (GLenum <i>target</i>, GLenum <i>pname</i>, TYPE *<i>params</i>);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>GLboolean <b>glIsList</b> (GLuint <i>list</i>);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>GLboolean <b>glIsTexture</b> (GLuint <i>texObject</i>);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void <b>gluGetNurbsProperty</b> (GLUnurbsObj *<i>nobj</i>, GLenum <i>property</i>, GLfloat *<i>value</i>);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>const GLubyte* <b>gluGetString</b> (GLenum <i>name</i>);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>void <b>gluGetTessProperty</b> (GLUtesselator *<i>tess</i>, GLenum <i>which</i>, GLdouble *<i>data</i>);<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<h2>Переменные состояния OpenGL</h2>

<p class=text align=left style='text-align:left'>Следующие страницы содержат
таблицы, в которых перечислены имена переменных состояния. Для каждой
переменной в таблице есть описание, группа атрибутов, к которой она
принадлежит, начальное или минимальное значение, а также рекомендуемая для
получения значения переменной команда <b>glGet*()</b>. Для переменных
состояния, значения которых могут быть получены с помощью команд <b>glGetBooleanv()</b>,
<b>glGetIntegerv()</b>, <b>glGetFloatv()</b> или <b>glDoublev()</b> в таблице
приводится только одна из этих команд – та, которая более всего подходит в
соответствии с типом возвращаемого значения. (Некоторые переменные, связанные с
вершинными массивами могут опрашиваться только с помощью <b>glGetPointerv()</b>.)
Эти переменные состояния не могут быть получены с помощью команды <b>glIsEnabled()</b>.
Однако переменные, для которых <b>glIsEnabled()</b> указано в качестве команды
опроса, могут быть получены так же и с помощью команды <b>glBooleanv()</b>, <b>glGetIntegerv()</b>,
<b>glGetFloatv()</b> или <b>glDoublev()</b>. Переменные состояния, для которых
в таблице указана любая другая опросная команда, могут быть получены только с
помощью этой команды.</p>

<p class=warning>Замечание: Когда вы опрашиваете состояние текстуры, например,
GL_TEXTURE_MATRIX, в реализации OpenGL, поддерживающей расширение
GL_ARB_multitexture, будут возвращены величины, относящиеся только к активному
в данный момент текстурному блоку.</p>

<p class=text align=left style='text-align:left'>Если в таблице приводится одна
или более групп атрибутов, это значит, что переменная состояния относится к
этой группе или группам. Если группа атрибутов не указана – переменная не
принадлежит ни к одной группе. Для сохранения и восстановления значений всех
переменных состояния, относящихся к определенной группе или группам атрибутов,
можно использовать команды <b>glPushAttrib()</b>, <b>glPopAttrib()</b>, <b>glPushClientAttrib()</b>
и <b>glPopClientAttrib()</b>.</p>

<p class=text align=left style='text-align:left'>Все опрашиваемые переменные
состояния имеют начальное значение, однако, для переменных, зависящих от
реализации, начальные значения могут не приводиться. </p>

<p class=text align=left style='text-align:left'>Таблица A-1. Текущие величины
и связанные с ними данные</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Переменная состояния</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Описание</span></b><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Группа атрибутов</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Начальное значение</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Опросная команда</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_CURRENT_COLOR<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Текущий цвет<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>текущие<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>(1,1,1,1)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv(), glGetFloatv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_CURRENT_INDEX<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Текущий цветовой индекс<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>текущие<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv(), glGetFloatv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_CURRENT_TEXTURE_COORDS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Текущие координаты текстуры<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>текущие<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>(0,0,0,1)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetFloatv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_CURRENT_NORMAL<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Текущая нормаль<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>текущие<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>(0,0,1)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetFloatv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:5'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_CURRENT_RASTER_POSITION<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Текущая позиция растра<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>текущие<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>(0,0,0,1)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetFloatv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:6'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_CURRENT_RASTER_DISTANCE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Текущая дистанция растра<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>текущие<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetFloatv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:7'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_CURRENT_RASTER_COLOR<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Цвет, ассоциированный с текущей позицией растра<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>текущие<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>(1,1,1,1)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv(), glGetFloatv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:8'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_CURRENT_RASTER_INDEX<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Цветовой индекс, ассоциированный с текущей позицией растра<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>текущие<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv(), glGetFloatv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:9'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_CURRENT_RASTER_TEXTURE_COORDS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Координаты текстуры, ассоциированные с текущей позицией растра<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>текущие<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>(0,0,0,1)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetFloatv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:10'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_CURRENT_RASTER_POSITION_VALID<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Бит допустимости позиции растра<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>текущие<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TRUE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetBooleanv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:11;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_EDGE_FLAG<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Флаг ребра (флаг границы)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>текущие<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TRUE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetBooleanv()<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Таблица A-2. Вершинные массивы</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Переменная состояния</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Описание</span></b><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Группа атрибутов</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Начальное значение</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Опросная команда</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_VERTEX_ARRAY<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Активность массива координат вершин<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>вершинные массивы<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glIsEnabled()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_VERTEX_ARRAY_SIZE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Число координат на вершину<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>вершинные массивы<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>4<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_VERTEX_ARRAY_TYPE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Тип координат вершин<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>вершинные массивы<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FLOAT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_VERTEX_ARRAY_STRIDE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Смещение между вершинами<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>вершинные массивы<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:5'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_VERTEX_ARRAY_POINTER<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Указатель на массив координат вершин<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>вершинные массивы<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>NULL<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetPointerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:6'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_NORMAL_ARRAY<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Активность массива нормалей<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>вершинные массивы<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glIsEnabled()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:7'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_NORMAL_ARRAY_TYPE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Тип координат нормали<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>вершинные массивы<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FLOAT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:8'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_NORMAL_ARRAY_STRIDE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Смещение между нормалями<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>вершинные массивы<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:9'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_NORMAL_ARRAY_POINTER<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Указатель на массив координат нормалей<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>вершинные массивы<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>NULL<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetPointerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:10'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_COLOR_ARRAY<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Активность массива RGBA цветов<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>вершинные массивы<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glIsEnabled()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:11'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_COLOR_ARRAY_SIZE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Число компонент на вершину<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>вершинные массивы<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>4<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:12'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_COLOR_ARRAY_TYPE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Тип цветовых компонентов<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>вершинные массивы<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FLOAT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:13'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_COLOR_ARRAY_STRIDE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Смещение между цветами<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>вершинные массивы<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:14'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_COLOR_ARRAY_POINTER<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Указатель на массив цветов<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>вершинные массивы<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>NULL<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetPointerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:15'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_INDEX_ARRAY<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Активность массива цветовых индексов<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>вершинные массивы<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glIsEnabled()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:16'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_INDEX_ARRAY_TYPE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Тип индексов<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>вершинные массивы<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FLOAT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:17'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_INDEX_ARRAY_STRIDE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Смещение между индексами<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>вершинные массивы<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:18'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_INDEX_ARRAY_POINTER<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Указатель на массив индексов<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>вершинные массивы<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>NULL<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetPointerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:19'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TEXTURE_COORD_ARRAY<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Активность массива координат текстуры<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>вершинные массивы<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glIsEnabled()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:20'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TEXTURE_COORD_ARRAY_SIZE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Число координат на элемент<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>вершинные массивы<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>4<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:21'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TEXTURE_COORD_ARRAY_TYPE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Тип координат текстуры<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>вершинные массивы<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FLOAT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:22'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TEXTURE_COORD_ARRAY_STRIDE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Смещение между координатами<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>вершинные массивы<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:23'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TEXTURE_COORD_ARRAY_POINTER<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Указатель на массив координат текстуры<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>вершинные массивы<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>NULL<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetPointerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:24'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_EDGE_FLAG_ARRAY<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Активность массива флагов ребра<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>вершинные массивы<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glIsEnabled()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:25'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_EDGE_FLAG_ARRAY_STRIDE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Смещение между флагами<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>вершинные массивы<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:26'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_EDGE_FLAG_ARRAY_POINTER<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Указатель на массив флагов<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>вершинные массивы<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>NULL<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetPointerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:27;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_CLIENT_ACTIVE_TEXTURE_ARB<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Активный текстурный блок для спецификации массивом текстурных
  координат<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>вершинные массивы<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TEXTURE0_ ARB<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Таблица A-3. Преобразования</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Переменная состояния</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Описание</span></b><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Группа атрибутов</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Начальное значение</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Опросная команда</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_COLOR_MATRIX<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Стек цветовых матриц<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Единичная<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetFloatv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_MODELVIEW_MATRIX<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Стек видовых матриц<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Единичная<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetFloatv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_PROJECTION_MATRIX<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Стек проекционных матриц<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Единичная<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetFloatv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TEXTURE_MATRIX<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Стек текстурных матриц<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Единичная<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetFloatv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:5'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_VIEWPORT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Начальная точка и размеры порта просмотра<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>порт просмотра<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:6'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_DEPTH_RANGE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Разброс глубин<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>порт просмотра<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0, 1<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetFloatv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:7'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_COLOR_STACK_DEPTH<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Указатель стека цветовых матриц<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:8'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_MODELVIEW_STACK_DEPTH<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Указатель стека видовых матриц<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:9'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_PROJECTION_STACK_DEPTH<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Указатель стека проекционных матриц<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:10'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TEXTURE_STACK_DEPTH<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Указатель стека текстурных матриц<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:11'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_MATRIX_MODE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Текущий матричный режим<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>трансформация<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_MODELVIEW<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:12'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_NORMALIZE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Активность режима нормализации нормалей<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>трансформация/ включенные<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glIsEnabled()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:13'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_RESCALE_NORMAL<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Активность режима масштабирования нормалей<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>трансформация/ включенные<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glIsEnabled()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:14'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_GET_CLIP_PLANE<i>i</i><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Коэффициенты <i>i</i>-ой пользовательской отсекающей плоскости<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>трансформация<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>(0,0,0,0)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetClipPlane()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:15;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_GET_CLIP_PLANE<i>i</i><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Активность <i>i</i>-ой пользовательской отсекающей плоскости<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>трансформация/ включенные<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glIsEnabled()<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Таблица A-4. Цвет</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Переменная состояния</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Описание</span></b><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Группа атрибутов</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Начальное значение</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Опросная команда</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FOG_COLOR<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Цвет тумана<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>туман<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>(0,0,0,0)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetFloatv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FOG_INDEX<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Цветовой индекс тумана<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>туман<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetFloatv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FOG_DENSITY<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Плотность экспоненциальная тумана<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>туман<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1.0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetFloatv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FOG_START<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Начало линейного тумана<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>туман<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0.0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetFloatv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:5'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FOG_END<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Конец линейного тумана<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>туман<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1.0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetFloatv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:6'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FOG_MODE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Режим тумана<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>туман<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_EXP<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:7'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FOG<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Активность тумана<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>туман/ включенные<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glIsEnabled()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:8;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_SHADE_MODEL<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Режим закраски<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>освещение<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_SMOOTH<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Таблица A-5. Освещение</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Переменная состояния</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Описание</span></b><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Группа атрибутов</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Начальное значение</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Опросная команда</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_LIGHTING<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Активность расчета освещенности<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>освещение/ включенные<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glIsEnabled()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_COLOR_MATERIAL<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Активность режима цвета материала<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>освещение<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glIsEnabled()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_COLOR_MATERIAL_PARAMETER<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Параметр, совпадающий с текущим цветом для режима цвета
  материала<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>освещение<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_AMBIENT_ AND_DIFFUSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_COLOR_MATERIAL_FACE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Затрагиваемые грани для режима цвета материала<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>освещение<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FRONT_ AND_BACK<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:5'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_AMBIENT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Фоновый цвет материала<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>освещение<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>(0.2,0.2,0.2,1.0)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetMaterialfv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:6'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_DIFFUSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Диффузный цвет материала<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>освещение<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>(0.8,0.8,0.8,1.0)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetMaterialfv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:7'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_SPECULAR<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Зеркальный цвет материала<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>освещение<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>(0.0,0.0,0.0,1.0)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetMaterialfv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:8'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_EMISSION<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Исходящий цвет материала<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>освещение<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>(0.0,0.0,0.0,1.0)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetMaterialfv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:9'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_SHININESS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Зеркальная экспонента материала<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>освещение<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0.0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetMaterialfv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:10'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_LIGHT_MODEL_AMBIENT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Глобальный фоновый цвет<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>освещение<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>(0.2,0.2,0.2,1.0)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetFloatv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:11'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_LIGHT_MODEL_LOCAL_VIEWER<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Локален ли наблюдатель<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>освещение<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetBooleanv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:12'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_LIGHT_MODEL_TWO_SIZE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Включено ли двухстороннее освещение<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>освещение<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetBooleanv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:13'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_LIGHT_MODEL_COLOR_CONTROL<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Отделяется ли зеркальный цвет<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>освещение<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_SINGLE_ COLOR<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:14'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_AMBIENT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Фоновая интенсивность источника <i>i</i><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>освещение<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>(0.0,0.0,0.0,1.0)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetLightfv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:15'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_DIFFUSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Диффузная интенсивность источника <i>i</i><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>освещение<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetLightfv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:16'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_SPECULAR<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Зеркальная интенсивность источника <i>i</i><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>освещение<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetLightfv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:17'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_POSITION<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Позиция источника <i>i</i><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>освещение<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>(0.0,0.0,1.0,0.0)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetLightfv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:18'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_CONSTANT_ATTENUATION<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Постоянный фактор ослабления<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>освещение<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1.0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetLightfv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:19'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_LINEAR_ATTENUATION<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Линейный фактор ослабления<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>освещение<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0.0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetLightfv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:20'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_QUDRATIC_ATTENUATION<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Квадратичный фактор ослабления<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>освещение<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0.0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetLightfv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:21'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_SPOT_DIRECTION<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Прожекторное направление источника <i>i</i><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>освещение<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>(0.0,0.0,-1.0)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetLightfv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:22'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_SPOT_EXPONENT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Прожекторная экспонента источника <i>i</i><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>освещение<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0.0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetLightfv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:23'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_SPOT_CUTOFF<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Прожекторный угол источника <i>i</i><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>освещение<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>180.0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetLightfv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:24'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_LIGHT<i>i</i><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Активность источника <i>i</i><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>освещение/ включенные<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glIsEnabled()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:25;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_COLOR_INDEXES<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Цветовые индексы для освещения в индексном режиме<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>освещение/ включенные<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0,1,1<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetMaterialfv()<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Таблица A-6. Растеризация</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Переменная состояния</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Описание</span></b><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Группа атрибутов</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Начальное значение</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Опросная команда</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_POINT_SIZE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Размер точек<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>точка<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1.0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetFloatv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_POINT_SMOOTH<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Активность режима сглаживания точек<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>точка/включенные<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glIsEnabled()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_LINE_WIDTH<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Толщина линий<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>линия<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1.0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetFloatv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_LINE_SMOOTH<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Активность режима сглаживания линий<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>линия/включенные<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glIsEnabled()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:5'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_LINE_STIPPLE_PATTERN<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Рисунок шаблона линий<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>линия<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Единицы<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:6'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_LINE_STIPPLE_REPEAT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Повторение шаблона линий<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>линия<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:7'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_LINE_STIPPLE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Активность режима шаблонирования линий<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>линия/ включенные<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glIsEnabled()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:8'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_CULL_FACE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Активность режима удаления нелицевых граней<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>полигон/ включенные<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glIsEnabled()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:9'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_CULL_FACE_MODE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Какие грани нужно удалять<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>полигон<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_BACK<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:10'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FRONT_FACE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Что считать лицевой гранью<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>полигон<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_CCW<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:11'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_POLYGON_SMOOTH<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Активность режима сглаживания полигонов<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>полигон/ включенные<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glIsEnabled()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:12'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_POLYGON_MODE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Режим растеризации полигонов<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>полигон<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FILL<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:13'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_POLYGON_OFFSET_FACTOR<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Фактор полигонального смещения<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>полигон<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetFloatv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:14'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_POLYGON_OFFSET_BIAS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Скос полигонального смещения<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>полигон<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetFloatv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:15'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_POLYGON_OFFSET_POINT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Активность полигонального смещения для точек<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>полигон/ включенные<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glIsEnabled()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:16'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_POLYGON_OFFSET_LINE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Активность полигонального смещения для линий<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>полигон/ включенные<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glIsEnabled()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:17'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_POLYGON_OFFSET_FILL<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Активность полигонального смещения для закрашенных областей<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>полигон/ включенные<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glIsEnabled()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:18'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_POLYGON_STIPPLE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Активность режима шаблонирования полигонов<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>полигон/ включенные<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glIsEnabled()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:19;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Рисунок шаблона полигона<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>шаблон полигона<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Единицы<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetPolygonStipple()<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Таблица A-7. Текстурирование</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Переменная состояния</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Описание</span></b><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Группа атрибутов</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Начальное значение</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Опросная команда</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TEXTURE_<i>x</i><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Активность текстурирования с размерностью <i>x</i><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>текстура/включенные<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glIsEnabled()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TEXTURE_BINDING_<i>x</i><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Объект текстуры прикреплен к GL_TEXTURE_<i>x</i> (где <i>x</i> –
  1D, 2D или 3D)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>текстура<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TEXTURE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Изображение <i>x</i>-D текстуры на уровне <i>i</i><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetTexImage()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TEXTURE_WIDTH<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Ширина <i>i</i>-го изображения <i>x</i>-D текстуры<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetTexLevelParameter*()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:5'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TEXTURE_HEIGHT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Высота <i>i</i>-го изображения <i>x</i>-D текстуры<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetTexLevelParameter*()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:6'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TEXTURE_DEPTH<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Глубина <i>i</i>-го изображения <i>x</i>-D текстуры<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetTexLevelParameter*()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:7'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TEXTURE_BORDER<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Ширина границы <i>i</i>-го изображения <i>x</i>-D текстуры<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetTexLevelParameter*()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:8'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TEXTURE_INTERNAL_FORMAT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Внутренний формат <i>i</i>-го изображения <i>x</i>-D текстуры<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetTexLevelParameter*()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:9'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TEXTURE_RED_SIZE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Разрешение красного компонента <i>i</i>-го изображения <i>x</i>-D
  текстуры<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetTexLevelParameter*()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:10'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TEXTURE_GREEN_SIZE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Разрешение зеленого компонента <i>i</i>-го изображения <i>x</i>-D
  текстуры<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetTexLevelParameter*()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:11'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TEXTURE_BLUE_SIZE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Разрешение синего компонента <i>i</i>-го изображения <i>x</i>-D
  текстуры<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetTexLevelParameter*()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:12'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TEXTURE_ALPHA_SIZE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Разрешение альфа компонента <i>i</i>-го изображения <i>x</i>-D
  текстуры<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetTexLevelParameter*()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:13'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TEXTURE_LUMINANCE_SIZE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Разрешение светлоты <i>i</i>-го изображения <i>x</i>-D текстуры<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetTexLevelParameter*()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:14'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TEXTURE_INTENSITY_SIZE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Разрешение интенсивности <i>i</i>-го изображения <i>x</i>-D
  текстуры<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetTexLevelParameter*()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:15'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TEXTURE_BORDER_COLOR<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Цвет границы текстуры<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>текстура<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>(0,0,0,0)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetTexParameter*()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:16'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TEXTURE_MIN_FILTER<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Функция уменьшения текстуры<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>текстура<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_NEAREST_ MIPMAP_ LINEAR<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetTexParameter*()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:17'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TEXTURE_MAG_FILTER<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Функция увеличения текстуры<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>текстура<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_LINEAR<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetTexParameter*()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:18'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TEXTURE_WRAP_<i>x</i><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Режим присоединения текстуры (где <i>x</i> – S, T или R)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>текстура<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_REPEAT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetTexParameter*()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:19'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TEXTURE_PRIORITY<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Приоритет текстурного объекта<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>текстура<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetTexParameter*()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:20'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TEXTURE_RESIDENT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Является ли текстура резидентной<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>текстура<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>по-разному<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetTexParameterfv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:21'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TEXTURE_MIN_LOD<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Минимальный уровень детализации<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>текстура<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-1000<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetTexParameterfv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:22'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TEXTURE_MAX_LOD<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Максимальный уровень детализации<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>текстура<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1000<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetTexParameterfv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:23'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TEXTURE_BASE_LEVEL<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Базовый текстурный массив<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>текстура<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetTexParameterfv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:24'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TEXTURE_MAX_LEVEL<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Максимальный уровень текстурного массива<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>текстура<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1000<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetTexParameterfv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:25'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TEXTURE_ENV_MODE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Режим наложения текстуры<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>текстура<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_MODULATE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetTexEnviv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:26'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TEXTURE_ENV_COLOR<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Цвет окружения текстуры<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>текстура<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>(0,0,0,0)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetTexEnvfv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:27'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TEXTURE_GEN_<i>x</i><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Активность автоматической генерации координат (где <i>x</i> – S,
  T или R)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>текстура/включенные<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glIsEnabled()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:28'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_EYE_PLANE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Коэффициенты уравнения плоскости для вычисления координат
  текстуры<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>текстура<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetTexGenfv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:29'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_OBJECT_PLANE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Коэффициенты уравнения плоскости&nbsp; в объектных координатах
  для вычисления координат текстуры<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>текстура<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetTexGenfv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:30'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TEXTURE_GEN_MODE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Режим генерирования текстурных координат<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>текстура<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_EYE_ LINEAR<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetTexGeniv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:31;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_ACTIVE_TEXTURE_ARB<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>активный текстурный блок<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>текстура<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TEXTURE0_ ARB<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Таблица A-8. Пиксельные
операции</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Переменная состояния</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Описание</span></b><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Группа атрибутов</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Начальное значение</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Опросная команда</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_SCISSOR_TEST<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Активность теста отреза<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>отрез/ включенные<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glIsEnabled()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_SCISSOR_BOX<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Габариты прямоугольника для теста отреза<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>отрез<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_ALPHA_TEST<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Активность альфа теста<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>цветовой буфер/включенные<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glIsEnabled()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_ALPHA_TEST_FUNC<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Функция альфа теста<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>цветовой буфер<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_ALWAYS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:5'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_ALPHA_TEST_REF<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Сравниваемое значения для альфа теста<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>цветовой буфер<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:6'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_STENCIL_TEST<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Активность теста трафарета<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>буфер трафарета/включенные<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glIsEnabled()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:7'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_STENCIL_FUNC<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Функция для теста трафарета<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>буфер трафарета<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_ALWAYS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:8'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_STENCIL_VALUE_MASK<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Маска теста трафарета<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>буфер трафарета<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Единицы<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:9'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_STENCIL_REF<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Сравниваемое значение теста трафарета<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>буфер трафарета<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:10'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_STENCIL_FAIL<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Действие при провале теста трафарета<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>буфер трафарета<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_KEEP<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:11'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_STENCIL_PASS_DEPTH_FAIL<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Действие при прохождении теста трафарета и провале теста глубины<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>буфер трафарета<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_KEEP<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:12'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_STENCIL_PASS_DEPTH_PASS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Действие при прохождении теста трафарета и прохождении теста
  глубины<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>буфер трафарета<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_KEEP<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:13'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_DEPTH_TEST<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Активность теста глубины<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>буфер глубины/включенные<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glIsEnabled()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:14'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_DEPTH_FUNC<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Функция теста глубины<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>буфер глубины<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_LESS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:15'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_BLEND<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Активность цветового наложения<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>цветовой буфер/включенные<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glIsEnabled()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:16'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_BLEND_SRC<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Фактор источника цветового наложения<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>цветовой буфер<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_ONE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:17'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_BLEND_DST<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Фактор приемника цветового наложения<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>цветовой буфер<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_ZERO<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:18'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_BLEND_EQUATION<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Уравнение цветового наложения<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>цветовой буфер<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FUNC_ADD<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:19'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_BLEND_COLOR<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Постоянный цвет наложения<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>цветовой буфер<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>(0,0,0,0)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetFloatv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:20'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_DITHER<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Активность микширования<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>цветовой буфер/ включенные<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TRUE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glIsEnabled()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:21'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_INDEX_LOGIC_OP<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Активность логических операций над цветовыми индексами<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>цветовой буфер/ включенные<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glIsEnabled()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:22'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_COLOR_LOGIC_OP<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Активность логических операций над RGBA цветами<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>цветовой буфер/ включенные<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glIsEnabled()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:23;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_LOGIC_OP_MODE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Применяемая логическая операция<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>цветовой буфер<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_COPY<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Таблица A-9. Управление
буфером кадра</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Переменная состояния</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Описание</span></b><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Группа атрибутов</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Начальное значение</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Опросная команда</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_DRAW_BUFFER<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Буферы, выбранные для записи<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>цветовой буфер<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_INDEX_WRITEMASK<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Маска записи цветовых индексов<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>цветовой буфер<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Единицы<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_COLOR_WRITEMASK<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Маска записи RGBA цветов<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>цветовой буфер<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TRUE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetBooleanv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_DEPTH_WRITEMASK<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Доступность буфера глубины для записи<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>буфер глубины<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_TRUE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetBooleanv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:5'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_STENCIL_WRITEMASK<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Маска записи индексов трафарета<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>буфер трафарета<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Единицы<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:6'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_COLOR_CLEAR_VALUE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Очищающий цвет (RGBA)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>цветовой буфер<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>(0,0,0,0)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetFloat()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:7'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_INDEX_CLEAR_VALUE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Очищающий цвет (индекс)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>цветовой буфер<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetFloat()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:8'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_DEPTH_CLEAR_VALUE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Очищающая величина для буфера глубины<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>буфер глубины<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:9'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_STENCIL_CLEAR_VALUE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Очищающая величина для буфера трафарета<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>буфер трафарета<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:10;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_ACCUM_CLEAR_VALUE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Очищающая величина для буфера аккумуляции<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>аккумулятор<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetFloat()<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Таблица A-10. Пиксели</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Переменная состояния</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Описание</span></b><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Группа атрибутов</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Начальное значение</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Опросная команда</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_UNPACK_SWAP_BYTES<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Значение для GL_UNPACK_SWAP_BYTES<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>режимы хранения пикселей<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetBooleanv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_UNPACK_LSB_FIRST<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Значение для GL_UNPACK_LSB_FIRST<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>режимы хранения пикселей<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetBooleanv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_UNPACK_IMAGE_HEIGHT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Значение для GL_UNPACK_IMAGE_HEIGHT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>режимы хранения пикселей<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_UNPACK_SKIP_IMAGES<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Значение для GL_UNPACK_SKIP_IMAGES<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>режимы хранения пикселей<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:5'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_UNPACK_ROW_LENGTH<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Значение для GL_UNPACK_ROW_LENGTH<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>режимы хранения пикселей<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:6'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_UNPACK_SKIP_ROWS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Значение для GL_UNPACK_SKIP_ROWS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>режимы хранения пикселей<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:7'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_UNPACK_SKIP_PIXELS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Значение для GL_UNPACK_SKIP_PIXELS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>режимы хранения пикселей<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:8'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_UNPACK_ALIGNMENT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Значение для GL_UNPACK_ALIGNMENT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>режимы хранения пикселей<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>4<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:9'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_PACK_SWAP_BYTES<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Значение для GL_PACK_SWAP_BYTES<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>режимы хранения пикселей<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetBooleanv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:10'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_PACK_LSB_FIRST<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Значение для GL_PACK_LSB_FIRST<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>режимы хранения пикселей<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetBooleanv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:11'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_PACK_IMAGE_HEIGHT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Значение для GL_PACK_IMAGE_HEIGHT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>режимы хранения пикселей<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:12'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_PACK_SKIP_IMAGES<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Значение для GL_PACK_SKIP_IMAGES<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>режимы хранения пикселей<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:13'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_PACK_ROW_LENGTH<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Значение для GL_PACK_ROW_LENGTH<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>режимы хранения пикселей<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:14'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_PACK_SKIP_ROWS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Значение для GL_PACK_SKIP_ROWS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>режимы хранения пикселей<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:15'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_PACK_SKIP_PIXELS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Значение для GL_PACK_SKIP_PIXELS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>режимы хранения пикселей<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:16'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_PACK_ALIGNMENT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Значение для GL_PACK_ALIGNMENT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>режимы хранения пикселей<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>4<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:17'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_MAP_COLOR<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Активность отображения цвета<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>пиксели<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetBooleanv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:18'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_MAP_STENCIL<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Активность отображения индексов трафарета<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>пиксели<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetBooleanv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:19'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_INDEX_SHIFT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Значение для GL_INDEX_SHIFT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>пиксели<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:20'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_INDEX_OFFSET<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Значение для GL_INDEX_OFFSET<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>пиксели<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:21'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_<i>x</i>_SCALE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Значение для GL_x_SCALE (где <i>x</i> – RED, GREEN, BLUE или
  ALPHA)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>пиксели<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetFloatv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:22'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_<i>x</i>_BIAS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Значение для GL_<i>x</i>_BIAS (где <i>x</i> – RED, GREEN, BLUE
  или ALPHA)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>пиксели<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetFloatv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:23'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_COLOR_TABLE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Активность цветовой таблицы<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>пиксели/ включенные<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glIsEnabled()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:24'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_POST_CONVOLUTION_COLOR_TABLE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Активность пост фильтрационной цветовой таблицы<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>пиксели/ включенные<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glIsEnabled()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:25'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_POST_COLOR_MATRIX_COLOR_TABLE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Активность пост матричной цветовой таблицы<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>пиксели/ включенные<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glIsEnabled()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:26'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_COLOR_TABLE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Цветовые таблицы<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Пусто<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetColorTable()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:27'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_COLOR_TABLE_FORMAT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Формат цветовой таблицы<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_RGBA<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetColorTableParameteriv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:28'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_COLOR_TABLE_WIDTH<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Ширина цветовой таблицы<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetColorTableParameteriv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:29'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_COLOR_TABLE_<i>x</i>_SIZE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Разрешение цветовых компонент цветовой таблицы (где <i>x</i> –
  RED, GREEN, BLUE, ALPHA, LUMINANCE или INTENSITY)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetColorTableParameteriv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:30'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_COLOR_TABLE_SCALE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Фактор масштаба цветовой таблицы<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>пиксели<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>(1,1,1,1)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetColorTableParameteriv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:31'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_COLOR_TABLE_BIAS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Скос цветовой таблицы<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>пиксели<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>(0,0,0,0)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetColorTableParameteriv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:32'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_CONVOLUTION_1D<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Активность 1D фильтрации<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>пиксели/ включенные<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glIsEnabled()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:33'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_CONVOLUTION_2D<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Активность 2D фильтрации<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>пиксели/ включенные<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glIsEnabled()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:34'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_SEPARABLE_2D<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Активность разделяемой 2D фильтрации<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>пиксели/ включенные<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glIsEnabled()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:35'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_CONVOLUTION_1D<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1D фильтр<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Пусто<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetConvolutionFilter()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:36'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_CONVOLUTION_2D<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>2D фильтр<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Пусто<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetConvolutionFilter()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:37'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_SEPARABLE_2D<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Разделяемый 2D фильтр<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Пусто<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetSeparableFilter()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:38'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_CONVOLUTION_BORDER_COLOR<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Цвет границы фильтра<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>пиксели<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>(0,0,0,0)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetConvolutionParameterfv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:39'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_CONVOLUTION_BORDER_MODE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Режим границы фильтра<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>пиксели<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_REDUCE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetConvolutionParameteriv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:40'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_CONVOLUTION_FILTER_SCALE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Масштаб фильтра<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>пиксели<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>(1,1,1,1)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetConvolutionParameterfv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:41'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_CONVOLUTION_FILTER_BIAS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Скос фильтра<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>пиксели<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>(0,0,0,0)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetConvolutionParameterfv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:42'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_CONVOLUTION_FORMAT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Формат фильтра<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_RGBA<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetConvolutionParameteriv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:43'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_CONVOLUTION_WIDTH<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Ширина фильтра<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetConvolutionParameteriv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:44'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_CONVOLUTION_HEIGHT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Высота фильтра<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetConvolutionParameteriv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:45'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_POST_CONVOLUTION_<i>x</i>_SCALE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Пост фильтрационный масштаб (где <i>x</i> – RED, GREEN, BLUE или
  ALPHA)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>пиксели<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetFloatv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:46'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_POST_CONVOLUTION_<i>x</i>_BIAS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Пост фильтрационный скос (где <i>x</i> – RED, GREEN, BLUE или
  ALPHA)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>пиксели<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetFloatv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:47'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_POST_COLOR_MATRIX_<i>x</i>_SCALE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Пост матричный масштаб (где <i>x</i> – RED, GREEN, BLUE или
  ALPHA)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>пиксели<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetFloatv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:48'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_POST_COLOR_MATRIX_<i>x</i>_BIAS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Пост матричный скос (где <i>x</i> – RED, GREEN, BLUE или ALPHA)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>пиксели<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetFloatv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:49'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_HISTOGRAM<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Активность гистограммы<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>пиксели/ включенные<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glIsEnabled()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:50'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_HISTOGRAM<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Таблица гистограммы<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Пусто<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetHistogram()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:51'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_HISTOGRAM_WIDTH<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Ширина гистограммы<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetHistogramParameteriv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:52'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_HISTOGRAM_FORMAT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Формат гистограммы<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_RGBA<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetHistogramParameteriv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:53'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_HISTOGRAM_<i>x</i>_SIZE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Разрешение цветовых компонент гистограммы (где <i>x</i> – RED,
  GREEN, BLUE, ALPHA или LUMINANCE)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetHistogramParameteriv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:54'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_HISTOGRAM_SINK<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Поглощение пиксельных групп<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetHistogramParameteriv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:55'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_MINMAX<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Активность расчетов минимального и максимального цветовых
  значений<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>пиксели/ включенные<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glIsEnabled()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:56'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_MINMAX<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Таблица минимальных и максимальных цветовых значений<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Таблица минимумов устанавливается в максимально допустимые
  величины, а таблица максимумов – в минимально представляемые<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetMinmax()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:57'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_MINMAX_FORMAT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Формат минимальных и максимальных цветовых значений<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_RGBA<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetMinmaxParameteriv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:58'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_MINMAX_SINK<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Поглощение пиксельных групп<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetMinmaxParameteriv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:59'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_ZOOM_X<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Фактор масштаба по X<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>пиксели<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1.0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetFloatv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:60'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_ZOOM_Y<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Фактор масштаба по Y<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>пиксели<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1.0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetFloatv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:61'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_PIXEL_MAP_<i>x</i><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Таблицы отображения пикселей<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Нули<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetPixelMap*()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:62'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_PIXEL_MAP_<i>x</i>_SIZE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Размер таблицы<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:63;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_READ_BUFFER<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Текущий буфер для чтения<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>пиксели<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Таблица A-11. Вычислители</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Переменная состояния</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Описание</span></b><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Группа атрибутов</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Начальное значение</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Опросная команда</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_ORDER<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>порядок 1D карты<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetMapiv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_ORDER<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>порядок 2D карты<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1,1<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetMapiv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_COEFF<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>контрольные точки 1D карты<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetMapfv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_COEFF<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>контрольные точки 2D карты<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetMapfv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:5'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_DOMAIN<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1D конечные точки<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetMapfv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:6'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_DOMAIN<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>2D конечные точки<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetMapfv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:7'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_MAP1_<i>x</i><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Активность 1D карты (где <i>x</i> – тип карты)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>вычислители/включенные<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glIsEnabled()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:8'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_MAP2_<i>x</i><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Активность 2D карты (где <i>x</i> – тип карты)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>вычислители/ включенные<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glIsEnabled()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:9'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_MAP1_GRID_DOMAIN<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Конечные точки 1D сетки<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>вычислители<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0,1<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetFloatv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:10'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_MAP2_GRID_DOMAIN<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Конечные точки 2D сетки<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>вычислители<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0,1;0,1<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetFloatv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:11'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_MAP1_GRID_SEGMENTS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Разделители 1D сетки<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>вычислители<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetFloatv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:12'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_MAP2_GRID_ SEGMENTS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Разделители 2D сетки<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>вычислители<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1,1<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetFloatv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:13'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_AUTO_NORMAL<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Активность автоматической генерации нормалей<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>вычислители<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FALSE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glIsEnabled()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:14'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_PERSPECTIVE_CORRECTION_HINT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Комплексная установка перспективной коррекции<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>комплексные установки<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_DONT_CARE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:15'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_POINT_SMOOTH_HINT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Комплексная установка сглаживания точек<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>комплексные установки<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_DONT_CARE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:16'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_LINE_SMOOTH_HINT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Комплексная установка сглаживания линий<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>комплексные установки<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_DONT_CARE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:17'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_POLYGON_SMOOTH_HINT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Комплексная установка сглаживания полигонов<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>комплексные установки<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_DONT_CARE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:18;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FOG_HINT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Комплексная установка качества тумана<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>комплексные установки<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_DONT_CARE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Таблица A-12. Значения,
зависящие от реализации</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Переменная состояния</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Описание</span></b><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Группа атрибутов</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Минимальное значение</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Опросная команда</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_MAX_LIGHTS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Максимальное количество источников света<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>8<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_MAX_CLIP_PLANES<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Максимальное количество отсекающих плоскостей<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>6<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_MAX_MODELVIEW_STACK_DEPTH<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Максимальная глубина стека видовых матриц<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>32<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_MAX_PROJECTION_STACK_DEPTH<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Максимальная глубина стека проекционных матриц<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>2<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:5'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_MAX_TEXTURE_STACK_DEPTH<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Максимальная глубина стека текстурных матриц<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>2<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:6'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_SUBPIXEL_BITS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Количество битов в <i>x</i> и <i>y</i>, влияющих на положение
  соответствующего пикселя на экране<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>4<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:7'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_MAX_3D_TEXTURE_SIZE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Для текстурного прокси<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>16<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:8'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_MAX_TEXTURE_SIZE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Для текстурного прокси<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>64<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:9'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_MAX_PIXEL_MAP_TABLE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Максимальный размер таблицы отображения пикселей (glPixelMap())<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>32<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:10'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_MAX_NAME_STACK_DEPTH<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Максимальная глубина стека имен для режима выбора<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>64<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:11'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_MAX_LIST_NESTING<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Максимальная вложенность вызовов списков отображения<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>64<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:12'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_MAX_EVAL_ORDER<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Максимальный порядок полинома вычислителя<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>8<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:13'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_MAX_VIEWPORT_DIMS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Максимальные размеры порта просмотра<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:14'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_MAX_ATTRIB_STACK_DEPTH<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Максимальная глубина стека атрибутов<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>16<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:15'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_MAX_CLIENT_ATTRIB_STACK_DEPTH<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Максимальная глубина клиентского стека атрибутов<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>16<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:16'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_AUX_BUFFERS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Количество дополнительных цветовых буферов<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetBooleanv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:17'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_RGBA_MODE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Текущим является режим RGBA<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetBooleanv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:18'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_INDEX_MODE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Текущим является индексный режим<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetBooleanv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:19'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_DOUBLEBUFFER<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Существуют передний и задний буферы<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetBooleanv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:20'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_STEREO<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Существуют левый и правый буферы<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetBooleanv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:21'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_ALIASED_POINT_SIZE_RANGE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Диапазон размеров несглаженных точек<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1,1<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetFloatv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:22'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_SMOOTH_POINT_SIZE_RANGE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Диапазон размеров сглаженных точек<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1,1<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetFloatv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:23'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_SMOOTH_POINT_SIZE_GRANULARITY<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Гранулярность размеров сглаженных точек<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetFloatv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:24'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_ALIASED_LINE_WIDTH_RANGE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Диапазон толщины несглаженных линий<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1,1<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetFloatv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:25'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_SMOOTH_LINE_ WIDTH_RANGE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Диапазон толщины сглаженных линий<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1,1<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetFloatv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:26'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_SMOOTH_LINE_WIDTH_GRANULARITY<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Гранулярность толщины сглаженных линий<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetFloatv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:27'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_MAX_CONVOLUTION_WIDTH<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Максимальная ширина фильтра<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetConvolutionParameteriv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:28'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_MAX_CONVOLUTION_HEIGHT<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Максимальная высота фильтра<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetConvolutionParameteriv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:29'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_MAX_ELEMENTS_INDICES<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Рекомендуемое максимальное число индексов при использовании
  glDrawRangeElements()<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:30'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_MAX_ELEMENTS_VERTICES<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Рекомендуемое максимальное число вершин при использовании
  glDrawRangeElements()<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:31;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_MAX_TEXTURE_UNITS_ARB<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Максимальное число текстурных блоков<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>1<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Таблица A-13. Глубина
пикселей, зависящая от реализации</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Переменная состояния</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Описание</span></b><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Группа атрибутов</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Минимальное значение</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Опросная команда</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_RED_BITS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Число бит на красный компонент в цветовом буфере<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_GREEN_BITS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Число бит на зеленый компонент в цветовом буфере<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_BLUE_BITS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Число бит на синий компонент в цветовом буфере<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_ALPHA_BITS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Число бит на альфа компонент в цветовом буфере<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:5'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_INDEX_BITS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Число бит на индекс в цветовом буфере<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:6'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_DEPTH_BITS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Число бит на глубину в буфере глубины<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:7'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_STENCIL_BITS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Число бит на индекс в буфере трафарета<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:8'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_ACCUM_RED_BITS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Число бит на красный компонент в буфере аккумулятора<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:9'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_ACCUM_GREEN_BITS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Число бит на зеленый компонент в буфере аккумулятора<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:10'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_ACCUM_BLUE_BITS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Число бит на синий компонент в буфере аккумулятора<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:11;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_ACCUM_ALPHA_BITS<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Число бит на альфа компонент в буфере аккумулятора<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Таблица A-14. Дополнительные</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 style='mso-cellspacing:1.5pt;
 border:solid black 1.0pt;mso-border-alt:solid black .75pt;mso-padding-left-alt:
 3.75pt;mso-padding-right-alt:3.75pt'>
 <tr style='mso-yfti-irow:0'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Переменная состояния</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Описание</span></b><span style='font-size:8.0pt;font-family:
  Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Группа атрибутов</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Начальное значение</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><b><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Опросная команда</span></b><span style='font-size:8.0pt;
  font-family:Verdana;color:black'><o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_LIST_BASE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Установка glListBase()<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>список<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_LIST_INDEX<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Номер конструируемого списка отображения, 0 – если такого нет<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_LIST_MODE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Режим конструируемого списка, 0 – если такого нет<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_ATTRIB_STACK_DEPTH<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Указатель на стек атрибутов<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:5'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:Verdana;
  color:black;mso-ansi-language:EN-US'>GL_CLIENT_ATTRIB_STACK_DEPTH<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Указатель на клиентский стек атрибутов<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:6'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_NAME_STACK_DEPTH<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Глубина стека имен<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:7'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_RENDER_MODE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Текущий режим визуализации (glRenderMode())<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_RENDER<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:8'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_SELECTION_BUFFER_POINTER<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Указатель на буфер выбора<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>выбор<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetPointerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:9'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_SELECTION_BUFFER_SIZE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Размер буфера выбора<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>выбор<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:10'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FEEDBACK_BUFFER_POINTER<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Указатель на буфер отклика<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>отклик<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetPointerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:11'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FEEDBACK _BUFFER_SIZE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Размер буфера отклика<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>отклик<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:12'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_FEEDBACK _BUFFER_TYPE<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Тип буфера отклика<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>отклик<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>GL_2D<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetIntegerv()<o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:13;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>Код текущей ошибки (ошибок)<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>-<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>0<o:p></o:p></span></p>
  </td>
  <td style='border:none;padding:.75pt 3.75pt .75pt 3.75pt'>
  <p class=MsoNormal><span style='font-size:8.0pt;font-family:Verdana;
  color:black'>glGetError()<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Verdana;
color:black'>&nbsp; <o:p></o:p></span></p>

<p class=MsoNormal><a name=ПриложениеB><span style='display:none;mso-hide:all'><o:p>&nbsp;</o:p></span></a></p>

<h1 align=left style='text-align:left'><span style='mso-bookmark:ПриложениеB'>Приложение
B. Вычисление векторов нормалей</span></h1>

<span style='mso-bookmark:ПриложениеB'></span>

<p class=MsoNormal><a href="mailto:ahinar@list.ru"></a><span style='font-size:
10.0pt;font-family:Verdana'>В этом приложении описываются детали вычислений
нормалей к поверхностям, необходимых для использования освещения в OpenGL. <o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Поскольку нормали являются
перпендикулярами к поверхности, вы можете начать поиск нормали в конкретной
точке с нахождения плоскости, которая касается вашей поверхности только в одной
этой точке. Нормаль – это вектор перпендикулярный к этой плоскости. На
идеальной сфере, например, нормаль к точке поверхности имеет то же направление,
что и вектор из центра сферы в эту точку. Для других типов поверхностей
существуют иные лучшие способы нахождения нормалей, зависящие от того, как
задается поверхность.</p>

<p class=text align=left style='text-align:left'>Помните о том, что гладкие
поверхности аппроксимируютсяя большим числом небольших плоских полигонов. Если
векторы, перпендикулярные к этим полигонам используются в качестве нормалей
аппроксимированных поверхностей, то сами поверхности выглядят сегментированными,
поскольку пространство векторов не является непрерывным за границами полигонов.
Однако во многих случаях для модели существует точное математическое описание,
и в каждой точке может быть вычислен вектор истинной нормали. Использование
истинных нормалей существенно улучшает результат визуализации, как показано на
рисунке B-1. Даже если у вас нет математического описания поверхности, вы
можете добиться лучшего результата, чем сегментированная поверхность.</p>

<p class=text align=left style='text-align:left'>Рисунок B-1. Истинные нормали
(справа) против полигональных нормалей (слева) </p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1524" type="#_x0000_t75" alt="" style='width:450pt;height:189pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image384.jpg" o:href="file:///H:\ProgZ_ru%20-%20портал%20для%20программистовB.files\B-1.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=600 height=252
src="OpenGL%20Red%20Book.files/image384.jpg" v:shapes="_x0000_i1524"><![endif]><o:p></o:p></span></p>

<h2>Нахождение нормалей для аналитических поверхностей</h2>

<p class=text align=left style='text-align:left'>Аналитические поверхности –
это плавные поверхности, которые описываются математическим уравнением (или
некоторым набором уравнений). Во многих случаях, нормали проще всего находить
для аналитических поверхностей, для которых у вас есть исчерпывающее описание в
следующей форме:</p>

<p class=text align=left style='text-align:left'><b><span lang=EN-US
style='mso-ansi-language:EN-US'>V</span></b><span lang=EN-US style='mso-ansi-language:
EN-US'>(<i>s</i>, <i>t</i>) = [<b>X</b>(<i>s</i>, <i>t</i>) <b>Y</b>(<i>s</i>, <i>t</i>)
<b>Z</b>(<i>s</i>, <i>t</i>)],<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>где <i>s</i> и <i>t</i> определены
в некотором пространстве, а <b>X</b>, <b>Y</b> и <b>Z</b> – дифференцируемые
функции 2-ух переменных. Чтобы вычислить нормаль, найдите</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1525" type="#_x0000_t75" alt="" style='width:66.75pt;height:43.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image385.jpg" o:href="file:///H:\ProgZ_ru%20-%20портал%20для%20программистовB.files\form001.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=89 height=58
src="OpenGL%20Red%20Book.files/image385.jpg" v:shapes="_x0000_i1525"><![endif]>,</p>

<p class=text align=left style='text-align:left'>являющиеся векторами
касательными к поверхности в направлениях <i>s</i> и <i>t.</i> Их векторное
произведение</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1526" type="#_x0000_t75" alt="" style='width:59.25pt;height:38.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image386.jpg" o:href="file:///H:\ProgZ_ru%20-%20портал%20для%20программистовB.files\form002.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=79 height=51
src="OpenGL%20Red%20Book.files/image386.jpg" v:shapes="_x0000_i1526"><![endif]></p>

<p class=text align=left style='text-align:left'>перпендикулярно им обоим и,
как следствие, перпендикулярно поверхности. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Следующая формула отражает процесс вычисления векторного произведения 2-ух
векторов. (Следите за случаями, когда векторное произведение имеет нулевую
длину.)</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1527" type="#_x0000_t75" alt="" style='width:381pt;height:27.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image387.jpg" o:href="file:///H:\ProgZ_ru%20-%20портал%20для%20программистовB.files\form003.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=508 height=37
src="OpenGL%20Red%20Book.files/image387.jpg" v:shapes="_x0000_i1527"><![endif]></p>

<p class=text align=left style='text-align:left'>Вероятно, вам потребуется
нормализовать результирующий вектор. Для нормализации вектора [<i>x y z</i>],
вычислите его длину</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1528" type="#_x0000_t75" alt="" style='width:2in;height:32.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image388.jpg" o:href="file:///H:\ProgZ_ru%20-%20портал%20для%20программистовB.files\form004.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=192 height=43
src="OpenGL%20Red%20Book.files/image388.jpg" v:shapes="_x0000_i1528"><![endif]></p>

<p class=text align=left style='text-align:left'>и разделите на нее каждый из
компонентов вектора.</p>

<p class=text align=left style='text-align:left'>В качестве примера для этих
расчетов, возьмем следующую аналитическую поверхность</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1529" type="#_x0000_t75" alt="" style='width:159pt;height:20.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image389.jpg" o:href="file:///H:\ProgZ_ru%20-%20портал%20для%20программистовB.files\form005.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=212 height=27
src="OpenGL%20Red%20Book.files/image389.jpg" v:shapes="_x0000_i1529"><![endif]></p>

<p class=text align=left style='text-align:left'>Отсюда имеем</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1530" type="#_x0000_t75" alt="" style='width:466.5pt;height:42.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image390.jpg" o:href="file:///H:\ProgZ_ru%20-%20портал%20для%20программистовB.files\form006.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=622 height=57
src="OpenGL%20Red%20Book.files/image390.jpg" v:shapes="_x0000_i1530"><![endif]></p>

<p class=text align=left style='text-align:left'>Таким образом, если в данном
примере <i>s</i>=1 и <i>t</i>=2, соответствующей точкой поверхности является
точка с координатами (1, 8, 1), а вектор (-24, 2, 24) является перпендикуляром
к поверхности в этой точке. Длина этого вектора равна 34, следовательно, вектор
нормали единичной длины равен </p>

<p class=text align=left style='text-align:left'>(-24/34, 2/34, 24/34) =
(-0.70588, 0.058823, 0.70588).</p>

<p class=text align=left style='text-align:left'>В случае аналитических
поверхностей, заданных в неявной форме </p>

<p class=text align=left style='text-align:left'><b>F</b>(<i>x</i>, <i>y</i>, <i>z</i>)=0</p>

<p class=text align=left style='text-align:left'>найти решение значительно
сложнее. В некоторых случаях вы можете разрешить это уравнение относительно
одной из переменных, скажем <i>z</i>=<b>G</b>(<i>x</i>, <i>y</i>) и записать
его в уже рассмотренной форме</p>

<p class=text align=left style='text-align:left'><b>V</b>(<i>s</i>, <i>t</i>) =
[<i>s</i> <i>t</i> <b>G</b>(<i>s</i>, <i>t</i>)].</p>

<p class=text align=left style='text-align:left'>В этом случае можно продолжать
работу уже описанным способом.</p>

<p class=text align=left style='text-align:left'>Если вы не можете привести
уравнение поверхности к явной форме, вам, возможно, поможет тот факт, что
вектор нормали можно получить как градиент</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1531" type="#_x0000_t75" alt="" style='width:2in;height:40.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image391.jpg" o:href="file:///H:\ProgZ_ru%20-%20портал%20для%20программистовB.files\form007.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=192 height=54
src="OpenGL%20Red%20Book.files/image391.jpg" v:shapes="_x0000_i1531"><![endif]>,</p>

<p class=text align=left style='text-align:left'>вычисленный в конкретной точке
(<b><i>x</i></b>, <b><i>y</i></b>, <b><i>z</i></b>). Вычислить градиента
довольно просто, однако значительно сложнее найти точку, которая лежит на
поверхности. В качестве примера неявно определенной аналитической функции
рассмотрим уравнение сферы радиусом в 1 с центром в начале координат:</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1532" type="#_x0000_t75" alt="" style='width:129.75pt;height:23.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image392.jpg" o:href="file:///H:\ProgZ_ru%20-%20портал%20для%20программистовB.files\form008.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=173 height=31
src="OpenGL%20Red%20Book.files/image392.jpg" v:shapes="_x0000_i1532"><![endif]></p>

<p class=text align=left style='text-align:left'>Это означает, что</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1533" type="#_x0000_t75" alt="" style='width:185.25pt;height:21pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image393.jpg" o:href="file:///H:\ProgZ_ru%20-%20портал%20для%20программистовB.files\form009.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=247 height=28
src="OpenGL%20Red%20Book.files/image393.jpg" v:shapes="_x0000_i1533"><![endif]>.</p>

<p class=text align=left style='text-align:left'>Это уравнение может быть
разрешено относительно <i>z</i> следующим образом:</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1534" type="#_x0000_t75" alt="" style='width:119.25pt;height:26.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image394.jpg" o:href="file:///H:\ProgZ_ru%20-%20портал%20для%20программистовB.files\form010.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=159 height=35
src="OpenGL%20Red%20Book.files/image394.jpg" v:shapes="_x0000_i1534"><![endif]>.</p>

<p class=text align=left style='text-align:left'>Таким образом, нормали можно
рассчитать с помощью явного вида</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1535" type="#_x0000_t75" alt="" style='width:201pt;height:26.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image395.jpg" o:href="file:///H:\ProgZ_ru%20-%20портал%20для%20программистовB.files\form011.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=268 height=35
src="OpenGL%20Red%20Book.files/image395.jpg" v:shapes="_x0000_i1535"><![endif]></p>

<p class=text align=left style='text-align:left'>как было описано ранее.</p>

<p class=text align=left style='text-align:left'>Если бы не могли разрешить
уравнение относительно <i>z</i>, вы могли бы воспользоваться градиентом</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1536" type="#_x0000_t75" alt="" style='width:130.5pt;height:21.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image396.jpg" o:href="file:///H:\ProgZ_ru%20-%20портал%20для%20программистовB.files\form012.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=174 height=29
src="OpenGL%20Red%20Book.files/image396.jpg" v:shapes="_x0000_i1536"><![endif]>,</p>

<p class=text align=left style='text-align:left'>конечно, если бы смогли найти
точку на поверхности. В данном случае это совсем не сложно – например, (2/3,
1/3, 2/3) лежит на поверхности. Вычисленная с помощью градиента нормаль в
данной точке будет равна (4/3, 2/3, 4/3). Тогда нормаль единичной длины – (2/3,
1/3, 2/3), что, как и ожидалось, совпадает с точкой на поверхности.</p>

<h2>Нахождение нормалей по полигональным данным</h2>

<p class=text align=left style='text-align:left'>Как указывалось ранее, вам
часто требуется находить нормали к поверхностям, заданным в виде полигональных
данных, для того, чтобы они выглядели гладкими, а не сегментированными. В
большинстве случаев простейший способ сделать это (однако вполне возможно не
самый эффективный) – вычислить вектор нормали каждого полигонального фрагмента
поверхности, а затем усреднить нормали соседних фрагментов. на рисунке B-2 показана
поверхность и ее полигональная аппроксимация. (Конечно, если полигоны
представляют собой точную поверхность, а не являются просто аппроксимацией – не
делайте усреднение.) Вычислите нормаль для каждого фрагмента, как описано в
следующих параграфах, и используйте эту нормаль для всех вершин фрагмента.</p>

<p class=text align=left style='text-align:left'>Рисунок B-2. Усреднение
векторов нормали</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1537" type="#_x0000_t75" alt="" style='width:465pt;height:463.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image397.jpg" o:href="file:///H:\ProgZ_ru%20-%20портал%20для%20программистовB.files\B-2.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=620 height=618
src="OpenGL%20Red%20Book.files/image397.jpg" v:shapes="_x0000_i1537"><![endif]></p>

<p class=text align=left style='text-align:left'>Чтобы найти вектор нормали для
плоского полигона, возьмите три любые вершины полигона <i>v1</i>, <i>v2</i> и <i>v3</i>,
не лежащие на одной прямой. Векторное произведение</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1538" type="#_x0000_t75" alt="" style='width:114.75pt;height:20.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image398.jpg" o:href="file:///H:\ProgZ_ru%20-%20портал%20для%20программистовB.files\form013.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=153 height=27
src="OpenGL%20Red%20Book.files/image398.jpg" v:shapes="_x0000_i1538"><![endif]></p>

<p class=text align=left style='text-align:left'>и будет перпендикулярно
полигону. (Обычно результирующий вектор нужно нормализовать.) Затем вам нужно
усреднить нормали соседствующих полигонов, чтобы не давать больше веса одному
из них. Например, если в случае, показанном на рисунке B-2, <i>n1</i>, <i>n2</i>,
<i>n4</i> &nbsp;и <i>n5</i> – нормали полигонов, соединяющихся в точке P,
вычислите <i>n1</i>+<i>n2</i>+<i>n4</i>+<i>n5</i>, а затем нормализуйте
получившийся вектор. (Вы можете получить лучшее усреднение, если взвесите
нормали величинами углов в общем пересечении.) Результирующий вектор может
использоваться в качестве нормали в точке P.</p>

<p class=text align=left style='text-align:left'>Иногда вы должны
модифицировать этот метод под конкретную ситуацию. Например, на границе
поверхности (такой как точка Q на рисунке B-2) вы можете выбрать лучшую
нормаль, основываясь на вашем знании о том, как поверхность должна выглядеть.
Иногда лучшее, что вы можете сделать, это усреднить и нормали полигонов на
границе. Кроме того, у некоторых моделей есть плавные части и острые углы
(точка R на рисунке B-2 находится на таком ребре). В этом случае не нужно
усреднять нормали соседствующих полигонов, даже наоборот – полигоны с одной
стороны ребра должны быть нарисованы с использованием одной нормали, а с другой
– с использованием другой нормали.</p>

<p class=MsoNormal><a name=ПриложениеC><span style='display:none;mso-hide:all'><o:p>&nbsp;</o:p></span></a></p>

<h1 align=left style='text-align:left'><span style='mso-bookmark:ПриложениеC'>Приложение
C. Основы GLUT</span></h1>

<span style='mso-bookmark:ПриложениеC'></span>

<p class=MsoNormal><a href="mailto:ahinar@list.ru"></a><span style='font-size:
10.0pt;font-family:Verdana'>При использовании GLUT ваше приложение
структурируется благодаря тому, что для обработки событий используются функции
обратного вызова. (Этот метод похож на использование Xt Toolkit, также
известного как X Intristics.) Например, сначала вы открываете окно и
регистрируете функции обратного вызова для нужных событий. Затем вы создаете
главный цикл, из которого нет выхода. Если в этом цикле происходит событие,
вызывается ассоциированная с ним функция обратного вызова. По завершении этой
функции поток управления возвращается в главный цикл.<o:p></o:p></span></p>

<h2>Управление окном</h2>

<p class=text align=left style='text-align:left'>Для инициализации окна
существует минимальный набор из пяти функций.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glutInit</b>
  (int <i>argc</i>, char **<i>argv</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'><b>glutInit()</b> должна быть
вызвана до любых других GLUT – функций, так как она инициализирует саму
библиотеку GLUT. <b>glutInit()</b> также обрабатывает параметры командной
строки, но сами параметры зависят от конкретной оконной системы. Для системы X
Window, примерами могут быть –iconic, -geometry и –display. (Параметры,
передаваемые <b>glutInit()</b>, должны быть теми же самыми, что и параметры,
передаваемые в функцию <b>main()</b>).</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glutInitDisplayMode</b>
  (unsigned int <i>mode</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Указывает режим отображения
(например, RGBA или индексный, одинарной или двойной буферизации) для окон,
создаваемых вызовами <b>glutCreateWindow()</b>. Вы также можете указывать,
имеет ли окно ассоциированные с ним буфер или буферы глубины, трафарета и
аккумуляции. Аргумент <i>mask</i> – это битовая комбинация, полученная при
помощи операции OR и следующих констант: GLUT_RGBA или GLUT_INDEX (для указания
цветового режима), GLUT_SINGLE или GLUT_DOUBLE (для указания режима
буферизации), а также константы для включения различных буферов GLUT_DEPTH,
GLUT_STENCIL, GLUT_ACCUN. Например, для окна с двойной буферизаций, RGBA –
цветовым режимом и ассоциированными буферами глубины и трафарета, используйте
GLUT_DOUBLE | GLUT_RGBA | GLUT_DEPTH | GLUT_STENCIL. Значение по умолчанию –
GLUT_RGBA | GLUT_ SINGLE (окно с однократной буферизацией в RGBA - режиме).</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glutInitWindowSize</b>
  (int <i>width</i>, int <i>height</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:Verdana;
color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glutInitWindowPosition</b>
  (int <i>x</i>, int <i>y</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Запрашивают окно определенного
размера и в определенном месте экрана соответственно. Аргументы (<i>x</i>, <i>y</i>)
определяют, где будет находиться угол окна относительно всего экрана. <i>width</i>
и <i>height</i> определяют размер окна (в пикселях). Начальные размеры и место
размещения окна могут быть перекрыты последующими вызовами.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>int <b>glutCreateWindow</b>
  (char *<i>name</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Открывает окно с
предварительно установленными характеристиками (режимом отображения, размером и
так далее). Строка <i>name</i> может быть отображена в заголовке окна, но это
зависит от конкретной оконной системы. Окно не отображается до того, как
произведен вход в <b>glutMainLoop()</b>, поэтому до вызова этой функции нельзя
рисовать что-либо в окно.</p>

<p class=text align=left style='text-align:left'>Возвращаемая целая величина
представляет собой уникальный идентификатор окна. Этот идентификатор может быть
использован для управления несколькими окнами в одном приложении (каждое со
своим контекстом OpenGL) и рисования в них.</p>

<h2>Функции управления событиями</h2>

<p class=text align=left style='text-align:left'>После того, как окно создано,
но до входа в главный цикл программы, вы должны зарегистрировать функции
обратного вызова, используя следующие функции GLUT.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glutDisplayFunc</b>
  (void (*<i>func</i>)(void));<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Позволяет указать функцию
(аргументом <i>func</i>), которая будет вызываться каждый раз, когда содержимое
окна требует перерисовки. Это может случиться, когда окно открывается,
разворачивается, освобождается его часть, ранее перекрытая другим окном, или
вызывается функция <b>glutPostRedisplay()</b>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glutReshapeFunc</b>
  (void (*<i>func</i>)(int <i>width</i>, int <i>height</i>));<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Позволяет указать функцию,
которая вызывается каждый раз при изменении размера окна или его позиции на
экране. Аргумент <i>func</i> – это указатель на функцию, которая принимает два
параметра: <i>width</i> – новая ширина окна и <i>height</i> – новая высота
окна. Обычно <i>func</i> вызывает <b>glViewport()</b> для отсечения
графического вывода по новым размерам окна, а также настраивает проекционную матрицу
для сохранения пропорций спроецированного изображения в соответствии с новыми
размерами порта просмотра. Если <b>glutReshapeFunc()</b> не вызывается или ей
передается NULL (для отмены регистрации функции обратного вызова), вызывается
функция изменения метрик по умолчанию, которая вызывает <b>glViewport </b>(<i>0</i>,<i>0</i>,<i>width</i>,<i>height</i>).</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glutKeyboardFunc</b>
  (void (*<i>func</i>)(unsigned int <i>key</i>, int <i>x</i>, int <i>y</i>));<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Задает функцию <i>func</i>,
которая вызывается, когда нажимается клавиша, имеющая ASCII-код. Этот код
передается функции обратного вызова в параметре <i>key</i>. В параметрах <i>x</i>
и <i>y</i> передается позиция курсора мыши (относительно окна) в момент нажатия
клавиши.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glutMouseFunc</b>
  (void (*<i>func</i>)(int <i>button</i>, int <i>state</i>, int <i>width</i>,
  int <i>height</i>));<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Указывает функцию, которая
вызывается при нажатии или отпускании кнопки мыши. Параметр<span
style='mso-ansi-language:EN-US'> <i><span lang=EN-US>button</span></i><span
lang=EN-US> </span></span>может<span style='mso-ansi-language:EN-US'> </span>иметь<span
style='mso-ansi-language:EN-US'> </span>значения<span lang=EN-US
style='mso-ansi-language:EN-US'> GLUT_LEFT_BUTTON, GLUT_MIDDLE_BUTTON </span>или<span
lang=EN-US style='mso-ansi-language:EN-US'> GLUT_RIGHT_BUTTON. </span>Параметр <i>state</i>
может иметь значения GLUT_UP или GLUT_DOWN в зависимости от того отпущена или
нажата кнопка мыши. В параметрах <i>x</i> и <i>y</i> передаются координаты
курсора мыши (относительно окна) в момент наступления события.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glutMotionFunc</b>
  (void (*<i>func</i>)(int <i>x</i>, int <i>y</i>));<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Указывает функцию, которая
будет вызываться при движении мыши внутри окна в то время, как на ней нажата
одна или несколько клавиш. В параметрах <i>x</i> и <i>y</i> передаются
координаты курсора мыши (относительно окна) в текущий момент.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>glutPostRedisplay</b>
  (void);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Помечает, что текущее окно
требует перерисовки. После этого при любой возможности будет вызвана функция
перерисовки окна, зарегистрированная вызовом <b>glutDisplayFunc()</b>.</p>

<h2>Загрузка палитры</h2>

<p class=text align=left style='text-align:left'>Если вы работаете в индексном
режиме, то можете к своему удивлению обнаружить, что в OpenGL нет команд для
загрузки цвета в цветовую таблицу. Дело в том, что процесс загрузки палитры
целиком зависит от оконной системы. В GLUT существует обобщенная функция для
загрузки одного цветового индекса с соответствующим RGB значением.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glutSetColor</b>
  (Glint <i>index</i>, GLfloat <i>red</i>, GLfloat <i>green</i>, GLfloat <i>blue</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Загружает в палитру по индексу
<i>index</i>, RGB-значение, определенное параметрами <i>red</i>, <i>green</i> и
<i>blue</i>. Последние три параметра нормализуются до диапазона [0.0, 1.0].</p>

<h2>Рисование трехмерных объектов</h2>

<p class=text align=left style='text-align:left'>Многие программы примеры
используют простые трехмерные объекты для иллюстрации различных методов и
техник визуализации изображения. GLUT содержит несколько функций для рисования
таких объектов. Все эти функции работают в непосредственном режиме. Каждая из
них имеет два варианта: первый рисует объект в виде проволочного каркаса и не
генерирует нормалей, второй рисует объект сплошным и генерирует нормали
поверхности (для чайника помимо этого генерируются координаты текстуры). Если
используется освещение, следует выбирать сплошную версию объекта. Все объекты
рисуются с учетом текущих параметров, например, цвета и характеристик
материала. Кроме того, все объекты рисуются центрированными относительно
текущих модельных координат.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glutWireSphere</b>
  (GLdouble <i>radius</i>, GLint <i>slices</i>, GLint <i>stacks</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:Verdana;
color:black;mso-ansi-language:EN-US'>&nbsp; <o:p></o:p></span></p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glutSolidSphere</b>
  (GLdouble <i>radius</i>, GLint <i>slices</i>, GLint <i>stacks</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Рисуют проволочную или
сплошную сферу с радиусом radius, количеством частей (полигонов из которых
состоит сфера) <i>slices</i> – вокруг оси z и <i>stacks</i> – вдоль оси z. Для
того, чтобы понять, что означает вокруг оси z и вдоль нее, представьте себе,
что вы смотрите в длинную трубу. В данном случае направление вашего обзора
совпадает с осью z трубы. Она может быть мысленно разделена как вдоль (на
длинные фрагменты), так и поперек (на кольца). После таких разбиений труба
фактически состоит из множества мелких кусочков. В случае сферы количество
разбиений поперек задается параметром <i>stacks</i>, а количество разбиений
вдоль – параметром <i>slices</i>. Из этого следует, что чем больше разбиений,
тем более гладкой выглядит сфера на экране, но тем больше вычислений требуется
для ее рисования.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>glutWireCube</b>
  (GLdouble <i>size</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Verdana;
color:black'><o:p>&nbsp;</o:p></span></p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>glutSolidCube</b>
  (GLdouble <i>size</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Рисуют проволочный или
сплошной куб с длиной ребра <i>size</i>.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glutWireTorus</b>
  (GLdouble <i>innerRadius</i>, GLdouble <i>outerRadius</i>, GLint <i>nsides</i>,
  GLint <i>rings</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:Verdana;
color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glutSolidTorus</b>
  (GLdouble <i>innerRadius</i>, GLdouble <i>outerRadius</i>, GLint <i>nsides</i>,
  GLint <i>rings</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Рисуют проволочный или
сплошной торус (бублик) с внешним радиусом <i>outerRadius</i> и внутренним
радиусом <i>innerRadius</i>. Параметр <i>rings</i> задает желаемое число колец
из которых будет состоять торус, параметр <i>nsides</i> – из скольких частей
будет состоять каждое кольцо.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glutWireCone</b>
  (GLdouble <i>radius</i>, GLdouble <i>height</i>, GLint <i>slices</i>, GLint <i>stacks</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:Verdana;
color:black;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glutSolidCone</b>
  (GLdouble <i>radius</i>, GLdouble <i>height</i>, GLint <i>slices</i>, GLint <i>stacks</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Рисуют проволочный или
сплошной конус радиусом <i>radius</i>, высотой <i>height</i>. Значение
параметров <i>slices</i> и <i>stacks</i> аналогично таким же параметрам для
сферы.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>glutWireIcosahedron</b>
  (void);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Verdana;
color:black'><o:p>&nbsp;</o:p></span></p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>glutSolidIcosahedron</b>
  (void);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Verdana;
color:black'><o:p>&nbsp;</o:p></span></p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>glutWireOctahedron</b>
  (void);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Verdana;
color:black'><o:p>&nbsp;</o:p></span></p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>glutSolidOctahedron</b>
  (void);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Verdana;
color:black'><o:p>&nbsp;</o:p></span></p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>glutWireTetrahedron</b>
  (void);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Verdana;
color:black'><o:p>&nbsp;</o:p></span></p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>glutSolidTetrahedron</b>
  (void);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Verdana;
color:black'><o:p>&nbsp;</o:p></span></p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>glutWireDodecahedron</b>
  (GLdouble <i>radius</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Verdana;
color:black'><o:p>&nbsp;</o:p></span></p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>glutSolidDodecahedron</b>
  (GLdouble <i>radius</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Рисуют проволочные или
сплошные икосаэдр, октаэдр, тетраэдр и додекаэдр соответственно (единственный
параметр последний пары функций задает радиус додекаэдра).</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>glutWireTeapot</b>
  (GLdouble <i>size</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Verdana;
color:black'><o:p>&nbsp;</o:p></span></p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>glutSolidTeapot</b>
  (GLdouble <i>size</i>);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Рисуют проволочный или
сплошной чайник размера size.</p>

<h2>Управление фоновым процессом</h2>

<p class=text align=left style='text-align:left'>Вы можете указать функцию,
которая будет вызываться в том случае, если нет других сообщений, то есть во
время простоя приложения. Это может быть полезно для выполнения анимации или
другой фоновой обработки.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black;mso-ansi-language:EN-US'>void <b>glutIdleFunc</b>
  (void (*<i>func</i>)(void));<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Задает функцию, выполняемую в
случае, если больше приложению делать нечего (отсутствуют сообщения).
Выполнение этой функции обратного вызова можно отменить передачей <b>glutIdleFunc()</b>
аргумента NULL.</p>

<h2>Запуск программы</h2>

<p class=text align=left style='text-align:left'>После того, как все настройки
выполнены, программы GLUT входят в цикл обработки сообщений функцией
glutMainLoop().</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;background:#FAFAFA;border:solid #D1D7DC 1.0pt;
 mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:15.0pt;mso-padding-right-alt:
 15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>void <b>glutMainLoop </b>(void);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>Вводит программу в цикл
обработки сообщений. Функции обратного вызова будут выполняться в случае
наступления соответствующих событий.</p>

<p class=text align=left style='text-align:left'>Пример 1-2 показывает, как с
помощью GLUT можно заставить работать программу, показанную в примере 1-1.
Обратите внимание на реструктуризацию кода. Для увеличения эффективности
операции, которые нужно выполнить только один раз (установка цвета фона и
координатной системы), теперь помещены в функцию <b>init()</b>. Операции по
визуализации (и пересчету) сцены находятся в функции <b>display()</b>, которая
зарегистрирована в качестве дисплейной функции обратного вызова.<o:p></o:p></p>

<p class=MsoNormal><span style='display:none;mso-hide:all'><o:p>&nbsp;</o:p></span></p>

<h1 align=left style='text-align:left'><a name=ПриложениеD>Приложение D</a>.
Порядок операций</h1>

<p class=MsoNormal><a href="mailto:ahinar@list.ru"></a><span style='font-size:
10.0pt;font-family:Verdana'>В этой книге описаны все операции, производимые
между начальным указанием вершин и финальной записью фрагментов в буфер кадра.
Главы книги расположены так, чтобы упростить изучение, их порядок не совпадает
с порядком, в котором выполняются операции. Иногда точный порядок операций не имеет
значения – поверхности могут быть преобразованы в полигоны и трансформированы
или могут быть сначала трансформированы, а затем преобразованы в полигоны с
идентичным результатом. Разные реализации OpenGL иногда имеют разный порядок
операций.<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>В этом разделе описан
возможный порядок. Любая реализация OpenGL должна выдавать эквивалентный
результат.</p>

<h2>Введение</h2>

<p class=text align=left style='text-align:left'>В этом разделе дается введение
в порядок операций, показанный на рисунке D-1. Геометрические данные (вершины,
линии и полигоны) следуют по пути через ряд блоков, включающих вычислители и
повершинные операции, в то время как пиксельные данные (пиксели, изображения и
битовые карты) в определенной части процесса обрабатываются иначе. Оба типа
данных подвергаются растеризации и пофрагментным операциям до того, как будут
записаны в буфер кадра.</p>

<p class=text align=left style='text-align:left'>Рисунок D-1. Порядок операций </p>

<p><span style='font-size:10.0pt;font-family:Verdana;color:black'><!--[if gte vml 1]><v:shape
 id="_x0000_i1539" type="#_x0000_t75" alt="" style='width:6in;height:555pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image002.gif" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистовD.mht!http://www.progz.ru/images/opengl/appD/D-1.gif"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=576 height=740
src="OpenGL%20Red%20Book.files/image002.gif" v:shapes="_x0000_i1539"><![endif]><o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Все данные, описаны ли они
геометрически или в виде пикселей, могут быть сохранены в списке отображения
или обработаны немедленно. При исполнении списка отображения, данные из него
пересылаются точно так же, как они пересылались бы из приложения
непосредственно.</p>

<p class=text align=left style='text-align:left'>Все геометрические примитивы,
в конце концов, описываются своими вершинами. Если используются вычислители,
данные преобразуются к вершинам и, с момента преобразования, обрабатываются как
вершины. Кроме того, вершинные данные могут быть сохранены и использованы из
специализированных вершинных массивов. Для каждой вершины производятся
повершинные вычисления, за которыми следует растеризация в фрагменты. С
пиксельными данными производятся пиксельные операции, после чего данные
сохраняются в текстурной памяти, используются для полигонального шаблонирования
или растеризуются в фрагменты.</p>

<p class=text align=left style='text-align:left'>Наконец, фрагменты
подвергаются серии пофрагментных операций, после чего результирующие пиксельные
значения записываются в буфер кадра.</p>

<h2>Геометрические операции</h2>

<p class=text align=left style='text-align:left'>Геометрические данные,
появляются ли они из списка отображения, из вычислителя, из вершинного массива
или в качестве вершин прямоугольника, состоят из вершин и типа примитива,
который они описывают (точка, линия, полигон). Вершинные данные включают не
только координаты (<i>x</i>, <i>y</i>, <i>z</i>, <i>w</i>), но и вектор нормали,
координаты текстуры, цвет RGBA, цветовой индекс, свойства материала и флаг
ребра. За исключением координат вершины все эти элементы могут быть заданы в
любом порядке, кроме того, существуют значения по умолчанию. Как только
вызывается команда <b>glVertex*()</b>, компоненты расширяются до 4 измерений,
если в том есть необходимость (с использованием <i>z=0</i> и <i>w=1</i>), и
текущие значения элементов ассоциируются с вершиной. Полный комплект вершинных
данных уходит на обработку. (Если используются вершинные массивы, вершины могут
обрабатываться группами, а обработанные группы могут использоваться
многократно.)</p>

<h2>Повершинные операции</h2>

<p class=text align=left style='text-align:left'>На этапе повершинных операций
геометрические координаты вершины преобразуются с помощью видовой матрицы, в то
время как вектор нормали вершины преобразуется с использованием инвертированной
и транспонированной видовой матрицы и заново нормализуется, если это требуется.
Если активизирована автоматическая генерация координат текстуры, новые
координаты текстуры генерируются с помощью преобразованных координат вершины и
заменяют старые координаты текстуры для вершины. Далее координаты текстуры
преобразуются с помощью текущей текстурной матрицы и передаются на этап сборки
примитивов.</p>

<p class=text align=left style='text-align:left'>В то же время производятся
расчеты, связанные с освещением (если освещение включено). В расчетах
используются координаты вершины, координаты вектора нормали, параметры
материала, текущие источники света, их параметры, а также текущие параметры
модели освещения. С помощью этих расчетов генерируются новые цвета или индексы,
которые усекаются или маскируются до необходимого диапазона и передаются на
этап сборки примитивов.</p>

<h2>Сборка примитивов</h2>

<p class=text align=left style='text-align:left'>Сборка примитивов проходим
по-разному в зависимости от того, является ли примитив точкой, линией или
полигоном. Если активизирована плоская заливка, цвета или индексы всех вершин
линии или полигона устанавливается в одно и то же значение. Если созданы и
активизированы дополнительные плоскости отсечения, они используются для
отсечения примитивов всех трех типов. (Уравнения отсекающих плоскостей сразу
после определения преобразуются с помощью инвертированной транспозиции видовой
матрицы.) Отсечение точек просто пропускает или отвергает вершины; отсечение
линий или полигонов может создать дополнительные вершины в зависимости от того,
как отсекаются эти примитивы. После этого пространственные координаты каждой
вершины преобразуются с помощью проекционной матрицы, и результаты отсекаются
по стандартными видовыми плоскостями <!--[if gte vml 1]><v:shape id="_x0000_i1540"
 type="#_x0000_t75" alt="" style='width:146.25pt;height:14.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image399.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистовD.mht!http://www.progz.ru/images/opengl/appD/form001.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=195 height=19
src="OpenGL%20Red%20Book.files/image399.jpg" v:shapes="_x0000_i1540"><![endif]>.</p>

<p class=text align=left style='text-align:left'>Если активизирован режим
выбора, любые примитивы, не устраненные отсечением, генерируют записи о
попаданиях, а дальнейшая обработка не производится. В отсутствие режима выбора
производится перспективное деление на w, производятся операции порта просмотра
и диапазона глубин. Кроме того, если примитив является полигоном, он
подвергается тесту отсечения нелицевых граней (если таковой активизирован).
Полигон может быть конвертирован в вершины или линии в зависимости от режима
его отображения.</p>

<h2>Операции над пикселями</h2>

<p class=text align=left style='text-align:left'>Сначала пиксели из памяти
хоста распаковываются в нужное количество компонент. Часть OpenGL,
ответственная за распаковку, обрабатывает большое количество разных форматов.
Далее данные масштабируются, скашиваются и обрабатываются с использованием
пиксельной карты (pixel map). Результаты усекаются до нужного диапазона в
зависимости от типа данных и затем либо записываются в текстурную память для
использования при текстурировании, либо растеризуются в фрагменты.</p>

<p class=text align=left style='text-align:left'>Если пиксельные данные
считываются из буфера кадра, производятся операции пиксельного переноса
(масштабирование и скос, отображение и усечение). Результаты упаковываются в
нужный формат и возвращаются в процессорную память.</p>

<p class=text align=left style='text-align:left'>Операция копирования пикселей
похожа на комбинацию распаковки и операций переноса, но упаковка и распаковка
не нужны, и через операции пиксельного переноса делается только один проход
перед тем, как данные записываются обратно в буфер кадра.</p>

<h2>Текстурная память</h2>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>OpenGL</span><span lang=EN-US> </span>версии
1.1 предоставляет дополнительный контроль над текстурной памятью. Изображения
текстуры могут извлекаться из текстурной памяти, так же как из процессорной.
Все изображение текстуры или его часть могут быть заменены. Данные текстуры можно
загружать в текстурные объекты, которые могут быть загружены в текстурную
память. Если объектов так много, что все они не помещаются в текстурной памяти
одновременно, в ней остаются текстуры, имеющие наивысшие приоритеты.</p>

<h2>Операции над фрагментами</h2>

<p class=text align=left style='text-align:left'>Если активизировано
текстурирование, для каждого фрагмента генерируется тексель, который
накладывается на фрагмент. Далее следует вычисление тумана, за которым следует
вычисление величины покрытия фрагментами пикселей (антиалиасинг), если
активизирован антиалиасинг.</p>

<p class=text align=left style='text-align:left'>Далее производится тест
отреза, потом альфа тест (только в RGBA режиме), тест трафарета и тест глубины.
Если работа ведется в режиме RGBA, производится цветовое наложение. За цветовым
наложением производятся цветовое микширование и логические операции. Все
описанные операции могут быть деактивированы.</p>

<p class=text align=left style='text-align:left'>Далее фрагменты маскируются с
помощью цветовой маски или индексной маски, в зависимости от режима, и
записываются в нужный буфер. Если фрагменты записываются в буфер трафарета или
глубины, маскирование происходит после тестов трафарета или глубины, и
результаты записываются в буфер кадра без проведения цветового наложения,
микширования и логических операций.</p>

<h2>Матричные операции</h2>

<p class=text align=left style='text-align:left'>Матричные операции работают на
текущем матричном стеке, коим может быть видовой, проекционный или текстурный.
Команды <b>glMultMatrix*()</b>, <b>glLoadMatrix*()</b> и <b>glLoadIdentity()</b>
применяются к верхней матрице стека, а <b>glTranslate*()</b>, <b>glRotate*()</b>,
<b>glScale*()</b>, <b>glOrtho()</b> и <b>glFrustum()</b> используются для
создания матрицы, на которую затем умножается верхняя матрица стека. Когда
изменяется видовая матрица, также генерируется ее инвертированная транспозиция
для преобразований векторов нормали.</p>

<p class=text align=left style='text-align:left'>Команды, устанавливающие
текущую растровую позицию, обрабатываются точно так же, как вершины до точки, в
которой должна производиться растеризация. В этой точке величина сохраняется и
используется при растеризации пиксельных данных.</p>

<p class=text align=left style='text-align:left'>Различные команды <b>glClear()</b>
проходят мимо всех операций за исключением теста отреза, микширования и
маскирования. </p>

<p class=MsoNormal><a name=ПриложениеE><span style='display:none;mso-hide:all'><o:p>&nbsp;</o:p></span></a></p>

<h1 align=left style='text-align:left'><span style='mso-bookmark:ПриложениеE'>Приложение
E. Однородные координаты и матрицы преобразований</span></h1>

<span style='mso-bookmark:ПриложениеE'></span>

<p class=MsoNormal><a href="mailto:ahinar@list.ru"></a><span style='font-size:
10.0pt;font-family:Verdana'>В этом приложении представлено краткое обсуждение
однородных координат. Здесь также приведены общие виды матриц, используемых для
поворота, переноса, масштабирования, перспективной и ортогональной проекций. В
следующем обсуждении термин однородные координаты всегда применяется к
трехмерным координатам, хотя проективная геометрия существует для всех
измерений.<o:p></o:p></span></p>

<h2>Однородные координаты</h2>

<p class=text align=left style='text-align:left'>Команды OpenGL обычно работают
с двумерными и трехмерными вершинами, но на самом деле все вершины
интерпретируются как трехмерные, состоящие из четырех координат. Любой вектор –
столбец <!--[if gte vml 1]><v:shape id="_x0000_i1541" type="#_x0000_t75" alt=""
 style='width:73.5pt;height:21.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image400.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистовE.mht!http://www.progz.ru/images/opengl/appE/form001.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=98 height=29
src="OpenGL%20Red%20Book.files/image400.jpg" v:shapes="_x0000_i1541"><![endif]>&nbsp;представляет
собой однородную вершину, если хотя бы один из его элементов не равен <i>0</i>.
Если вещественное число a не равно <i>0</i>, то <!--[if gte vml 1]><v:shape
 id="_x0000_i1542" type="#_x0000_t75" alt="" style='width:73.5pt;height:21.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image400.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистовE.mht!http://www.progz.ru/images/opengl/appE/form001.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=98 height=29
src="OpenGL%20Red%20Book.files/image400.jpg" v:shapes="_x0000_i1542"><![endif]>&nbsp;и
<!--[if gte vml 1]><v:shape id="_x0000_i1543" type="#_x0000_t75" alt=""
 style='width:105pt;height:21pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image401.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистовE.mht!http://www.progz.ru/images/opengl/appE/form002.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=140 height=28
src="OpenGL%20Red%20Book.files/image401.jpg" v:shapes="_x0000_i1543"><![endif]>&nbsp;представляют
одну и ту же однородную вершину. Трехмерная точка Евклидового пространства <!--[if gte vml 1]><v:shape
 id="_x0000_i1544" type="#_x0000_t75" alt="" style='width:57.75pt;height:21pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image402.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистовE.mht!http://www.progz.ru/images/opengl/appE/form003.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=77 height=28
src="OpenGL%20Red%20Book.files/image402.jpg" v:shapes="_x0000_i1544"><![endif]>&nbsp;переходит
в однородную вершину с координатами <!--[if gte vml 1]><v:shape id="_x0000_i1545"
 type="#_x0000_t75" alt="" style='width:79.5pt;height:22.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image403.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистовE.mht!http://www.progz.ru/images/opengl/appE/form004.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=106 height=30
src="OpenGL%20Red%20Book.files/image403.jpg" v:shapes="_x0000_i1545"><![endif]>,
а двумерная точка Евклидового пространства <!--[if gte vml 1]><v:shape id="_x0000_i1546"
 type="#_x0000_t75" alt="" style='width:44.25pt;height:20.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image404.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистовE.mht!http://www.progz.ru/images/opengl/appE/form005.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=59 height=27
src="OpenGL%20Red%20Book.files/image404.jpg" v:shapes="_x0000_i1546"><![endif]>&nbsp;--
в однородную вершину <!--[if gte vml 1]><v:shape id="_x0000_i1547" type="#_x0000_t75"
 alt="" style='width:90pt;height:21.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image405.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистовE.mht!http://www.progz.ru/images/opengl/appE/form006.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=120 height=29
src="OpenGL%20Red%20Book.files/image405.jpg" v:shapes="_x0000_i1547"><![endif]>.</p>

<p class=text align=left style='text-align:left'>До тех пор, пока w не равно 0,
однородная вершины <!--[if gte vml 1]><v:shape id="_x0000_i1548" type="#_x0000_t75"
 alt="" style='width:73.5pt;height:21.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image400.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистовE.mht!http://www.progz.ru/images/opengl/appE/form001.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=98 height=29
src="OpenGL%20Red%20Book.files/image400.jpg" v:shapes="_x0000_i1548"><![endif]>&nbsp;соответствует
трехмерной точке <!--[if gte vml 1]><v:shape id="_x0000_i1549" type="#_x0000_t75"
 alt="" style='width:118.5pt;height:22.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image406.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистовE.mht!http://www.progz.ru/images/opengl/appE/form007.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=158 height=30
src="OpenGL%20Red%20Book.files/image406.jpg" v:shapes="_x0000_i1549"><![endif]>.
Если <i>w=0.0</i>, вершина не соответствует ни одной точке в Евклидовом
пространстве, а представляет собой некоторую идеализированную «точку в
бесконечности». Чтобы понять, что такое «точка в бесконечности», рассмотрим
вершину с координатами <i>(1, 2, 0, 0)</i> и заметим что последовательность
точек <i>(1, 2, 0, 1)</i>, <i>(1, 2, 0, 0.01)</i> и <i>(1, 2, 0, 0.0001)</i>,
соответствует Евклидовым точкам <i>(1, 2)</i>, <i>(100, 200)</i> и <i>(10,000,
20,000)</i>. Эта последовательность представляет точки, быстро смещающиеся в
бесконечность вдоль прямой <i>2x=y</i>. Таким образом, вы можете думать о точке
<i>(1, 2, 0, 0)</i> как о точке в бесконечности, лежащей на этой прямой.</p>

<p class=warning>Замечание: <span lang=EN-US style='mso-ansi-language:EN-US'>OpenGL</span>
может неверно обрабатывать однородные усеченные координаты с <i>w&lt;0</i>.
Чтобы быть уверенными, что ваш код является переносимым на все реализации
OpenGL, используйте только неотрицательные значения.</p>

<h2>Преобразование вершин</h2>

<p class=text align=left style='text-align:left'>Преобразования вершин (такие
как повороты, переносы, масштабирования и отражения) и проекционные
преобразования (такие как перспективное и ортографическое) могут быть
представлены в виде применения соответствующей матрицы 4x4 к координатам,
представляющим вершину. Если v представляет однородную вершину, а <b>М</b> –
трансформационная матрица 4x4, то <b>Mv</b> является отображением <b>v</b> под
воздействием <b>M</b>. (В приложениях компьютерной графики применяемые
преобразования, как правило, не вырожденные – иными словами, матрица является
обратимой. Это не является обязательным условием, но позволяет избежать ряда
проблем с вырожденными преобразованиями.)</p>

<p class=text align=left style='text-align:left'>После преобразования все
трансформированные вершины усекаются, чтобы <i>x</i>, <i>y</i> и <i>z</i>
лежали в диапазоне <i>[-w, w]</i> (в предположении, что <i>w&gt;0</i>).
Заметьте, что этот диапазон соответствует Евклидовому <i>[-1.0, 1.0]</i>.</p>

<h2>Преобразование нормалей</h2>

<p class=text align=left style='text-align:left'>Вектора нормалей преобразуются
не так, как вершины или позиции вершин. Математически лучше думать о векторах
нормалей не как о векторах, а как о плоскостях, перпендикулярным к этим
векторам. Тогда можно описывать правила преобразования нормалей правилами
преобразования перпендикулярных плоскостей.</p>

<p class=text align=left style='text-align:left'>Однородная плоскость
определяется вектор – строкой <i>((a, b, c, d)</i>, где как минимум один из
компонентов не равен <i>0</i>. Если <i>q</i> – вещественное число не равное <i>0</i>,
то <i>(a, b, c, d)</i> и <i>(qa, qb, qc, qd)</i> представляют одну и ту же
плоскость. Точка <!--[if gte vml 1]><v:shape id="_x0000_i1550" type="#_x0000_t75"
 alt="" style='width:73.5pt;height:21.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image400.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистовE.mht!http://www.progz.ru/images/opengl/appE/form001.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=98 height=29
src="OpenGL%20Red%20Book.files/image400.jpg" v:shapes="_x0000_i1550"><![endif]>&nbsp;лежит
на поверхности <i>((a, b, c, d)</i>, если <i>ax+by+cz+dw=0</i>. (Если <i>w=1</i>,
то это стандартное описание Евклидовой плоскости.) Чтобы <i>(a, b, c, d)</i>
представляло Евклидову плоскость, как минимум один из компонентов <i>a</i>, <i>b</i>
или <i>c</i> не должен быть равен <i>0</i>. Если все они равны <i>0</i>, то <i>(0,
0, 0, d)</i> представляет «плоскость в бесконечности», содержащую все «точки в
бесконечности».</p>

<p class=text align=left style='text-align:left'>Если <b>pp</b> – однородная
плоскость, а <b>v</b> – однородная вершина, то утверждение «<b>v</b> лежит на <b>p</b>»
математически записывается как <b>pv=0</b>, где <b>pv</b> – обычное
произведение матриц. Если <b>M</b> – невырожденное вершинное преобразование (то
есть матрица 4x4 имеющая обратную матрицу <!--[if gte vml 1]><v:shape id="_x0000_i1551"
 type="#_x0000_t75" alt="" style='width:27.75pt;height:19.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image407.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистовE.mht!http://www.progz.ru/images/opengl/appE/form008.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=37 height=26
src="OpenGL%20Red%20Book.files/image407.jpg" v:shapes="_x0000_i1551"><![endif]>),
то <b>pv=0</b> эквивалентно <!--[if gte vml 1]><v:shape id="_x0000_i1552"
 type="#_x0000_t75" alt="" style='width:83.25pt;height:21pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image408.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистовE.mht!http://www.progz.ru/images/opengl/appE/form009.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=111 height=28
src="OpenGL%20Red%20Book.files/image408.jpg" v:shapes="_x0000_i1552"><![endif]>,
то есть <b>Mv</b> лежит в плоскости <!--[if gte vml 1]><v:shape id="_x0000_i1553"
 type="#_x0000_t75" alt="" style='width:38.25pt;height:21.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image409.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистовE.mht!http://www.progz.ru/images/opengl/appE/form010.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=51 height=29
src="OpenGL%20Red%20Book.files/image409.jpg" v:shapes="_x0000_i1553"><![endif]>.
Следовательно, <!--[if gte vml 1]><v:shape id="_x0000_i1554" type="#_x0000_t75"
 alt="" style='width:38.25pt;height:21.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image409.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистовE.mht!http://www.progz.ru/images/opengl/appE/form010.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=51 height=29
src="OpenGL%20Red%20Book.files/image409.jpg" v:shapes="_x0000_i1554"><![endif]>&nbsp;является
отображением плоскости под воздействием вершинного преобразования <b>M</b>.</p>

<p class=text align=left style='text-align:left'>Если вам хочется думать о
векторах нормалей именно как о векторах, а не как о плоскостях, перпендикулярным
к ним, пусть <b>v</b> и <b>n</b> – такие векторы, что <b>v</b> перпендикулярно <b>n</b>.
Тогда <!--[if gte vml 1]><v:shape id="_x0000_i1555" type="#_x0000_t75" alt=""
 style='width:50.25pt;height:21pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image410.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистовE.mht!http://www.progz.ru/images/opengl/appE/form011.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=67 height=28
src="OpenGL%20Red%20Book.files/image410.jpg" v:shapes="_x0000_i1555"><![endif]>.
Следовательно, для произвольного невырожденного преобразования <b>M</b>, <!--[if gte vml 1]><v:shape
 id="_x0000_i1556" type="#_x0000_t75" alt="" style='width:91.5pt;height:19.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image411.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистовE.mht!http://www.progz.ru/images/opengl/appE/form012.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=122 height=26
src="OpenGL%20Red%20Book.files/image411.jpg" v:shapes="_x0000_i1556"><![endif]>,
что означает, что <!--[if gte vml 1]><v:shape id="_x0000_i1557" type="#_x0000_t75"
 alt="" style='width:45pt;height:18.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image412.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистовE.mht!http://www.progz.ru/images/opengl/appE/form013.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=60 height=25
src="OpenGL%20Red%20Book.files/image412.jpg" v:shapes="_x0000_i1557"><![endif]>&nbsp;является
транспозицией преобразованного вектора нормали. Следовательно, преобразованный
вектор нормали -- <!--[if gte vml 1]><v:shape id="_x0000_i1558" type="#_x0000_t75"
 alt="" style='width:57.75pt;height:21pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image413.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистовE.mht!http://www.progz.ru/images/opengl/appE/form014.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=77 height=28
src="OpenGL%20Red%20Book.files/image413.jpg" v:shapes="_x0000_i1558"><![endif]>.
Иными словами вектор нормали преобразуется инвертированной транспозицией
матрицы преобразования, преобразующей точки.</p>

<h2>Матрицы преобразования</h2>

<p class=text align=left style='text-align:left'>Несмотря на то, что любая
невырожденная матрица <b>M</b> представляет допустимое проективное
преобразование, несколько специальных случаев матриц особенно полезны. Эти
матрицы перечислены в следующих разделах.</p>

<h2>Перенос</h2>

<p class=text align=left style='text-align:left'>Вызов команды <b>glTranslate*</b>(<i>x</i>,
<i>y</i>, <i>z</i>) генерирует T, где</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1559" type="#_x0000_t75" alt="" style='width:108.75pt;height:89.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image414.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистовE.mht!http://www.progz.ru/images/opengl/appE/form015.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=145 height=119
src="OpenGL%20Red%20Book.files/image414.jpg" v:shapes="_x0000_i1559"><![endif]>&nbsp;и
<!--[if gte vml 1]><v:shape id="_x0000_i1560" type="#_x0000_t75" alt=""
 style='width:121.5pt;height:81pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image415.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистовE.mht!http://www.progz.ru/images/opengl/appE/form016.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=162 height=108
src="OpenGL%20Red%20Book.files/image415.jpg" v:shapes="_x0000_i1560"><![endif]>.</p>

<h2>Масштабирование</h2>

<p class=text align=left style='text-align:left'>Вызов команды <b>glScale*</b>(<i>x</i>,
<i>y</i>, <i>z</i>) генерирует <b>S</b>, где</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1561" type="#_x0000_t75" alt="" style='width:107.25pt;height:84pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image416.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистовE.mht!http://www.progz.ru/images/opengl/appE/form017.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=143 height=112
src="OpenGL%20Red%20Book.files/image416.jpg" v:shapes="_x0000_i1561"><![endif]>&nbsp;и
<!--[if gte vml 1]><v:shape id="_x0000_i1562" type="#_x0000_t75" alt=""
 style='width:117pt;height:116.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image417.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистовE.mht!http://www.progz.ru/images/opengl/appE/form018.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=156 height=155
src="OpenGL%20Red%20Book.files/image417.jpg" v:shapes="_x0000_i1562"><![endif]>.</p>

<p class=text align=left style='text-align:left'>Заметьте, что <!--[if gte vml 1]><v:shape
 id="_x0000_i1563" type="#_x0000_t75" alt="" style='width:21.75pt;height:17.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image418.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистовE.mht!http://www.progz.ru/images/opengl/appE/form019.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=29 height=23
src="OpenGL%20Red%20Book.files/image418.jpg" v:shapes="_x0000_i1563"><![endif]>&nbsp;определена
только если <i>x</i>, <i>y</i> и <i>z</i> одновременно не равны 0.</p>

<h2>Поворот</h2>

<p class=text align=left style='text-align:left'>Вызов команды <b>glRotate*</b>(<i>a</i>,
<i>x</i>, <i>y</i>, <i>z</i>) генерирует <b>R</b> следующим образом:</p>

<p class=text align=left style='text-align:left'>Пусть <!--[if gte vml 1]><v:shape
 id="_x0000_i1564" type="#_x0000_t75" alt="" style='width:82.5pt;height:21pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image419.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистовE.mht!http://www.progz.ru/images/opengl/appE/form020.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=110 height=28
src="OpenGL%20Red%20Book.files/image419.jpg" v:shapes="_x0000_i1564"><![endif]>,
и <!--[if gte vml 1]><v:shape id="_x0000_i1565" type="#_x0000_t75" alt=""
 style='width:145.5pt;height:24pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image420.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистовE.mht!http://www.progz.ru/images/opengl/appE/form021.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=194 height=32
src="OpenGL%20Red%20Book.files/image420.jpg" v:shapes="_x0000_i1565"><![endif]>.</p>

<p class=text align=left style='text-align:left'>Также пусть</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1566" type="#_x0000_t75" alt="" style='width:93pt;height:63.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image421.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистовE.mht!http://www.progz.ru/images/opengl/appE/form022.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=124 height=85
src="OpenGL%20Red%20Book.files/image421.jpg" v:shapes="_x0000_i1566"><![endif]>&nbsp;и
<!--[if gte vml 1]><v:shape id="_x0000_i1567" type="#_x0000_t75" alt=""
 style='width:242.25pt;height:21.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image422.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистовE.mht!http://www.progz.ru/images/opengl/appE/form023.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=323 height=29
src="OpenGL%20Red%20Book.files/image422.jpg" v:shapes="_x0000_i1567"><![endif]>.</p>

<p class=text align=left style='text-align:left'>Затем</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1568" type="#_x0000_t75" alt="" style='width:117.75pt;height:84.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image423.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистовE.mht!http://www.progz.ru/images/opengl/appE/form024.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=157 height=113
src="OpenGL%20Red%20Book.files/image423.jpg" v:shapes="_x0000_i1568"><![endif]>,</p>

<p class=text align=left style='text-align:left'>где <i>m</i> представляет
элементы матрицы из <b>M</b>, которая является матрицей 3x3, определенной
ранее. Матрица <b>R</b> определена всегда. Если <i>x=y=z=0</i>, <b>R</b>
представляет собой единичную матрицу. Вы можете получить инверсию <b>R</b>, <!--[if gte vml 1]><v:shape
 id="_x0000_i1569" type="#_x0000_t75" alt="" style='width:24pt;height:18.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image424.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистовE.mht!http://www.progz.ru/images/opengl/appE/form026.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=32 height=25
src="OpenGL%20Red%20Book.files/image424.jpg" v:shapes="_x0000_i1569"><![endif]>,
заменив <i>a</i> на <i>–a</i>, или транспонировав матрицу.</p>

<p class=text align=left style='text-align:left'>Команда <b>glRotate*()</b>
генерирует матрицу для поворота вокруг произвольной оси. Часто вы выполняете
поворот вокруг одной из координатных осей, этим поворотам соответствуют
следующие матрицы:</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1570" type="#_x0000_t75" alt="" style='width:250.5pt;height:251.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image425.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистовE.mht!http://www.progz.ru/images/opengl/appE/form025.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=334 height=335
src="OpenGL%20Red%20Book.files/image425.jpg" v:shapes="_x0000_i1570"><![endif]>.</p>

<p class=text align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Как и раньше обратные матрицы получаются с помощью транспозиции.</p>

<h2>Перспективная проекция</h2>

<p class=text align=left style='text-align:left'>Обращение к <b>glFrustum</b>(<i>l</i>,<i>r</i>,<i>b</i>,<i>t</i>,<i>n</i>,<i>f</i>)
генерирует <b>R</b>, где</p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Verdana;
color:black'><!--[if gte vml 1]><v:shape id="_x0000_i1571" type="#_x0000_t75"
 alt="" style='width:3in;height:122.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image426.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистовE.mht!http://www.progz.ru/images/opengl/appE/form027.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=288 height=163
src="OpenGL%20Red%20Book.files/image426.jpg" v:shapes="_x0000_i1571"><![endif]>&nbsp;и
<!--[if gte vml 1]><v:shape id="_x0000_i1572" type="#_x0000_t75" alt=""
 style='width:220.5pt;height:120pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image427.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистовE.mht!http://www.progz.ru/images/opengl/appE/form028.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=294 height=160
src="OpenGL%20Red%20Book.files/image427.jpg" v:shapes="_x0000_i1572"><![endif]>.
<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><b>R</b> определена до тех
пор, пока <!--[if gte vml 1]><v:shape id="_x0000_i1573" type="#_x0000_t75"
 alt="" style='width:66.75pt;height:18.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image428.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистовE.mht!http://www.progz.ru/images/opengl/appE/form029.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=89 height=25
src="OpenGL%20Red%20Book.files/image428.jpg" v:shapes="_x0000_i1573"><![endif]>&nbsp;и
<!--[if gte vml 1]><v:shape id="_x0000_i1574" type="#_x0000_t75" alt=""
 style='width:40.5pt;height:19.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image429.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистовE.mht!http://www.progz.ru/images/opengl/appE/form030.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=54 height=26
src="OpenGL%20Red%20Book.files/image429.jpg" v:shapes="_x0000_i1574"><![endif]>.</p>

<h2>Ортографическая проекция</h2>

<p class=text align=left style='text-align:left'>Обращение к <b>glOrtho</b>(<i>l</i>,<i>r</i>,<i>b</i>,<i>t</i>,<i>n</i>,<i>f</i>)
генерирует <b>R</b>, где</p>

<p class=text align=left style='text-align:left'><!--[if gte vml 1]><v:shape
 id="_x0000_i1575" type="#_x0000_t75" alt="" style='width:197.25pt;height:123pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image430.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистовE.mht!http://www.progz.ru/images/opengl/appE/form031.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=263 height=164
src="OpenGL%20Red%20Book.files/image430.jpg" v:shapes="_x0000_i1575"><![endif]>&nbsp;и
<!--[if gte vml 1]><v:shape id="_x0000_i1576" type="#_x0000_t75" alt=""
 style='width:204.75pt;height:119.25pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image431.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистовE.mht!http://www.progz.ru/images/opengl/appE/form032.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=273 height=159
src="OpenGL%20Red%20Book.files/image431.jpg" v:shapes="_x0000_i1576"><![endif]>.</p>

<p class=text align=left style='text-align:left'><b>R</b> определена до тех
пор, пока <!--[if gte vml 1]><v:shape id="_x0000_i1577" type="#_x0000_t75"
 alt="" style='width:66.75pt;height:18.75pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image428.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистовE.mht!http://www.progz.ru/images/opengl/appE/form029.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=89 height=25
src="OpenGL%20Red%20Book.files/image428.jpg" v:shapes="_x0000_i1577"><![endif]>&nbsp;и
<!--[if gte vml 1]><v:shape id="_x0000_i1578" type="#_x0000_t75" alt=""
 style='width:40.5pt;height:19.5pt'>
 <v:imagedata src="OpenGL%20Red%20Book.files/image429.jpg" o:href="mhtml:file:///H:\ProgZ_ru%20-%20портал%20для%20программистовE.mht!http://www.progz.ru/images/opengl/appE/form030.jpg"/>
</v:shape><![endif]--><![if !vml]><img border=0 width=54 height=26
src="OpenGL%20Red%20Book.files/image429.jpg" v:shapes="_x0000_i1578"><![endif]>.
</p>

<p class=MsoNormal><a name=ПриложениеF><span style='display:none;mso-hide:all'><o:p>&nbsp;</o:p></span></a></p>

<h1 align=left style='text-align:left'><span style='mso-bookmark:ПриложениеF'>Приложение
F. Советы</span></h1>

<span style='mso-bookmark:ПриложениеF'></span>

<p class=MsoNormal><a href="mailto:ahinar@list.ru"></a><span style='font-size:
10.0pt;font-family:Verdana'>В этом приложении представлены некоторые советы и
наставления, которые могут быть для вас полезными. Имейте в виду, что эти
советы базируются на рекомендациях разработчиков OpenGL, а не опыте работы с
конкретными приложениями или реализациями.<o:p></o:p></span></p>

<h2>Во избежание сбоев</h2>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l43 level1 lfo66;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Постоянно производите контроль. Вызывайте <b>glGetError()</b>
как минимум единожды каждый раз при отрисовке сцены, чтобы быть уверенным в
том, что ошибка будет обнаружена.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l43 level1 lfo66;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Не полагайтесь на поведение реализации OpenGL в
отношении ошибок – оно может измениться в следующих версиях. Например, OpenGL
версии 1.1 игнорирует матричные операции, производящиеся между вызовами команд <b>glBegin()</b>/<b>glEnd()</b>,
но в будущих версиях это может быть и не так.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l43 level1 lfo66;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Если вам нужно схлопнуть всю геометрию к одной
плоскости, используйте проекционную матрицу. Использование видовой матрицы
может привести к тому, что механизмы OpenGL, оперирующие в видовых координатах
(такие как освещение и отсекающие плоскости) перестанут работать.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l43 level1 lfo66;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Не вносите слишком интенсивные изменения в одну
и ту же матрицу. Например, не следует создавать анимацию вращения, много раз
вызывая <b>glRotate*()</b> с одним и тем же углом. Вместо этого используйте <b>glLoadIdentity()</b>
для инициализации нужной матрицы каждый кадр, а затем вызывайте <b>glRotate*()</b>
один раз с полным углом вращения для этого кадра.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l43 level1 lfo66;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Вы можете рассчитывать на то, что при
многократном прохождении через базу данных визуализации каждый раз будут
сгенерированы одни и те же фрагменты, только в том случае, если такое поведение
гарантировано правилами инвариантности, установленными для подчиняющейся
реализации OpenGL. Иначе, при двух разных проходах через базу данных
визуализации (например, при выполнении списков отображения) могут быть
сгенерированы разные наборы фрагментов.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l43 level1 lfo66;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Не рассчитывайте на то, что OpenGL будет
рапортовать об ошибках. Команды внутри списка генерируют ошибки только тогда,
когда список выполняется.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l43 level1 lfo66;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Размещайте ближнюю плоскость отсечения
перспективного объема видимости максимально далеко от точки наблюдения для
оптимизации работы буфера глубины.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l43 level1 lfo66;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Вызывайте <b>glFlush()</b> для форсирования всех
ранее вызванных команд OpenGL к исполнению. Не рассчитывайте на то, что <b>glGet*()</b>
или <b>glIs*()</b> выполнят формирование потока визуализации. Команды опроса
вызывают исполнение только части потока, необходимой для возвращения корректных
данных, но не гарантируют выполнения всех команд визуализации.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l43 level1 lfo66;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Деактивируйте цветовое микширование при
визуализации предопределенных изображений (например, при использовании <b>glCopyPixels()</b>).</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l43 level1 lfo66;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Используйте полный диапазон буфера аккумуляции.
Например, если вы аккумулируете 4 изображения, во время аккумуляции берите по
четверти от каждого из них.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l43 level1 lfo66;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Если требуется именно двумерная растеризация, вы
должны аккуратно задавать ортографическую проекцию и вершины примитивов,
которые должны быть растеризованы. Ортографическая проекция должна быть задана
с целыми координатами, как показано в следующем примере:</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;margin-left:36.0pt;background:#FAFAFA;
 border:solid #D1D7DC 1.0pt;mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:
 15.0pt;mso-padding-right-alt:15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'>
  <p class=MsoNormal><span style='font-size:8.5pt;font-family:Courier;
  mso-bidi-font-family:"Courier New";color:black'>gluOrtho2D(0,
  width,0,height);<o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<p class=text align=left style='text-align:left'>где <i>width</i> и <i>height</i>
– это размеры порта просмотра. При такой проекционной матрице координаты
примитивов и пиксельных изображений должны быть представлены целыми числами,
чтобы растеризация была предсказуемой. Например, <b>glRecti(0,0,1,1)</b> точно
закрасит нижний левый угол порта просмотра, а <b>glRasterPosi(0,0)</b>
определенно позиционирует неизмененное изображение в нижний левый угол порта
просмотра. Однако вершины точек, вершины линий и позиции битовых карт должны
помещаться посередине между двумя целыми числами. Например, линия, нарисованная
из (<i>x1</i>, <i>0.5</i>) в (<i>x2</i>, <i>0.5</i>) гарантированно будет
отображена в нижнем ряду пикселей порта просмотра, а точка, нарисованная с
координатами (<i>0.5</i>, <i>0.5</i>), заполнит тот же пиксель, что и <b>glRecti(0,0,1,1)</b>.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l58 level1 lfo67;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Оптимальный компромисс, позволяющий задавать все
примитивы в целых локациях, получая предсказуемую визуализацию, заключается в
том, чтобы перенести <i>x</i> и <i>y</i> на <i>0.375</i>, как показано в
следующем примере. Такой перенос держит полигоны и границы пиксельных изображений
на безопасном расстоянии от центров пикселей, одновременно перемещая вершины
линий достаточно близко к этим центрам.</p>

<div align=center>

<table class=MsoNormalTable border=1 cellpadding=0 width="90%"
 style='width:90.0%;mso-cellspacing:1.5pt;margin-left:36.0pt;background:#FAFAFA;
 border:solid #D1D7DC 1.0pt;mso-border-alt:solid #D1D7DC .75pt;mso-padding-left-alt:
 15.0pt;mso-padding-right-alt:15.0pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes'>
  <td style='border:none;padding:.75pt 15.0pt .75pt 15.0pt'><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glViewport(0,0,width,height);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glMatrixMode(GL_PROJECTION);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>glLoadIdentity();<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>gluOrtho2D(0,width,0,height);<o:p></o:p></span></pre><pre><span
  lang=EN-US style='color:black;mso-ansi-language:EN-US'>gllMatrixMode(GL_MODELVIEW);<o:p></o:p></span></pre><pre><span
  style='color:black'>glLadIdentity();<o:p></o:p></span></pre><pre><span
  style='color:black'>glTranslatef(0.375,0.375,0.0);<o:p></o:p></span></pre><pre><span
  style='color:black'>/* визуализируйте все примитивы в целых локациях */<o:p></o:p></span></pre></td>
 </tr>
</table>

</div>

<ul type=disc>
 <li class=MsoNormal style='color:black;mso-margin-top-alt:auto;mso-margin-bottom-alt:
     auto;mso-list:l58 level1 lfo67;tab-stops:list 36.0pt'><span
     style='font-size:10.0pt;font-family:Verdana'><o:p>&nbsp;</o:p></span></li>
</ul>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l58 level1 lfo67;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Избегайте использования отрицательного <i>w</i>
в координатах вершин и отрицательного <i>q</i> в координатах текстуры. OpenGL
может не усекать такие вершины корректно, и может совершать ошибки интерполяции
при закраске примитивов с такими вершинами.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l58 level1 lfo67;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Не предполагайте, что точность операций OpenGL
зависит от типов аргументов команд библиотеки. Например, если вы используете <b>glRotated()</b>,
вы не должны ожидать, что геометрический конвейер сохраняет двойную точность
чисел с плавающей точкой в процессе своей работы. Возможно, что до обработки
аргументы <b>glRotated()</b> будут преобразованы к другому типу.</p>

<h2>Для увеличения скорости работы OpenGL</h2>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l38 level1 lfo68;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Если частым изменениям подвержено только одно
свойство материала (например, в каждой вершине), используйте <b>glColorMaterial()</b>.
Используйте <b>glMaterial()</b> для редких изменений или в тех случаях, когда
частые изменения претерпевают несколько свойств материала.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l38 level1 lfo68;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Вместо того, чтобы загружать свою копию
единичной матрицы, используйте <b>glLoadIdentity()</b>.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l38 level1 lfo68;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Используйте специфические команды, такие как <b>glRotate*()</b>,
<b>glTranslate*()</b> и <b>glScale*()</b> вместо того, чтобы составлять свои
собственные матрицы вращений, переносов и масштабирования.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l38 level1 lfo68;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Используйте команды опроса только в случаях,
когда вашему приложению требуется ряд значений переменных состояния для своих
собственных вычислений. Если вашему приложению требуется несколько переменных
состояния из одной группы атрибутов, для их сохранения и восстановления используйте
<b>glPushAttrib()</b> и <b>glPopAttrib()</b>.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l38 level1 lfo68;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Инкапсулируйте потенциально дорогие (с точки
зрения быстродействия) изменения состояния в списках отображения.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l38 level1 lfo68;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Инкапсулируйте в списках отображения вызовы
команд визуализации объектов, которые используются часто.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l38 level1 lfo68;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Для инкапсуляции текстурных данных используйте
текстурные объекты. Поместите все вызовы команды <b>glTexImage*()</b> (включая
мипмапы), необходимые для полного определения текстуры, а также ассоциированные
вызовы <b>glTexParameter*()</b> в текстурный объект. Свяжите текстурный объект
для выбора текстуры.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l38 level1 lfo68;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Если ситуация позволяет это, используйте <b>gl*TexSubImage()</b>
для замены всего изображения текстуры или его части, вместо того, чтобы
выполнять более затратные операции по удалению и созданию новой текстуры.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l38 level1 lfo68;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Если ваша реализация OpenGL поддерживает
высокоскоростное подмножество резидентных текстур, попытайтесь сделать все ваши
текстуры резидентными – то есть, сделать так, чтобы они уместились в текстурной
памяти. Если это необходимо, сокращайте размеры или разрешение внутреннего формата
ваших текстур до тех пор, пока они не влезут в память. Если такое сокращение
приводит к недопустимо выглядящим текстурным объектам, вы можете назначить
некоторым текстурам более низкий приоритет. В этом случае при нехватке памяти
такие текстуры будут вытеснены из текстурной памяти.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l38 level1 lfo68;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Для сокращения нагрузки на сеть в клиент –
серверном окружении используйте вычислители даже для тесселяции даже самых
простых поверхностей.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l38 level1 lfo68;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Если возможно, поставляйте нормали единичной
длины и избегайте частых обращений к GL_NORMALIZE. При использовании освещения
избегайте вызовов <b>glScale*()</b>, поскольку масштабирование практически
всегда требует перенормализации векторов нормалей.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l38 level1 lfo68;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Если плавная закраска не требуется, установите
режим GL_FLAT командой <b>glShadeModel()</b>.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l38 level1 lfo68;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Если возможно используйте только один вызов <b>glClear()</b>
на каждый кадр. Не используйте <b>glClear()</b> для очистки небольших областей
буферов, используйте ее только для полной или близкой к полной очистке.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l38 level1 lfo68;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Для рисования нескольких треугольников
используйте один вызов <b>glBegin(GL_TRIANGLES)</b> (то же касается примитивов
GL_QUADS и GL_LINES), а не множество таких вызовов или вызовов <b>glBegin(GL_POLYGON)</b>.
Даже если должен быть нарисован только один треугольник, используйте
GL_TRIANGLES, а не GL_POLYGON. </p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l38 level1 lfo68;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Некоторые реализации OpenGL извлекают пользу из
хранения вершинных данных в вершинных массивах. Использование вершинных
массивов сокращает количество вызовов функций. Некоторые реализации извлекают
пользу путем блочной обработки или повторного использования уже обработанных
вершин.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l38 level1 lfo68;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Вообще, следует использовать векторные версии
команд для передачи заранее вычисленных данных и скалярные версии – для данных,
которые были вычислены недалеко от момента вызова.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l38 level1 lfo68;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Избегайте совершения ненужных изменений
состояния, таких как установка цвета перед каждой вершиной в режиме плоской
заливки.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l38 level1 lfo68;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Убедитесь в том, что вы заблокировали растратные
растеризующие и пофрагментные операции перед рисованием или копированием
изображений. Если приказано, OpenGL будет накладывать текстуру даже на
пиксельные изображения.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l38 level1 lfo68;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Избегайте различия в полигональном режиме для
лицевых и обратных гранях, кроме тех случаев, когда это абсолютно необходимо.</p>

<h2>Советы по работе с GLX</h2>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l33 level1 lfo69;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Используйте <b>glXWaitGL()</b> вместо <b>glFinish()</b>,
чтобы команды визуализации X следовали за командами визуализации GL.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l33 level1 lfo69;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Точно так же используйте <b>glXWaitX()</b>
вместо <b>glFinish()</b>, чтобы команды визуализации GL следовали за командами
визуализации X.</p>

<p class=text align=left style='margin-left:36.0pt;text-align:left;text-indent:
-18.0pt;mso-list:l33 level1 lfo69;tab-stops:list 36.0pt'><![if !supportLists]><span
style='font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:
Symbol'><span style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Будьте осторожны при использовании <b>glXChooseVisual()</b>,
поскольку Булевский выбор осуществляется по точному соответствию. Поскольку
некоторые реализации не выполняют экспорта визуальных объектов со всеми
Булевскими комбинациями возможностей, вы должны вызвать <b>glXChooseVisual()</b>
несколько раз с разными Булевскими значениями до того, как сдадитесь. Например,
если нет однократно буферизованного визуального объекта с нужными
характеристиками, проверьте наличие визуального объекта с двойной буферизацией
и теми же характеристиками. Он может существовать, и его легко использовать. </p>

<p class=MsoNormal><a name=ПриложениеG><span style='display:none;mso-hide:all'><o:p>&nbsp;</o:p></span></a></p>

<p class=MsoNormal><span style='mso-bookmark:ПриложениеG'><span lang=EN-US
style='display:none;mso-hide:all;mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></span></p>

<p class=MsoNormal><span style='mso-bookmark:ПриложениеG'><span
style='display:none;mso-hide:all'><o:p>&nbsp;</o:p></span></span></p>

<h1 align=left style='text-align:left'><span style='mso-bookmark:ПриложениеG'>Приложение
G. Инвариантность OpenGL</span></h1>

<span style='mso-bookmark:ПриложениеG'></span>

<p class=MsoNormal><a href="mailto:ahinar@list.ru"></a><span style='font-size:
10.0pt;font-family:Verdana'>OpenGL не является точной пиксельной спецификацией.
Это означает, что она не гарантирует точного совпадения между изображениями,
сгенерированными разными реализациями. Однако OpenGL специфицирует ряд четких
соглашений по некоторым моментам, касающимся изображений, сгенерированных одной
и той же реализацией. В этом приложении описаны правила инварианта,
определяющие эти случаи.<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Самый очевидный и
фундаментальный момент – это повторяемость. Любая удобоваримая реализация
OpenGL генерирует один и тот же результат, каждый раз, когда специфическая
последовательность команд выполняется при одних и тех же начальных условиях.
Хотя такое заявление удобно для тестирования и проверок, оно часто не
устраивает программистов, поскольку достаточно сложно приводить систему к одним
и тем же начальным условиям. Например, рисование сцены дважды – второй раз
после переключения переднего и заднего буферов – не соответствует требованию об
одинаковых начальных условиях. Таким образом, повторяемость не может быть использована
в качестве гарантии стабильного изображения в режиме двойной буферизации.</p>

<p class=text align=left style='text-align:left'>Рисование линии и стирание ее
цветом фона – это простой и полезный алгоритм, рассчитанный на инвариантное
исполнение. Он работает, только если в случае обоих линий будут сгенерированы
фрагменты на одних и тех же (<i>x</i>, <i>y</i>). OpenGL требует, чтобы
координаты генерируемых растеризацией фрагментов не зависели от содержимого
буфера кадра, того, разрешена ли запись в цветовой буфер, значений всех матриц,
которые не находятся на вершинах матричных стеков, параметров теста отреза,
всех масок записи, всех очищающих величин, текущих цвета, индекса, нормали,
координат текстуры и флага ребра, текущих цвета растра, индекса растра и
координат текстуры растра и свойств материала. Она также требует, чтобы в
точности те же фрагменты, включая цветовые значения, генерировались вне
зависимости от содержимого буфера кадра, того, разрешен ли цветовой буфер для
записи, значений всех матриц, которые не находятся на вершинах матричных
стеков, параметров теста отреза, всех масок записи и всех очищающих величин.</p>

<p class=text align=left style='text-align:left'>OpenGL также предполагает, но
не требует, чтобы генерация фрагментов проходила независимо от матричного
режима, глубин матричных стеков, параметров альфа теста (отличных от состояния
активности), параметров трафарета (отличных от состояния активности),
параметров цветового наложения (отличных от состояния активности), логических
операций (но не от того, активны ли они), а также режимов хранения пикселей и
параметров пиксельного переноса. Поскольку инвариантность по отношению к
некоторых флагам активности не рекомендуется, вы должны использовать другие
параметры для блокировки соответствующих механизмов, когда требуется
инвариантная визуализация. Например, чтобы провести инвариантную визуализацию с
включенным и выключенным цветовым наложением, установите факторы наложения в
GL_ONE и GL_ZERO вместо того, чтобы вызывать <b>glDisable(GL_BLEND)</b>. (Это
может потребоваться, например, если в некоторых кадрах анимации должно работать
цветовое наложение, а в некоторых – нет.) Альфа тестирование, тест трафарета,
тест глубины и логические операции – все это может быть заблокировано подобным
образом.</p>

<p class=text align=left style='text-align:left'>Наконец, OpenGL требует, чтобы
пофрагментая арифметика, такая как цветовое наложение и тест глубины, была
инвариантна по отношению к (независима от) всех элементов состоянию OpenGL за
исключением тех, которые непосредственно ее определяют. Например, единственные
параметры OpenGL, влияющие на то, как производятся арифметические операции для
цветового наложения – это факторы источника и приемника, а также флаг
активности цветового наложения. Цветовое наложение инвариантно по отношению ко
всем остальным изменениям состояния. Такая инвариантность имеет место для теста
отреза, альфа теста, теста глубины, теста трафарета, цветового наложения,
цветового микширования, логических операций и масок записи.</p>

<p class=text align=left style='text-align:left'>Как результат всех этих
требований инвариантности, OpenGL может гарантировать, что два изображения,
одновременно или по очереди визуализированные в разных цветовых буферах с
использованием одной и той же последовательности команд, являются попиксельно
идентичными. Это касается всех цветовых буферов в буфере кадра, а также всех
цветовых буферов во внеэкранном буфере, но это не относится к буферу кадра и
внеэкранному буферу взятым вместе.</p>

<p class=MsoNormal><a name=ПриложениеH><span style='display:none;mso-hide:all'><o:p>&nbsp;</o:p></span></a></p>

<h1 align=left style='text-align:left'><span style='mso-bookmark:ПриложениеH'>Приложение
H. OpenGL и оконные системы</span></h1>

<span style='mso-bookmark:ПриложениеH'></span>

<p class=text align=left style='text-align:left'>OpenGL доступна на множестве
различных платформ и работает со множеством различных оконных систем. OpenGL
разработана для дополнения оконных систем, а не для дублирования их
функциональности. Вследствие этого OpenGL выполняет визуализацию геометрии и
изображений в двумерном и трехмерном пространствах, но она не управляет окнами
и не обрабатывает события пользовательского ввода.</p>

<p class=text align=left style='text-align:left'>Однако базовые определения
большинства оконных систем не поддерживают такую сложную библиотеку, как
OpenGL, с ее сложными и множественными форматами пикселей, буферами трафарета,
глубины и аккумуляции, а также двойную буферизацию. Для большинства оконных
систем были добавлены функции, расширяющие эти системы поддержкой OpenGL.</p>

<p class=text align=left style='text-align:left'>В этом приложении представлены
расширения, определенные для нескольких оконных и операционных систем: X
Windows System, Apple Mac OS, IBM OS/2 Warp и Microsoft Windows 95/98/NT. Для
полного понимания приложения вам понадобятся некоторые знания об оконных
системах.</p>

<h2><span lang=EN-US style='mso-ansi-language:EN-US'>GLX: </span>Расширения<span
lang=EN-US style='mso-ansi-language:EN-US'> OpenGL </span>для<span lang=EN-US
style='mso-ansi-language:EN-US'> X Window System<o:p></o:p></span></h2>

<p class=text align=left style='text-align:left'>В системе X Window
визуализация OpenGL реализована в качестве расширения к X в формальном
понимании этого термина. GLX представляет собой расширение протокола X (и
ассоциированного с ним API) для взаимодействия команд OpenGL с расширенным
сервером X. Соединение и аутентификация производятся в соответствии с
формальным механизмом X.</p>

<p class=text align=left style='text-align:left'>Как и в случае других
расширений XX, команды OpenGL инкапсулируются внутри потока байт X согласно
определенному сетевому протоколу для поддержки клиент – серверной визуализации
OpenGL. Поскольку быстродействие является критическим для трехмерной
визуализации, расширение OpenGL для X позволяет OpenGL избегать вмешательства
сервера X в кодирование, копирование и интерпретацию данных и вместо этого
осуществлять визуализацию непосредственно на графический конвейер.</p>

<p class=text align=left style='text-align:left'>GLX версии 1.3 добавил
несколько новшеств, например, новую структуру данных GLXFBConfig, описывающую
конфигурацию буфера кадра GLX (включая глубину компонент цветового буфера, а
также типы и размеры буферов глубины, трафарета, аккумуляции и дополнительных
буферов). Структура GLXFBConfig описывает эти атрибуты для поверхности
визуализации GLXDrawable. (В X, поверхность визуализации называется Drawable.)</p>

<p class=text align=left style='text-align:left'>GLX 1.3 поддерживает 3 типа
поверхностей GLXDrawable: GLXWindow, GLXPixmap и GLXPbuffer. GLXWindow является
экранным, а остальные – внеэкранными. Поскольку поверхность GLXPixmap имеет
ассоциированную с ней карту пикселей X, и OpenGL и X могут осуществлять
визуализацию на этой поверхности. На поверхности GLXPbuffer может осуществлять
визуализацию только OpenGL, такие поверхности предназначены для сохранения
пиксельных данных в невидимой памяти буфера кадра.&nbsp; (Не гарантируется, что
внеэкранная визуализация поддерживается непосредственными визуализаторами.)</p>

<p class=text align=left style='text-align:left'>X Visual является важной
структурой данных для управления форматом пикселей окна OpenGL. Информация о
формате пикселей отслеживается с помощью переменной типа XVisualInfo, включая
тип пикселей (индексные или RGBA), однократная или двойная буферизация,
разрешение цветов, а также наличие буферов глубины, трафарета и аккумуляции.
Стандартные объекты X Visual (например, PseudoColor или TrueColor) не описывают
деталей пиксельного формата, так что каждая реализация должна расширять число
объектов X Visual.</p>

<p class=text align=left style='text-align:left'>В GLX 1.3 GLXWindow имеет X
Visual, ассоциированный с его GLXFBConfig. Для GLXPixmap и GLXPBuffer может
быть, а может и не быть похожего ассоциированного X Visual. До GLX 1.3 все
поверхности (окна или пиксельные карты) были ассоциированы с X Visual. (До
версии 1.3 P – буферы не были частью GLX.)</p>

<p class=text align=left style='text-align:left'>Если вам требуется изучить
внутренности GLX, его спецификацию можно найти по адресу:
ftp://sgigate.sgi.com/pub/opengl/doc/opengl1.2.</p>

<h2>Инициализация</h2>

<p class=text align=left style='text-align:left'>Используйте функции <b>glXQueryExtension()</b>
и <b>glXQueryVersion()</b> для установления того, присутствует ли расширение
GLX для сервера X и, если да, то какой он версии. <b>glXQueryExtensionString()</b>
возвращает информацию о клиент – серверном соединении. <b>glXGetClientString()</b>
возвращает информацию о клиентской библиотеке, включая расширения и номер
версии. &nbsp;<b>glXGetServerString()</b> возвращает такую же информацию о
сервере.</p>

<p class=text align=left style='text-align:left'><b>glXChooseFBConfig()</b>
возвращает указатель на массив структур GLXFBConfig, описывающих все возможные
конфигурации буфера GLX, удовлетворяющие атрибутам, заданным клиентом. Вы
можете использовать <b>glXGetFBConfigAttrib()</b> для установления того,
поддерживает ли конфигурация буфера кадра конкретный атрибут GLX. Также вы
можете вызвать <b>glXGetVisualFromFBConfig()</b> для получения X Visual,
ассоциированного с GLXFBConfig.</p>

<p class=text align=left style='text-align:left'>Процесс создания областей
визуализации несколько различается в зависимости от типа поверхности. Для
GLXWindow сначала создайте X Window с X Visual, соответствующим GLXFBConfig.
Затем используйте это X Window при вызове функции <b>glXCreateWindow()</b>,
которая возвращает GLXWindow. Для GLXPixmap сначала создайте X Pixmap с
глубиной пикселей, соответствующей GLXFBConfig. Затем используйте эту Pixmap
при вызове функции <b>glXCreatePixmap()</b> для создания GLXPixmap. GLXPbuffer
не требует X Window или X Pixmap – просто вызовите <b>glxCreatePbuffer()</b> с
соответствующей структурой GLXFBConfig.</p>

<p class=warning>Замечание: Если вы используете GLX 1.2 или меньше, у вас нет
структуры GLXFBConfig. Вместо нее используйте функцию <b>glXChooseVisual()</b>,
возвращающую указатель на структуру XVisualInfo, описывающую X Visual,
соответствующий атрибутам, заданным клиентом. Вы можете опросить X Visual на
предмет поддержки определенного атрибута OpenGL с помощью функции <b>glXGetConfig()</b>.
Для визуализации на внеэкранную пиксельную карту, вы должны использовать
функцию <b>glXCreateGLXPixmap()</b>.</p>

<h2>Управление визуализацией</h2>

<p class=text align=left style='text-align:left'>GLX предоставляет несколько
функций для создания и управления контекстом визуализации OpenGL. Также
предоставляются функции для таких задач, как обработка событий GLX,
синхронизация потоков исполнения X и OpenGL, переключение переднего и заднего
буферов, а также использование X font.</p>

<h2>Управление контекстом визуализации OpenGL</h2>

<p class=text align=left style='text-align:left'>Контекст визуализации OpenGL
создается функцией <b>glXCreateNewContext()</b>. Один из аргументов этой
функции позволяет вам запросить непосредственный контекст визуализации, который
минует X Server, как было описано ранее. (Для осуществления непосредственной
визуализации соединение с сервером X должно быть локальным и реализация OpenGL
должна поддерживать непосредственную визуализацию.) <b>glXCreateNewContext()</b>
также позволяет нескольким контекстам разделять списки отображения и текстурные
объекты. Вы можете проверить, является ли контекст OpenGL непосредственным с
помощью функции <b>glXIsDirect()</b>.</p>

<p class=text align=left style='text-align:left'><b>glXMakeContextCurrent()</b>
привязывает контекст визуализации к текущему потому визуализации и
устанавливает две текущие поверхности для рисования. Вы можете рисовать на
одной из текущих поверхностей для рисования и считывать пиксели с другой. Во
многих ситуациях, обе этих поверхности являются одной и той же поверхностью GLXDrawable.
<b>glXGetCurrentContext()</b> возвращает текущий контекст. Вы можете получить
текущую поверхность для рисования с помощью <b>glXGetCurrentDrawable()</b>,
текущую поверхность для считывания – с помощью функции <b>glXGetCurrentReadDrawable()</b>,
а текущий X Display – с помощью <b>glXGetCurrentDisplay()</b>. Вы можете
использовать <b>glXQueryContext()</b> для выяснения текущих значений атрибутов
контекста.</p>

<p class=text align=left style='text-align:left'>В любое время для одного
потока может существовать только один текущий контекст. Если у вас создано
несколько контекстов, вы можете копировать группы переменных состояния OpenGL
из одного в другой с помощью функции <b>glXCopyContext()</b>. Когда вы
закончили работы с отдельным контекстом, уничтожьте его функцией <b>glXDestroyContext()</b>.</p>

<p class=warning>Замечание: Если у вас GLX 1.2 или меньше, используйте <b>glXCreateContext()</b>
для создания контекста визуализации и <b>glXMakeCurrent()</b> для установки его
в качестве текущего. Вы не можете объявить поверхность в качестве отдельной
поверхности для чтения, и у вас нет функции <b>glXGetCurrentReadDrawable()</b>.</p>

<h2>Обработка событий GLX</h2>

<p class=text align=left style='text-align:left'>События появились в GLX 1.3.
Они возвращаются в стандартном потоке событий X11. Обработка событий GLX была
добавлена специально для разрешение проблемы неоднозначности содержимого <b>GLXPbuffer</b>.
В GLX 1.3 вы можете использовать <b>glXSelectEvent()</b> для выбора только
одного события – GLX_PBUFFER_CLOBBER_MASK. С помощью стандартного механизма
обработки события X вы теперь можете засечь повреждение части <b>GLXPbuffer</b>
и принять меры для восстановления, если это необходимо. (Вы также можете
вызвать <b>glXGetSelectedEvent()</b> для выяснения того, проводите ли вы
мониторинг этого события.)</p>

<h2>Синхронизация исполнения</h2>

<p class=text align=left style='text-align:left'>Во избежании запросов об
исполнении X до того, как визуализация OpenGL закончится, вызовите <b>glXWaitGL()</b>.
В этом случае гарантируется, что все вызванные команды OpenGL будут выполнены
до того, как начнут исполняться функции визуализации X, вызванные после <b>glXWaitGL()</b>.
Хотя тех же результатов можно достигнуть с помощью команды <b>glFinish()</b>, <b>glXWaitGL()</b>
не требует дополнительного обращения к серверу и, таким образом, работает
эффективнее в ситуациях, когда клиент и сервер OpenGL размещены на разных
машинах.</p>

<p class=text align=left style='text-align:left'>Для предотвращения исполнения
последовательностей команд OpenGL перед исполнением вызванных ранее функций
визуализации X, используйте <b>glXWaitX()</b>. В этом случае гарантируется, что
все вызванные функции X будут выполнены до того, как начнут исполняться команды
визуализации OpenGL, вызванные после <b>glXWaitX()</b>.</p>

<h2>Переключение буферов</h2>

<p class=text align=left style='text-align:left'>Для режима двойной буферизации
передний и задний буферы можно переключить вызовом <b>glXSwapBuffer()</b>. <b>glFlush()</b>
выполняется как часть этой функции.</p>

<h2>Использование X Font</h2>

<p class=text align=left style='text-align:left'>Короткий путь к использованию
X Font в OpenGL предоставляется функцией <b>glXUseXFont()</b>. Эта функция
строит списки отображения для каждого запрошенного шрифта и его размера, каждый
из которых вызывает <b>glBitmap()</b>.</p>

<h2>Очистка поверхностей</h2>

<p class=text align=left style='text-align:left'>После завершения визуализации,
вы можете уничтожить поверхность для рисования с помощью функции <b>glXDestroyWindow()</b>,
<b>glXDestroyPixmap()</b> или <b>glXDestroyPbuffer()</b>. (Эти функции
отсутствуют в GLX версии 1.2 и ниже, хотя там есть функция <b>glXDestroyGLXPixmap()</b>
по смыслу аналогичная <b>glXDestroyPixmap()</b>.)</p>

<h2>Прототипы GLX</h2>

<h2>Инициализация</h2>

<p class=text align=left style='text-align:left'>Выяснить, определено ли
расширение GLX для сервера X:</p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>bool <b>glXQueryExtension</b> (Display *<i>dpy</i>,
int *<i>errorBase</i>, int *<i>eventBase</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Запросить версию и информацию
о расширениях клиента и сервера:</p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>bool <b>glXQueryVersion</b> (Display *<i>dpy</i>,
int *<i>major</i>, int *<i>minor</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>const char* <b>glXGetClientString</b> (Display
*<i>dpy</i>, int <i>name</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>const char* <b>glXQueryServerString</b>
(Display *<i>dpy</i>, int <i>screen</i>, int <i>name</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>const char* <b>glXQueryExtensionString</b>
(Display *<i>dpy</i>, int <i>screen</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Получить доступные
конфигурации буфера кадра:</p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>GLXFBConfig* <b>glXGetFBConfigs</b> (Display *<i>dpy</i>,
int <i>screen</i>, int* <i>nelements</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>GLXFBConfig* <b>glXChooseFBConfig</b> (Display
*<i>dpy</i>, int <i>screen</i>, const int <i>attribList</i>, int *<i>nelements</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Опросить буфер кадра на
предмет атрибута GLX или информации X:</p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>int <b>glXGetFBConfigAttrib</b> (Display *<i>dpy</i>,
GLXFBConfig <i>config</i>, int <i>attribute</i>, int *<i>value</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>XVisualInfo* <b>glXGetVisualFromFB</b> (Display
*<i>dpy</i>, GLXFBConfig <i>config</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Создать поверхности для
поддержки визуализации (экранной или внеэкранной):</p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>GLXWindow <b>glXCreateWindow</b> (Display *<i>dpy</i>,
GLXFBConfig <i>config</i>, Window <i>win</i>, &nbsp;&nbsp;&nbsp;&nbsp; const
int* <i>attribList</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>GLXPixmap <b>glXCreatePixmap</b> (Display *<i>dpy</i>,
GLXFBConfig <i>config</i>, Pixmap <i>pixmap</i>, &nbsp;&nbsp;&nbsp; const int* <i>attribList</i>);
<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>GLXPbuffer <b>glXCreatePbuffer</b> (Display *<i>dpy</i>,
GLXFBConfig <i>config</i>, const int* <i>attribList</i>);<o:p></o:p></span></p>

<h2>Управление визуализацией</h2>

<p class=text align=left style='text-align:left'>Управление и опрос контекста
визуализации OpenGL:</p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>GLXContext <b>glXCreateNewContext</b> (Display
*<i>dpy</i>, GLXBFConfig <i>config</i>, int <i>renderType</i>, GLXContext <i>shareList</i>,
bool <i>direct</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>bool <b>glXMakeContextCurrent</b> (Display *<i>dpy</i>,
GLXDrawable <i>drawable</i>, GLXDrawable <i>read</i>, GLXContext <i>context</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>void <b>glXCopyContext</b> (Display *<i>dpy</i>,
GLXContext <i>source</i>, GLXContext <i>dest</i>, unsigned long <i>mask</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>bool <b>glXIsDirect</b> (Display *<i>dpy</i>,
GLXContext <i>context</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>GLXContext <b>glXGetCurrentContext</b> (void);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>Display * <b>glXGetCurrentDisplay</b> (void);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>GLXDrawable <b>glXGetCurrentDrawable</b>
(void);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>GLXDrawable <b>glXGetCurrentReadDrawable</b>
(void);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>int <b>glXQueryContext</b> (Display *<i>dpy</i>,
GLXContext <i>context</i>, int <i>attribute</i>, int* <i>value</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>void <b>glXDestroyContext</b> (Display *<i>dpy</i>,
GLXContext <i>context</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Запрос<span style='mso-ansi-language:
EN-US'> </span>событий<span lang=EN-US style='mso-ansi-language:EN-US'> GLX:<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>int <b>glXSelectEvent</b> (Display *<i>dpy</i>,
GLXDrawable <i>drawable</i>, unsigned long <i>eventMask</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>int <b>glXGetSelectedEvent</b> (Display *<i>dpy</i>,
GLXDrawable <i>drawable</i>, unsigned long* <i>eventMask</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Синхронизация исполнения:</p>

<p class=text align=left style='text-align:left'>void <b>glXWaitGL</b> (void);</p>

<p class=text align=left style='text-align:left'>void <b>glXWaitX</b> (void);</p>

<p class=text align=left style='text-align:left'>Поменять местами передний и
задний буферы:</p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>void <b>glXSwapBuffers</b> (Display *<i>dpy</i>,
GLXDrawable <i>drawable</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Использовать<span lang=EN-US
style='mso-ansi-language:EN-US'> X Font:<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>void <b>glXUseXFont</b> (Font font, int <i>first</i>,
int count, int <i>listBase</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Очистить<span
style='mso-ansi-language:EN-US'> </span>поверхности<span lang=EN-US
style='mso-ansi-language:EN-US'>:<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>void <b>glXDestroyWindow</b> (Display *<i>dpy</i>,
GLXWindow <i>win</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>void <b>glXDestroyPixmap</b> (Display *<i>dpy</i>,
GLXPixmap <i>pixmap</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>void <b>glXDestroyPbuffer</b> (Display *<i>dpy</i>,
GLXPbuffer <i>pbuffer</i>);<o:p></o:p></span></p>

<h2>Устаревшие прототипы</h2>

<p class=text align=left style='text-align:left'>Следующие функции являются
устаревшими по отношению к GLX 1.3. Если вы используете GLX 1.2 или его
предшественника, вам могут понадобиться некоторые из них.</p>

<p class=text align=left style='text-align:left'>Получить желаемый объект X
Visual:</p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>XVisualInfo* <b>glXChooseVisual</b> (Display *<i>dpy</i>,
int <i>screen</i>, int* <i>attribList</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>int <b>glXGetConfig</b> (Display *<i>dpy</i>,
XVisualInfo* <i>visual</i>, int <i>attrib</i>, int* <i>value</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Управление<span
style='mso-ansi-language:EN-US'> </span>контекстом<span lang=EN-US
style='mso-ansi-language:EN-US'> OpenGL:<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>GLXContext <b>glXCreateContext</b> (Display *<i>dpy</i>,
XVisualInfo *<i>visual</i>, GLXContext <i>shareList</i>, bool <i>direct</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>bool <b>glXMakeCurrent</b> (Display *<i>dpy</i>,
GLXDrawable <i>drawable</i>, GLXContext <i>context</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Внеэкранная<span
style='mso-ansi-language:EN-US'> </span>визуализация<span lang=EN-US
style='mso-ansi-language:EN-US'>:<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>GLXPixmap <b>glXCreateGLXPixmap</b> (Display *<i>dpy</i>,
XVisualInfo *<i>visual</i>, Pixmap <i>pixmap</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>void <b>glXDestroyGLXPixmap</b> (Display *<i>dpy</i>,
GLXPixmap <i>pix</i>);<o:p></o:p></span></p>

<h2><span lang=EN-US style='mso-ansi-language:EN-US'>AGL: </span>Расширения<span
lang=EN-US style='mso-ansi-language:EN-US'> OpenGL </span>для<span lang=EN-US
style='mso-ansi-language:EN-US'> Apple Macintosh<o:p></o:p></span></h2>

<p class=text align=left style='text-align:left'>В этом разделе описаны
функции, определенные в качестве расширений OpenGL для Apple Macintosh (AGL).
Здесь требуется понимание того, как Macintosh производит графическую
визуализацию (QuickDraw).</p>

<p class=text align=left style='text-align:left'>Для получения более подробной
информации (включая способы получения программной библиотеки для Macintosh) вы
можете получить на сайте Apple: <a href="http://www.apple.com/opengl">http://www.apple.com/opengl</a>.</p>

<p class=text align=left style='text-align:left'>Визуализация OpenGL для
Macintosh реализуется через библиотеку, которая либо присоединяется к
приложению, либо является резидентной для приложения, которое хочет ее
использовать. Для систем, в которых отсутствует аппаратная поддержка, OpenGL
реализована на программном уровне. Если поддержка имеется, используются ее
возможности, соответствующие требованиям конвейера OpenGL, а остальные
реализуются программно.</p>

<p class=text align=left style='text-align:left'>Тип данных AGLPixelFormat
(аналог AGL для XVisualInfo) хранит информацию о формате пикселей, включая тип
пикселей (индексные или RGBA), тип буферизации (однократная или двойная),
разрешение цветов, а также наличие буферов глубины, трафарета и аккумуляции.</p>

<p class=text align=left style='text-align:left'>В отличие от реализаций OpenGL
для других систем (например, для X&nbsp; Window System) клиент – серверная
модель не используется. Однако вам все равно может понадобиться команда <b>glFlush()</b>,
поскольку некоторая аппаратура может буферизовать команды OpenGL и требовать
толчка, чтобы их выполнить.</p>

<h2>Инициализация</h2>

<p class=text align=left style='text-align:left'>Используйте функцию <b>aglGetVersion()</b>
для определения присутствующей версии AGL для Macintosh.</p>

<p class=text align=left style='text-align:left'>Соответствие возможностей
нижележащих графических устройств и ваших требований к буферам визуализации
устанавливается с помощью функции <b>aglChoosePixelFormat()</b>. Она возвращает
структуру AGLPixelFormat или NULL в зависимости от того, могут ли быть
выполнены ваши требования.</p>

<h2>Визуализация и контексты</h2>

<p class=text align=left style='text-align:left'>Для создания и управления
контекстом OpenGL AGL предоставляет несколько функций. Вы можете использовать
контекст и для визуализации в окне и для внеэкранной визуализации. Также
предоставляются функции для переключения переднего и заднего буферов, для
использования шрифтов и для изменения настроек буфера в ответ на перемещение,
изменение размера или событие от аппаратуры. Буферы для программной
визуализации (и в некоторых случаях для аппаратной) создаются в системной
памяти.</p>

<h2>Управление контекстом визуализации OpenGL</h2>

<p class=text align=left style='text-align:left'>Контекст OpenGL создается
(должен быть как минимум один контекст на каждое окно, в которое осуществляется
визуализация) с помощью функции <b>aglCreateContext()</b>. Она принимает
выбранный вами формат пикселей в качестве аргумента и использует его при
инициализации буфера.</p>

<p class=text align=left style='text-align:left'>Используйте <b>aglSetDrawable()</b>
для присоединения контекста к поверхности рисования и, далее, <b>aglSetCurrentContext()</b>
для того, чтобы сделать контекст текущим. Только один контекст может быть
текущим для одного потока управления в каждый конкретный момент. Это
определяет, на какую поверхность производится визуализация, и какой контекст
следует использовать совместно с ней. Для визуализации на одну и ту же
поверхность может быть использовано более одного контекста (не одновременно).
Определить текущий контекст визуализации и поверхность визуализации позволяют
две функции: <b>aglGetCurrentContext()</b> и <b>aglGetDrawable()</b>.</p>

<p class=text align=left style='text-align:left'>Если у вас создано несколько
контекстов, вы можете копировать группы переменных состояния OpenGL из одного в
другой с помощью функции <b>aglCopyContext()</b>. Когда вы закончили работы с
отдельным контекстом, уничтожьте его функцией <b>aglDestroyContext()</b>.</p>

<h2>Экранная визуализация</h2>

<p class=text align=left style='text-align:left'>Для экранной визуализации
сначала создайте формат пикселей. Затем создайте контекст на основании этого
формата пикселей и присоедините его к окну с помощью функции <b>aglSetDrawable()</b>.
Прямоугольник буфера может быть изменен с помощью вызова <b>aglSetInteger(AGL_BUFFER_RECT,
...)</b>.</p>

<h2>Внеэкранная визуализация</h2>

<p class=text align=left style='text-align:left'>Для внеэкранной визуализации
создайте формат пикселей с атрибутом AGL_OFFSCREEN. Затем создайте контекст на
основании этого формата пикселей и свяжите его с экраном с помощью функции <b>aglSetOffScreen()</b>.</p>

<h2>Полноэкранная визуализация</h2>

<p class=text align=left style='text-align:left'>Для полноэкранной визуализации
создайте формат пикселей с атрибутом AGL_FULLSCREEN. Затем создайте контекст на
основании этого формата пикселей и свяжите его с экраном с помощью функции <b>aglSetFullScreen()</b>.</p>

<h2>Переключение буферов</h2>

<p class=text align=left style='text-align:left'>Для поверхностей с двойной
буферизацией (для формата пикселей текущего контекста) используйте <b>aglSwapBuffers()</b>
для переключения переднего и заднего буферов. Переключаемый прямоугольник может
быть настроен с помощью вызова <b>aglSetInteger(AGL_SWAP_RECT, ...)</b>. <b>glFlush()</b>
выполняется как часть этой функции.</p>

<h2>Обновление буферов визуализации</h2>

<p class=text align=left style='text-align:left'>Apple Macintosh требует от вас
производить собственную обработку событий и не позволяет библиотекам
автоматически подключаться к потоку событий. Чтобы поверхности под управлением
OpenGL могли изменяться в размере, положении и глубине пикселей, AGL
представляет функцию <b>aglUpdateContext()</b>.</p>

<p class=text align=left style='text-align:left'>Эта функция должна вызываться
вашим кодом обработки событий, как только одно из этих событий произойдет на
текущей поверхности. В идеале, стоит перерисовать сцену после обновления для
учета изменений в буфере визуализации.</p>

<h2>Использование шрифтов Apple Macintosh</h2>

<p class=text align=left style='text-align:left'>Простой путь использования
шрифтов Apple Macintosh предоставляется с помощью функции <b>aglUseFont()</b>.Эта
функция строит списки отображения для каждого запрошенного шрифта и его
размера, каждый из которых вызывает <b>glBitmap()</b>.</p>

<h2>Обработка ошибок</h2>

<p class=text align=left style='text-align:left'>Для расширения OpenGL в
системе Apple Macintosh предоставляется механизм обработки ошибок. Когда ошибка
произошла, вы можете вызвать функцию <b>aglGetError()</b> для более точного
описания того, что вызвало эту ошибку.</p>

<h2>Прототипы AGL</h2>

<h2>Инициализация</h2>

<p class=text align=left style='text-align:left'>Получить информацию о версии:</p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>void <b>aglGetVersion</b> (GLint* <i>major</i>,
GLint* <i>minor</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Получить<span
style='mso-ansi-language:EN-US'> </span>доступные<span style='mso-ansi-language:
EN-US'> </span>форматы<span style='mso-ansi-language:EN-US'> </span>пикселей<span
lang=EN-US style='mso-ansi-language:EN-US'>:<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>AGLPixelFormat <b>aglChoosePixelFormat</b>
(const AGLDevice* <i>gdevs</i>, GLint <i>ndev</i>, onst GLint *<i>attribs</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>void <b>aglDestroyPixelFormat</b>
(AGLPixelFormat <i>pix</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>AGLPixelFormat <b>aglNextPixelFormat</b>
(AGLPixelFormat <i>pix</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>GLboolean <b>aglDescribePixelFormat</b>
(AGLPixelFormat <i>pix</i>, GLint <i>attrib</i>, GLint *<i>value</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>AGLDevice* <b>aglDevicesOfPixelFormat</b>
(AGLPixelFormat <i>pix</i>, GLint *<i>ndevs</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Информация<span
style='mso-ansi-language:EN-US'> </span>о<span style='mso-ansi-language:EN-US'>
</span>визуализаторе<span lang=EN-US style='mso-ansi-language:EN-US'>:<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>AGLRendererInfo <b>aglQueryRendererInfo</b>
(const AGLDevice* <i>gdevs</i>, GLint <i>ndev</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>void <b>aglDestroyRendererInfo</b>
(AGLRendererInfo <i>rend</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>AGLRendererInfo <b>aglNextRendererInfo</b>
((AGLRendererInfo <i>rend</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>GLboolean <b>aglDescribeRenderer</b>
(AGLRendererInfo <i>rend</i>, GLint <i>prop</i>, GLint *<i>value</i>);<o:p></o:p></span></p>

<h2>Управление визуализацией</h2>

<p class=text align=left style='text-align:left'>Управление контекстом
визуализации OpenGL:</p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>AGLContext <b>aglCreateContext</b>
(AGLPixelFormat <i>pix</i>, AGLContext <i>share</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>GLboolean <b>aglDestroyContext</b> (AGLContext <i>ctx</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>GLboolean <b>aglCopyContext</b> (AGLContext <i>src</i>,
AGLContext <i>dst</i>, GLuint <i>mask</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>GLboolean <b>aglUpdateContext</b> (AGLContext <i>ctx</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Установка<span
style='mso-ansi-language:EN-US'> </span>текущего<span style='mso-ansi-language:
EN-US'> </span>состояния<span lang=EN-US style='mso-ansi-language:EN-US'>:<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>GLboolean <b>aglSetCurrentContext</b>
(AGLContext <i>ctx</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>AGLContext <b>aglGetCurrentContext</b> (void);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Функции<span style='mso-ansi-language:
EN-US'> </span>поверхностей<span lang=EN-US style='mso-ansi-language:EN-US'>:<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>GLboolean <b>aglSetDrawable</b> (AGLContext <i>ctx</i>,
AGLDrawable <i>draw</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>GLboolean <b>aglSetOffScreen</b> (AGLContext <i>ctx</i>,
GLsizei <i>width</i>, GLsizei <i>height</i>, GLsizei <i>rowbytes</i>, GLvoid *<i>baseaddr</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>GLboolean <b>aglSetFullScreen</b> (AGLContext <i>ctx</i>,
GLsizei <i>width</i>, GLsizei <i>height</i>,&nbsp; GLsizei <i>freq</i>, GLint <i>device</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>AGLDrawable <b>aglGetDrawable</b> (AGLContext <i>ctx</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Функции<span style='mso-ansi-language:
EN-US'> </span>виртуального<span style='mso-ansi-language:EN-US'> </span>экрана<span
lang=EN-US style='mso-ansi-language:EN-US'>:<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>GLboolean <b>aglSetVirtualScreen</b>
(AGLContext <i>ctx</i>, GLint <i>screen</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>GLint <b>aglGetVirtualScreen</b> (AGLContext <i>ctx</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Конфигурирование<span
style='mso-ansi-language:EN-US'> </span>глобальных<span style='mso-ansi-language:
EN-US'> </span>опций<span style='mso-ansi-language:EN-US'> </span>библиотеки<span
lang=EN-US style='mso-ansi-language:EN-US'>:<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>GLboolean <b>aglConfigure</b> (GLenum <i>pname</i>,
GLuint <i>param</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Функции<span style='mso-ansi-language:
EN-US'> </span>переключения<span lang=EN-US style='mso-ansi-language:EN-US'>:<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>void <b>aglSwapBuffers</b> (AGLContext <i>ctx</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Опции<span style='mso-ansi-language:
EN-US'> </span>контекстов<span lang=EN-US style='mso-ansi-language:EN-US'>:<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>GLboolean <b>aglEnable</b> (AGLContext <i>ctx</i>,
GLenum <i>pname</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>GLboolean <b>aglDisable</b> (AGLContext <i>ctx</i>,
GLenum <i>pname</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>GLboolean <b>aglIsEnabled</b> (AGLContext <i>ctx</i>,
GLenum <i>pname</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>GLboolean <b>aglSetInteger</b> (AGLContext <i>ctx</i>,
GLenum <i>pname</i>, contst GLint *<i>params</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>GLboolean <b>aglGetInteger</b> (AGLContext <i>ctx</i>,
GLenum <i>pname</i>, contst GLint *<i>params</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Шрифтовые<span
style='mso-ansi-language:EN-US'> </span>функции<span lang=EN-US
style='mso-ansi-language:EN-US'>:<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>GLboolean <b>aglUseFont</b> (AGLContext <i>ctx</i>,
GLint <i>fontID</i>, Style <i>face</i>, GLint <i>size</i>, GLint <i>first</i>,
GLint <i>count</i>, GLint <i>base</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Функции работы с ошибками:</p>

<p class=text align=left style='text-align:left'>GLenum <b>aglGetError</b>
(void);</p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>const GLubyte *<b>aglErrorString</b> (GLenum <i>code</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Функция<span style='mso-ansi-language:
EN-US'> </span>сброса<span lang=EN-US style='mso-ansi-language:EN-US'>:<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>void <b>aglResetLibrary</b> (void);<o:p></o:p></span></p>

<h2><span lang=EN-US style='mso-ansi-language:EN-US'>PGL: </span>Расширения<span
lang=EN-US style='mso-ansi-language:EN-US'> OpenGL </span>для<span lang=EN-US
style='mso-ansi-language:EN-US'> IBM OS/2 Warp<o:p></o:p></span></h2>

<p class=text align=left style='text-align:left'>Визуализация OpenGL для IBM
OS/2 Warp осуществляется с помощью функций PGL, добавленных с целью интеграции
OpenGL в стандартный Presentation Manager IBM. OpenGL совместно с PGL
поддерживают и непосредственный контекст (который часто работает быстрее) и
опосредованный контекст (который позволяет некоторую долю интеграции Интерфейса
программирования графики (Graphics Programming Interface -- GPI) и визуализации
OpenGL).</p>

<p class=text align=left style='text-align:left'>Тип данных VISUALCONFIG
(аналог PGL для XVisualInfo) хранит информацию о формате пикселей, включая тип
пикселей (индексные или RGBA), тип буферизации (однократная или двойная),
разрешение цветов, а также наличие буферов глубины, трафарета и аккумуляции.</p>

<p class=text align=left style='text-align:left'>Для получения более подробной
информации (включая способы получения программной библиотеки для IBM OS/2 Warp,
Version 3.0) вы можете получить на сайте IBM: <a
href="http://www.austin.ibm.com/software/opengl">http://www.austin.ibm.com/software/opengl</a>.</p>

<h2>Инициализация</h2>

<p class=text align=left style='text-align:left'>Используйте функции <b>pglQueryCapability()</b>
и <b>pglQueryVersion()</b> для определения того, поддерживается ли OpenGL на
данной машине и, если так, как она поддерживается и какая версия присутствует. <b>pglChooseConfig()</b>
возвращает указатель на структуру VISUALCONFIG, описывающую визуальную конфигурацию,
наилучшим образом подходящую к заданным клиентом атрибутам. Список отдельных
визуальных конфигураций, поддерживаемых графическим устройством можно получить
с помощью <b>pglQueryConfigs()</b>.</p>

<h2>Управление визуализацией</h2>

<p class=text align=left style='text-align:left'>PGL предоставляет несколько
функций для создания и управления контекстом визуализации OpenGL, захвата
содержимого битовой карты, синхронизации потоков Presentation Manager и OpenGL,
переключения буферов, использования цветовой палитры и использования
логического шрифта OS/2.</p>

<h2>Управление контекстом визуализации OpenGL</h2>

<p class=text align=left style='text-align:left'>Контекст визуализации OpenGL
создается с помощью функции <b>pglCreateContext()</b>. Один из аргументов этой
функции позволяет запросить непосредственный контекст, который, минуя GPI,
производит визуализацию прямо в окно PM, что обычно происходит быстрее. Вы
можете определить, является ли контекст непосредственным с помощью функции <b>pglIsDirect()</b>.</p>

<p class=text align=left style='text-align:left'>Чтобы сделать контекст
текущим, используйте <b>pglMakeCurrent()</b>; <b>pglGetCurrentContext()</b>
возвращает текущий контекст. Вы также можете получить текущее окно с помощью <b>pglGetCurrentWindow()</b>.
Вы можете копировать значения переменных состояния OpenGL с помощью <b>pglCopyContext()</b>.
Когда вы закончите работы с контекстом OpenGL, вы можете удалить его с помощью <b>pglDestroyContext()</b>.</p>

<h2>Доступ к битовой карте переднего буфера</h2>

<p class=text align=left style='text-align:left'>Для доступа к битовому
представлению содержимого переднего буфера используйте функцию <b>pglGrabFrontBitmap()</b>.
В качестве части этой функции вызывается команда <b>glFlush()</b> после чего вы
можете получить доступ к битовой карте, но она будет доступна только для
чтения. Немедленно после того, как доступ завершен, вы должны вызвать функцию <b>pglReleaseFrontBitmap()</b>
для восстановления режима записи в передний буфер.</p>

<h2>Синхронизация исполнения</h2>

<p class=text align=left style='text-align:left'>Во избежании запросов об
исполнении функций GPI до того, как визуализация OpenGL закончится, вызовите <b>pglWaitGL()</b>.
В этом случае гарантируется, что все вызванные команды OpenGL будут выполнены
до того, как начнут исполняться функции визуализации GPI, вызванные после <b>pglWaitGL()</b>.
Для предотвращения исполнения последовательностей команд OpenGL перед
исполнением вызванных ранее функций визуализации GPI, используйте <b>pglWaitPM()</b>.
В этом случае гарантируется, что все вызванные функции GPI будут выполнены до
того, как начнут исполняться команды визуализации OpenGL, вызванные после <b>pglWaitPM()</b>.</p>

<p class=warning>Замечание: Визуализации OpenGL и GPI могут интегрироваться,
только если контекст является опосредованным.</p>

<h2>Переключение буферов</h2>

<p class=text align=left style='text-align:left'>Для окон с двойной
буферизацией передний и задний буферы можно поменять местами с помощь функции <b>pglSwapBuffers()</b>.
<b>glFlush()</b> выполняется как часть этой функции.</p>

<h2>Использование цветовой палитры</h2>

<p class=text align=left style='text-align:left'>Когда вы работаете в 8-битном
режиме (с 256 цветами), вы должны позаботиться об управлении цветовой палитрой.
Для окон с индексной визуальной конфигурацией вызовите <b>pglSelectColorIndexPalette()</b>,
чтобы сообщить OpenGL о том, какую палитру вы хотите использовать с вашим
контекстом. Цветовая палитра должна быть выбрана до того, как контекст будет
изначально связан с окном. В RGBA режиме OpenGL настраивает палитру
автоматически.</p>

<h2>Использование логического шрифта OS/2</h2>

<p class=text align=left style='text-align:left'>Простой путь использования
шрифтов OS/2 предоставляется с помощью функции <b>pglUseFont()</b>. Эта функция
строит списки отображения для каждого запрошенного шрифта и его размера, каждый
из которых вызывает <b>glBitmap()</b>.</p>

<h2>Прототипы PGL</h2>

<h2>Инициализация</h2>

<p class=text align=left style='text-align:left'>Определить, поддерживается ли
OpenGL и, если да, то какой версии:</p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>long <b>pglQueryCapability</b> (HAB <i>hab</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>void <b>pglQueryVersion</b> (HAB <i>hab</i>,
int *<i>major</i>, int *<i>minor</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Выбор<span style='mso-ansi-language:
EN-US'> </span>визуальной<span style='mso-ansi-language:EN-US'> </span>конфигурации<span
lang=EN-US style='mso-ansi-language:EN-US'>:<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>PVISUALCONFIG <b>pglChooseConfig</b> (HAB <i>hab</i>,
int *<i>attribList</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>PVISUALCONFIG <b>pglQueryConfigs</b> (HAB <i>hab</i>);<o:p></o:p></span></p>

<h2>Управление<span style='mso-ansi-language:EN-US'> </span>конфигурацией<span
lang=EN-US style='mso-ansi-language:EN-US'><o:p></o:p></span></h2>

<p class=text align=left style='text-align:left'>Управление контекстами и их
опрос:</p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>HGC <b>pglCreateContext</b> (HAB <i>hab</i>,
PVISUALCONFIG <i>pVisualConfig</i>, HGC <i>shareList</i>, bool <i>isDirect</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>bool <b>pglDestroyContext</b> (HAB <i>hab</i>,
HGC <i>hgc</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>bool <b>pglMakeCurrent</b> (HAB <i>hab</i>, HGC
<i>hgc</i>, HWND <i>hwnd</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>long <b>pglIsDirect</b> (HAB <i>hab</i>, HGC <i>hgc</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>HGL <b>pglGetCurrentContext</b> (HAB <i>hab</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>HWND <b>pglGetCurrentWindow</b> (HAB <i>hab</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Доступ и освобождение битовой
карты переднего буфера:</p>

<p class=text align=left style='text-align:left'>bool <b>pglGrabFrontBitmap</b>
(HAB <i>hab</i>, HPS *<i>hps</i>, HBITMAP *<i>phbitmap</i>);</p>

<p class=text align=left style='text-align:left'>bool <b>pglReleaseFrontBitmap</b>
(HAB <i>hab</i>);</p>

<p class=text align=left style='text-align:left'>Синхронизация исполнения:</p>

<p class=text align=left style='text-align:left'>HPS <b>pglWaitGL</b> (HAB <i>hab</i>);</p>

<p class=text align=left style='text-align:left'>void <b>pglWaitPM</b> (HAB <i>hab</i>);</p>

<p class=text align=left style='text-align:left'>Поменять местами передний и
задний буферы:</p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>void <b>pglSwapBuffers</b> (HAB <i>hab</i>,
HWND <i>hwnd</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Выбрать<span style='mso-ansi-language:
EN-US'> </span>палитру<span lang=EN-US style='mso-ansi-language:EN-US'>:<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>void <b>pglSelectColorIndexPalette</b> (HAB <i>hab</i>,
HPAL <i>hpal</i>, HGC <i>hgc</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Использовать<span
style='mso-ansi-language:EN-US'> </span>логический<span style='mso-ansi-language:
EN-US'> </span>шрифт<span lang=EN-US style='mso-ansi-language:EN-US'> OS/2:<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>bool <b>pglUseFont</b> (HAB <i>hab</i>, HPS <i>hps</i>,
FATTRS *<i>fontAttribs</i>, long <i>logicalID</i>, int <i>first</i>, int <i>count</i>,
int <i>listBase</i>);<o:p></o:p></span></p>

<h2><span lang=EN-US style='mso-ansi-language:EN-US'>WGL: </span>Расширения<span
lang=EN-US style='mso-ansi-language:EN-US'> OpenGL </span>для<span lang=EN-US
style='mso-ansi-language:EN-US'> Microsoft Windows 95/98/NT<o:p></o:p></span></h2>

<p class=text align=left style='text-align:left'>Визуализация OpenGL поддерживается
на системах с Microsoft Windows 95, 98 и NT. Для инициализации формата
пикселей, управления визуализацией и получения доступа к расширениям OpenGL
необходимы функции библиотеки Win32. Для полной поддержки OpenGL был добавлен
ряд функций с префиксом <b>wgl</b>.</p>

<p class=text align=left style='text-align:left'>Ключевой структурой данных для
управления форматом пикселей окна OpenGL в системе Win32/WGL является
PIXELFORMATDESCRIPTOR. Переменная типа PIXELFORMATDESCRIPTOR хранит информацию
о формате пикселей, включая тип пикселей (индексные или RGBA), тип буферизации
(однократная или двойная), разрешение цветов, а также наличие буферов глубины,
трафарета и аккумуляции. </p>

<p class=text align=left style='text-align:left'>Для получения более подробной
информации о WGL вам следует начать с технических статей, доступных через веб –
сайт Microsoft Developer Network.</p>

<h2>Инициализация</h2>

<p class=text align=left style='text-align:left'>Для получения информации о
версии используйте функцию <b>GetVersion()</b> или более новую <b>GetVersionEx()</b>.
<b>ChoosePixelFormat()</b> пытается найти PIXELFORMATDESCRIPTOR с заданными
атрибутами. Если совпадение найдено, следует вызвать <b>SetPixelFormat()</b>
для перехода к использованию этого формата пикселей. Вы должны выбрать формат
пикселей в контексте устройства до вызова <b>wglCreateContext()</b>.</p>

<p class=text align=left style='text-align:left'>Если вы хотите получить
подробную информацию о полученном формате пикселей, используйте <b>DecribePixelFormat()</b>
или, для оверлеев, <b>wglDescribeLayerPlane()</b>.</p>

<h2>Управление визуализацией</h2>

<p class=text align=left style='text-align:left'>Несколько функций WGL
предоставлены для создания и управления контекстом OpenGL, визуализации на
битовую карту, переключения буферов, установки цветовой палитры и использования
растровых или векторных шрифтов.</p>

<h2>Управление контекстом визуализации OpenGL</h2>

<p class=text align=left style='text-align:left'>Для создания контекста OpenGL,
рисующего на устройстве с выбранным в контекст устройства нужным форматом
пикселей применяется функция <b>wglCreateContext()</b>. (Для создания контекста
визуализации для окон – оверлеев используется <b>wglCreateLayerContext()</b>.)
Чтобы сделать контекст текущим, используйте <b>wglMakeCurrent()</b>; <b>wglGetCurrentContext()</b>
возвращает текущий контекст. Вы также можете получить текущий контекст
устройства с помощью <b>wglGetCurrentDC()</b>. Вы можете копировать некоторые
переменные состояния OpenGL из контекста в контекст с помощью <b>wglCopyContext()</b>
или разделять списки отображения или текстурные объекты с помощью <b>wglShareLists()</b>.
Когда вы закончите работы с контекстом визуализации, вы можете уничтожить его
функцией <b>wglDestroyContext()</b>.</p>

<h2>Доступ к расширениям OpenGL</h2>

<p class=text align=left style='text-align:left'>Для доступа к специфичным для
реализации функциям расширений OpenGL используйте функцию <b>wglGetProcAddress()</b>.
Для определения того, какие расширения поддерживаются реализацией OpenGL,
используйте <b>glGetString(GL_EXTENSIONS)</b>. Если передать функции <b>wglGetProcAddress()</b>
имя функции расширения (например «glMinmax» или «glConvolution2D») она
возвратит фактический указатель на эту функцию внутри библиотеки, если таковая
функция там есть или NULL, если расширение не поддерживается.</p>

<h2>Визуализация на битовой карте</h2>

<p class=text align=left style='text-align:left'>Win32 включает несколько
функций для выделения и освобождения памяти под битовые карты, на которые
визуализация OpenGL может производиться непосредственно. <b>CreateDIBBitmap()</b>
создает зависимую от устройства битовую карту (Device Dependent Bitmap – DDB)
из независимой от устройства битовой карты (Device Independent Bitmap – DIB). <b>CreateDibSection()</b>
создает независимую от устройства битовую карту, на которую приложение может
писать непосредственно. Когда вы закончите работу с картой, вы можете
освободить память с помощью <b>DeleteObject()</b>.</p>

<h2>Синхронизация исполнения</h2>

<p class=text align=left style='text-align:left'>Если вы хотите комбинировать
визуализацию GDI и OpenGL, имейте в виду, что в Win32 не функций аналогичных <b>glXWaitGL()</b>,
<b>glXWaitX()</b> или <b>pglWaitGL()</b>. Хотя <b>glXWaitGL()</b> отсутствует в
Win32, вы можете добиться того же эффекта с помощью <b>glFinish()</b>, которая
заставляет приложение ждать, когда исполнятся все ожидающие команды OpenGL или <b>GdiFlush()</b>,
которая заставляет приложение ждать, когда завершаться все ожидающие функции
GDI.</p>

<h2>Переключение буферов</h2>

<p class=text align=left style='text-align:left'>Для окон с двойной
буферизацией передний и задний буферы могут быть переключены с помощью <b>SwapBuffers()</b>
или <b>wglSwapLayerBuffers()</b> последняя используется для оверлеев.</p>

<h2>Управление цветовой палитрой</h2>

<p class=text align=left style='text-align:left'>Для доступа к цветовой палитре
стандартных (не оверлейных) битовых поверхностей используйте стандартные
функции GDI для установки вхождений в палитру. Для оверлеев используйте <b>wglRealizeLayerPalette()</b>,
которая отображает вхождения их палитры индексного слоя на физическую палитру
или инициализирует палитру RGBA слоя. <b>wglGetLayerPaletteEntries()</b> и <b>wglSetLayerPaletteEntries()</b>
используются для установки и получения вхождений в цветовую палитру слоев.</p>

<h2>Использование растрового или векторного шрифта</h2>

<p class=text align=left style='text-align:left'>В WGL есть две функции <b>wglUseFontBitmaps()</b>
и <b>wglUseFontOutlines()</b>, для конвертирования системных шрифтов в формы
пригодные для использования в OpenGL. Обе функции строят списки отображения для
каждого символа запрошенного шрифта и его размера.</p>

<h2>Прототипы WGL</h2>

<h2>Инициализация</h2>

<p class=text align=left style='text-align:left'>Получить информацию о версии:</p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>BOOL <b>GetVersion</b> (LPOSVERSIONINFO <i>lpVersionInformation</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>BOOL <b>GetVersionEx</b> (LPOSVERSIONINFO <i>lpVersionInformation</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Выбор<span style='mso-ansi-language:
EN-US'> </span>формата<span style='mso-ansi-language:EN-US'> </span>пикселей<span
lang=EN-US style='mso-ansi-language:EN-US'>:<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>int <b>ChoosePixelFormat</b> (HDC <i>hdc</i>,
CONST PIXELFORMATDESCRIPTOR *<i>ppfd</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>BOOL <b>SetPixelFormat</b> (HDC <i>hdc</i>,
CONST PIXELFORMATDESCRIPTOR *<i>ppfd</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>int <b>DescribePixelFormat</b> (HDC&nbsp; <i>hdc</i>,&nbsp;
int&nbsp; <i>iPixelFormat</i>,&nbsp; UINT&nbsp; <i>nBytes</i>,
LPPIXELFORMATDESCRIPTOR&nbsp; <i>ppfd</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>BOOL <b>wglDescribeLayerPlane</b> (HDC&nbsp; <i>hdc</i>,&nbsp;
int&nbsp; <i>iPixelFormat</i>, int&nbsp; <i>iLayerPlane</i>,&nbsp; UINT&nbsp; <i>nBytes</i>,
LPLAYERPLANEDESCRIPTOR <i>plpd</i>);<o:p></o:p></span></p>

<h2>Управление визуализацией</h2>

<p class=text align=left style='text-align:left'>Создание и опрос контекстов
устройства OpenGL:</p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>HGLRC <b>wglCreateContext</b> (HDC hdc);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>HGLRC <b>wglCreateLayerContext</b> (HDC hdc,
int iLayerPlane);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>BOOL <b>wglShareLists</b> (HGLRC hglrc1, HGLRC
hglrc2);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>BOOL <b>wglDeleteContext</b> (HGLRC hglrc);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>BOOL <b>wglCopyContext</b> (HGLRC&nbsp;
hglrcSrc, HGLRC&nbsp; hglrcDst, UINT&nbsp; mask);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>BOOL <b>wglMakeCurrent</b> (HDC hdc, HGLRC
hglrc);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>HGLRC <b>wglGetCurrentContext</b> (void);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>HDC <b>wlgGetCurrentDC</b> (void);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Доступ<span style='mso-ansi-language:
EN-US'> </span>к<span style='mso-ansi-language:EN-US'> </span>функциям<span
style='mso-ansi-language:EN-US'> </span>расширений<span lang=EN-US
style='mso-ansi-language:EN-US'>:<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>PROC <b>wglGetProcAddress</b> (LPCSTR <i>lpszProc</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Создание<span
style='mso-ansi-language:EN-US'> </span>битовых<span style='mso-ansi-language:
EN-US'> </span>карт<span lang=EN-US style='mso-ansi-language:EN-US'>:<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>HBITMAP <b>CreateDIBitmap</b> (HDC <i>hdc</i>,
CONST BITMAPINFOHEADER *<i>lpbmih</i>, DWORD <i>fdwInit</i>, CONST VOID *<i>lpbInit</i>,
CONST BITMAPINFO *<i>lpbmi</i>, UINT <i>fuUsage</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>HBITMAP <b>CreateDIBSection</b>(HDC <i>hdc</i>,
CONST BITMAPINFO *<i>pbmi</i>, UINT <i>iUsage</i>, VOID **<i>ppvBits</i>,
HANDLE <i>hSection</i>, DWORD <i>dwOffset</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>BOOL <b>DeleteObject</b>
(HGDIOBJ <i>hObject</i>);</p>

<p class=text align=left style='text-align:left'>Поменять местами передний и
задний буферы:</p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>BOOL <b>SwapBuffers</b> (HDC <i>hdc</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>BOOL <b>wglSwapLayerBuffers</b> (HDC <i>hdc</i>,
UINT <i>fuPlanes</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Управление цветовой палитрой
для оверлеев:</p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>int <b>wglGetLayerPaletteEntries</b> (HDC&nbsp;
<i>hdc</i>, int <i>iLayerPlane</i>, int&nbsp; <i>iStart</i>, int&nbsp; <i>cEntries</i>,
CONST COLORREF *<i>pcr</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>int <b>wglSetLayerPaletteEntries</b> (HDC&nbsp;
<i>hdc</i>, int&nbsp; <i>iLayerPlane</i>, int&nbsp; <i>iStart</i>, int&nbsp; <i>cEntries</i>,
CONST COLORREF *<i>pcr</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>BOOL <b>wglRealizeLayerPalette</b>(HDC&nbsp; <i>hdc</i>,
int&nbsp; <i>iLayerPlane</i>, BOOL <i>bRealize</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'>Использование<span
style='mso-ansi-language:EN-US'> </span>шрифтов<span lang=EN-US
style='mso-ansi-language:EN-US'>:<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>BOOL <b>wglUseFontBitmaps</b> (HDC&nbsp; <i>hdc</i>,
DWORD&nbsp; <i>first</i>, DWORD&nbsp; <i>count</i>, DWORD&nbsp; <i>listBase</i>);<o:p></o:p></span></p>

<p class=text align=left style='text-align:left'><span lang=EN-US
style='mso-ansi-language:EN-US'>BOOL <b>wglUseFontOutlines</b>(HDC&nbsp; <i>hdc</i>,
DWORD&nbsp; <i>first</i>, DWORD&nbsp; <i>count</i>, DWORD&nbsp; <i>listBase</i>,
FLOAT&nbsp; <i>deviation</i>, FLOAT&nbsp; <i>extrusion</i>, int&nbsp; <i>format</i>,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
LPGLYPHMETRICSFLOAT&nbsp; <i>lpgmf</i>); <o:p></o:p></span></p>

<p class=MsoNormal><span style='display:none;mso-hide:all'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-US style='display:none;mso-hide:all;
mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-US style='display:none;mso-hide:all;
mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-US style='display:none;mso-hide:all;
mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-US style='display:none;mso-hide:all;
mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-US style='display:none;mso-hide:all;
mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-US style='display:none;mso-hide:all;
mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-US style='display:none;mso-hide:all;
mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-US style='display:none;mso-hide:all;
mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-US style='display:none;mso-hide:all;
mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-US style='display:none;mso-hide:all;
mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-US style='display:none;mso-hide:all;
mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-US style='display:none;mso-hide:all;
mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-US style='display:none;mso-hide:all;
mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-US style='display:none;mso-hide:all;
mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-US style='display:none;mso-hide:all;
mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-US style='display:none;mso-hide:all;
mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:Verdana;
mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></p>

</div>

</body>

</html>
