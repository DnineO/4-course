<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=win-1251">
</head>
<body text=black bgcolor=white link=blue vlink=blue alink=red>
<link rel=stylesheet type=text/css href=../../1.css>
<font color=red><h2 align=center>Шаг 38 - Quadric-и.</h2></font>
По своей идее <b>OpenGL</b> является базовым уровнем. Как и вокруг любого <b>API</b> вокруг неё существует большое количество различных оболочек для упрощения жизни, начиная от самых простых, типа <b>GLU</b> и заканчивая объектной надстройкой <b>Open Invertor (SGI)</b>, которая к сожалению не является свободно распространяемой. Библиотека <b>GLU</b> входит в стандартную поставку <b>OpenGL</b> и потому ей грех не воспользоваться.
<p>Библиотека имеет целый ряд интересных функций, но на мой взгляд наиболее привлекательное свойство - <b>quadric</b> объекты. Резонный вопрос - что это такое? Ответ прост как и сами объекты - это геометрические фигуры 2-го порядка, т.е. сфера, цилиндр, диск, конус. Рассмотрим пример создания и использования <b>quadric</b> объекта на сфере, остальные примитивы вы сможете попробовать сами.
<p>Итак, классика, создаем проект. Выбросили оттуда все старые вставки.
Добавили в <b>stdafx.h</b>
<pre> #include &lt;GL/glu.h&gt; (если вы еще не сделали этого раньше)</pre>
Теперь объявляем переменную класса <b>C...View</b>:
<pre>
private:
	GLUquadricObj* m_qObj;
</pre>
Переходим в конструктор класса и инициализируем её:
<pre>
CExampleView::CExampleView()
{
	// TODO: add construction code here
	m_qObj = gluNewQuadric();
}
</pre>
Функция <b>gluNewQuadric</b> создает новый объект нужного нам типа (в реальности просто создается указатель на пустую структуру).
<p>Теперь мы можем воспользовать этим указателем и создать нужный нам объект:
<pre>
void CExampleView::OnDraw(CDC* pDC)
{
    CExampleDoc* pDoc = GetDocument();
    ASSERT_VALID(pDoc);

    // TODO: add draw code for native data here
	glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);

	glColor3f(0.0f, 0.5f, 0.5f);
	gluSphere(m_qObj, 1.0f, 10, 10);

	SwapBuffers(pDC->m_hDC);
}
</pre>
Функция <b>gluSphere</b> принимает 4 аргумента, 1-й - это указатель на <b>Quadric</b> объект, 2-й - радиус сферы, 3-й и 4-й - количество узлов, из которых будет строится сфера вокруг оси <b>Z</b> и вдоль оси <b>Z</b> соответственно.
<p>Должно быть не совсем понятно, но попробуйте просто поменять число 10 на 100 и почувствуйте разницу.
<p>Ну и последнее, все <b>Quadric</b> объекты должны быть удалены после работы.
<pre>
CExampleView::~CExampleView()
{
	gluDeleteQuadric(m_qObj);
}
</pre>
Здесь есть одна хитрость. При желании вы можете поставить команду удаления объекта до его использования и при этом все будет работать!!! Этого делать не рекомендуется, т.к. при этом все равно объект отрисуется неправильно. Как выглядит эта "неправильность" - посмотрите сами.
<p>Так же можно попробовать использовать один объект для создания сферы, цилиндра и еще чего-нибудь... но при этом я не гарантирую, что у вас не будет теряться память. Ведь объект представляет собой набор вершин. Что будет если свера имела 1000 узлов, а цилиндр 100? После "перехода" объекта от сферы к цилиндру возможна потеря памяти, необходимой для хранения как минимум 900 вершин. Возможно, что она и не будет теряться, если функция  создания новой фигуры проверяет занятость объекта, корректно все удаляет, а потом создает новую фигуру.
<p>К сожалению документация по <b>GLU</b> умалчивает об этом. Поэтому надежнее всего будет создавать объекты для каждой фигуры и удалять их тогда, когда они уже не нужны.
<p><hr><center><font size=2><a href=prog/38.zip>Загрузить проект</a> | <a href=37.html>Предыдущий шаг</a> | <a href=39.html>Следующий Шаг</a> | <a href=opengl1.html>Оглавление</a></font></center>
<hr><center><font size=2>By <a href="mailto:kirill@scsc.ru@SUBJECT=OpenGLByStep">Kirill V. Ratkin</a>.</center></body></html>
