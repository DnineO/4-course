<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=win-1251">
</head>
<body text=black bgcolor=white link=blue vlink=blue alink=red>
<link rel=stylesheet type=text/css href=../../1.css>
<font color=red><h2 align=center>Шаг 44 - Материалы.</h2></font>
В этом шаге мы посмотрим простенький пример работы с материалами.
<p>Вообще-то понятие материала и источника света - это основа <b>3D</b> графики (да и не только <b>3D</b>, и не только графики ;) ).
<p>Посмотрим каждый их них в отдельности:
<ol>
<li>Свет
<ul><li>может быть рассеяным, параллельно направленым, прожектором
<li>может излучаться в определенной длинне волны, например, только красный спектр
</ul>
<li>Материал
<ul><li>обладает различными оптическими свойствами, т.е. может рассеивать, пропускать, отражать или поглащать свет определенной длины волны
<li>предмет из определенного материала может быть покрашен определенной краской
</ol>
Комбинаций свойств материала, источника света и окраски объекта может быть множество.
В <a href=42.html>шаге 42</a> мы задавали интенсивность источника света. Делали это так:
<pre>	GLfloat			light1_Intensity[4] = {1.0f, 1.0f, 1.0f, 1.0f};</pre>
Попробуйте теперь уменьшить красную составляющую на 1/2. Что получилось увидите сами.
Объяснение простое. На источник света как бы наложен фильтр, который пропускает только свет определенного спектра.
<p>Такая ситуация как предыдущая в природе случается редко. Как правило мы сталкиваемся с тем, что источник света белый (или близкий к нему, т.е. дневной свет), а вот материалы имеют разные свойства и потому мы видим их как бы определенного цвета (если они не окрашены). Пример - кирпич, он не крашенный, но имеет оранжевый цвет (я даже задумался ... цвет кирпича-то оранжевый? Наверное да, но в любом случае, правильный ответ - цвет зависит от свойств материала этого кирпича)
<p>Вот теперь посмотрим тот же пример, но уже менять будем не свойства источника света, а свойства материала объекта. Для начала 2 глобальных переменных:
<pre>
GLuint			m_lstCube;
GLfloat			m_matDiffuse[]	= {0.0f, 0.0f, 0.0f};
</pre>
Первая это идентификатор списка, в котором будет содержаться куб. Второй - свойства материала рассеивать свет.
Каждый элемент массива определяет рассеивает ли этот материал определенную длину волны света.
<p>Теперь зададим это свойство:
<pre>
	glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, 0);
	glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, m_matDiffuse);
</pre>
Первая команда определяет так называемую модель освещения. Первый параметр может принимать два значения:
<b>GL_LIGHT_MODEL_TWO_SIDE</b> и <b>GL_LIGHT_MODEL_LOCAL_VIEWER</b>. Первый определяет будет ли освещение расчитываться только для внешних граней или и для внешних и для внутренних, а второй -  определяет как будет расчитываться угол отражения. Второй параметр задает значение для первого. Вторая команда собственно включает нам то самое свойство материала, которое мы ранее определили в массиве.
<p>Вот и все. Свойства материала установлены, источник света включен. Все работает.
Просто ради наглядности я добавил в обработчик от клавиатуры <b>WM_KEYDOWN</b> обработчики от кнопочек <b>r,g,b</b>.
<p>Нажимая на них можно изименять свойство материала рассеивать ту или иную составляющую света.
<pre>	case WM_KEYDOWN:
		if(wParam == VK_ESCAPE) SendMessage(hWnd, WM_CLOSE, 0, 0);
		if(wParam == 82)	// r
		{
			if(red&lt;=1.0f)
				red += 0.1f;
			else
				red = 0.0f;
		}
		if(wParam == 71)	// g
		{
			if(green &lt;= 1.0f)
				green += 0.1f;
			else
				green += 0.0f;
		}
		if(wParam == 66)	// b
		{
			if(blue &lt;= 1.0f)
				blue += 0.1f;
			else
				blue = 0.0f;
		}

		if(wParam == 76)	// l (можно отключить и включить источник света)
		{
			if(light)
			{
				light=FALSE;
				glDisable(GL_LIGHTING);
				glDisable(GL_LIGHT0);
			}
			else
			{
				light=TRUE;
				glEnable(GL_LIGHTING);
				glEnable(GL_LIGHT0);
			}
		}

		if(wParam == 67)	// c (можно включить или выключить окраску объекта)
		{
			if(color)
			{
				color=FALSE;
				glEnable(GL_COLOR_MATERIAL);
			}
			else
			{
				color=TRUE;
				glDisable(GL_COLOR_MATERIAL);
			}
		}

		m_matDiffuse[0] = red;
		m_matDiffuse[1] = green;
		m_matDiffuse[2] = blue;
		glMaterialfv(GL_FRONT, GL_DIFFUSE, m_matDiffuse);

		break;
</pre>
И еще одна маленькая деталь. Я немного поменял аргументы в команде установки вида:
<pre>
GLvoid Resize(GLsizei w, GLsizei h)
{
	if(w&gt;=h)
		glViewport ((w-h)/2, 0, (GLsizei) h, (GLsizei) h); 
	if(w&lt;h)
		glViewport (0, (h-w)/2, (GLsizei) w, (GLsizei) w); 

	glMatrixMode (GL_PROJECTION);
	glLoadIdentity();
	glFrustum (-1, 1, -1, 1, 4, 15);
	glMatrixMode (GL_MODELVIEW);
	glLoadIdentity();

 	glTranslatef(0.0, 0.0, -12.0);
	glRotatef(30.0, 1.0, 0.0, 0.0);
	glRotatef(70.0, 0.0, 1.0, 0.0);
}
</pre>
Теперь куб это действительно куб, а не что-то параллелепипедное.
<p><b>P.S.</b> Забыл один небольшой, но важный момент. В тексте я писал слово рассеивать, очень хотелось написать слово
отражать, но дело в том, что слово <b>diffuse</b> действительно переводится как рассеивать. По логике работы приложение,
нажимая, например, на букву "<b>r</b>" мы как бы говорим <b>OpenGL</b>-ю, что наш материал НЕ БУДЕТ рассеиваить красный свет.
У материала есть так же свойство отражения света, т.е. как бы качество полировки поверхности, поэтому не стоит
путать <b>diffuse</b> со <b>specular</b>, но об этом в следующем шаге.

<p><hr><center><font size=2><a href=prog/44.zip>Загрузить проект</a> | <a href=43.html>Предыдущий шаг</a> | <a href=45.html>Следующий Шаг</a> | <a href=opengl1.html>Оглавление</a></font></center>
<hr><center><font size=2>By <a href="mailto:kirill@scsc.ru@SUBJECT=OpenGLByStep">Kirill V. Ratkin</a>.</center></body></html>
