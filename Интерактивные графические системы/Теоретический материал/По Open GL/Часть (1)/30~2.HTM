<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=win-1251">
</head>
<body text=black bgcolor=white link=blue vlink=blue alink=red>
<link rel=stylesheet type=text/css href=../../1.css>
<font color=red><h2 align=center>Шаг 30 - Построение в пространстве.</h2></font>
В этом примере мы посмотрим на то, как установить параметры вида в 3-х мерной системе координат.
<p>Чтобы не быть голословным я предлагаю скомпилить и запустить пример. Разок, другой нажать левую кнопку мыши, а потом раз 9-10 правую кнопку. Что получится вы увидите сами. А вот почему ... сейчас посмотрим. И так функция <b>OnDraw(...)</b> теперь имеет такой вид:
<pre>
void CExampleView::OnDraw(CDC* pDC)
{
    CRect clientRect;

    CExampleDoc* pDoc = GetDocument();
    ASSERT_VALID(pDoc);

    // TODO: add draw code for native data here
    GetClientRect(&clientRect);
    glViewport(0, 0, clientRect.right, clientRect.bottom);

	glPushMatrix();
	glFrustum (-1, 1, -1, 1, 3, 10);

	glTranslatef(0.0, 0.0, -5.0);

	glClearColor (0.5, 0.5, 0.75, 1.0);
	glClear (GL_COLOR_BUFFER_BIT);

	glColor3f (1.0, 0.0, 0.5);
	glBegin (GL_TRIANGLES);
		glVertex3f (-1, -1, 0);
		glVertex3f (-1, 1, 0);
		glVertex3f (1, 0, m_Height);
	glEnd();
	glPopMatrix();

	SwapBuffers(pDC->m_hDC);
}
</pre>
Переменная <b>m_Height</b> задает глубину одной из вершин треугольника, она как обычно объявлена как член класса <b>C...View</b> и изменяется в двух обработчиках <b>OnLButtonDown(...)</b> и <b>OnRButtonDown(...)</b>. Но главное в функции <b>OnDraw(...)</b>.
<p>Основная последовательность команд заключена между командами <b>glPushMatrix</b>, <b>glPopMatrix</b>. Если не делать этого, то изменения пространства в предыдущем вызове <b>OnDraw</b> будут влиять на преобразования в следующем вызове.
<p>В примере появилась новая команда <b>glFurstum</b>. Эта команда задает как бы параллелепипед в пространстве, в котором будет отображаться наш треугольник. Если треугольник выходит за пределы этого пространства, то он автоматически отсекается (что и происходит если подольше понажимать на правую кнопку).
<p>Как вы помните из курса начертательной геометрии, то существует много видов проекцирования <b>3D</b> координат в <b>2D</b>.
<p>В "чистом" варианте <b>OpenGL</b> поддерживает 2 вида проекции: Ортогональную и Перспективную. Разумеется никто не запрещает вам пользоваться другими видами проекций, но для этого вам придется вручную загрузить матрицу проекции. Позже мы посмотрим как это можно сделать.
<p>Параметры <b>glFurstum</b> вполне очевидны: левая, правая, нижняя, верхняя, ближняя, дальняя плоскости отсечения. Последние 2 параметра задают бижнее и дальнее расстояние от глаз наблюдателя.
<p>Если вы посмотрите <b>MSDN</b> по команде <b>glFurstum</b>, то обнаружите, что второй с конца параметр, задающий заднюю плоскость отсечения должен быть не нулевым и положительным. Это важно и об этом не стоит забывать. Связано это с некоторыми формулами <b>OpenGL</b>, в которых просходит умножение или деление <b>far</b> на <b>near</b> (см. <b>MSDN</b>)
<p>И последнее, командой <b>glTranslate</b> мы отодвигаем систему координат на 5 единиц в глубь экрана. Попробуйте сдвинуть на значение меньше 3-х, больше 10, на 3 и на 10.
<p><hr><center><font size=2><a href=prog/30.zip>Загрузить проект</a> | <a href=29.html>Предыдущий шаг</a> | <a href=31.html>Следующий Шаг</a> | <a href=opengl1.html>Оглавление</a></font></center>
<hr><center><font size=2>By <a href="mailto:kirill@scsc.ru@SUBJECT=OpenGLByStep">Kirill V. Ratkin</a>.</center></body></html>
