<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0045)http://www.rsdn.ru/article/opengl/ogltut2.xml -->
<HTML><HEAD><TITLE>Графическая библиотека OpenGL</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1251">
<META content="Учебное пособие по OpenGL." name=description>
<META content=index,nofollow name=robots><LINK href="ogltut2.files/article.css" 
type=text/css rel=stylesheet>
<SCRIPT language=javascript src="ogltut2.files/rsdn.js">
    </SCRIPT>

<SCRIPT language=javascript src="ogltut2.files/Forum.js">
    </SCRIPT>

<META content="MSHTML 6.00.2800.1106" name=GENERATOR></HEAD>
<BODY marginheight="20" marginwidth="20"><!-- SpyLOG f:1211 -->
<SCRIPT language=javascript><!--
Mu="u1358.84.spylog.com";Md=document;Mnv=navigator;Mp=1;
Mn=(Mnv.appName.substring(0,2)=="Mi")?0:1;Mrn=Math.random();
Mt=(new Date()).getTimezoneOffset();
Mz="p="+Mp+"&rn="+Mrn+"&t="+Mt;
My="";
My+="<a href='http://"+Mu+"/cnt?cid=135884&f=3&p="+Mp+"&rn="+Mrn+"' target=_blank>";
My+="<img src='http://"+Mu+"/cnt?cid=135884&"+Mz+"&r1="+escape(Md.referrer)+"&r="+escape(parent.document.referrer)+"&pg="+escape(window.location.href)+"' border=0 width=1 height=1 alt=' '>";
My+="</a>";Md.write(My);//--></SCRIPT>
<NOSCRIPT><A href="http://u1358.84.spylog.com/cnt?cid=135884&amp;f=3&amp;p=1" 
target=_blank><IMG height=1 alt=" " src="ogltut2.files/cnt.gif" width=1 
border=0> </A></NOSCRIPT><!-- SpyLOG --><!-- HotLog -->
<SCRIPT language=javascript>
hotlog_js="1.0";hotlog_d=document; hotlog_n=navigator;hotlog_rn=Math.random();
hotlog_n_n=(hotlog_n.appName.substring(0,3)=="Mic")?0:1;
hotlog_r=""+hotlog_rn+"&s=21251&r="+escape(hotlog_d.referrer)+"&pg="+
escape(window.location.href);
hotlog_d.cookie="hotlog=1"; hotlog_r+="&c="+(hotlog_d.cookie?"Y":"N");
hotlog_d.cookie="hotlog=1; expires=Thu, 01-Jan-70 00:00:01 GMT"</SCRIPT>

<SCRIPT language=javascript1.1>
hotlog_js="1.1";hotlog_r+="&j="+(navigator.javaEnabled()?"Y":"N")</SCRIPT>

<SCRIPT language=javascript1.2>
hotlog_js="1.2";hotlog_s=screen;
hotlog_r+="&wh="+hotlog_s.width+'x'+hotlog_s.height+"&px="+((hotlog_n_n==0)?
hotlog_s.colorDepth:hotlog_s.pixelDepth)</SCRIPT>

<SCRIPT language=javascript1.3>hotlog_js="1.3"</SCRIPT>

<SCRIPT language=javascript>hotlog_r+="&js="+hotlog_js;
hotlog_d.write("<img src=\"http://hit2.hotlog.ru/cgi-bin/hotlog/count?"+
hotlog_r+"&\" border=0 width=1 height=1 alt=' '>")</SCRIPT>
<NOSCRIPT><IMG height=1 alt=" " src="ogltut2.files/count" width=1 border=0> 
</NOSCRIPT><!-- /HotLog --><!--begin of Rambler's Top100 code --><A 
href="http://top100.rambler.ru/top100/"><IMG height=1 alt="" 
src="ogltut2.files/top100.gif" width=1 border=0></A> <!--end of Top100 code--><!--Rating@Mail.ru COUNTER-->
<SCRIPT language=JavaScript><!--
d=document;a='';a+=';r='+escape(d.referrer)
js=10//--></SCRIPT>

<SCRIPT language=JavaScript1.1><!--
a+=';j='+navigator.javaEnabled()
js=11//--></SCRIPT>

<SCRIPT language=JavaScript1.2><!--
s=screen;a+=';s='+s.width+'*'+s.height
a+=';d='+(s.colorDepth?s.colorDepth:s.pixelDepth)
js=12//--></SCRIPT>

<SCRIPT language=JavaScript1.3><!--
js=13//--></SCRIPT>

<SCRIPT language=JavaScript><!--
d.write('<img src="http://top.list.ru/counter'+
'?id=555384;js='+js+a+';rand='+Math.random()+
'" height=1 width=1>')
if(js>11)d.write('<'+'!-- ')//--></SCRIPT>
<NOSCRIPT><IMG height=1 alt="" src="ogltut2.files/counter.gif" 
width=1></NOSCRIPT>
<SCRIPT language=JavaScript><!--
if(js>11)d.write('--'+'>')//--></SCRIPT>
<!--/COUNTER--> 
<TABLE 
style="BORDER-RIGHT: #9daabd 1px solid; PADDING-RIGHT: 5px; BORDER-TOP: #9daabd 1px solid; PADDING-LEFT: 5px; FONT-WEIGHT: bold; PADDING-BOTTOM: 0px; BORDER-LEFT: #9daabd 1px solid; COLOR: #646464; PADDING-TOP: 0px; BORDER-BOTTOM: #9daabd 1px solid; FONT-FAMILY: verdana; BACKGROUND-COLOR: #e6e6e6" 
cellSpacing=0 width="100%" border=0 celpadding="2">
  <TBODY>
  <TR>
    <TD noWrap><FONT style="FONT-WEIGHT: normal" size=1>
      <SCRIPT language=javascript src="ogltut2.files/shMenu.js" 
      type=text/javascript></SCRIPT>
      </FONT></TD>
    <TD noWrap align=right width="100%"><FONT size=2>&nbsp;<A 
      title="Версия для печати" 
      href="http://www.rsdn.ru/article/opengl/ogltut2.xml?print" 
      target=_blank><IMG height=14 src="ogltut2.files/printer2.gif" width=16 
      align=absMiddle border=0></A>&nbsp;&nbsp;<A 
      title="Перейти к обсуждению статьи" 
      href="http://www.rsdn.ru/forum/?mid=338827" target=_self><FONT 
      color=#646464 size=1> Сообщений </FONT><FONT 
      color=black>0</FONT></A>&nbsp;&nbsp;<A title="Перейти к обсуждению статьи" 
      href="http://www.rsdn.ru/forum/?mid=338827" target=_self><IMG height=14 
      src="ogltut2.files/showfr.gif" width=18 align=absMiddle 
      border=0></A>&nbsp;<A 
      href="http://www.rsdn.ru/Forum/RateList.aspx?mid=338827"><FONT 
      color=#646464><FONT size=1> Оценка </FONT><FONT 
      color=black>225</FONT></FONT></A>&nbsp;&nbsp; <A 
      title="Добавить в избранное" 
      href="http://www.rsdn.ru/Users/Private/AddFav.aspx?mid=338827" 
      target=_blank><IMG onclick="AddFav(338827);return false;" height=14 
      src="ogltut2.files/fav.gif" align=absMiddle border=0></A>&nbsp;&nbsp;<A 
      title="Подписка на сообщения" href="javascript:SubMsg(338827)"><IMG 
      class=i height=14 src="ogltut2.files/sub.gif" width=18 align=absMiddle 
      border=0></A>&nbsp;&nbsp;&nbsp;<FONT size=1>Оценить </FONT><A title=+1 
      href="http://www.rsdn.ru/forum/Private/Rate.aspx?mid=338827&amp;rate=-3" 
      target=_blank><IMG onclick="RateMsg(338827,-3);return false;" height=14 
      src="ogltut2.files/n11.gif" width=18 align=absMiddle border=0></A><A 
      title=Интересно 
      href="http://www.rsdn.ru/forum/Private/Rate.aspx?mid=338827&amp;rate=1" 
      target=_blank><IMG onclick="RateMsg(338827,1);return false;" height=14 
      src="ogltut2.files/n1.gif" width=18 align=absMiddle border=0></A><A 
      title=Спасибо 
      href="http://www.rsdn.ru/forum/Private/Rate.aspx?mid=338827&amp;rate=2" 
      target=_blank><IMG onclick="RateMsg(338827,2);return false;" height=14 
      src="ogltut2.files/n2.gif" width=18 align=absMiddle border=0></A><A 
      title=Супер 
      href="http://www.rsdn.ru/forum/Private/Rate.aspx?mid=338827&amp;rate=3" 
      target=_blank><IMG onclick="RateMsg(338827,3);return false;" height=14 
      src="ogltut2.files/n3.gif" width=18 align=absMiddle border=0></A><A 
      title="Удалить оценку" 
      href="http://www.rsdn.ru/forum/Private/Rate.aspx?mid=338827&amp;rate=-1" 
      target=_blank><IMG onclick="RateMsg(338827,-1);return false;" height=14 
      src="ogltut2.files/nx.gif" width=18 align=absMiddle border=0></A><A 
      title=Согласен 
      href="http://www.rsdn.ru/forum/Private/Rate.aspx?mid=338827&amp;rate=-4" 
      target=_blank><IMG onclick="RateMsg(338827,-4);return false;" height=14 
      src="ogltut2.files/np.gif" width=18 align=absMiddle border=0></A><A 
      title="Не согласен" 
      href="http://www.rsdn.ru/forum/Private/Rate.aspx?mid=338827&amp;rate=0" 
      target=_blank><IMG onclick="RateMsg(338827,0);return false;" 
      src="ogltut2.files/nm.gif" width=18 align=absMiddle border=0 
      eight="14px"></A>&nbsp; </FONT></TD></TR></TBODY></TABLE>
<SCRIPT language=javascript src="ogltut2.files/orfo.js" 
type=text/javascript></SCRIPT>

<SCRIPT language=javascript>
function ToggleCode(id)
{
	el=document.getElementById(id);
	img=document.getElementById("img"+id);
	if(el.style.display=="none")
	{
	  img.src="/images/ls2.gif";
	  el.style.display="";
	}
	else
	{
	img.src="/images/ls1.gif";
	el.style.display="none";
	}
}
</SCRIPT>

<H1>Графическая библиотека OpenGL<BR><SPAN class=subtitle>методическое 
пособие</SPAN></H1>
<H5><SPAN class=title>Авторы: </SPAN><SPAN class=value><A 
title="Отправить письмо" href="mailto:ymb@graphics.cs.msu.su" target=_blank>Юрий 
Баяковский</A><BR><A title="Отправить письмо" 
href="mailto:ignatenko@graphics.cs.msu.su" target=_blank>Игнатенко 
Алексей</A><BR><A title="Отправить письмо" href="mailto:frolov_an@mail.ru" 
target=_blank>Фролов Антон</A></SPAN><BR><SPAN class=title>Источник: 
</SPAN><SPAN class=value><A title="Открыть в новом окне" 
href="http://graphics.cs.msu.su/" target=_blank>Лаборатория компьютерной графики 
при ВМиК МГУ</A></SPAN></H5>
<H6><SPAN class=title>Опубликовано: </SPAN><SPAN 
class=value>17.09.2002</SPAN><BR><SPAN class=title>Исправлено: </SPAN><SPAN 
class=value>15.01.2004</SPAN><BR><SPAN class=title>Версия текста: </SPAN><SPAN 
class=value>2.0</SPAN></H6>
<DIV style="MARGIN-LEFT: 2em"><A 
href="http://www.rsdn.ru/article/opengl/ogltut2.xml#XSLTPART141120120"><B>Введение</B></A><BR>
<DIV style="MARGIN-LEFT: 2em"></DIV><A 
href="http://www.rsdn.ru/article/opengl/ogltut2.xml#XSLTPART143120120"><B>Основы 
OpenGL</B></A><BR>
<DIV style="MARGIN-LEFT: 2em"><A 
href="http://www.rsdn.ru/article/opengl/ogltut2.xml#XSLTSECTION122143120120">Основные 
возможности</A><BR><A 
href="http://www.rsdn.ru/article/opengl/ogltut2.xml#XSLTSECTION124143120120">Интерфейс 
OpenGL</A><BR><A 
href="http://www.rsdn.ru/article/opengl/ogltut2.xml#XSLTSECTION126143120120">Архитектура 
OpenGL</A><BR><A 
href="http://www.rsdn.ru/article/opengl/ogltut2.xml#XSLTSECTION128143120120">Синтаксис 
команд</A><BR><A 
href="http://www.rsdn.ru/article/opengl/ogltut2.xml#XSLTSECTION130143120120">Пример 
приложения</A><BR></DIV><A 
href="http://www.rsdn.ru/article/opengl/ogltut2.xml#XSLTPART145120120"><B>Рисование 
геометрических объектов</B></A><BR>
<DIV style="MARGIN-LEFT: 2em"><A 
href="http://www.rsdn.ru/article/opengl/ogltut2.xml#XSLTSECTION122145120120">Процесс 
обновления изображения</A><BR><A 
href="http://www.rsdn.ru/article/opengl/ogltut2.xml#XSLTSECTION124145120120">Вершины 
и примитивы</A><BR><A 
href="http://www.rsdn.ru/article/opengl/ogltut2.xml#XSLTSECTION126145120120">Операторные 
скобки glBegin / glEnd</A><BR><A 
href="http://www.rsdn.ru/article/opengl/ogltut2.xml#XSLTSECTION128145120120">Дисплейные 
списки</A><BR><A 
href="http://www.rsdn.ru/article/opengl/ogltut2.xml#XSLTSECTION130145120120">Массивы 
вершин</A><BR></DIV><A 
href="http://www.rsdn.ru/article/opengl/ogltut2.xml#XSLTPART147120120"><B>Преобразования 
объектов</B></A><BR>
<DIV style="MARGIN-LEFT: 2em"><A 
href="http://www.rsdn.ru/article/opengl/ogltut2.xml#XSLTSECTION130147120120">Работа 
с матрицами</A><BR><A 
href="http://www.rsdn.ru/article/opengl/ogltut2.xml#XSLTSECTION132147120120">Модельно-Видовые 
преобразования</A><BR><A 
href="http://www.rsdn.ru/article/opengl/ogltut2.xml#XSLTSECTION134147120120">Проекции</A><BR><A 
href="http://www.rsdn.ru/article/opengl/ogltut2.xml#XSLTSECTION136147120120">Область 
вывода</A><BR></DIV><A 
href="http://www.rsdn.ru/article/opengl/ogltut2.xml#XSLTPART149120120"><B>Материалы 
и освещение</B></A><BR>
<DIV style="MARGIN-LEFT: 2em"><A 
href="http://www.rsdn.ru/article/opengl/ogltut2.xml#XSLTSECTION124149120120">Модель 
освещения</A><BR><A 
href="http://www.rsdn.ru/article/opengl/ogltut2.xml#XSLTSECTION126149120120">Спецификация 
материалов</A><BR><A 
href="http://www.rsdn.ru/article/opengl/ogltut2.xml#XSLTSECTION128149120120">Описание 
источников света</A><BR><A 
href="http://www.rsdn.ru/article/opengl/ogltut2.xml#XSLTSECTION130149120120">Создание 
эффекта тумана</A><BR></DIV><A 
href="http://www.rsdn.ru/article/opengl/ogltut2.xml#XSLTPART151120120"><B>Текстурирование</B></A><BR>
<DIV style="MARGIN-LEFT: 2em"><A 
href="http://www.rsdn.ru/article/opengl/ogltut2.xml#XSLTSECTION136151120120">Подготовка 
текстуры</A><BR><A 
href="http://www.rsdn.ru/article/opengl/ogltut2.xml#XSLTSECTION138151120120">Наложение 
текстуры на объекты</A><BR><A 
href="http://www.rsdn.ru/article/opengl/ogltut2.xml#XSLTSECTION140151120120">Текстурные 
координаты</A><BR></DIV><A 
href="http://www.rsdn.ru/article/opengl/ogltut2.xml#XSLTPART153120120"><B>Операции 
с пикселями</B></A><BR>
<DIV style="MARGIN-LEFT: 2em"><A 
href="http://www.rsdn.ru/article/opengl/ogltut2.xml#XSLTSECTION144153120120">Смешивание 
изображений. Прозрачность</A><BR><A 
href="http://www.rsdn.ru/article/opengl/ogltut2.xml#XSLTSECTION146153120120">Буфер-накопитель</A><BR><A 
href="http://www.rsdn.ru/article/opengl/ogltut2.xml#XSLTSECTION148153120120">Буфер 
маски</A><BR><A 
href="http://www.rsdn.ru/article/opengl/ogltut2.xml#XSLTSECTION150153120120">Управление 
растеризацией</A><BR></DIV><A 
href="http://www.rsdn.ru/article/opengl/ogltut2.xml#XSLTPART155120120"><B>Приемы 
работы с OpenGL</B></A><BR>
<DIV style="MARGIN-LEFT: 2em"><A 
href="http://www.rsdn.ru/article/opengl/ogltut2.xml#XSLTSECTION124155120120">Устранение 
ступенчатости</A><BR><A 
href="http://www.rsdn.ru/article/opengl/ogltut2.xml#XSLTSECTION126155120120">Построение 
теней</A><BR><A 
href="http://www.rsdn.ru/article/opengl/ogltut2.xml#XSLTSECTION128155120120">Зеркальные 
отражения</A><BR></DIV><A 
href="http://www.rsdn.ru/article/opengl/ogltut2.xml#XSLTPART157120120"><B>Оптимизация 
программ</B></A><BR>
<DIV style="MARGIN-LEFT: 2em"><A 
href="http://www.rsdn.ru/article/opengl/ogltut2.xml#XSLTSECTION122157120120">Организация 
приложения</A><BR><A 
href="http://www.rsdn.ru/article/opengl/ogltut2.xml#XSLTSECTION124157120120">Оптимизация 
вызовов OpenGL</A><BR></DIV><A 
href="http://www.rsdn.ru/article/opengl/ogltut2.xml#XSLTPART159120120"><B>Структура 
GLUT-приложения</B></A><BR>
<DIV style="MARGIN-LEFT: 2em"></DIV><A 
href="http://www.rsdn.ru/article/opengl/ogltut2.xml#XSLTPART161120120"><B>Примитивы 
библиотек GLU и GLUT</B></A><BR>
<DIV style="MARGIN-LEFT: 2em"></DIV><A 
href="http://www.rsdn.ru/article/opengl/ogltut2.xml#XSLTPART163120120"><B>Настройка 
приложений OpenGL</B></A><BR>
<DIV style="MARGIN-LEFT: 2em"><A 
href="http://www.rsdn.ru/article/opengl/ogltut2.xml#XSLTSECTION122163120120">Создание 
приложения в среде Borland C++ 5.02</A><BR><A 
href="http://www.rsdn.ru/article/opengl/ogltut2.xml#XSLTSECTION124163120120">Создание 
приложения в среде MS Visual C++ 6.0</A><BR></DIV><A 
href="http://www.rsdn.ru/article/opengl/ogltut2.xml#XSLTPART165120120"><B>Демонстрационные 
программы</B></A><BR>
<DIV style="MARGIN-LEFT: 2em"><A 
href="http://www.rsdn.ru/article/opengl/ogltut2.xml#XSLTSECTION122165120120">Пример 
1: Простое GLUT-приложение</A><BR><A 
href="http://www.rsdn.ru/article/opengl/ogltut2.xml#XSLTSECTION124165120120">Пример 
2: Модель освещения OpenGL</A><BR><A 
href="http://www.rsdn.ru/article/opengl/ogltut2.xml#XSLTSECTION126165120120">Пример 
3: Текстурирование</A><BR></DIV><A 
href="http://www.rsdn.ru/article/opengl/ogltut2.xml#XSLTPART167120120"><B>Примеры 
практических заданий</B></A><BR>
<DIV style="MARGIN-LEFT: 2em"><A 
href="http://www.rsdn.ru/article/opengl/ogltut2.xml#XSLTSECTION122167120120">Cornell 
Box</A><BR><A 
href="http://www.rsdn.ru/article/opengl/ogltut2.xml#XSLTSECTION124167120120">Виртуальные 
часы</A><BR><A 
href="http://www.rsdn.ru/article/opengl/ogltut2.xml#XSLTSECTION126167120120">Интерактивный 
ландшафт</A><BR></DIV><A 
href="http://www.rsdn.ru/article/opengl/ogltut2.xml#XSLTPART169120120"><B>Литература</B></A><BR>
<DIV style="MARGIN-LEFT: 2em"></DIV></DIV>
<H2>Введение<A name=XSLTPART141120120></A></H2>
<P>OpenGL является одним из самых популярных прикладных программных интерфейсов 
(API – Application Programming Interface) для разработки приложений в области 
двумерной и трехмерной графики. </P>
<P>Стандарт OpenGL (Open Graphics Library – открытая графическая библиотека) был 
разработан и утвержден в 1992 году ведущими фирмами в области разработки 
программного обеспечения как эффективный аппаратно-независимый интерфейс, 
пригодный для реализации на различных платформах. Основой стандарта стала 
библиотека IRIS GL, разработанная фирмой Silicon Graphics Inc.</P>
<P>Библиотека насчитывает около 120 различных команд, которые программист 
использует для задания объектов и операций, необходимых для написания 
интерактивных графических приложений.</P>
<P>На сегодняшний день графическая система OpenGL поддерживается большинством 
производителей аппаратных и программных платформ. Эта система доступна тем, кто 
работает в среде Windows, пользователям компьютеров Apple. Свободно 
распространяемые коды системы Mesa (пакет API на базе OpenGL) можно 
компилировать в большинстве операционных систем, в том числе в Linux.</P>
<P>Характерными особенностями OpenGL, которые обеспечили распространение и 
развитие этого графического стандарта, являются:</P>
<UL style="LIST-STYLE-TYPE: square">
  <LI><I>Стабильность. </I>Дополнения и изменения в стандарте реализуются таким 
  образом, чтобы сохранить совместимость с разработанным ранее программным 
  обеспечением. 
  <LI><I>Надежность и переносимость. </I>Приложения, использующие OpenGL, 
  гарантируют одинаковый визуальный результат вне зависимости от типа 
  используемой операционной системы и организации отображения информации. Кроме 
  того, эти приложения могут выполняться как на персональных компьютерах, так и 
  на рабочих станциях и суперкомпьютерах. 
  <LI><I>Легкость применения. </I>Стандарт OpenGL имеет продуманную структуру и 
  интуитивно понятный интерфейс, что позволяет с меньшими затратами создавать 
  эффективные приложения, содержащие меньше строк кода, чем с использованием 
  других графических библиотек. Необходимые функции для обеспечения 
  совместимости с различным оборудованием реализованы на уровне библиотеки и 
  значительно упрощают разработку приложений. </LI></UL>
<P>Наличие хорошего базового пакета для работы с трехмерными приложениями 
упрощает понимание студентами ключевых тем курса компьютерной графики – 
моделирование трехмерных объектов, закрашивание, текстурирование, анимацию и 
т.д. Широкие функциональные возможности OpenGL служат хорошим фундаментом для 
изложения теоретических и практических аспектов предмета.</P>
<H2>Основы OpenGL<A name=XSLTPART143120120></A></H2>
<H3>Основные возможности<A name=XSLTSECTION122143120120></A></H3>
<P>Описывать возможности OpenGL мы будем через функции его библиотеки. Все 
функции можно разделить на пять категорий:</P>
<UL style="LIST-STYLE-TYPE: square">
  <LI><I>Функции описания примитивов</I> определяют объекты нижнего уровня 
  иерархии (примитивы), которые способна отображать графическая подсистема. В 
  OpenGL в качестве примитивов выступают точки, линии, многоугольники и т.д. 
  <LI><I>Функции описания источников света </I>служат для описания положения и 
  параметров источников света, расположенных в трехмерной сцене. 
  <LI><I>Функции задания атрибуто</I>в. С помощью задания атрибутов программист 
  определяет, <I>как</I> будут выглядеть на экране отображаемые объекты. Другими 
  словами, если с помощью примитивов определяется, <I>что</I> появится на 
  экране, то атрибуты определяют <I>способ</I> вывода на экран. В качестве 
  атрибутов OpenGL позволяет задавать цвет, характеристики материала, текстуры, 
  параметры освещения. 
  <LI><I>Функции визуализации</I> позволяет задать положение наблюдателя в 
  виртуальном пространстве, параметры объектива камеры. Зная эти параметры, 
  система сможет не только правильно построить изображение, но и отсечь объекты, 
  оказавшиеся вне поля зрения. 
  <LI>Набор <I>функций геометрических преобразований </I>позволяют программисту 
  выполнять различные преобразования объектов – поворот, перенос, 
  масштабирование. </LI></UL>
<P>При этом OpenGL может выполнять дополнительные операции, такие как 
использование сплайнов для построения линий и поверхностей, удаление невидимых 
фрагментов изображений, работа с изображениями на уровне пикселей и т.д.</P>
<H3>Интерфейс OpenGL<A name=XSLTSECTION124143120120></A></H3>
<P>OpenGL состоит из набора библиотек. Все базовые функции хранятся в основной 
библиотеке, для обозначения которой в дальнейшем мы будем использовать 
аббревиатуру <I>GL.</I> Помимо основной, OpenGL включает в себя несколько 
дополнительных библиотек. </P>
<P>Первая из них – <I>библиотека утилит</I> <I>GL</I>(<I>GLU – GL Utility</I>). 
Все функции этой библиотеки определены через базовые функции GL. В состав GLU 
вошла реализация более сложных функций, таких как набор популярных 
геометрических примитивов (куб, шар, цилиндр, диск), функции построения 
сплайнов, реализация дополнительных операций над матрицами и т.п. </P>
<P>OpenGL не включает в себя никаких специальных команд для работы с окнами или 
ввода информации от пользователя. Поэтому были созданы специальные переносимые 
библиотеки для обеспечения часто используемых функций взаимодействия с 
пользователем и для отображения информации с помощью оконной подсистемы. 
Наиболее популярной является библиотека GLUT (GL Utility Toolkit). Формально 
GLUT не входит в OpenGL, но de facto включается почти во все его дистрибутивы и 
имеет реализации для различных платформ. GLUT предоставляет только минимально 
необходимый набор функций для создания OpenGL-приложения. Функционально 
аналогичная библиотека GLX менее популярна. В дальнейшем в этом пособии в 
качестве основной будет рассматриваться GLUT.</P>
<P style="TEXT-ALIGN: center"><IMG src="ogltut2.files/oglimpl.gif"><BR><I 
style="FONT-SIZE: x-small; font-face: verdana">Рис. 1 Организация библиотеки 
OpenGL</I></P>
<P>Кроме того, функции, специфичные для конкретной оконной подсистемы, обычно 
входят в ее прикладной программный интерфейс. Так, функции, поддерживающие 
выполнение OpenGL, есть в составе Win32 API и X Window. На рисунке схематически 
представлена организация системы библиотек в версии, работающей под управлением 
системы Windows. Аналогичная организация используется и в других версиях 
OpenGL.</P>
<H3>Архитектура OpenGL<A name=XSLTSECTION126143120120></A></H3>
<P>Функции OpenGL реализованы в модели клиент-сервер. Приложение выступает в 
роли клиента – оно вырабатывает команды, а сервер OpenGL интерпретирует и 
выполняет их. Сам сервер может находиться как на том же компьютере, на котором 
находится клиент (например, в виде динамически загружаемой библиотеки – DLL), 
так и на другом (при этом может быть использован специальный протокол передачи 
данных между машинами).</P>
<P>GL обрабатывает и рисует в буфере кадра графические <I>примитивы</I> с учетом 
некоторого числа выбранных режимов. Каждый примитив – это точка, отрезок, 
многоугольник и т.д. Каждый режим может быть изменен независимо от других. 
Определение примитивов, выбор режимов и другие операции описываются с помощью 
<I>команд </I>в форме вызовов функций прикладной библиотеки.</P>
<P>Примитивы определяются набором из одной или более <I>вершин </I>(vertex). 
Вершина определяет точку, конец отрезка или угол многоугольника. С каждой 
вершиной ассоциируются некоторые данные (координаты, цвет, нормаль, текстурные 
координаты и т.д.), называемые <I>атрибутами</I>. В подавляющем большинстве 
случаев каждая вершина обрабатывается независимо от других.</P>
<P>С точки зрения архитектуры графическая система OpenGL является конвейером, 
состоящим из нескольких последовательных этапов обработки графических 
данных.</P>
<P>Команды OpenGL всегда обрабатываются в том порядке, в котором они поступают, 
хотя могут происходить задержки перед тем, как проявится эффект от их 
выполнения. В большинстве случаев OpenGL предоставляет непосредственный 
интерфейс, т.е. определение объекта вызывает его визуализацию в буфере 
кадра.</P>
<P>С точки зрения разработчиков, OpenGL – это набор команд, которые управляют 
использованием графической аппаратуры. Если аппаратура состоит только из 
адресуемого буфера кадра, тогда OpenGL должен быть реализован полностью с 
использованием ресурсов центрального процессора. Обычно графическая аппаратура 
предоставляет различные уровни ускорения: от аппаратной реализации вывода линий 
и многоугольников до изощренных графических процессоров с поддержкой различных 
операций над геометрическими данными.</P>
<P style="TEXT-ALIGN: center"><IMG src="ogltut2.files/pipeline.gif"><BR><I 
style="FONT-SIZE: x-small; font-face: verdana">Рис. 2. Функционирование 
конвейера OpenGL</I></P>
<P>OpenGL является прослойкой между аппаратурой и пользовательским уровнем, что 
позволяет предоставлять единый интерфейс на разных платформах, используя 
возможности аппаратной поддержки.</P>
<P>Кроме того, OpenGL можно рассматривать как конечный автомат, состояние 
которого определяется множеством значений специальных переменных и значениями 
текущей нормали, цвета, координат текстуры и других атрибутов и признаков. Вся 
эта информация будет использована при поступлении в графическую систему 
координат вершины для построения фигуры, в которую она входит. Смена состояний 
происходит с помощью команд, которые оформляются как вызовы функций.</P>
<H3>Синтаксис команд<A name=XSLTSECTION128143120120></A></H3>
<P>Определения команд GL находятся в файле gl.h, для включения которого нужно 
написать</P>
<DIV id=XSLTCODE124128143120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>#include</SPAN> &lt;gl/gl.h&gt;
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>Для работы с библиотекой GLU нужно аналогично включить файл glu.h. Версии 
этих библиотек, как правило, включаются в дистрибутивы систем программирования, 
например Microsoft Visual C++ или Borland C++ 5.02.</P>
<P>В отличие от стандартных библиотек, пакет GLUT нужно инсталлировать и 
подключать отдельно. Подробная информация о настройке сред программирования для 
работы с OpenGL дана в Приложении С.</P>
<P>Все команды (процедуры и функции) библиотеки GL начинаются с префикса gl, все 
константы – с префикса GL_. Соответствующие команды и константы библиотек GLU и 
GLUT аналогично имеют префиксы glu (GLU_) и glut (GLUT_)</P>
<P>Кроме того, в имена команд входят суффиксы, несущие информацию о числе и типе 
передаваемых параметров. В OpenGL полное имя команды имеет вид:</P>
<DIV id=XSLTCODE134128143120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE>type <STRONG>glCommand_name[1 2 3 4][b s i f d ub us ui][v]</STRONG>
                   (type1 arg1,…,typeN argN)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>Таким образом, имя состоит из нескольких частей:</P>
<TABLE cellSpacing=2 cellPadding=5 border=0>
  <TBODY>
  <TR>
    <TD><STRONG>Gl</STRONG></TD>
    <TD>это имя библиотеки, в которой описана эта функция: для базовых функций 
      OpenGL, функций из библиотек GLU, GLUT, GLAUX это gl, glu, glut, glaux 
      соответственно</TD></TR>
  <TR>
    <TD><STRONG>Command_name</STRONG></TD>
    <TD>имя команды</TD></TR>
  <TR>
    <TD><STRONG>[1 2 3 4]</STRONG></TD>
    <TD>число аргументов команды</TD></TR>
  <TR>
    <TD><STRONG>[b s i f d ub us ui]</STRONG></TD>
    <TD>тип аргумента: символ b означает тип GLbyte (аналог char в С\С++), 
      символ f – тип GLfloat (аналог float), символ i – тип GLint (аналог int) и 
      так далее. Полный список типов и их описание можно посмотреть в файле 
    gl.h</TD></TR>
  <TR>
    <TD><STRONG>[v]</STRONG></TD>
    <TD>наличие этого символа показывает, что в качестве параметров функции 
      используется указатель на массив значений</TD></TR></TBODY></TABLE>
<P>Символы в квадратных скобках в некоторых названиях не используются. Например, 
команда glVertex2i() описана как базовая в библиотеке OpenGL, и использует в 
качестве параметров два целых числа, а команда glColor3fv() использует в 
качестве параметра указатель на массив из трех вещественных чисел.</P>
<P>Использования нескольких вариантов каждой команды можно частично избежать, 
применяя перегрузку функций языка C++. Но интерфейс OpenGL не рассчитан на 
конкретный язык программирования, и, следовательно, должен быть максимально 
универсален.</P>
<H3>Пример приложения<A name=XSLTSECTION130143120120></A></H3>
<P>Типичная программа, использующая OpenGL, начинается с определения окна, в 
котором будет происходить отображение. Затем создается контекст (клиент) OpenGL 
и ассоциируется с этим окном. Далее программист может свободно использовать 
команды и операции OpenGL API. </P>
<P>Ниже приведен текст небольшой программы, написанной с использованием 
библиотеки GLUT – своеобразный аналог классического примера “Hello, World!”.</P>
<P>Все, что делает эта программа – рисует в центре окна красный квадрат. Тем не 
менее, даже на этом простом примере можно понять принципы программирования с 
помощью OpenGL.</P>
<DIV id=XSLTCODE128130143120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>#include</SPAN> &lt;stdlib.h&gt;

<SPAN class=COMMENT>/* подключаем библиотеку GLUT */</SPAN>
<SPAN class=KEYWORD>#include</SPAN> &lt;gl/glut.h&gt;

<SPAN class=COMMENT>/* начальная ширина и высота окна */</SPAN>
GLint Width = 512, Height = 512;

<SPAN class=COMMENT>/* размер куба */</SPAN>
<SPAN class=KEYWORD>const</SPAN> <SPAN class=KEYWORD>int</SPAN> CubeSize = 200;

<SPAN class=COMMENT>/* эта функция управляет всем выводом на экран */</SPAN>
<SPAN class=KEYWORD>void</SPAN> Display(<SPAN class=KEYWORD>void</SPAN>)
{
    <SPAN class=KEYWORD>int</SPAN> left, right, top, bottom;

    left  = (Width - CubeSize) / 2;
    right = left + CubeSize;
    bottom = (Height - CubeSize) / 2;
    top = bottom + CubeSize;

    glClearColor(0, 0, 0, 1);
    glClear(GL_COLOR_BUFFER_BIT);
    
    glColor3ub(255,0,0);
    glBegin(GL_QUADS);
      glVertex2f(left,bottom);
      glVertex2f(left,top);
      glVertex2f(right,top);
      glVertex2f(right,bottom);
    glEnd();

    glFinish();
}

<SPAN class=COMMENT>/* Функция вызывается при изменении размеров окна */</SPAN>
<SPAN class=KEYWORD>void</SPAN> Reshape(GLint w, GLint h)
{
    Width = w;
    Height = h;

    <SPAN class=COMMENT>/* устанавливаем размеры области отображения */</SPAN>
    glViewport(0, 0, w, h);

    <SPAN class=COMMENT>/* ортографическая проекция */</SPAN>
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(0, w, 0, h, -1.0, 1.0);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
}

<SPAN class=COMMENT>/* Функция обрабатывает сообщения от клавиатуры */</SPAN>
<SPAN class=KEYWORD>void </SPAN>Keyboard(<SPAN class=KEYWORD>unsigned</SPAN> <SPAN class=KEYWORD>char</SPAN> key, <SPAN class=KEYWORD>int</SPAN> x, <SPAN class=KEYWORD>int</SPAN> y)
{
<SPAN class=KEYWORD>#define</SPAN> ESCAPE '\033'

    <SPAN class=KEYWORD>if</SPAN>( key == ESCAPE )
        exit(0);
}

<SPAN class=COMMENT>/* Главный цикл приложения */</SPAN>
main(<SPAN class=KEYWORD>int</SPAN> argc, <SPAN class=KEYWORD>char</SPAN> *argv[])
{
    glutInit(&amp;argc, argv);
    glutInitDisplayMode(GLUT_RGB);
    glutInitWindowSize(Width, Height);
    glutCreateWindow(<SPAN class=STRING>"Red square example"</SPAN>);

    glutDisplayFunc(Display);
    glutReshapeFunc(Reshape);
    glutKeyboardFunc(Keyboard);

    glutMainLoop();
}
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>Несмотря на малый размер, это полностью завершенная программа, которая должна 
компилироваться и работать на любой системе, поддерживающей OpenGL и GLUT.</P>
<P>Библиотека GLUT поддерживает взаимодействие с пользователем с помощью так 
называемых функций c обратным вызовом (<I>callback function</I>). Если 
пользователь подвинул мышь, нажал на кнопку клавиатуры или изменил размеры окна, 
происходит событие и вызывается соответствующая функция пользователя – 
обработчик событий (функция с обратным вызовом).</P>
<P>Рассмотрим более подробно функцию main данного примера. Она состоит из трех 
частей – инициализации окна, в котором будет рисовать OpenGL, настройки функций 
c обратным вызовом и главного цикла обработки событий.</P>
<P>Инициализация окна состоит из настройки соответствующих буферов кадра, 
начального положения и размеров окна, а также заголовка окна.</P>
<P>Функция glutInit(&amp;argc, argv) производит начальную инициализацию самой 
библиотеки GLUT. </P>
<P>Команда glutInitDisplayMode(GLUT_RGB) инициализирует буфер кадра и 
настраивает полноцветный (непалитровый) режим RGB.</P>
<P>glutInitWindowSize(Width, Height) используется для задания начальных размеров 
окна. </P>
<P>Наконец, glutCreateWindow("Red square example") задает заголовок окна и 
визуализирует само окно на экране.</P>
<P>Затем команды</P>
<DIV id=XSLTCODE148130143120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE>glutDisplayFunc(Display);
glutReshapeFunc(Reshape);
glutKeyboardFunc(Keyboard);
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>регистрируют функции Display(), Reshape() и Keyboard() как функции, которые 
будут вызваны, соответственно, при перерисовке окна, изменении размеров окна, 
нажатии клавиши на клавиатуре. </P>
<P>Контроль всех событий и вызов нужных функций происходит внутри бесконечного 
цикла в функции glutMainLoop()</P>
<P>Заметим, что библиотека GLUT не входит в состав OpenGL, а является лишь 
переносимой прослойкой между OpenGL и оконной подсистемой, предоставляя 
минимальный интерфейс. OpenGL-приложение для конкретной платформы может быть 
написано с использованием специфических API (Win32, X Window и т.д.), которые 
как правило предоставляют более широкие возможности.</P>
<P>Более подробно работа с библиотекой GLUT описана в Приложении А.</P>
<P>Все вызовы команд OpenGL происходят в обработчиках событий. Более подробно 
они будут рассмотрены в следующих главах. Сейчас обратим внимание на функцию 
Display, в которой сосредоточен код, непосредственно отвечающий за рисование на 
экране. </P>
<P>Следующая последовательность команд из функции Display</P>
<DIV id=XSLTCODE162130143120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE>glClearColor(0, 0, 0, 1);
glClear(GL_COLOR_BUFFER_BIT);
    
glColor3ub(255,0,0);
glBegin(GL_QUADS);
  glVertex2f(left,bottom);
  glVertex2f(left,top);
  glVertex2f(right,top);
  glVertex2f(right,bottom);
glEnd();
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>очищает окно и выводит на экран квадрат, задавая координаты четырех угловых 
вершин и цвет. </P>
<P>В приложении 0 приведен еще один пример несложной программы, при нажатии 
кнопку мыши рисующей на экране разноцветные случайные прямоугольники. </P>
<H4>Контрольные вопросы:</H4>
<P>В чем, по вашему мнению, заключается необходимость создания стандартной 
графической библиотеки?</P>
<P>Кратко опишите архитектуру библиотек OpenGL и организацию конвейера.</P>
<P>В чем заключаются функции библиотек, подобных GLUT или GLX? Почему они 
формально не входят в OpenGL?</P>
<P>Назовите категории команд (функций) библиотеки.</P>
<P>Почему организацию OpenGL часто сравнивают с конечным автоматом?</P>
<P>Зачем нужны различные варианты команд OpenGL, отличающиеся только типами 
параметров?</P>
<P>Что можно сказать о количестве и типе параметров команды glColor4ub()? 
glVertex3fv()?</P>
<H2>Рисование геометрических объектов<A name=XSLTPART145120120></A></H2>
<H3>Процесс обновления изображения<A name=XSLTSECTION122145120120></A></H3>
<P>Как правило, задачей программы, использующей OpenGL, является обработка 
трехмерной сцены и интерактивное отображение в буфере кадра. Сцена состоит из 
набора трехмерных объектов, источников света и виртуальной камеры, определяющей 
текущее положение наблюдателя. </P>
<P>Обычно приложение OpenGL в бесконечном цикле вызывает функцию обновления 
изображения в окне. В этой функции и сосредоточены вызовы основных команд 
OpenGL. Если используется библиотека GLUT, то это будет функция с обратным 
вызовом, зарегистрированная с помощью вызова glutDisplayFunc(). GLUT вызывает 
эту функцию, когда операционная система информирует приложение о том, что 
содержимое окна необходимо перерисовать (например, если окно было перекрыто 
другим). Создаваемое изображение может быть как статичным, так и анимированным, 
т.е. зависеть от каких-либо параметров, изменяющихся со временем. В этом случае 
лучше вызывать функцию обновления самостоятельно. Например, с помощью команды 
glutPostRedisplay(). За более подробной информацией можно обратиться к 
приложению A.</P>
<P>Приступим, наконец, к тому, чем занимается типичная функция обновления 
изображения. Как правило, она состоит из трех шагов:</P>
<P>очистка буферов OpenGL;</P>
<P>установка положения наблюдателя;</P>
<P>преобразование и рисование геометрических объектов.</P>
<P>Очистка буферов производится с помощью команды:</P>
<DIV id=XSLTCODE136122145120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void</SPAN> <STRONG>glClearColor </STRONG>(clampf r, clampf g, clampf b, clampf a)
<SPAN class=KEYWORD>void</SPAN> <STRONG>glClear </STRONG>(bitfield buf)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>Команда<STRONG> </STRONG>glClearColor устанавливает цвет, которым будет 
заполнен буфер кадра. Первые три параметра команды задают R,G и B компоненты 
цвета и должны принадлежать отрезку [0,1]. Четвертый параметр задает так 
называемую альфа компоненту (см. п. 0). Как правило, он равен 1. По умолчанию 
цвет – черный (0,0,0,1).</P>
<P>Команда glClear очищает буферы, а параметр <I>buf</I> определяет комбинацию 
констант, соответствующую буферам, которые нужно очистить (см. главу 6). 
Типичная программа вызывает команду</P>
<DIV id=XSLTCODE142122145120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE>glClear(GL_COLOR_BUFFER_BIT&nbsp;|&nbsp;GL_DEPTH_BUFFER_BIT) 
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>для очистки буферов цвета и глубины.</P>
<P>Установка положения наблюдателя и преобразования трехмерных объектов 
(поворот, сдвиг и т.д.) контролируются с помощью задания матриц преобразования. 
Преобразования объектов и настройка положения виртуальной камеры описаны в главе 
3.</P>
<P>Сейчас сосредоточимся на том, как передать в OpenGL описания объектов, 
находящихся в сцене. Каждый объект является набором примитивов OpenGL.</P>
<H3>Вершины и примитивы<A name=XSLTSECTION124145120120></A></H3>
<P><I>Вершина</I> является атомарным графическим примитивом OpenGL и определяет 
точку, конец отрезка, угол многоугольника и т.д. Все остальные примитивы 
формируются с помощью задания вершин, входящих в данный примитив. Например, 
отрезок определяется двумя вершинами, являющимися концами отрезка. </P>
<P>С каждой вершиной ассоциируются ее <I>атрибуты</I>. В число основных 
атрибутов входят положение вершины в пространстве, цвет вершины и вектор 
нормали.</P>
<H4>Положение вершины в пространстве</H4>
<P>Положение вершины определяются заданием ее координат в двух-, трех-, или 
четырехмерном пространстве (однородные координаты). Это реализуется с помощью 
нескольких вариантов команды glVertex*:</P>
<DIV id=XSLTCODE124126124145120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void</SPAN> <STRONG>glVertex[2 3 4][s i f d]</STRONG> (type <I>coords</I>)
<SPAN class=KEYWORD>void</SPAN> <STRONG>glVertex[2 3 4][s i f d]v</STRONG> (type *<I>coords</I>)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>Каждая команда задает четыре координаты вершины: x, y, z, w. Команда 
glVertex2* получает значения x и y. Координата z в таком случае устанавливается 
по умолчанию равной 0, координата w – равной 1. Vertex3* получает координаты x, 
y, z и заносит в координату w значение 1. Vertex4* позволяет задать все четыре 
координаты.</P>
<P>Для ассоциации с вершинами цветов, нормалей и текстурных координат 
используются текущие значения соответствующих данных, что отвечает организации 
OpenGL как конечного автомата. Эти значения могут быть изменены в любой момент с 
помощью вызова соответствующих команд.</P>
<H4>Цвет вершины</H4>
<P>Для задания текущего цвета вершины используются команды :</P>
<DIV id=XSLTCODE124128124145120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void</SPAN> <STRONG>glColor[3 4][b s i f]</STRONG> (GLtype <I>components</I>)
<SPAN class=KEYWORD>void</SPAN> <STRONG>glColor[3 4][b s i f]v</STRONG> (GLtype <I>components</I>)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>Первые три параметра задают R, G, B компоненты цвета, а последний параметр 
определяет коэффициент непрозрачности (так называемая альфа-компонента). Если в 
названии команды указан тип ‘f’ (float), то значения всех параметров должны 
принадлежать отрезку [0,1], при этом по умолчанию значение альфа-компоненты 
устанавливается равным 1.0, что соответствует полной непрозрачности. Тип ‘ub’ 
(unsigned byte) подразумевает, что значения должны лежать в отрезке [0,255]. 
</P>
<P>Вершинам можно назначать различные цвета, и, если включен соответствующий 
режим, то будет проводиться линейная интерполяция цветов по поверхности 
примитива.</P>
<P>Для управления режимом интерполяции используется команда</P>
<DIV id=XSLTCODE132128124145120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void</SPAN> <STRONG>glShadeModel</STRONG> (GLenum  <I>mode</I>)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>вызов которой с параметром <STRONG>GL_SMOOTH</STRONG> включает интерполяцию 
(установка по умолчанию), а с <STRONG>GL_FLAT</STRONG> – отключает.</P>
<H4>Нормаль</H4>
<P>Определить нормаль в вершине можно, используя команды </P>
<DIV id=XSLTCODE124130124145120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void</SPAN> <STRONG>glNormal3[b s i f d]</STRONG> (type <I>coords</I>) 
<SPAN class=KEYWORD>void</SPAN> <STRONG>glNormal3[b s i f d]v</STRONG> (type <I>coords</I>)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>Для правильного расчета освещения необходимо, чтобы вектор нормали имел 
единичную длину. Командой glEnable(GL_NORMALIZE)можно включить специальный 
режим, при котором задаваемые нормали будут нормироваться автоматически.</P>
<P>Режим автоматической нормализации должен быть включен, если приложение 
использует модельные преобразования растяжения/сжатия, так как в этом случае 
длина нормалей изменяется при умножении на модельно-видовую матрицу.</P>
<P>Однако применение этого режима уменьшает скорость работы механизма 
визуализации OpenGL, так как нормализация векторов имеет заметную вычислительную 
сложность (взятие квадратного корня и т.п.). Поэтому лучше сразу задавать 
единичные нормали.</P>
<P>Отметим, что команды</P>
<DIV id=XSLTCODE134130124145120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void</SPAN> <STRONG>glEnable</STRONG> (GLenum <I>mode</I>)
<SPAN class=KEYWORD>void</SPAN> <STRONG>glDisable</STRONG> (GLenum <I>mode</I>)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>производят включение и отключение того или иного режима работы конвейера 
OpenGL. Эти команды применяются достаточно часто, и их возможные параметры будут 
рассматриваться в каждом конкретном случае. </P>
<H3>Операторные скобки glBegin / glEnd<A name=XSLTSECTION126145120120></A></H3>
<P>Мы рассмотрели задание атрибутов одной вершины. Однако, чтобы задать атрибуты 
графического примитива, одних координат вершин недостаточно. Эти вершины надо 
объединить в одно целое, определив необходимые свойства. Для этого в OpenGL 
используются так называемые операторные скобки, являющиеся вызовами специальных 
команд OpenGL Определение примитива или последовательности примитивов происходит 
между вызовами команд</P>
<DIV id=XSLTCODE124126145120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void</SPAN> <STRONG>glBegin</STRONG> (GLenum <I>mode</I>);
<SPAN class=KEYWORD>void</SPAN> <STRONG>glEnd</STRONG> (void);
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>Параметр <I>mode</I> определяет тип примитива, который задается внутри и 
может принимать следующие значения:</P>
<TABLE cellSpacing=2 cellPadding=5 border=0>
  <TBODY>
  <TR>
    <TD><STRONG>GL_POINTS</STRONG></TD>
    <TD>каждая вершина задает координаты некоторой точки.</TD></TR>
  <TR>
    <TD><STRONG>GL_LINES</STRONG></TD>
    <TD>каждая отдельная пара вершин определяет отрезок; если задано нечетное 
      число вершин, то последняя вершина игнорируется.</TD></TR>
  <TR>
    <TD><STRONG>GL_LINE_STRIP</STRONG></TD>
    <TD>каждая следующая вершина задает отрезок вместе с предыдущей.</TD></TR>
  <TR>
    <TD><STRONG>GL_LINE_LOOP</STRONG></TD>
    <TD>отличие от предыдущего примитива только в том, что последний отрезок 
      определяется последней и первой вершиной, образуя замкнутую ломаную.</TD></TR>
  <TR>
    <TD><STRONG>GL_TRIANGLES</STRONG></TD>
    <TD>каждая отдельная тройка вершин определяет треугольник; если задано не 
      кратное трем число вершин, то последние вершины игнорируются.</TD></TR>
  <TR>
    <TD><STRONG>GL_TRIANGLE_STRIP</STRONG></TD>
    <TD>каждая следующая вершина задает треугольник вместе с двумя 
    предыдущими.</TD></TR>
  <TR>
    <TD><STRONG>GL_TRIANGLE_FAN</STRONG></TD>
    <TD>треугольники задаются первой и каждой следующей парой вершин (пары не 
      пересекаются).</TD></TR>
  <TR>
    <TD><STRONG>GL_QUADS</STRONG></TD>
    <TD>каждая отдельная четверка вершин определяет четырехугольник; если 
      задано не кратное четырем число вершин, то последние вершины 
    игнорируются.</TD></TR>
  <TR>
    <TD><STRONG>GL_QUAD_STRIP</STRONG></TD>
    <TD>четырехугольник с номером n определяется вершинами с номерами 2n-1, 
      2n, 2n+2, 2n+1.</TD></TR>
  <TR>
    <TD><STRONG>GL_POLYGON</STRONG></TD>
    <TD>последовательно задаются вершины выпуклого 
  многоугольника.</TD></TR></TBODY></TABLE>
<P>Например, чтобы нарисовать треугольник с разными цветами в вершинах, 
достаточно написать:</P>
<DIV id=XSLTCODE132126145120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE>GLfloat BlueCol[3] = {0,0,1};  

glBegin(GL_TRIANGLES); 
glColor3f(1.0, 0.0, 0.0);   <SPAN class=COMMENT>/* красный */</SPAN>
glVertex3f(0.0, 0.0, 0.0); 
glColor3ub(0,255,0);    <SPAN class=COMMENT>/* зеленый */</SPAN>
glVertex3f(1.0, 0.0, 0.0); 
glColor3fv(BlueCol);    <SPAN class=COMMENT>/* синий */</SPAN>
glVertex3f(1.0, 1.0, 0.0); 
glEnd();
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>Как правило, разные типы примитивов имеют различную скорость визуализации на 
разных платформах. Для увеличения производительности предпочтительнее 
использовать примитивы, требующие меньшее количество информации для передачи на 
сервер, такие как <STRONG>GL_TRIANGLE_STRIP</STRONG>, 
<STRONG>GL_QUAD_STRIP</STRONG>, <STRONG>GL_TRIAGLE_FAN.</STRONG></P>
<P style="TEXT-ALIGN: center"><IMG src="ogltut2.files/primitives.gif"><BR><I 
style="FONT-SIZE: x-small; font-face: verdana">Рис. 3. Примитивы OpenGL</I></P>
<P>Кроме задания самих многоугольников, можно определить метод их отображения на 
экране.</P>
<P>Однако сначала надо определить понятие лицевых и обратных граней.</P>
<P>Под <I>гранью</I> понимается одна из сторон многоугольника, и по умолчанию 
лицевой считается та сторона, вершины которой обходятся против часовой стрелки. 
Направление обхода вершин лицевых граней можно изменить вызовом команды</P>
<DIV id=XSLTCODE144126145120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void</SPAN> <STRONG>glFrontFace</STRONG> (GLenum <I>mode</I>)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>со значением параметра <I>mode</I> равным <STRONG>GL_CW </STRONG>(clockwise), 
а вернуть значение по умолчанию можно, указав <STRONG>GL_CCW 
</STRONG>(counter-clockwise).</P>
<P>Чтобы изменить метод отображения многоугольника используется команда</P>
<DIV id=XSLTCODE150126145120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void</SPAN> <STRONG>glPolygonMode</STRONG> (GLenum <I>face</I>, Glenum <I>mode</I>)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>Параметр <I>mode</I> определяет, как будут отображаться многоугольники, а 
параметр <I>face</I> устанавливает тип многоугольников, к которым будет 
применяться эта команда и может принимать следующие значения:</P>
<TABLE cellSpacing=2 cellPadding=5 border=0>
  <TBODY>
  <TR>
    <TD><STRONG>GL_FRONT</STRONG></TD>
    <TD>для лицевых граней</TD></TR>
  <TR>
    <TD><STRONG>GL_BACK</STRONG></TD>
    <TD>для обратных граней</TD></TR>
  <TR>
    <TD><STRONG>GL_FRONT_AND_BACK</STRONG></TD>
    <TD>для всех граней</TD></TR></TBODY></TABLE>
<P>Параметр <I>mode</I> может быть равен:</P>
<TABLE cellSpacing=2 cellPadding=5 border=0>
  <TBODY>
  <TR>
    <TD><STRONG>GL_POINT</STRONG></TD>
    <TD>при таком режиме будут отображаться только вершины 
  многоугольников.</TD></TR>
  <TR>
    <TD><STRONG>GL_LINE</STRONG></TD>
    <TD>при таком режиме многоугольник будет представляться набором 
    отрезков.</TD></TR>
  <TR>
    <TD><STRONG>GL_FILL</STRONG></TD>
    <TD>при таком режиме многоугольники будут закрашиваться текущим цветом с 
      учетом освещения, и этот режим установлен по 
умолчанию.</TD></TR></TBODY></TABLE>
<P>Также можно указывать, какой тип граней отображать на экране. Для этого 
сначала надо установить соответствующий режим вызовом команды 
<STRONG>glEnable</STRONG> (GL_CULL_FACE), а затем выбрать тип отображаемых 
граней с помощью команды </P>
<DIV id=XSLTCODE162126145120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void</SPAN> <STRONG>glCullFace</STRONG> (GLenum <I>mode</I>)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>Вызов с параметром <STRONG>GL_FRONT</STRONG> приводит к удалению из 
изображения всех лицевых граней, а с параметром <STRONG>GL_BACK</STRONG> – 
обратных (установка по умолчанию). </P>
<P>Кроме рассмотренных стандартных примитивов в библиотеках GLU и GLUT описаны 
более сложные фигуры, такие как сфера, цилиндр, диск (в GLU) и сфера, куб, 
конус, тор, тетраэдр, додекаэдр, икосаэдр, октаэдр и чайник (в GLUT). 
Автоматическое наложение текстуры предусмотрено только для фигур из библиотеки 
GLU (создание текстур в OpenGL будет рассматриваться в главе 5).</P>
<P>Например, чтобы нарисовать сферу или цилиндр, надо сначала создать объект 
специального типа GLUquadricObj с помощью команды</P>
<DIV id=XSLTCODE170126145120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE>GLUquadricObj* <STRONG>gluNewQuadric</STRONG>(void);
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>а затем вызвать соответствующую команду: </P>
<DIV id=XSLTCODE174126145120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void</SPAN> <STRONG>gluSphere</STRONG> (GLUquadricObj *<I> qobj</I>, GLdouble<I> radius</I>,
                GLint<I> slices</I>, GLint<I> stacks</I>)

<SPAN class=KEYWORD>void</SPAN> <STRONG>gluCylinder</STRONG> (GLUquadricObj *<I> qobj</I><STRONG>, 
                  </STRONG>GLdouble<I> baseRadius</I><STRONG>,
                  </STRONG>GLdouble <I>topRadius</I><STRONG>, 
                  </STRONG>GLdouble<I> height</I><STRONG>, </STRONG>GLint<I> slices</I><STRONG>, 
                  </STRONG>GLint<I> stacks</I>)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>где параметр <I>slices</I> задает число разбиений вокруг оси z, а 
<I>stacks</I> – вдоль оси z.</P>
<P>Более подробную информацию об этих и других командах построения примитивов 
можно найти в приложении В.</P>
<H3>Дисплейные списки<A name=XSLTSECTION128145120120></A></H3>
<P>Если мы несколько раз обращаемся к одной и той же группе команд, то их можно 
объединить в так называемый дисплейный список (display list), и вызывать его при 
необходимости. Для того, чтобы создать новый дисплейный список, надо поместить 
все команды, которые должны в него войти, между следующими операторными 
скобками:</P>
<DIV id=XSLTCODE124128145120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void</SPAN> <STRONG>glNewList</STRONG> (GLuint <I>list</I>, GLenum <I>mode</I>)
<SPAN class=KEYWORD>void</SPAN> <STRONG>glEndList </STRONG>()
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>Для различения списков используются целые положительные числа, задаваемые при 
создании списка значением параметра <I>list</I>, а параметр <I>mode</I> 
определяет режим обработки команд, входящих в список:</P>
<TABLE cellSpacing=2 cellPadding=5 border=0>
  <TBODY>
  <TR>
    <TD><STRONG>GL_COMPILE</STRONG></TD>
    <TD>команды записываются в список без выполнения</TD></TR>
  <TR>
    <TD><STRONG>GL_COMPILE_AND_EXECUTE</STRONG></TD>
    <TD>команды сначала выполняются, а затем записываются в 
  список</TD></TR></TBODY></TABLE>
<P>После того, как список создан, его можно вызвать командой</P>
<DIV id=XSLTCODE132128145120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void</SPAN> <STRONG>glCallList</STRONG> (GLuint <I>list</I>)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>указав в параметре <I>list</I> идентификатор нужного списка. Чтобы вызвать 
сразу несколько списков, можно воспользоваться командой</P>
<DIV id=XSLTCODE136128145120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void</SPAN> <STRONG>glCallLists </STRONG>(GLsizei <I>n</I>, GLenum <I>type</I>, <SPAN class=KEYWORD>const</SPAN> GLvoid *<I>lists</I>)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>вызывающей <I>n</I> списков с идентификаторами из массива <I>lists</I>, тип 
элементов которого указывается в параметре <I>type</I>. Это могут быть типы 
<STRONG>GL_BYTE</STRONG>, <STRONG>GL_UNSIGNED_BYTE</STRONG>, 
<STRONG>GL_SHORT</STRONG>, <STRONG>GL_INT</STRONG>, 
<STRONG>GL_UNSIGNED_INT</STRONG> и некоторые другие. Для удаления списков 
используется команда</P>
<DIV id=XSLTCODE140128145120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void</SPAN> <STRONG>glDeleteLists </STRONG>(GLint <I>list</I>, GLsizei <I>range</I>)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>которая удаляет списки с идентификаторами ID из диапазона <I>list</I> &lt;= 
ID &lt;= <I>list</I>+<I>range</I>-1.</P>
<P>Пример:</P>
<DIV id=XSLTCODE146128145120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE>glNewList(1, GL_COMPILE);
  glBegin(GL_TRIANGLES);
    glVertex3f(1.0f, 1.0f, 1.0f);
    glVertex3f(10.0f, 1.0f, 1.0f);
    glVertex3f(10.0f, 10.0f, 1.0f);
  glEnd();
glEndList()
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>…</P>
<DIV id=XSLTCODE150128145120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE>glCallList(1);
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>Дисплейные списки в оптимальном, скомпилированном виде хранятся в памяти 
сервера, что позволяет рисовать примитивы в такой форме максимально быстро. В то 
же время большие объемы данных занимают много памяти, что влечет, в свою 
очередь, падение производительности. Такие большие объемы (больше нескольких 
десятков тысяч примитивов) лучше рисовать с помощью массивов вершин.</P>
<H3>Массивы вершин<A name=XSLTSECTION130145120120></A></H3>
<P>Если вершин много, то чтобы не вызывать для каждой команду glVertex*(), 
удобно объединять вершины в массивы, используя команду </P>
<DIV id=XSLTCODE124130145120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void</SPAN> <STRONG>glVertexPointer </STRONG>(GLint <I>size</I>, GLenum <I>type</I>, 
                      GLsizei <I>stride</I>, <SPAN class=KEYWORD>void</SPAN>* <I>ptr</I>)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P></P>
<P>которая определяет способ хранения и координаты вершин. При этом <I>size</I> 
определяет число координат вершины (может быть равен 2, 3, 4), type определяет 
тип данных (может быть равен <STRONG>GL_SHORT</STRONG>, <STRONG>GL_INT</STRONG>, 
<STRONG>GL_FLOAT</STRONG>, <STRONG>GL_DOUBLE</STRONG>). Иногда удобно хранить в 
одном массиве другие атрибуты вершины, тогда параметр <I>stride</I> задает 
смещение от координат одной вершины до координат следующей; если <I>stride</I> 
равен нулю, это значит, что координаты расположены последовательно. В параметре 
<I>ptr</I> указывается адрес, где находятся данные.</P>
<P>Аналогично можно определить массив нормалей, цветов и некоторых других 
атрибутов вершины, используя команды </P>
<DIV id=XSLTCODE132130145120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void</SPAN> <STRONG>glNormalPointer</STRONG> ( GLenum <I>type</I>, GLsizei <I>stride</I>, 
                     <SPAN class=KEYWORD>void</SPAN>  *<I>pointer</I> )
<SPAN class=KEYWORD>void</SPAN> <STRONG>glColorPointer</STRONG> ( GLint <I>size</I>, GLenum <I>type</I>, 
                    GLsizei <I>stride</I>, <SPAN class=KEYWORD>void</SPAN> *<I>pointer</I> )
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>Для того, чтобы эти массивы можно было использовать в дальнейшем, надо 
вызвать команду</P>
<DIV id=XSLTCODE136130145120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void</SPAN> <STRONG>glEnableClientState</STRONG> (GLenum <I>array</I>)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>с параметрами <STRONG>GL_VERTEX_ARRAY</STRONG>, 
<STRONG>GL_NORMAL_ARRAY</STRONG>, <STRONG>GL_COLOR_ARRAY</STRONG> 
соответственно. После окончания работы с массивом желательно вызвать команду</P>
<DIV id=XSLTCODE140130145120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void</SPAN> <STRONG>glDisableClientState</STRONG> (GLenum <I>array</I>)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>с соответствующим значением параметра <I>array.</I></P>
<P>Для отображения содержимого массивов используется команда</P>
<DIV id=XSLTCODE146130145120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void</SPAN> <STRONG>glArrayElement</STRONG> (GLint <I>index</I>)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>которая передает OpenGL атрибуты вершины, используя элементы массива с 
номером <I>index</I>. Это аналогично последовательному применению команд вида 
glColor*(…), glNormal*(…), glVertex*(…) c соответствующими параметрами. Однако 
вместо нее обычно вызывается команда</P>
<DIV id=XSLTCODE150130145120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void</SPAN> <STRONG>glDrawArrays</STRONG> (GLenum <I>mode</I>, GLint <I>first</I>, 
                   GLsizei <I>count</I>)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>рисующая <I>count</I> примитивов, определяемых параметром <I>mode</I>, 
используя элементы из массивов с индексами от <I>first</I> до 
<I>first</I>+<I>count</I>-1. Это эквивалентно вызову последовательности команд 
glArrayElement() с соответствующими индексами. </P>
<P>В случае, если одна вершина входит в несколько примитивов, то вместо 
дублирования ее координат в массиве удобно использовать ее индекс.</P>
<P>Для этого надо вызвать команду </P>
<DIV id=XSLTCODE158130145120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void</SPAN> <STRONG>glDrawElements</STRONG> (GLenum <I>mode</I>, GLsizei <I>count</I>, 
                     GLenum <I>type</I>, void *<I>indices</I>)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>где <I>indices</I> – это массив номеров вершин, которые надо использовать для 
построения примитивов, <I>type</I> определяет тип элементов этого массива: 
<STRONG>GL_UNSIGNED_BYTE</STRONG>, <STRONG>GL_UNSIGNED_SHORT</STRONG>, 
<STRONG>GL_UNSIGNED_INT</STRONG>, а <I>count</I> задает их количество.</P>
<P>Важно отметить, что использование массивов вершин позволяет оптимизировать 
передачу данных на сервер OpenGL, и, как следствие, повысить скорость рисования 
трехмерной сцены. Такой метод определения примитивов является одним из самых 
быстрых и хорошо подходит для визуализации больших объемов данных.</P>
<H4>Контрольные вопросы</H4>
<P>Что такое функция обратного вызова и как функции обратного вызова могут быть 
использованы для работы с OpenGL? </P>
<P>Для чего нужна функция обновления изображения и что она делает?</P>
<P>Что такое примитив в OpenGL? </P>
<P>Что такое атрибут? Перечислите известные вам атрибуты вершин в OpenGL.</P>
<P>Что в OpenGL является атомарным примитивом? Какие типы примитивов вы 
знаете?</P>
<P>Для чего в OpenGL используются команды glEnable/glDisable?</P>
<P>Что такое операторные скобки и для чего они используются в OpenGL?</P>
<P>Что такое дисплейные списки? Как определить список и как вызвать его 
отображение?</P>
<P>Поясните организацию работы с массивами вершин и их отличие от дисплейных 
списков.</P>
<P>Поясните работу команды glDrawElements()</P>
<H2>Преобразования объектов<A name=XSLTPART147120120></A></H2>
<P>В OpenGL используются как основные три системы координат: левосторонняя, 
правосторонняя и оконная. Первые две системы являются трехмерными и отличаются 
друг от друга направлением оси z: в правосторонней она направлена на 
наблюдателя, в левосторонней – в глубину экрана. Ось x направлена вправо 
относительно наблюдателя, ось y – вверх. </P>
<P>Левосторонняя система используется для задания значений параметрам команды 
gluPerspective(), glOrtho(), которые будут рассмотрены в пункте 0. 
Правосторонняя система координат используется во всех остальных случаях. 
Отображение трехмерной информации происходит в двумерную <I>оконную</I> систему 
координат.</P>
<P style="TEXT-ALIGN: center"><IMG src="ogltut2.files/coord_sys.gif"><BR><I 
style="FONT-SIZE: x-small; font-face: verdana">Рис. 4 Системы координат в 
OpenGL</I></P>
<P>Строго говоря, OpenGL позволяет путем манипуляций с матрицами моделировать 
как правую, так и левую систему координат. Но на данном этапе лучше пойти 
простым путем и запомнить: основной системой координат OpenGL является 
правосторонняя система.</P>
<H3>Работа с матрицами<A name=XSLTSECTION130147120120></A></H3>
<P>Для задания различных преобразований объектов сцены в OpenGL используются 
операции над матрицами, при этом различают три типа матриц: модельно-видовая, 
матрица проекций и матрица текстуры. Все они имеют размер 4x4. Видовая матрица 
определяет преобразования объекта в мировых координатах, такие как параллельный 
перенос, изменение масштаба и поворот. Матрица проекций определяет, как будут 
проецироваться трехмерные объекты на плоскость экрана (в оконные координаты), а 
матрица текстуры определяет наложение текстуры на объект. </P>
<P>Умножение координат на матрицы происходит в момент вызова соответствующей 
команды OpenGL, определяющей координату (как правило, это команда glVertex*)</P>
<P>Для того чтобы выбрать, какую матрицу надо изменить, используется 
команда:</P>
<DIV id=XSLTCODE128130147120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void</SPAN> <STRONG>glMatrixMode</STRONG> (GLenum <I>mode</I>)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>вызов которой со значением параметра <I>mode</I> равным 
<STRONG>GL_MODELVIEW</STRONG>, <STRONG>GL_PROJECTION</STRONG>, или 
<STRONG>GL_TEXTURE</STRONG> включает режим работы с модельно-видовой матрицей, 
матрицей проекций, или матрицей текстуры соответственно. Для вызова команд, 
задающих матрицы того или иного типа, необходимо сначала установить 
соответствующий режим.</P>
<P>Для определения элементов матрицы текущего типа вызывается команда</P>
<DIV id=XSLTCODE134130147120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void</SPAN> <STRONG>glLoadMatrix[f d]</STRONG> (GLtype *<I>m</I>)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>где <I>m</I> указывает на массив из 16 элементов типа float или double в 
соответствии с названием команды, при этом сначала в нем должен быть записан 
первый столбец матрицы, затем второй, третий и четвертый. Еще раз обратим 
внимание: в массиве <I>m </I>матрица записана <I>по столбцам</I>.</P>
<P>Команда</P>
<DIV id=XSLTCODE140130147120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void</SPAN> <STRONG>glLoadIdentity</STRONG> (void)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>заменяет текущую матрицу на единичную. </P>
<P>Часто бывает необходимо сохранить содержимое текущей матрицы для дальнейшего 
использования, для чего применяются команды </P>
<DIV id=XSLTCODE146130147120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void</SPAN> <STRONG>glPushMatrix</STRONG> (<SPAN class=KEYWORD>void</SPAN>)
<SPAN class=KEYWORD>void</SPAN> <STRONG>glPopMatrix</STRONG> (<SPAN class=KEYWORD>void</SPAN>) 
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>Они записывают и восстанавливают текущую матрицу из стека, причем для каждого 
типа матриц стек свой. Для модельно-видовых матриц его глубина равна как минимум 
32, для остальных – как минимум 2.</P>
<P>Для умножения текущей матрицы на другую матрицу используется команда</P>
<DIV id=XSLTCODE152130147120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void</SPAN> <STRONG>glMultMatrix[f d]</STRONG> (GLtype *<I>m</I>)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>где параметр <I>m</I> должен задавать матрицу размером 4x4. Если обозначить 
текущую матрицу за М, передаваемую матрицу за T, то в результате выполнения 
команды glMultMatrix текущей становится матрица M * T. Однако обычно для 
изменения матрицы того или иного типа удобно использовать специальные команды, 
которые по значениям своих параметров создают нужную матрицу и умножают ее на 
текущую. </P>
<P>В целом, для отображения трехмерных объектов сцены в окно приложения 
используется последовательность, показанная на рисунке.</P>
<P style="TEXT-ALIGN: center"><IMG 
src="ogltut2.files/coord_trans_diagram.gif"><BR><I 
style="FONT-SIZE: x-small; font-face: verdana">Рис. 5. Преобразования координат 
в OpenGL</I></P>
<TABLE class=note width="98%">
  <TBODY>
  <TR>
    <TD><B>ПРИМЕЧАНИЕ</B><BR>
      <P>Запомните: все преобразования объектов и камеры в OpenGL производятся с 
      помощью умножения векторов координат на матрицы. Причем умножение 
      происходит на <I>текущую матрицу</I> в момент определения координаты 
      командой glVertex* и некоторыми другими.</P></TD></TR></TBODY></TABLE>
<H3>Модельно-Видовые преобразования<A name=XSLTSECTION132147120120></A></H3>
<P>К модельно-видовым преобразованиям будем относить перенос, поворот и 
изменение масштаба вдоль координатных осей. Для проведения этих операций 
достаточно умножить на соответствующую матрицу каждую вершину объекта и получить 
измененные координаты этой вершины:</P>
<P>(x’, y’, z’, 1)<SUP>T</SUP> = M * (x, y, z, 1)<SUP>T</SUP></P>
<P>где M – матрица модельно-видового преобразования. Перспективное 
преобразование и проектирование производится аналогично. Сама матрица может быть 
создана с помощью следующих команд:</P>
<DIV id=XSLTCODE128132147120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void</SPAN> <STRONG>glTranslate[f d] </STRONG>(GLtype <I>x</I>, GLtype <I>y</I>, GLtype <I>z</I>)
<SPAN class=KEYWORD>void</SPAN> <STRONG>glRotate[f d] </STRONG>(GLtype <I>angle</I>, GLtype <I>x</I>, GLtype <I>y</I>,
                    GLtype z)
<SPAN class=KEYWORD>void</SPAN> <STRONG>glScale[f d] </STRONG>(GLtype <I>x</I>, GLtype <I>y</I>, GLtype <I>z</I>)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>glTranlsate*() производит перенос объекта, прибавляя к координатам его вершин 
значения своих параметров. </P>
<P>glRotate*(<STRONG>)</STRONG> производит поворот объекта против часовой 
стрелки на угол <I>angle</I> (измеряется в градусах) вокруг вектора (x,y,z).</P>
<P>glScale*() производит масштабирование объекта (сжатие или растяжение) вдоль 
вектора (x,y,z), умножая соответствующие координаты его вершин на значения своих 
параметров.</P>
<P>Все эти преобразования изменяют текущую матрицу, а поэтому применяются к 
примитивам, которые определяются позже. В случае, если надо, например, повернуть 
один объект сцены, а другой оставить неподвижным, удобно сначала сохранить 
текущую видовую матрицу в стеке командой glPushMatrix(), затем вызвать 
glRotate() с нужными параметрами, описать примитивы, из которых состоит этот 
объект, а затем восстановить текущую матрицу командой glPopMatrix().</P>
<P>Кроме изменения положения самого объекта, часто бывает необходимо изменить 
положение наблюдателя, что также приводит к изменению модельно-видовой матрицы. 
Это можно сделать с помощью команды</P>
<DIV id=XSLTCODE140132147120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void</SPAN> <STRONG>gluLookAt 
  </STRONG>(GLdouble <I>eyex</I>, GLdouble <I>eyey</I>, GLdouble <I>eyez</I>, 
   GLdouble <I>centerx</I>, GLdouble <I>centery</I>, GLdouble <I>centerz</I>,
   GLdouble <I>upx</I>, GLdouble <I>upy</I>, GLdouble <I>upz</I>)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>где точка (<I>eyex,eyey,eyez</I>) определяет точку наблюдения, (<I>centerx, 
centery, centerz</I>) задает центр сцены, который будет проектироваться в центр 
области вывода, а вектор (<I>upx,upy,upz</I>) задает положительное направление 
оси у, определяя поворот камеры. Если, например, камеру не надо поворачивать, то 
задается значение (0,1,0), а со значением (0,-1,0) сцена будет перевернута.</P>
<P>Строго говоря, эта команда совершает перенос и поворот объектов сцены, но в 
таком виде задавать параметры бывает удобнее. Следует отметить, что вызывать 
команду gluLookAt() имеет смысл <I>перед </I>определением преобразований 
объектов, когда модельно-видовая матрица равна единичной. </P>
<P>Запомните: В общем случае матричные преобразования в OpenGL нужно записывать 
в обратном порядке. Например, если вы хотите сначала повернуть объект, а затем 
передвинуть его, сначала вызовите команду glTranslate(), а только потом – 
glRotate(). Ну а после этого определяйте сам объект.</P>
<H3>Проекции<A name=XSLTSECTION134147120120></A></H3>
<P>В OpenGL существуют стандартные команды для задания ортографической 
(параллельной) и перспективной проекций. Первый тип проекции может быть задан 
командами</P>
<DIV id=XSLTCODE124134147120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void</SPAN> <STRONG>glOrtho </STRONG>(GLdouble <I>left</I>, GLdouble <I>right</I>, 
              GLdouble <I>bottom</I>, GLdouble <I>top</I>, 
              GLdouble <I>near</I>, GLdouble <I>far</I>)
<SPAN class=KEYWORD>void</SPAN> <STRONG>gluOrtho2D</STRONG> (GLdouble <I>left</I>, GLdouble <I>right</I>, GLdouble <I>bottom</I>, GLdouble <I>top</I>)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P style="TEXT-ALIGN: center"><IMG src="ogltut2.files/ortho.gif"><BR><I 
style="FONT-SIZE: x-small; font-face: verdana">Рис. 6 Ортографическая 
проекция</I></P>
<P>Первая команда создает матрицу проекции в усеченный объем видимости 
(параллелепипед видимости) в левосторонней системе координат. Параметры команды 
задают точки (<I>left, bottom, znear</I>) и (<I>right, top, zfar</I>), которые 
отвечают левому нижнему и правому верхнему углам окна вывода. Параметры 
<I>near</I> и <I>far</I> задают расстояние до ближней и дальней плоскостей 
отсечения по удалению от точки (0,0,0) и могут быть отрицательными. </P>
<P>Во второй команде, в отличие от первой, значения <I>near</I> и <I>far</I> 
устанавливаются равными –1 и 1 соответственно. Это удобно, если OpenGL 
используется для рисования двумерных объектов. В этом случае положение вершин 
можно задавать, используя команды glVertex2*()</P>
<P>Перспективная проекция определяется командой</P>
<DIV id=XSLTCODE134134147120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void</SPAN> <STRONG>gluPerspective</STRONG> (GLdouble <I>angley</I>, GLdouble <I>aspect</I>,
                     GLdouble <I>znear</I>, GLdouble <I>zfar</I>)  
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>которая задает усеченный конус видимости в левосторонней системе координат. 
Параметр <I>angley</I> определяет угол видимости в градусах по оси у и должен 
находиться в диапазоне от 0 до 180. Угол видимости вдоль оси x задается 
параметром <I>aspect</I>, который обычно задается как отношение сторон области 
вывода (как правило, размеров окна) Параметры <I>zfar</I> и <I>znear</I> задают 
расстояние от наблюдателя до плоскостей отсечения по глубине и должны быть 
положительными. Чем больше отношение <I>zfar</I>/<I>znear</I>, тем хуже в буфере 
глубины будут различаться расположенные рядом поверхности, так как по умолчанию 
в него будет записываться ‘сжатая’ глубина в диапазоне от 0 до 1 (см. п. 0.). 
</P>
<P style="TEXT-ALIGN: center"><IMG src="ogltut2.files/perspective.gif"><BR><I 
style="FONT-SIZE: x-small; font-face: verdana">Рис. 7 Перспективная 
проекция</I></P>
<P>Прежде чем задавать матрицы проекций, не забудьте включить режим работы с 
нужной матрицей командой glMatrixMode(GL_PROJECTION<STRONG>) </STRONG>и<STRONG> 
</STRONG>сбросить текущую, вызвав<STRONG> </STRONG>glLoadIdentity().</P>
<P>Например:</P>
<DIV id=XSLTCODE144134147120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=COMMENT>/* ортографическая проекция */</SPAN>
glMatrixMode(GL_PROJECTION);
glLoadIdentity();
glOrtho(0, w, 0, h, -1.0, 1.0);
</PRE></TD></TR></TBODY></TABLE></DIV>
<H3>Область вывода<A name=XSLTSECTION136147120120></A></H3>
<P>После применения матрицы проекций на вход следующего преобразования подаются 
так называемые усеченные (clipped) координаты. Затем находятся нормализованные 
координаты вершин по формуле:</P>
<P>(x<SUB>n</SUB>, y<SUB>n</SUB>, z<SUB>n</SUB>)<SUP>T</SUP> = 
(x<SUB>c</SUB>/w<SUB>c </SUB>, y<SUB>c</SUB>/w<SUB>c</SUB>, 
z<SUB>c</SUB>/w<SUB>c</SUB>)<SUP>T</SUP></P>
<P>Область вывода представляет собой прямоугольник в оконной системе координат, 
размеры которого задаются командой:</P>
<DIV id=XSLTCODE128136147120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void</SPAN> <STRONG>glViewPort</STRONG> (GLint <I>x</I>, GLint <I>y</I>, GLint <I>width</I>, GLint <I>height</I>)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>Значения всех параметров задаются в пикселах и определяют ширину и высоту 
области вывода с координатами левого нижнего угла (<I>x</I>,<I>y</I>) в оконной 
системе координат. Размеры оконной системы координат определяются текущими 
размерами окна приложения, точка (0,0) находится в левом нижнем углу окна.</P>
<P>Используя параметры команды glViewPort()<STRONG>,</STRONG> OpenGL вычисляет 
оконные координаты центра области вывода (o<SUB>x</SUB>,o<SUB>y</SUB>) по 
формулам o<SUB>x</SUB>=x+width/2, o<SUB>y</SUB>=y+height/2.</P>
<P>Пусть p<SUB>x</SUB>=width, p<SUB>y</SUB>=height, тогда можно найти оконные 
координаты каждой вершины:</P>
<P>(x<SUB>w</SUB>, y<SUB>w</SUB>, z<SUB>w</SUB>)<SUP>T </SUP>= ( 
(p<SUB>x</SUB>/2) x<SUB>n</SUB>+ o<SUB>x </SUB>, (p<SUB>y</SUB>/2) 
y<SUB>n</SUB>+ o<SUB>y , </SUB>[(f-n)/2] z<SUB>n</SUB>+(n+f)/2 )<SUP>T</SUP></P>
<P>При этом целые положительные величины n и f задают минимальную и максимальную 
глубину точки в окне и по умолчанию равны 0 и 1 соответственно. Глубина каждой 
точки записывается в специальный буфер глубины (z-буфер), который используется 
для удаления невидимых линий и поверхностей. Установить значения n и f можно 
вызовом функции</P>
<DIV id=XSLTCODE140136147120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void</SPAN> <STRONG>glDepthRange</STRONG> (GLclampd <I>n</I>, GLclampd <I>f</I>)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>Команда glViewPort() обычно используется в функции, зарегистрированной с 
помощью команды glutReshapeFunc(), которая вызывается, если пользователь 
изменяет размеры окна приложения.</P>
<H4>Контрольные вопросы</H4>
<P>Какие системы координат используются в OpenGL?</P>
<P>Перечислите виды матричных преобразований в OpenGL. Каким образом происходят 
преобразования объектов в OpenGL?</P>
<P>Что такое матричный стек?</P>
<P>Перечислите способы изменения положения наблюдателя в OpenGL.</P>
<P>Какая последовательность вызовов команд glTranslate(), glRotate() и glScale() 
соответствует команде gluLookAt(0, 0, -10, 10, 0, 0, 0, -1, 0)?</P>
<P>Какие вы знаете стандартные команды для задания проекций?</P>
<P>Что такое видовые координаты? Нормализованные координаты?</P>
<P>Как с помощью OpenGL задать косоугольную проекцию?</P>
<H2>Материалы и освещение<A name=XSLTPART149120120></A></H2>
<P>Для создания реалистичных изображений необходимо определить как свойства 
самого объекта, так и свойства среды, в которой он находится. Первая группа 
свойств включает в себя параметры материала, из которого сделан объект, способы 
нанесения текстуры на его поверхность, степень прозрачности объекта. Ко второй 
группе можно отнести количество и свойства источников света, уровень 
прозрачности среды, а также модель освещения. Все эти свойства можно задавать, 
вызывая соответствующие команды OpenGL.</P>
<H3>Модель освещения<A name=XSLTSECTION124149120120></A></H3>
<P>В OpenGL используется модель освещения, в соответствии с которой цвет точки 
определяется несколькими факторами: свойствами материала и текстуры, величиной 
нормали в этой точке, а также положением источника света и наблюдателя. Для 
корректного расчета освещенности в точке надо использовать единичные нормали, 
однако команды типа glScale*(), могут изменять длину нормалей. Чтобы это 
учитывать, используйте уже упоминавшийся в пункте 0 режим нормализации векторов 
нормалей, который включается вызовом команды glEnable(GL_NORMALIZE). </P>
<P>Для задания глобальных параметров освещения используются команды</P>
<DIV id=XSLTCODE126124149120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void</SPAN> <STRONG>glLightModel[i f] </STRONG>(GLenum <I>pname</I>, GLenum <I>param</I>)
<SPAN class=KEYWORD>void</SPAN> <STRONG>glLightModel[i f]v </STRONG>(GLenum <I>pname</I>, 
                         <SPAN class=KEYWORD>const</SPAN> GLtype *<I>params</I>)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>Аргумент <I>pname</I> определяет, какой параметр модели освещения будет 
настраиваться и может принимать следующие значения:</P>
<TABLE cellSpacing=2 cellPadding=5 border=0>
  <TBODY>
  <TR>
    <TD><STRONG>GL_LIGHT_MODEL_LOCAL_VIEWER</STRONG></TD>
    <TD>параметр param должен быть булевским и задает положение наблюдателя. 
      Если он равен FALSE, то направление обзора считается параллельным оси –z, 
      вне зависимости от положения в видовых координатах. Если же он равен TRUE, 
      то наблюдатель находится в начале видовой системы координат. Это может 
      улучшить качество освещения, но усложняет его расчет. Значение по 
      умолчанию: FALSE.</TD></TR>
  <TR>
    <TD><STRONG>GL_LIGHT_MODEL_TWO_SIDE</STRONG></TD>
    <TD>параметр param должен быть булевским и управляет режимом расчета 
      освещенности как для лицевых, так и для обратных граней. Если он равен 
      FALSE, то освещенность рассчитывается только для лицевых граней. Если же 
      он равен TRUE, расчет проводится и для обратных граней. Значение по 
      умолчанию: FALSE.</TD></TR>
  <TR>
    <TD><STRONG>GL_LIGHT_MODEL_AMBIENT</STRONG></TD>
    <TD>параметр params должен содержать четыре целых или вещественных числа, 
      которые определяют цвет фонового освещения даже в случае отсутствия 
      определенных источников света. Значение по умолчанию: (0.2, 0.2, 
    0.2,1.0).</TD></TR></TBODY></TABLE>
<H3>Спецификация материалов<A name=XSLTSECTION126149120120></A></H3>
<P>Для задания параметров текущего материала используются команды</P>
<DIV id=XSLTCODE124126149120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void</SPAN> <STRONG>glMaterial[i f] </STRONG>(GLenum <I>face</I>, GLenum <I>pname</I>, 
                      GLtype <I>param</I>)
<SPAN class=KEYWORD>void</SPAN> <STRONG>glMaterial[i f]v </STRONG>(GLenum <I>face</I>, GLenum <I>pname</I>, 
                       GLtype *<I>params</I>)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>С их помощью можно определить рассеянный, диффузный и зеркальный цвета 
материала, а также степень зеркального отражения и интенсивность излучения 
света, если объект должен светиться. Какой именно параметр будет определяться 
значением <I>param</I>, зависит от значения <I>pname</I>:</P>
<TABLE cellSpacing=2 cellPadding=5 border=0>
  <TBODY>
  <TR>
    <TD><STRONG>GL_AMBIENT</STRONG></TD>
    <TD>параметр params должен содержать четыре целых или вещественных 
      значения цветов RGBA, которые определяют рассеянный цвет материала (цвет 
      материала в тени). Значение по умолчанию: (0.2, 0.2, 0.2, 1.0).</TD></TR>
  <TR>
    <TD><STRONG>GL_DIFFUSE</STRONG></TD>
    <TD>параметр params должен содержать четыре целых или вещественных 
      значения цветов RGBA, которые определяют цвет диффузного отражения 
      материала. Значение по умолчанию: (0.8, 0.8, 0.8, 1.0).</TD></TR>
  <TR>
    <TD><STRONG>GL_SPECULAR</STRONG></TD>
    <TD>параметр params должен содержать четыре целых или вещественных 
      значения цветов RGBA, которые определяют цвет зеркального отражения 
      материала. Значение по умолчанию: (0.0, 0.0, 0.0, 1.0).</TD></TR>
  <TR>
    <TD><STRONG>GL_SHININESS</STRONG></TD>
    <TD>параметр params должен содержать одно целое или вещественное значение 
      в диапазоне от 0 до 128, которое определяет степень зеркального отражения 
      материала. Значение по умолчанию: 0.</TD></TR>
  <TR>
    <TD><STRONG>GL_EMISSION</STRONG></TD>
    <TD>параметр params должен содержать четыре целых или вещественных 
      значения цветов RGBA, которые определяют интенсивность излучаемого света 
      материала. Значение по умолчанию: (0.0, 0.0, 0.0, 1.0).</TD></TR>
  <TR>
    <TD><STRONG>GL_AMBIENT_AND_DIFFUSE</STRONG></TD>
    <TD>эквивалентно двум вызовам команды glMaterial*() со значением pname 
      GL_AMBIENT и GL_DIFFUSE и одинаковыми значениями 
params.</TD></TR></TBODY></TABLE>
<P>Из этого следует, что вызов команды glMaterial[i f]() возможен только для 
установки степени зеркального отражения материала (shininess). Команда 
glMaterial[i f]v() используется для задания остальных параметров. </P>
<P>Параметр <I>face</I> определяет тип граней, для которых задается этот 
материал и может принимать значения <STRONG>GL_FRONT</STRONG>, 
<STRONG>GL_BACK</STRONG> или <STRONG>GL_FRONT_AND_BACK</STRONG>.</P>
<P>Если в сцене материалы объектов различаются лишь одним параметром, 
рекомендуется сначала установить нужный режим, вызвав glEnable() c параметром 
<STRONG>GL_COLOR_MATERIAL</STRONG>, а затем использовать команду</P>
<DIV id=XSLTCODE136126149120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void</SPAN> <STRONG>glColorMaterial </STRONG>(GLenum <I>face</I>, GLenum <I>pname</I>)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>где параметр<I> face</I> имеет аналогичный смысл, а параметр <I>pname</I> 
может принимать все перечисленные значения. После этого значения выбранного с 
помощью <I>pname</I> свойства материала для конкретного объекта (или вершины) 
устанавливаются вызовом команды glColor*(), что позволяет избежать вызовов более 
ресурсоемкой команды glMaterial*() и повышает эффективность программы. Другие 
методы оптимизации приведены в п. 0.</P>
<P>Пример определения свойств материала:</P>
<DIV id=XSLTCODE142126149120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>float</SPAN> mat_dif[]={0.8,0.8,0.8};
<SPAN class=KEYWORD>float</SPAN> mat_amb[] = {0.2, 0.2, 0.2};
<SPAN class=KEYWORD>float</SPAN> mat_spec[] = {0.6, 0.6, 0.6};
<SPAN class=KEYWORD>float</SPAN> shininess = 0.7 * 128;
…
glMaterialfv (GL_FRONT_AND_BACK,GL_AMBIENT, mat_amb);
glMaterialfv (GL_FRONT_AND_BACK,GL_DIFFUSE, mat_dif);
glMaterialfv (GL_FRONT_AND_BACK,GL_SPECULAR, mat_spec);
glMaterialf  (GL_FRONT,GL_SHININESS, shininess);
</PRE></TD></TR></TBODY></TABLE></DIV>
<H3>Описание источников света<A name=XSLTSECTION128149120120></A></H3>
<P>Определение свойств материала объекта имеет смысл, только если в сцене есть 
источники света. Иначе все объекты будут черными (или, строго говоря, иметь 
цвет, равный рассеянному цвету материала, умноженному на интенсивность 
глобального фонового освещения, см. команду glLightModel). Добавить в сцену 
источник света можно с помощью команд</P>
<DIV id=XSLTCODE124128149120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void</SPAN> <STRONG>glLight[i f] </STRONG>(GLenum <I>light</I>, GLenum <I>pname</I>, 
                   GLfloat <I>param</I>)
<SPAN class=KEYWORD>void</SPAN> <STRONG>glLight[i f] </STRONG>(GLenum <I>light</I>, GLenum <I>pname</I>, 
                   GLfloat *<I>params</I>)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P></P>
<P>Параметр <I>light</I> однозначно определяет источник света. Он выбирается из 
набора специальных символических имен вида <STRONG>GL_LIGHTi</STRONG> , где i 
должно лежать в диапазоне от 0 до константы <STRONG>GL_MAX_LIGHT</STRONG>, 
которая обычно не превосходит восьми.</P>
<P>Параметры <I>pname </I>и <I>params</I> имеют смысл, аналогичный команде 
glMaterial*(). Рассмотрим значения параметра <I>pname</I>:</P>
<TABLE cellSpacing=2 cellPadding=5 border=0>
  <TBODY>
  <TR>
    <TD><STRONG>GL_SPOT_EXPONENT</STRONG></TD>
    <TD>параметр param должен содержать целое или вещественное число от 0 до 
      128, задающее распределение интенсивности света. Этот параметр описывает 
      уровень сфокусированности источника света. Значение по умолчанию: 0 
      (рассеянный свет).</TD></TR>
  <TR>
    <TD><STRONG>GL_SPOT_CUTOFF</STRONG></TD>
    <TD>параметр param должен содержать целое или вещественное число между 0 и 
      90 или равное 180, которое определяет максимальный угол разброса света. 
      Значение этого параметра есть половина угла в вершине конусовидного 
      светового потока, создаваемого источником. Значение по умолчанию: 180 
      (рассеянный свет).</TD></TR>
  <TR>
    <TD><STRONG>GL_AMBIENT</STRONG></TD>
    <TD>параметр params должен содержать четыре целых или вещественных 
      значения цветов RGBA, которые определяют цвет фонового освещения. Значение 
      по умолчанию: (0.0, 0.0, 0.0, 1.0).</TD></TR>
  <TR>
    <TD><STRONG>GL_DIFFUSE </STRONG></TD>
    <TD>параметр params должен содержать четыре целых или вещественных 
      значения цветов RGBA, которые определяют цвет диффузного освещения. 
      Значение по умолчанию: (1.0, 1.0, 1.0, 1.0) для LIGHT0 и (0.0, 0.0, 0.0, 
      1.0) для остальных.</TD></TR>
  <TR>
    <TD><STRONG>GL_SPECULAR</STRONG></TD>
    <TD>параметр params должен содержать четыре целых или вещественных 
      значения цветов RGBA, которые определяют цвет зеркального отражения. 
      Значение по умолчанию: (1.0, 1.0, 1.0, 1.0) для LIGHT0 и (0.0, 0.0, 0.0, 
      1.0) для остальных.</TD></TR>
  <TR>
    <TD><STRONG>GL_POSITION </STRONG></TD>
    <TD>параметр <I>params</I> должен содержать четыре целых или вещественных 
      числа, которые определяют положение источника света. Если значение 
      компоненты w равно 0.0, то источник считается бесконечно удаленным и при 
      расчете освещенности учитывается только направление на точку (x,y,z), в 
      противном случае считается, что источник расположен в точке (x,y,z,w). В 
      первом случае ослабления света при удалении от источника не происходит, 
      т.е. источник считается бесконечно удаленным. Значение по умолчанию: (0.0, 
      0.0, 1.0, 0.0).</TD></TR>
  <TR>
    <TD><STRONG>GL_SPOT_DIRECTION</STRONG></TD>
    <TD>параметр <I>params</I> должен содержать четыре целых или вещественных 
      числа, которые определяют направление света. Значение по умолчанию: (0.0, 
      0.0, -1.0, 1.0). Эта характеристика источника имеет смысл, если значение 
      <STRONG>GL_SPOT_CUTOFF</STRONG> отлично от 180 (которое, кстати, задано по 
      умолчанию). </TD></TR>
  <TR>
    <TD><STRONG>GL_CONSTANT_ATTENUATION, GL_LINEAR_ATTENUATION, 
      GL_QUADRATIC_ATTENUATION</STRONG></TD>
    <TD>параметр <I>params</I> задает значение одного из трех коэффициентов, 
      определяющих ослабление интенсивности света при удалении от источника. 
      Допускаются только неотрицательные значения. Если источник не является 
      направленным (см. <STRONG>GL_POSITION</STRONG>), то ослабление обратно 
      пропорционально сумме: 
      <STRONG>att</STRONG><SUB>constant</SUB>+att<SUB>linear</SUB>*d+ 
      att<SUB>quadratic</SUB> *d<SUP>2</SUP>, где d – расстояние между 
      источником света и освещаемой им вершиной, 
      <STRONG>att</STRONG><SUB>constant</SUB>, att<SUB>linear</SUB> и 
      att<SUB>quadratic</SUB> равны параметрам, заданным с помощью 
      констант&nbsp;<STRONG>GL_CONSTANT_ATTENUATION</STRONG>, 
      <STRONG>GL_LINEAR_ATTENUATION&nbsp;</STRONG>и 
      <STRONG>GL_QUADRATIC_ATTENUATION</STRONG> соответственно. По умолчанию эти 
      параметры задаются тройкой (1, 0, 0), и фактически ослабления не 
      происходит. </TD></TR></TBODY></TABLE>
<P>При изменении положения источника света следует учитывать следующий факт: в 
OpenGL источники света являются объектами, во многом такими же, как 
многоугольники и точки. На них распространяется основное правило обработки 
координат в OpenGL – параметры, описывающее положение в пространстве, 
преобразуются текущей модельно-видовой матрицей в момент формирования объекта, 
т.е. в момент вызова соответствующих команд OpenGL. Таким образом, формируя 
источник света одновременно с объектом сцены или камерой, его можно привязать к 
этому объекту. Или, наоборот, сформировать стационарный источник света, который 
будет оставаться на месте, пока другие объекты перемещаются.</P>
<P>Общее правило такое:</P>
<P>Если положение источника света задается командой glLight*() перед 
определением положения виртуальной камеры (например, командой glLookAt()), то 
будет считаться, что координаты (0,0,0) источника находится в точке наблюдения 
и, следовательно, положение источника света определяется относительно положения 
наблюдателя.</P>
<P>Если положение устанавливается между определением положения камеры и 
преобразованиями модельно-видовой матрицы объекта, то оно фиксируется, т.е. в 
этом случае положение источника света задается в мировых координатах. </P>
<P>Для использования освещения сначала надо установить соответствующий режим 
вызовом команды glEnable(GL_LIGHTNING), а затем включить нужный источник 
командой glEnable(GL_LIGHTi). </P>
<P>Еще раз обратим внимание на то, что при выключенном освещении цвет вершины 
равен текущему цвету, который задается командами glColor*(). При включенном 
освещении цвет вершины вычисляется исходя из информации о материале, нормалях и 
источниках света.</P>
<P>При выключении освещения визуализация происходит быстрее, однако в таком 
случае приложение должно само рассчитывать цвета вершин.</P>
<P>Текст программы, демонстрирующей основные принципы определения материалов и 
источников света, приведен в приложении 0</P>
<H3>Создание эффекта тумана<A name=XSLTSECTION130149120120></A></H3>
<P>В завершение рассмотрим одну интересную и часто используемую возможность 
OpenGL – создание эффекта тумана. Легкое затуманивание сцены создает 
реалистичный эффект, а частенько может и скрыть некоторые артефакты, которые 
появляются, когда в сцене присутствуют отдаленные объекты.</P>
<P>Туман в OpenGL реализуется путем изменения цвета объектов в сцене в 
зависимости от их глубины, т.е. расстояния до точки наблюдения. Изменение цвета 
происходит либо для вершин примитивов, либо для каждого пикселя на этапе 
растеризации в зависимости от реализации OpenGL. Этим процессом можно частично 
управлять – см. раздел 0.</P>
<P>Для включения эффекта затуманивания необходимо вызвать команду 
<STRONG>glEnable(GL_FOG)</STRONG>. </P>
<P>Метод вычисления интенсивности тумана в вершине можно определить с помощью 
команд</P>
<DIV id=XSLTCODE130130149120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void</SPAN> <STRONG>glFog[if]</STRONG> (enum <I>pname</I>, T <I>param</I>) 
<SPAN class=KEYWORD>void</SPAN> <STRONG>glFog[if]v</STRONG> (enum <I>pname</I>, T <I>params</I>)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>Аргумент <I>pname</I> может принимать следующие значения:</P>
<P><STRONG>GL_FOG_MODE </STRONG>аргумент <I>param</I> определяет формулу, по 
которой будет вычисляться интенсивность тумана в точке. </P>
<P>В этом случае <I>param</I> может принимать значения </P>
<TABLE cellSpacing=2 cellPadding=5 border=0>
  <TBODY>
  <TR>
    <TD><STRONG>GL_EXP</STRONG></TD>
    <TD>Интенсивность вычисляется по формуле f=exp(-d*z)</TD></TR>
  <TR>
    <TD><STRONG>GL_EXP2</STRONG></TD>
    <TD>Интенсивность вычисляется по формуле f=exp(-(d*z)<SUP>2</SUP>)</TD></TR>
  <TR>
    <TD><STRONG>GL_LINEAR</STRONG> </TD>
    <TD>Интенсивность вычисляется по формуле f=e-z/e-sгде z – расстояние от 
      вершины, в которой вычисляется интенсивность тумана, до точки 
      наблюдения.Коэффициенты d,e,s задаются с помощью следующих значений 
      аргумента <I>pname</I></TD></TR>
  <TR>
    <TD><STRONG>GL_FOG_DENSITY</STRONG></TD>
    <TD><I>param</I> определяет коээфициент d </TD></TR>
  <TR>
    <TD><STRONG>GL_FOG_START</STRONG></TD>
    <TD><I>param</I> определяет коэффициент s </TD></TR>
  <TR>
    <TD><STRONG>GL_FOG_END</STRONG></TD>
    <TD>param определяет коэффициент e </TD></TR></TBODY></TABLE>
<P>Цвет тумана задается с помощью аргумента <I>pname</I>, равного</P>
<TABLE cellSpacing=2 cellPadding=5 border=0>
  <TBODY>
  <TR>
    <TD><STRONG>GL_FOG_COLOR</STRONG></TD>
    <TD><I>params</I> – указатель на массив из 4-х компонент 
  цвета</TD></TR></TBODY></TABLE>
<P>Приведем пример использования этого эффекта:</P>
<DIV id=XSLTCODE146130149120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE>GLfloat FogColor[4]={0.5,0.5,0.5,1};
glEnable(GL_FOG);
glFogi(GL_FOG_MODE,GL_LINEAR);
glFogf(GL_FOG_START,20.0);
glFogf(GL_FOG_END,100.0);
glFogfv(GL_FOG_COLOR,FogColor);
</PRE></TD></TR></TBODY></TABLE></DIV>
<H4>Контрольные вопросы</H4>
<P>Поясните разницу между локальными и бесконечно удаленными источниками 
света.</P>
<P>Для чего служит команда glColorMaterial?</P>
<P>Как задать положение источника света таким образом, чтобы он всегда находился 
в точке положения наблюдателя?</P>
<P>Как задать фиксированное положение источника света? Можно ли задавать 
положение источника относительно локальных координат объекта?</P>
<P>Как задать конусный источник света?</P>
<P>Если в сцене включено освещение, но нет источников света, какой цвет будут 
иметь объекты?</P>
<H2>Текстурирование<A name=XSLTPART151120120></A></H2>
<P>Под <I>текстурой</I> будем понимать некоторое изображение, которое надо 
определенным образом нанести на объект, например, для придания иллюзии 
рельефности поверхности.</P>
<P>Наложение текстуры на поверхность объектов сцены повышает ее реалистичность, 
однако при этом надо учитывать, что этот процесс требует вычислительных затрат, 
особенно если OpenGL не поддерживается аппаратно. </P>
<P>Для работы с текстурой следует выполнить следующую последовательность 
действий: </P>
<P>выбрать изображение и преобразовать его к нужному формату;</P>
<P>передать изображение в OpenGL;</P>
<P>определить, как текстура будет наноситься на объект и как она будет с ним 
взаимодействовать;</P>
<P>связать текстуру с объектом.</P>
<H3>Подготовка текстуры<A name=XSLTSECTION136151120120></A></H3>
<P>Для использования текстуры необходимо сначала загрузить в память нужное 
изображение и передать его OpenGL.</P>
<P>Считывание графических данных из файла и их преобразование можно проводить 
вручную. Можно также воспользоваться функцией, входящей в состав библиотеки 
GLAUX (для ее использования надо дополнительно подключить glaux.lib), которая 
сама проводит необходимые операции. Это функция</P>
<DIV id=XSLTCODE126136151120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE>AUX_RGBImageRec* auxDIBImageLoad (<SPAN class=KEYWORD>const</SPAN> <SPAN class=KEYWORD>char</SPAN> *file)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>где <I>file</I> – название файла с расширением *.bmp или *.dib. Функция 
возвращает указатель на область памяти, где хранятся преобразованные данные.</P>
<P>При создании образа текстуры в памяти следует учитывать следующие требования: 
</P>
<P>Во-первых, размеры текстуры, как по горизонтали, так и по вертикали должны 
представлять собой степени двойки. Это требование накладывается для компактного 
размещения текстуры в текстурной памяти и способствует ее эффективному 
использованию. Работать только с такими текстурами конечно неудобно, поэтому 
после загрузки их надо преобразовать. Изменение размеров текстуры можно провести 
с помощью команды</P>
<DIV id=XSLTCODE134136151120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void</SPAN> gluScaleImage (GLenum format, GLint widthin, 
                    GL heightin, GLenum typein, 
                    <SPAN class=KEYWORD>const</SPAN> <SPAN class=KEYWORD>void</SPAN> *datain, 
                    GLint widthout, 
                    GLint heightout, GLenum typeout, 
                    <SPAN class=KEYWORD>void</SPAN> *dataout)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>В качестве значения параметра <I>format</I> обычно используется значение 
<STRONG>GL_RGB</STRONG> или <STRONG>GL_RGBA</STRONG>, определяющее формат 
хранения информации. Параметры <I>widthin</I>, <I>heightin</I>, <I>widhtout</I>, 
<I>heightout</I> определяют размеры входного и выходного изображений, а с 
помощью <I>typein</I> и <I>typeout</I> задается тип элементов массивов, 
расположенных по адресам <I>datain</I> и <I>dataout</I>. Как и обычно, это может 
быть тип <STRONG>GL_UNSIGNED_BYTE, GL_SHORT, GL_INT</STRONG> и так далее. 
Результат своей работы функция заносит в область памяти, на которую указывает 
параметр <I>dataout</I>. </P>
<P>Во-вторых, надо предусмотреть случай, когда объект после растеризации 
оказывается по размерам значительно меньше наносимой на него текстуры. Чем 
меньше объект, тем меньше должна быть наносимая на него текстура и поэтому 
вводится понятие <I>уровней детализации текстуры</I>. (mipmap) Каждый уровень 
детализации задает некоторое изображение, которое является, как правило, 
уменьшенной в два раза копией оригинала. Такой подход позволяет улучшить 
качество нанесения текстуры на объект. Например, для изображения размером 
2<SUP>m</SUP>x2<SUP>n </SUP>можно построить max(m,n)+1 уменьшенных изображений, 
соответствующих различным уровням детализации. </P>
<P>Эти два этапа создания образа текстуры во внутренней памяти OpenGL можно 
провести с помощью команды</P>
<DIV id=XSLTCODE142136151120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void</SPAN> <STRONG>gluBuild2DMipmaps </STRONG>(GLenum <I>target</I>, GLint <I>components</I>, 
                        GLint <I>width</I>, GLint <I>height</I>, 
                        GLenum <I>format</I>, GLenum <I>type</I>, 
                        <SPAN class=KEYWORD>const</SPAN> <SPAN class=KEYWORD>void</SPAN> *<I>data</I>)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P></P>
<P>где параметр <I>target</I> должен быть равен <STRONG>GL_TEXTURE_2D.</STRONG> 
Параметр <I>components</I> определяет количество цветовых компонент текстуры и 
может принимать следующие основные значения:</P>
<TABLE cellSpacing=2 cellPadding=5 border=0>
  <TBODY>
  <TR>
    <TD><STRONG>GL_LUMINANCE</STRONG></TD>
    <TD>одна компонента – яркость. (текстура будет монохромной)</TD></TR>
  <TR>
    <TD><STRONG>GL_RGB</STRONG></TD>
    <TD>красный, синий, зеленый</TD></TR>
  <TR>
    <TD><STRONG>GL_RGBA</STRONG></TD>
    <TD>все компоненты</TD></TR></TBODY></TABLE>
<P>Параметры <I>width</I>, <I>height</I>, <I>data</I> определяют размеры и 
расположение текстуры соответственно, а <I>format</I> и <I>type</I> имеют 
аналогичный смысл, что и в команде gluScaleImage().</P>
<P>После выполнения этой команды текстура копируется во внутреннюю память 
OpenGL, и поэтому память, занимаемую исходным изображением, можно 
освободить.</P>
<P>В OpenGL допускается использование одномерных текстур, то есть размера 1xN, 
однако, это всегда надо указывать, задавая в качестве значения <I>target</I> 
константу <STRONG>GL_TEXTURE_1D</STRONG>. Полезность одномерных текстур 
сомнительна, поэтому не будем останавливаться на этом подробно.</P>
<P>При использовании в сцене нескольких текстур, в OpenGL применяется подход, 
напоминающий создание списков изображений (так называемые <I>текстурные 
объекты</I>). Сначала с помощью команды </P>
<DIV id=XSLTCODE158136151120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void</SPAN> <STRONG>glGenTextures </STRONG>(GLsizei<I> n</I>, GLuint* <I>textures</I>)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>надо создать <I>n</I> идентификаторов текстур, которые будут записаны в 
массив <I>textures</I>. Перед началом определения свойств очередной текстуры 
следует сделать ее текущей («привязать» текстуру), вызвав команду</P>
<DIV id=XSLTCODE162136151120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void</SPAN> <STRONG>glBindTexture </STRONG>(GLenum <I>target</I>, GLuint <I>texture</I>)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>где <I>target</I> может принимать значения <STRONG>GL_TEXTURE_1D</STRONG> или 
<STRONG>GL_TEXTURE_2D</STRONG>, а параметр <I>texture</I> должен быть равен 
идентификатору той текстуры, к которой будут относиться последующие команды. Для 
того, чтобы в процессе рисования сделать текущей текстуру с некоторым 
идентификатором, достаточно опять вызвать команду glBindTexture() c 
соответствующим значением <I>target</I> и <I>texture</I>. Таким образом, команда 
glBindTexture() включает режим создания текстуры с идентификатором 
<I>texture</I>, если такая текстура еще не создана, либо режим ее использования, 
то есть делает эту текстуру текущей.</P>
<P>Так как не всякая аппаратура может оперировать текстурами большого размера, 
целесообразно ограничить размеры текстуры до 256x256 или 512x512 пикселей. 
Отметим, что использование небольших текстур повышает эффективность 
программы.</P>
<H3>Наложение текстуры на объекты<A name=XSLTSECTION138151120120></A></H3>
<P>При наложении текстуры, как уже упоминалось, надо учитывать случай, когда 
размеры текстуры отличаются от оконных размеров объекта, на который она 
накладывается. При этом возможно как растяжение, так и сжатие изображения, и то, 
как будут проводиться эти преобразования, может серьезно повлиять на качество 
построенного изображения. Для определения положения точки на текстуре 
используется параметрическая система координат (s,t), причем значения s и t 
находятся в отрезке [0,1] (см. рисунок)</P>
<P style="TEXT-ALIGN: center"><IMG src="ogltut2.files/ts.gif"><BR><I 
style="FONT-SIZE: x-small; font-face: verdana">Рис. 8 Текстурные 
координаты</I></P>
<P>Для изменения различных параметров текстуры применяются команды:</P>
<DIV id=XSLTCODE128138151120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void</SPAN> <STRONG>glTexParameter[i f]</STRONG> (GLenum <I>target</I>, GLenum <I>pname</I>,
                          GLenum <I>param</I>)
<SPAN class=KEYWORD>void</SPAN> <STRONG>glTexParameter[i f]v</STRONG> (GLenum <I>target</I>, GLenum <I>pname</I>,
                           Glenum* <I>params</I>)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>При этом <I>target</I> может принимать значения 
<STRONG>GL_TEXTURE_1D</STRONG> или <STRONG>GL_TEXTURE_2D</STRONG>, <I>pname</I> 
определяет, какое свойство будем менять, а с помощью <I>param</I> или 
<I>params</I> устанавливается новое значение. Возможные значения 
<I>pname</I>:</P>
<TABLE cellSpacing=2 cellPadding=5 border=0>
  <TBODY>
  <TR>
    <TD><STRONG>GL_TEXTURE_MIN_FILTER</STRONG></TD>
    <TD>параметр param определяет функцию, которая будет использоваться для 
      сжатия текстуры. При значении <STRONG>GL_NEAREST</STRONG> будет 
      использоваться один (ближайший), а при значении <STRONG>GL_LINEAR</STRONG> 
      четыре ближайших элемента текстуры. Значение по умолчанию: 
      <STRONG>GL_LINEAR</STRONG></TD></TR>
  <TR>
    <TD><STRONG>GL_TEXTURE_MAG_FILTER</STRONG></TD>
    <TD>параметр <I>param</I> определяет функцию, которая будет использоваться 
      для увеличения (растяжения) текстуры. При значении 
      <STRONG>GL_NEAREST</STRONG> будет использоваться один (ближайший), а при 
      значении <STRONG>GL_LINEAR</STRONG> четыре ближайших элемента текстуры. 
      Значение по умолчанию:<STRONG>GL_LINEAR</STRONG></TD></TR>
  <TR>
    <TD><STRONG>GL_TEXTURE_WRAP_S</STRONG></TD>
    <TD>параметр <I>param</I> устанавливает значение координаты s, если оно не 
      входит в отрезок [0,1]. При значении <STRONG>GL_ REPEAT</STRONG> целая 
      часть s отбрасывается, и в результате изображение размножается по 
      поверхности. При значении <STRONG>GL_CLAMP</STRONG> используются краевые 
      значения: 0 или 1, что удобно использовать, если на объект накладывается 
      один образ. Значение по умолчанию: <STRONG>GL_REPEAT</STRONG></TD></TR>
  <TR>
    <TD><STRONG>GL_TEXTURE_WRAP_T</STRONG></TD>
    <TD>аналогично предыдущему значению, только для координаты 
t</TD></TR></TBODY></TABLE>
<P>Использование режима <STRONG>GL_NEAREST</STRONG> повышает скорость наложения 
текстуры, однако при этом снижается качество, так как в отличие от 
<STRONG>GL_LINEAR</STRONG> интерполяция не производится. </P>
<P>Для того чтобы определить, как текстура будет взаимодействовать с материалом, 
из которого сделан объект, используются команды</P>
<DIV id=XSLTCODE138138151120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void</SPAN> <STRONG>glTexEnv[i f]</STRONG>  (GLenum <I>target</I>, GLenum <I>pname</I>, 
                     GLtype <I>param</I>)
<SPAN class=KEYWORD>void</SPAN> <STRONG>glTexEnv[i f]v</STRONG> (GLenum <I>target</I>, GLenum <I>pname</I>, 
                     GLtype *<I>params</I>)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>Параметр <I>target</I> должен быть равен <STRONG>GL_TEXTURE_ENV</STRONG>, а в 
качестве <I>pname</I> рассмотрим только одно значение 
<STRONG>GL_TEXTURE_ENV_MODE</STRONG>, которое наиболее часто применяется. </P>
<P>Наиболее часто используемые значения параметра <I>param</I>:</P>
<TABLE cellSpacing=2 cellPadding=5 border=0>
  <TBODY>
  <TR>
    <TD><STRONG>GL_MODULATE</STRONG></TD>
    <TD>конечный цвет находится как произведение цвета точки на поверхности и 
      цвета соответствующей ей точки на текстуре.</TD></TR>
  <TR>
    <TD><STRONG>GL_REPLACE</STRONG></TD>
    <TD>в качестве конечного цвета используется цвет точки на 
  текстуре.</TD></TR></TBODY></TABLE>
<P>Следующая программа демонстрирует общий подход к созданию текстур:</P>
<DIV id=XSLTCODE148138151120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=COMMENT>/* нужное нам количество текстур */</SPAN>
<SPAN class=KEYWORD>#define</SPAN> NUM_TEXTURES 10 
<SPAN class=COMMENT>/* идентификаторы текстур */</SPAN>
<SPAN class=KEYWORD>int</SPAN> TextureIDs[NUM_TEXTURES];  
<SPAN class=COMMENT>/* образ текстуры */</SPAN>
AUX_RGBImageRec *pImage;

…
<SPAN class=COMMENT>/* 1) получаем идентификаторы текстур */</SPAN>
glGenTextures(NUM_TEXTURES,TextureIDs);
<SPAN class=COMMENT>/* 2) выбираем текстуру для модификации параметров */</SPAN>
glBindTexture(TextureIDs[i]); <SPAN class=COMMENT>/* 0&lt;=i&lt;NUM_TEXTURES*/</SPAN>
<SPAN class=COMMENT>/* 3) загружаем текстуру. Размеры текстуры – степень 2 */</SPAN>
pImage=dibImageLoad(<SPAN class=STRING>"texture.bmp"</SPAN>);
<SPAN class=KEYWORD>if</SPAN> (Texture!=NULL)
{
  <SPAN class=COMMENT>/* 4) передаем текстуру OpenGL и задаем параметры*/</SPAN>
  <SPAN class=COMMENT>/* выравнивание по байту */</SPAN>
  glPixelStorei(GL_UNPACK_ALIGNMENT,1);
  gluBuildMipmaps(GL_TEXTURE_2D,GL_RGB, pImage-&gt;sizeX, 
    pImage-&gt;sizeY, GL_RGB, GL_UNSIGNED_BYTE, 
    pImage-&gt;data);
  glTexParameterf(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,
    (<SPAN class=KEYWORD>float</SPAN>)GL_LINEAR);
  glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
    (<SPAN class=KEYWORD>float</SPAN>)GL_LINEAR);
  glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S,
    (<SPAN class=KEYWORD>float</SPAN>)GL_REPEAT);
  glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T,
    (<SPAN class=KEYWORD>float</SPAN>)GL_REPEAT);
  glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE,
    (<SPAN class=KEYWORD>float</SPAN>)GL_REPLACE);
  <SPAN class=COMMENT>/* 5) удаляем исходное изображение.*/</SPAN>
  free(Texture);
}<SPAN class=KEYWORD>else</SPAN> Error();
</PRE></TD></TR></TBODY></TABLE></DIV>
<H3>Текстурные координаты<A name=XSLTSECTION140151120120></A></H3>
<P>Перед нанесением текстуры на объект необходимо установить соответствие между 
точками на поверхности объекта и на самой текстуре. Задавать это соответствие 
можно двумя методами: отдельно для каждой вершины или сразу для всех вершин, 
задав параметры специальной функции отображения.</P>
<P>Первый метод реализуется с помощью команд</P>
<DIV id=XSLTCODE126140151120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void</SPAN> <STRONG>glTexCoord[1 2 3 4][s i f d]</STRONG>  (type <I>coord</I>)
<SPAN class=KEYWORD>void</SPAN> <STRONG>glTexCoord[1 2 3 4][s i f d]v</STRONG> (type *<I>coord</I>)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P></P>
<P>Чаще всего используется команды вида <STRONG>glTexCoord2*(type s, type 
t)</STRONG>, задающие текущие координаты текстуры. Понятие текущих координат 
текстуры аналогично понятиям текущего цвета и текущей нормали, и является 
атрибутом вершины. Однако даже для куба нахождение соответствующих координат 
текстуры является довольно трудоемким занятием, поэтому в библиотеке GLU помимо 
команд, проводящих построение таких примитивов, как сфера, цилиндр и диск, 
предусмотрено также наложение на них текстур. Для этого достаточно вызвать 
команду</P>
<DIV id=XSLTCODE132140151120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void</SPAN> <STRONG>gluQuadricTexture</STRONG> (GLUquadricObj* <I>quadObject</I>, GLboolean<I> textureCoords</I>)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P></P>
<P>с параметром <I>textureCoords</I> равным <STRONG>GL_TRUE</STRONG>, и тогда 
текущая текстура будет автоматически накладываться на примитив.</P>
<P>Второй метод реализуется с помощью команд</P>
<DIV id=XSLTCODE140140151120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void</SPAN> <STRONG>glTexGen[i f d] </STRONG> (GLenum <I>coord</I>, GLenum <I>pname</I>, 
                       GLtype <I>param</I>)
<SPAN class=KEYWORD>void</SPAN> <STRONG>glTexGen[i f d]v</STRONG> (GLenum <I>coord</I>, GLenum <I>pname</I>,
                       <SPAN class=KEYWORD>const</SPAN> GLtype *<I>params</I>)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>Параметр <I>coord</I> определяет, для какой координаты задается формула, и 
может принимать значение <STRONG>GL_S,GL_T</STRONG>; <I>pname</I> может быть 
равен одному из следующих значений:</P>
<TABLE cellSpacing=2 cellPadding=5 border=0>
  <TBODY>
  <TR>
    <TD><STRONG>GL_TEXTURE_GEN_MODE</STRONG></TD>
    <TD>определяет функцию для наложения текстуры.</TD></TR></TBODY></TABLE>
<P>В этом случае аргумент <I>param</I> принимает значения:</P>
<TABLE cellSpacing=2 cellPadding=5 border=0>
  <TBODY>
  <TR>
    <TD><STRONG>GL_OBJECT_LINEAR</STRONG></TD>
    <TD>значение соответствующей текстурной координаты определяется 
      расстоянием до плоскости, задаваемой с помощью значения pname 
      GL_OBJECT_PLANE (см. ниже). Формула выглядит следующим образом: 
      g=x*xp+y*yp+z*zp+w*wp, где g-соответствующая текстурная координата ( s или 
      p), x, y, z, w – координаты соответствующей точки. xp, yp, zp, wp – 
      коэффициенты уравнения плоскости. В формуле используются координаты 
      объекта.</TD></TR>
  <TR>
    <TD><STRONG>GL_EYE_LINEAR</STRONG></TD>
    <TD>аналогично предыдущему значению, только в формуле используются видовые 
      координаты. Т.е. координаты текстуры объекта в этом случае зависят от 
      положения этого объекта.</TD></TR>
  <TR>
    <TD><STRONG>GL_SPHERE_MAP</STRONG></TD>
    <TD>позволяет эмулировать отражение от поверхности объекта. Текстура как 
      бы "оборачивается" вокруг объекта. Для данного метода используются видовые 
      координаты и необходимо задание нормалей.</TD></TR>
  <TR>
    <TD><STRONG>GL_OBJECT_PLANE</STRONG></TD>
    <TD>позволяет задать плоскость, расстояние до которой будет использоваться 
      при генерации координат, если установлен режим GL_OBJECT_LINEAR. В этом 
      случае параметр params является указателем на массив из четырех 
      коэффициентов уравнения плоскости.</TD></TR>
  <TR>
    <TD><STRONG>GL_EYE_PLANE</STRONG></TD>
    <TD>аналогично предыдущему значению. Позволяет задать плоскость для режима 
      GL_EYE_LINEAR</TD></TR></TBODY></TABLE>
<P>Для установки автоматического режима задания текстурных координат необходимо 
вызвать команду glEnable с параметром <STRONG>GL_TEXTURE_GEN_S</STRONG> или 
<STRONG>GL_TEXTURE_GEN_P</STRONG>.</P>
<P>Пример:</P>
<P>Рассмотрим, как можно задать зеркальную текстуру. При таком наложении 
текстуры изображение будет как бы отражаться от поверхности объекта, вызывая 
интересный оптический эффект. Для этого сначала надо создать два целочисленных 
массива коэффициентов s_coeffs и t_coeffs со значениями (1,0,0,1) и (0,1,0,1) 
соответственно, а затем вызвать команды:</P>
<DIV id=XSLTCODE156140151120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE>glEnable (GL_TEXTURE_GEN_S);
glTexGeni (GL_S, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR);
glTexGendv (GL_S, GL_EYE_PLANE, s_coeffs);
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>и такие же команды для координаты <U><I>t</I></U> с соответствующими 
изменениями.</P>
<P>Программа, использующая наложение текстуры и анимацию, приведена в приложении 
0</P>
<H4>Контрольные вопросы</H4>
<P>Что такое текстура и для чего используются текстуры?</P>
<P>Что такое текстурные координаты и как задать их для объекта?</P>
<P>Какой метод взаимодействия с материалом (GL_MODULATE, GL_REPLACE) нужно 
использовать, если текстура представляет собой картину, висящую на стене?</P>
<P>Перечислите известные вам методы генерации текстурных координат в OpenGL.</P>
<P>Для чего используются уровни детализации текстуры (mip-mapping)?</P>
<P>Что такое режимы фильтрации текстуры и как задать их в OpenGL?</P>
<H2>Операции с пикселями<A name=XSLTPART153120120></A></H2>
<P>После проведения всех операций по преобразованию координат вершин, вычисления 
цвета и т.п., OpenGL переходит к этапу <I>растеризации</I>, на котором 
происходит растеризация всех примитивов, наложение текстуры, наложение эффекта 
тумана. Для каждого примитива результатом этого процесса является занимаемая им 
в буфере кадра область, каждому пикселю этой области приписывается цвет и 
значение глубины.</P>
<P>OpenGL использует эту информацию, чтобы записать обновленные данные в буфер 
кадра. Для этого OpenGL имеет не только отдельный конвейер обработки пикселей, 
но и несколько дополнительных буферов различного назначения. Это позволяет 
программисту гибко контролировать процесс визуализации на самом низком 
уровне.</P>
<P>Графическая библиотека OpenGL поддерживает работу со следующими буферами:</P>
<P>несколько буферов цвета</P>
<P>буфер глубины</P>
<P>буфер-накопитель (аккумулятор)</P>
<P>буфер маски</P>
<P>Группа буферов цвета включает буфер кадра, но таких буферов может быть 
несколько. При использовании двойной буферизации говорят о рабочем (front) и 
фоновом (back) буферах. Как правило, в фоновом буфере программа создает 
изображение, которое затем разом копируется в рабочий буфер. На экране может 
появиться информация только из буферов цвета.</P>
<P>Буфер глубины используется для удаления невидимых поверхностей и прямая 
работа с ним требуется крайне редко.</P>
<P>Буфер-накопитель можно применять для различных операций. Более подробно 
работа с ним описана в разделе 0.</P>
<P>Буфер маски используется для формирования пиксельных масок (трафаретов), 
служащих для вырезания из общего массива тех пикселей, которые следует вывести 
на экран. Буфер маски и работа с ним более подробно рассмотрены в разделах 0, 0 
и 0.</P>
<H3>Смешивание изображений. Прозрачность<A 
name=XSLTSECTION144153120120></A></H3>
<P>Разнообразные прозрачные объекты – стекла, прозрачная посуда и т.д. часто 
встречаются в реальности, поэтому важно уметь создавать такие объекты в 
интерактивной графике. OpenGL предоставляет программисту механизм работы с 
полупрозрачными объектами, который и будет кратко описан в этом разделе.</P>
<P>Прозрачность реализуется с помощью специального режима смешения цветов 
(blending). Алгоритм смешения комбинирует цвета так называемых входящих пикселей 
(т.е. «кандидатов» на помещение в буфер кадра) с цветами соответствующих 
пикселей, уже хранящихся в буфере. Для смешения используется четвертая 
компонента цвета – альфа-компонента, поэтому этот режим называют еще 
альфа-смешиванием. Программа может управлять интенсивностью альфа-компоненты 
точно так же, как и интенсивностью основных цветов, т.е. задавать значение 
интенсивности для каждого пикселя или каждой вершины примитива.</P>
<P>Режим включается с помощью команды glEnable(GL_BLEND).</P>
<P>Определить параметры смешения можно с помощью команды:</P>
<DIV id=XSLTCODE130144153120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void </SPAN><STRONG>glBlendFunc</STRONG>(<SPAN class=KEYWORD>enum </SPAN><I>src</I>,<SPAN class=KEYWORD>enum</SPAN> <I>dst</I>)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>Параметр <I>src</I> определяет, как получить коэффициент k<SUB>1</SUB> 
исходного цвета пикселя, a <I>dst</I> задает способ получения коэффициента 
k<SUB>2</SUB> для цвета в буфере кадра. Для получения результирующего цвета 
используется следующая формула: 
res=с<SUB>src</SUB>*k<SUB>1</SUB>+c<SUB>dst</SUB>*k<SUB>2</SUB>, где с<SUB>src 
</SUB>– цвет исходного пикселя, c<SUB>dst </SUB>– цвет пикселя в буфере кадра 
(res, k<SUB>1</SUB>, k<SUB>1</SUB>, с<SUB>src,</SUB> c<SUB>dst </SUB>– 
четырехкомпонентные RGBA-векторы).</P>
<P>Приведем наиболее часто используемые значения агрументов src и dst.</P>
<TABLE cellSpacing=2 cellPadding=5 border=0>
  <TBODY>
  <TR>
    <TD><STRONG>GL_SRC_ALPHA</STRONG></TD>
    <TD>k=(A<SUB>s</SUB>,A<SUB>s</SUB>,A<SUB>s</SUB>,A<SUB>s</SUB>)</TD></TR>
  <TR>
    <TD><STRONG>GL_SRC_ONE_MINUS_ALPHA</STRONG></TD>
    <TD>k=(1,1,1,1)-(A<SUB>s</SUB>,A<SUB>s</SUB>,A<SUB>s</SUB>,A<SUB>s</SUB>)</TD></TR>
  <TR>
    <TD><STRONG>GL_DST_COLOR</STRONG></TD>
    <TD>k=(R<SUB>d</SUB>,G<SUB>d</SUB>,B<SUB>d</SUB>)</TD></TR>
  <TR>
    <TD><STRONG>GL_ONE_MINUS_DST_COLOR</STRONG></TD>
    <TD>k=(1,1,1,1)- 
    (R<SUB>d</SUB>,G<SUB>d</SUB>,B<SUB>d</SUB>,А<SUB>d</SUB>)</TD></TR>
  <TR>
    <TD><STRONG>GL_DST_ALPHA</STRONG></TD>
    <TD>k=(A<SUB>d</SUB>,A<SUB>d</SUB>,A<SUB>d</SUB>,A<SUB>d</SUB>)</TD></TR>
  <TR>
    <TD><STRONG>GL_DST_ONE_MINUS_ALPHA</STRONG></TD>
    <TD>k=(1,1,1,1)-(A<SUB>d</SUB>,A<SUB>d</SUB>,A<SUB>d</SUB>,A<SUB>d</SUB>)</TD></TR>
  <TR>
    <TD><STRONG>GL_SRC_COLOR</STRONG></TD>
    <TD>k=(R<SUB>s</SUB>,G<SUB>s</SUB>,B<SUB>s</SUB>)</TD></TR>
  <TR>
    <TD><STRONG>GL_ONE_MINUS_SRC_COLOR</STRONG></TD>
    <TD>k=(1,1,1,1)- 
    (R<SUB>s</SUB>,G<SUB>s</SUB>,B<SUB>s</SUB>,A<SUB>s</SUB>)</TD></TR></TBODY></TABLE>
<P>Пример:</P>
<P>Предположим, мы хотим реализовать вывод прозрачных объектов. Коэффициент 
прозрачности задается альфа-компонентой цвета. Пусть 1 – непрозрачный объект; 0 
– абсолютно прозрачный, т.е. невидимый. Для реализации служит следующий код:</P>
<DIV id=XSLTCODE142144153120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE>glEnable(GL_BLEND);
glBlendFunc(GL_SRC_ALPHA,GL_SRC_ONE_MINUS_ALPHA);
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>Например, полупрозрачный треугольник можно задать следующим образом:</P>
<DIV id=XSLTCODE146144153120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE>glColor3f(1.0, 0.0, 0.0, 0.5);
glBegin(GL_TRIANGLES); 
  glVertex3f(0.0, 0.0, 0.0); 
  glVertex3f(1.0, 0.0, 0.0); 
  glVertex3f(1.0, 1.0, 0.0); 
glEnd();
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>Если в сцене есть несколько прозрачных объектов, которые могут перекрывать 
друг друга, корректный вывод можно гарантировать только в случае выполнения 
следующих условий:</P>
<P>Все прозрачные объекты выводятся после непрозрачных.</P>
<P>При выводе объекты с прозрачностью должны быть упорядочены по уменьшению 
глубины, т.е. выводиться, начиная с наиболее отдаленных от наблюдателя.</P>
<P>В OpenGL команды обрабатываются в порядке их поступления, поэтому для 
реализации перечисленных требований достаточно расставить в соответствующем 
порядке вызовы команд glVertex*(), но и это в общем случае нетривиально.</P>
<H3>Буфер-накопитель<A name=XSLTSECTION146153120120></A></H3>
<P>Буфер-накопитель (<I>accumulation buffer</I>) – это один из дополнительных 
буферов OpenGL. В нем можно сохранять визуализированное изображение, применяя 
при этом попиксельно специальные операции. Буфер-накопитель широко используется 
для создания различных спецэффектов.</P>
<P>Изображение берется из буфера, выбранного на чтение командой </P>
<DIV id=XSLTCODE126146153120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void </SPAN><STRONG>glReadBuffer</STRONG>(<SPAN class=KEYWORD>enum</SPAN> <I>buf</I>)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>Аргумент <I>buf </I>определяет буфер для чтения. Значения <I>buf<STRONG>, 
</STRONG></I>равные <STRONG>GL_BACK</STRONG>, <STRONG>GL_FRONT</STRONG>, 
определяют соответствующие буферы цвета для чтения. <STRONG>GL_BACK</STRONG> 
задает в качестве источника пикселей внеэкранный буфер; 
<STRONG>GL_FRONT</STRONG> – текущее содержимое окна вывода. Команда имеет 
значение, если используется дублирующая буферизация. В противном случае 
используется только один буфер, соответствующий окну вывода (строго говоря, 
OpenGL имеет набор дополнительных буферов, используемых, в частности, для работы 
со стереоизображениями, но здесь мы их рассматривать не будем).</P>
<P>Буфер-накопитель является дополнительным буфером цвета. Он не используется 
непосредственно для вывода образов, но они добавляются в него после вывода в 
один из буферов цвета. Применяя различные операции, описанные ниже, можно 
понемногу «накапливать» изображение в буфере.</P>
<P>Затем полученное изображение переносится из буфера-накопителя в один из 
буферов цвета, выбранный на запись командой</P>
<DIV id=XSLTCODE134146153120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void </SPAN><STRONG>glDrawBuffer(</STRONG><SPAN class=KEYWORD>enum </SPAN><I>buf)</I>
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>Значение <I>buf</I> аналогично значению соответствующего аргумента в команде 
<STRONG>glReadBuffer</STRONG>.</P>
<P>Все операции с буфером-накопителем контролируются командой</P>
<DIV id=XSLTCODE140146153120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void </SPAN><STRONG>glAccum</STRONG>(<SPAN class=KEYWORD>enum </SPAN><I>op</I>,GLfloat <I>value</I>)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>Аргумент <I>op </I>задает операцию над пикселями и может принимать следующие 
значения:</P>
<TABLE cellSpacing=2 cellPadding=5 border=0>
  <TBODY>
  <TR>
    <TD><STRONG>GL_LOAD</STRONG></TD>
    <TD>Пиксель выбирается из буфера, выбранного на чтение, его значение 
      умножается на <I>value </I>и заносится в буфер накопления.</TD></TR>
  <TR>
    <TD><STRONG>GL_ACCUM</STRONG></TD>
    <TD>Аналогично предыдущему, но полученное после умножения значение 
      складывается с уже имеющимся в буфере.</TD></TR>
  <TR>
    <TD><STRONG>GL_MULT</STRONG></TD>
    <TD>Эта операция умножает значение каждого пикселя в буфере накопления на 
      <I>value </I>.</TD></TR>
  <TR>
    <TD><STRONG>GL_ADD</STRONG></TD>
    <TD>Аналогично предыдущему, только вместо умножения используется 
    сложение.</TD></TR>
  <TR>
    <TD><STRONG>GL_RETURN</STRONG></TD>
    <TD>Изображение переносится из буфера накопления в буфер, выбранный для 
      записи. Перед этим значение каждого пикселя умножается на 
  <I>value.</I></TD></TR></TBODY></TABLE>
<P>Следует отметить, что для использования буфера-накопителя нет необходимости 
вызывать какие-либо команды glEnable. Достаточно инициализировать только сам 
буфер. </P>
<P>Пример использования буфера-накопителя для устранения погрешностей 
растеризации (ступенчатости) приведен в разделе 0</P>
<H3>Буфер маски<A name=XSLTSECTION148153120120></A></H3>
<P>При выводе пикселей в буфер кадра иногда возникает необходимость выводить не 
все пиксели, а только некоторое подмножество, т.е. наложить трафарет (маску) на 
изображение. Для этого OpenGL предоставляет так называемый буфер маски (stencil 
buffer). Кроме наложения маски, этот буфер предоставляет еще несколько 
интересных возможностей. </P>
<P>Прежде чем поместить пиксель в буфер кадра, механизм визуализации OpenGL 
позволяет выполнить сравнение (тест) между заданным значением и значением в 
буфере маски. Если тест проходит, пиксель рисуется в буфере кадра. </P>
<P>Механизм сравнения весьма гибок и контролируется следующими командами:</P>
<DIV id=XSLTCODE128148153120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void</SPAN> glStencilFunc (<SPAN class=KEYWORD>enum</SPAN> func, <SPAN class=KEYWORD>int</SPAN> ref, uint mask) 
<SPAN class=KEYWORD>void</SPAN> glStencilOp (<SPAN class=KEYWORD>enum</SPAN> sfail, <SPAN class=KEYWORD>enum</SPAN> dpfail, <SPAN class=KEYWORD>enum</SPAN> dppass) 
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>Аргумент <I>ref</I> команды glStencilFunc задает значение для сравнения. Он 
должен принимать значение от 0 до 2<SUP>s </SUP>–1. s – число бит на точку в 
буфере маски.</P>
<P>С помощью аргумента <I>func</I> задается функция сравнения. Он может 
принимать следующие значения:</P>
<TABLE cellSpacing=2 cellPadding=5 border=0>
  <TBODY>
  <TR>
    <TD><STRONG>GL_NEVER</STRONG></TD>
    <TD>тест никогда не проходит, т.е всегда возвращает false</TD></TR>
  <TR>
    <TD><STRONG>GL_ALWAYS</STRONG></TD>
    <TD>тест проходит всегда.</TD></TR>
  <TR>
    <TD><STRONG>GL_LESS, GL_LEQUAL, GL_EQUAL, GL_GEQUAL, GL_GREATE, 
      GL_NOTEQUAL</STRONG></TD>
    <TD>тест проходит в случае, если ref соответственно меньше значения в 
      трафаретном буфере, меньше либо равен, равен, больше, больше либо равен 
      или не равен.</TD></TR></TBODY></TABLE>
<P>Аргумент <I>mask</I> задает маску для значений. Т.е. в итоге для трафаретного 
теста получаем следующую формулу: ((<I>ref</I> AND <I>mask</I>) <I>op</I> 
(svalue AND <I>mask</I>))</P>
<P>Команда StencilOp предназначена для определения действий над пикселем 
трафаретного буфера в случае положительного или отрицательного результата 
теста.</P>
<P>Аргумент <I>sfail</I> задает действие в случае отрицательного результата 
теста, и может принимать следующие значения:</P>
<TABLE cellSpacing=2 cellPadding=5 border=0>
  <TBODY>
  <TR>
    <TD><STRONG>GL_KEEP, GL_ZERO, GL_REPLACE, GL_INCR, GL_DECR, 
      GL_INVERT</STRONG></TD>
    <TD>соответственно сохраняет значение в трафаретном буфере, обнуляет его, 
      заменяет на заданное значение (ref), увеличивает, уменьшает или побитово 
      инвертирует.</TD></TR></TBODY></TABLE>
<P>Аргументы <I>dpfail</I> определяют действия в случае отрицательного 
результата теста на глубину в z-буфере, а <I>dppass</I> задает действие в случае 
положительного результата этого теста. Аргументы принимают те же значения, что и 
аргумент <I>sfail</I>. По умолчанию все три параметра установлены на 
<STRONG>GL_KEEP</STRONG>.</P>
<P>Для включения маскирования необходимо выполнить команду 
glEnable(GL_STENCIL_TEST);</P>
<P>Буфер маски используется при создании таких спецэффектов, как падающие тени, 
отражения, плавные переходы из одной картинки в другую и пр.</P>
<P>Пример использования буфера маски при построении теней и отражений приведен в 
разделах 0 и 0. </P>
<H3>Управление растеризацией<A name=XSLTSECTION150153120120></A></H3>
<P>Способ выполнения растеризации примитивов можно частично регулировать 
командой glHint (target, mode), где <I>target</I> – вид контролируемых действий, 
принимает одно из следующих значений</P>
<TABLE cellSpacing=2 cellPadding=5 border=0>
  <TBODY>
  <TR>
    <TD><STRONG>GL_FOG_HINT</STRONG></TD>
    <TD>точность вычислений при наложении тумана. Вычисления могут выполняться 
      по пикселям (наибольшая точность) или только в вершинах. Если реализация 
      OpenGL не поддерживает попиксельного вычисления, то выполняется только 
      вычисление по вершинам</TD></TR>
  <TR>
    <TD><STRONG>GL_LINE_SMOOTH_HINT</STRONG></TD>
    <TD>управление качеством прямых. При значении mode, равным 
      <STRONG>GL_NICEST</STRONG>, уменьшается ступенчатость прямых за счет 
      большего числа пикселей в прямых</TD></TR>
  <TR>
    <TD><STRONG>GL_PERSPECTIVE_CORRECTION_HINT</STRONG></TD>
    <TD>точность интерполяции координат при вычислении цветов и наложении 
      текстуры. Если реализация OpenGL не поддерживает режим 
      <STRONG>GL_NICEST</STRONG>, то осуществляется линейная интерполяция 
      координат</TD></TR>
  <TR>
    <TD><STRONG>GL_POINT_SMOOTH_HINT</STRONG></TD>
    <TD>управление качеством точек. При значении параметра mode равным 
      <STRONG>GL_NICEST</STRONG> точки рисуются как окружности</TD></TR>
  <TR>
    <TD><STRONG>GL_POLYGON_SMOOTH_HINT</STRONG> </TD>
    <TD>управление качеством вывода сторон многоугольника</TD></TR></TBODY></TABLE>
<P>параметра <I>mode</I> интерпретируется следующим образом:</P>
<TABLE cellSpacing=2 cellPadding=5 border=0>
  <TBODY>
  <TR>
    <TD><STRONG>GL_FASTEST</STRONG></TD>
    <TD>используется наиболее быстрый алгоритм</TD></TR>
  <TR>
    <TD><STRONG>GL_NICEST</STRONG></TD>
    <TD>используется алгоритм, обеспечивающий лучшее качество</TD></TR>
  <TR>
    <TD><STRONG>GL_DONT_CARE</STRONG></TD>
    <TD>выбор алгоритма зависит от реализации</TD></TR></TBODY></TABLE>
<P>Важно заметить, что командой glHint() программист может только определить 
свои пожелания относительно того или иного аспекта растеризации примитивов. 
Конкретная реализация OpenGL вправе игнорировать данные установки.</P>
<P>Обратите внимание, что glHint() нельзя вызывать между операторными скобками 
glBegin()/glEnd().</P>
<H4>Контрольные вопросы</H4>
<P>Какие буферы изображений используются в OpenGL и для чего?</P>
<P>Для чего используется команда glBlendFunc?</P>
<P>Почему для корректного вывода прозрачных объектов требуется соблюдение 
условий упорядоченного вывода примитивов с прозрачностью?</P>
<P>Для чего используется буфер-накопитель? Приведите пример работы с ним.</P>
<P>Как в OpenGL можно наложить маску на результирующее изображение?</P>
<P>Объясните, для чего применятся команда glHint(). Каков эффект выполнения 
команды glHint(GL_FOG_HINT, GL_DONT_CARE)?</P>
<H2>Приемы работы с OpenGL<A name=XSLTPART155120120></A></H2>
<P>В этой главе мы рассмотрим, как с помощью OpenGL создавать некоторые 
интересные визуальные эффекты, непосредственная поддержка которых отсутствует в 
стандарте библиотеки.</P>
<H3>Устранение ступенчатости<A name=XSLTSECTION124155120120></A></H3>
<P>Начнем с задачи устранения ступенчатости (<I>antialiasing</I>). Эффект 
ступенчатости (<I>aliasing</I>) возникает в результате погрешностей растеризации 
примитивов в буфере кадра из-за конечного (и, как, правило, небольшого) 
разрешения буфера. Есть несколько подходов к решению данной проблемы. Например, 
можно применять фильтрацию полученного изображения. Также этот эффект можно 
устранять на этапе растеризации, сглаживая образ каждого примитива. Здесь мы 
рассмотрим прием, позволяющий устранять подобные артефакты для всей сцены 
целиком.</P>
<P>Для каждого кадра необходимо нарисовать сцену несколько раз, на каждом 
проходе немного смещая камеру относительно начального положения. Положения 
камер, например, могут образовывать окружность. Если сдвиг камеры относительно 
мал, то погрешности дискретизации проявятся по-разному, и, усредняя полученные 
изображения, мы получим сглаженное изображение. </P>
<P>Проще всего сдвигать положение наблюдателя, но перед этим нужно вычислить 
размер сдвига так, чтобы приведенное к координатам экрана значение не превышало, 
скажем, половины размера пикселя. </P>
<P>Все полученные изображения сохраняем в буфере-накопителе с коэффициентом 1/n, 
где n – число проходов для каждого кадра. Чем больше таких проходов<I> </I>– тем 
ниже производительность, но лучше результат.</P>
<DIV id=XSLTCODE130124155120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>for</SPAN>(i=0;i&lt;samples_count;++i) 
<SPAN class=COMMENT>/* обычно samples_count лежит в пределах от 5 до 10 */</SPAN>
{
  ShiftCamera(i); <SPAN class=COMMENT>/* сдвигаем камеру */</SPAN>
  RenderScene(); 
  <SPAN class=KEYWORD>if</SPAN> (i==0)
   <SPAN class=COMMENT>/* на первой итерации загружаем изображение */</SPAN>
   glAccum(GL_LOAD,1/(<SPAN class=KEYWORD>float</SPAN>)samples_count);
  <SPAN class=KEYWORD>else</SPAN>
   <SPAN class=COMMENT>/* добавляем к уже существующему */</SPAN>
   glAccum(GL_ACCUM,1/(<SPAN class=KEYWORD>float</SPAN>)samples_count);
}
<SPAN class=COMMENT>/* Пишем то, что получилось, назад в исходный буфер */</SPAN>
glAccum(GL_RETURN,1.0);
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>Следует отметить, что устранение ступенчатости сразу для всей сцены, как 
правило, связано с серьезным падением производительности визуализации, так как 
вся сцена рисуется несколько раз. Современные ускорители обычно аппаратно 
реализуют другие методы, основанные на так называемом ресамплинге изображений. 
</P>
<H3>Построение теней<A name=XSLTSECTION126155120120></A></H3>
<P>В OpenGL нет встроенной поддержки построения теней на уровне базовых команд. 
В значительной степени это объясняется тем, что существует множество алгоритмов 
их построения, которые могут быть реализованы через функции OpenGL. Присутствие 
теней сильно влияет на реалистичность трехмерного изображения, поэтому 
рассмотрим один из подходов к их построению.</P>
<P>Большинство алгоритмов, предназначенных для построения теней, используют 
модифицированные принципы перспективной проекции. Здесь рассматривается один из 
самых простых методов. С его помощью можно получать тени, отбрасываемые 
трехмерным объектом на плоскость.</P>
<P>Общий подход таков: для всех точек объекта находится их проекция параллельно 
вектору, соединяющему данную точку и точку, в которой находится источник света, 
на некую заданную плоскость. Тем самым получаем новый объект, целиком лежащий в 
заданной плоскости. Этот объект и является тенью исходного.</P>
<P>Рассмотрим математические основы данного метода.</P>
<P>Пусть:</P>
<P><STRONG>P</STRONG> – точка в трехмерном пространстве, которая отбрасывает 
тень.</P>
<P><STRONG>L</STRONG> – положение источника света, который освещает данную 
точку.</P>
<P><STRONG>S</STRONG>=a(<STRONG>L</STRONG>-<STRONG>P</STRONG>)-<STRONG>P</STRONG> 
- точка, в которую отбрасывает тень точка P, где a – параметр.</P>
<P>Предположим, что тень падает на плоскость <I>z=0.</I> В этом случае 
a=z<SUB>p</SUB>/(z<SUB>l</SUB>-z<SUB>p</SUB>). Следовательно, </P>
<P>x<SUB>s </SUB>= (x<SUB>p</SUB>z<SUB>l </SUB>- z<SUB>l</SUB>z<SUB>p</SUB>) / 
(z<SUB>l </SUB>- z<SUB>p</SUB>),</P>
<P>y<SUB>s </SUB>= (y<SUB>p</SUB>z<SUB>l</SUB>-y<SUB>l</SUB>z<SUB>p</SUB>) / 
(z<SUB>l </SUB>- z<SUB>p</SUB>),</P>
<P>z<SUB>s </SUB>= 0</P>
<P>Введем однородные координаты:</P>
<P>x<SUB>s</SUB>=x<SUB>s</SUB>'/w<SUB>s</SUB>'</P>
<P>y<SUB>s</SUB>=y<SUB>s</SUB>'/w<SUB>s</SUB>'</P>
<P>z<SUB>s</SUB>=0</P>
<P>w<SUB>s</SUB>'=z<SUB>l</SUB>-z<SUB>p</SUB></P>
<P>Отсюда координаты S могут быть получены с использованием умножения матриц 
следующим образом:</P>
<P style="TEXT-ALIGN: center"><IMG src="ogltut2.files/matrix.gif"><BR><I 
style="FONT-SIZE: x-small; font-face: verdana"></I></P>
<P>Для того, чтобы алгоритм мог рассчитывать тень, падающую на произвольную 
плоскость, рассмотрим произвольную точку на линии между <STRONG>S </STRONG>и 
<STRONG>P</STRONG>, представленную в однородных координатах:</P>
<P>a<STRONG>P</STRONG>+b<STRONG>L, </STRONG>где a и b – скалярные параметры.</P>
<P>Следующая матрица задает плоскость через координаты ее нормали:</P>
<P style="TEXT-ALIGN: center"><IMG src="ogltut2.files/g.gif"><BR><I 
style="FONT-SIZE: x-small; font-face: verdana"></I></P>
<P>Точка, в которой луч, проведенный от источника света через данную точку 
<STRONG>P, </STRONG>пересекает плоскость G, определяется параметрами a и b, 
удовлетворяющими следующему уравнению:</P>
<P>(a<STRONG>P</STRONG>+b<STRONG>L)G </STRONG>= 0</P>
<P>Отсюда получаем: a(<STRONG>PG) </STRONG>+ b(<STRONG>LG) </STRONG>= 0. Этому 
уравнению удовлетворяют </P>
<P>a = (<STRONG>LG), </STRONG>b = -(<STRONG>PG)</STRONG></P>
<P>Следовательно, координаты искомой точки <STRONG>S </STRONG>= 
(<STRONG>LG)P-(PG)L. </STRONG>Пользуясь ассоциативностью матричного 
произведения, получим </P>
<P><STRONG>S </STRONG>= <STRONG>P</STRONG>[(<STRONG>LG</STRONG>)<STRONG>I 
</STRONG>- <STRONG>GL</STRONG>], где <STRONG>I – </STRONG>единичная матрица.</P>
<P>Матрица (<STRONG>LG</STRONG>)<STRONG>I </STRONG>- <STRONG>GL 
</STRONG>используется для получения теней на произвольной плоскости.</P>
<P>Рассмотрим некоторые аспекты практической реализации данного метода с помощью 
OpenGL.</P>
<P>Предположим, что матрица floorShadow была ранее получена нами из формулы 
(<STRONG>LG</STRONG>)<STRONG>I </STRONG>- <STRONG>GL</STRONG>. Следующий код с 
ее помощью строит тени для заданной плоскости:</P>
<DIV id=XSLTCODE186126155120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=COMMENT>/* Делаем тени полупрозрачными с использованием смешения цветов(blending) */</SPAN>
glEnable(GL_BLEND);
glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
glDisable(GL_LIGHTING); 
glColor4f(0.0, 0.0, 0.0, 0.5);
glPushMatrix();
   <SPAN class=COMMENT>/* Проецируем тень */</SPAN>
   glMultMatrixf((GLfloat *) floorShadow);
   <SPAN class=COMMENT>/* Визуализируем сцену в проекции */</SPAN>
   RenderGeometry();
glPopMatrix();
glEnable(GL_LIGHTING);
glDisable(GL_BLEND);
<SPAN class=COMMENT>/* Визуализируем сцену в обычном режиме */</SPAN>
RenderGeometry();  
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>Матрица floorShadow может быть получена из уравнения (*) с помощью следующей 
функции:</P>
<DIV id=XSLTCODE190126155120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=COMMENT>/* параметры:   plane – коэффициенты уравнения плоскости
        lightpos – координаты источника света
   возвращает: matrix – результирующая матрица
*/</SPAN>
<SPAN class=KEYWORD>void</SPAN> shadowmatrix(GLfloat matrix[4][4], GLfloat plane[4],
                  GLfloat lightpos[4])
{
  GLfloat dot;

  dot = plane[0] * lightpos[0] +
        plane[1] * lightpos[1] +
        plane[2] * lightpos[2] +
        plane[3] * lightpos[3];

  matrix[0][0] = dot - lightpos[0] * plane[0];
  matrix[1][0] = 0.f - lightpos[0] * plane[1];
  matrix[2][0] = 0.f - lightpos[0] * plane[2];
  matrix[3][0] = 0.f - lightpos[0] * plane[3];

  matrix[0][1] = 0.f - lightpos[1] * plane[0];
  matrix[1][1] = dot - lightpos[1] * plane[1];
  matrix[2][1] = 0.f - lightpos[1] * plane[2];
  matrix[3][1] = 0.f - lightpos[1] * plane[3];

  matrix[0][2] = 0.f - lightpos[2] * plane[0];
  matrix[1][2] = 0.f - lightpos[2] * plane[1];
  matrix[2][2] = dot - lightpos[2] * plane[2];
  matrix[3][2] = 0.f - lightpos[2] * plane[3];

  matrix[0][3] = 0.f - lightpos[3] * plane[0];
  matrix[1][3] = 0.f - lightpos[3] * plane[1];
  matrix[2][3] = 0.f - lightpos[3] * plane[2];
  matrix[3][3] = dot - lightpos[3] * plane[3];
}
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>Заметим, что тени, построенные таким образом, имеют ряд недостатков. </P>
<P>Описанный алгоритм предполагает, что плоскости бесконечны, и не отрезает тени 
по границе. Например, если некоторый объект отбрасывает тень на стол, она не 
будет отсекаться по границе, и, тем более, "заворачиваться" на боковую 
поверхность стола.</P>
<P>В некоторых местах тени может наблюдаться эффект "двойного смешения" 
(reblending), т.е. темные пятна в тех участках, где спроецированные треугольники 
перекрывают друг друга.</P>
<P>С увеличением числа поверхностей сложность алгоритма резко увеличивается, 
т.к. для каждой поверхности нужно заново строить всю сцену, даже если проблема 
отсечения теней по границе будет решена.</P>
<P>Тени обычно имеют размытые границы, а в приведенном алгоритме они всегда 
имеют резкие края. Частично избежать этого позволяет расчет теней из нескольких 
источников света, расположенных рядом и последующее смешение результатов.</P>
<P>Имеется решение первой и второй проблемы. Для этого используется буфер маски 
(см. п. 0)</P>
<P>Итак, задача – отсечь вывод геометрии (тени, в данном случае) по границе 
некоторой произвольной области и избежать "двойного смешения". Общий алгоритм 
решения с использованием буфера маски таков:</P>
<P>Очищаем буфер маски значением 0</P>
<P>Отображаем заданную область отсечения, устанавливая значения в буфере маски в 
1</P>
<P>Рисуем тени в тех областях, где в буфере маски установлены значения 1. Если 
тест проходит, устанавливаем в эти области значение 2.</P>
<P>Теперь рассмотрим эти этапы более подробно.</P>
<OL>
  <LI><BR>
  <DIV id=XSLTCODE121121214126155120120>
  <TABLE class=code width="98%">
    <TBODY>
    <TR>
      <TD><PRE><SPAN class=COMMENT>/* очищаем буфер маски*/</SPAN>
glClearStencil(0x0); 
<SPAN class=COMMENT>/* включаем тест */</SPAN>
glEnable(GL_STENCIL_TEST); 
</PRE></TD></TR></TBODY></TABLE></DIV>
  <LI><BR>
  <DIV id=XSLTCODE121123214126155120120>
  <TABLE class=code width="98%">
    <TBODY>
    <TR>
      <TD><PRE><SPAN class=COMMENT>/* условие всегда выполнено и значение в буфере будет равно 1*/</SPAN>
glStencilFunc (GL_ALWAYS, 0x1, 0xffffffff);
<SPAN class=COMMENT>/* в любом случае заменяем значение в буфере маски*/</SPAN>
glStencilOp (GL_REPLACE, GL_REPLACE, GL_REPLACE); 
<SPAN class=COMMENT>/* выводим геометрию, по которой затем будет отсечена тень*/</SPAN>
RenderPlane();
</PRE></TD></TR></TBODY></TABLE></DIV>
  <LI><BR>
  <DIV id=XSLTCODE121125214126155120120>
  <TABLE class=code width="98%">
    <TBODY>
    <TR>
      <TD><PRE><SPAN class=COMMENT>/* условие выполнено и тест дает истину только если значение в буфере маски равно 1 */</SPAN>
glStencilFunc (GL_EQUAL, 0x1, 0xffffffff);
<SPAN class=COMMENT>/* значение в буфере равно 2,если тень уже выведена */</SPAN>
glStencilOp (GL_KEEP, GL_KEEP, GL_INCR);
<SPAN class=COMMENT>/* выводим тени */</SPAN>
RenderShadow();
</PRE></TD></TR></TBODY></TABLE></DIV></LI></OL>
<P>Строго говоря, даже при применении маскирования остаются некоторые проблемы, 
связанные с работой z-буфера. В частности, некоторые участки теней могут стать 
невидимыми. Для решения этой проблемы можно немного приподнять тени над 
плоскостью c помощью модификации уравнения, описывающего плоскость. Описание 
других методов выходит за рамки данного пособия.</P>
<H3>Зеркальные отражения<A name=XSLTSECTION128155120120></A></H3>
<P>В этом разделе мы рассмотрим алгоритм построения отражений от плоских 
объектов. Такие отражения придают большую достоверность построенному изображению 
и их относительно легко реализовать. </P>
<P>Алгоритм использует интуитивное представление полной сцены с зеркалом как 
составленной из двух: «настоящей» и «виртуальной» – находящейся за зеркалом. 
Следовательно, процесс рисования отражений состоит из двух частей: 1) 
визуализации обычной сцены и 2) построения и визуализации виртуальной. Для 
каждого объекта «настоящей» сцены строится его отраженный двойник, который 
наблюдатель и увидит в зеркале. </P>
<P style="TEXT-ALIGN: center"><IMG src="ogltut2.files/mirror.gif"><BR><I 
style="FONT-SIZE: x-small; font-face: verdana">Рис. 9 Зеркальное 
отражение</I></P>
<P>Для иллюстрации рассмотрим комнату с зеркалом на стене. Комната и объекты, 
находящиеся в ней, выглядят в зеркале так, как если бы зеркало было окном, а за 
ним была бы еще одна такая же комната с тем же объектами, но симметрично 
отраженными относительно плоскости, проведенной через поверхность зеркала. </P>
<P>Упрощенный вариант алгоритма создания плоского отражения состоит из следующих 
шагов:</P>
<P>Рисуем сцену как обычно, но без объектов-зеркал.</P>
<P>Используя буфер маски, ограничиваем дальнейший вывод проекцией зеркала на 
экран.</P>
<P>Визуализируем сцену, отраженную относительно плоскости зеркала. При этом 
буфер маски позволит ограничить вывод формой проекции объекта-зеркала.</P>
<P>Эта последовательность действий позволит получить убедительный эффект 
отражения.</P>
<P>Рассмотрим этапы более подробно:</P>
<P>Сначала необходимо нарисовать сцену как обычно. Не будем останавливаться на 
этом этапе подробно. Заметим только, что, очищая буферы OpenGL непосредственно 
перед рисованием, нужно не забыть очистить буфер маски: </P>
<DIV id=XSLTCODE144128155120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE>glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT|
        GL_STENCIL_BUFFER_BIT);
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>Во время визуализации сцены лучше не рисовать объекты, которые затем станут 
зеркальными.</P>
<P>На втором этапе необходимо ограничить дальнейший вывод проекцией зеркального 
объекта на экран. </P>
<P>Для этого настраиваем буфер маски и рисуем зеркало </P>
<DIV id=XSLTCODE152128155120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE>glEnable(GL_STENCIL_TEST);
<SPAN class=COMMENT>/* условие всегда выполнено и значение в буфере будет равно 1*/</SPAN>
glStencilFunc(GL_ALWAYS, 1, 0);
glStencilOp(GL_KEEP, GL_KEEP, GL_REPLACE);
RenderMirrorObject();
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>В результате мы получили:</P>
<P>в буфере кадра – корректно нарисованная сцена, за исключением области 
зеркала;</P>
<P>в области зеркала (там, где мы хотим видеть отражение) значение буфера маски 
равно 1.</P>
<P>На третьем этапе нужно нарисовать сцену, отраженную относительно плоскости 
зеркального объекта.</P>
<P>Сначала настраиваем матрицу отражения. Матрица отражения должна зеркально 
отражать всю геометрию относительно плоскости, в которой лежит объект-зеркало. 
Ее можно получить, например, с помощью такой функции (попробуйте получить эту 
матрицу самостоятельно в качестве упражнения):</P>
<DIV id=XSLTCODE164128155120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void</SPAN> reflectionmatrix(GLfloat reflection_matrix[4][4], 
                 GLfloat plane_point[3], 
                 Glfloat plane_normal[3])
{
  GLfloat* p;
  GLfloat* v;
  <SPAN class=KEYWORD>float</SPAN> pv;

  GLfloat* p = (Glfloat*)plane_point;
  Glfloat* v = (Glfloat*)plane_normal;
  <SPAN class=KEYWORD>float</SPAN> pv = p[0]*v[0]+p[1]*v[1]+p[2]*v[2];
  
  reflection_matrix[0][0] = 1 - 2 * v[0] * v[0];
  reflection_matrix[1][0] = - 2 * v[0] * v[1];
  reflection_matrix[2][0] = - 2 * v[0] * v[2];
  reflection_matrix[3][0] = 2 * pv * v[0];
  
  reflection_matrix[0][1] = - 2 * v[0] * v[1];
  reflection_matrix[1][1] = 1- 2 * v[1] * v[1];
  reflection_matrix[2][1] = - 2 * v[1] * v[2];
  reflection_matrix[3][1] = 2 * pv * v[1];
  
  reflection_matrix[0][2] = - 2 * v[0] * v[2];
  reflection_matrix[1][2] = - 2 * v[1] * v[2];
  reflection_matrix[2][2] = 1 - 2 * v[2] * v[2];
  reflection_matrix[3][2] = 2 * pv * v[2];
  
  reflection_matrix[0][3] = 0;
  reflection_matrix[1][3] = 0;
  reflection_matrix[2][3] = 0;
  reflection_matrix[3][3] = 1;
}
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>Настраиваем буфер маски на рисование только в областях, где значения буфера 
равно 1:</P>
<DIV id=XSLTCODE168128155120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=COMMENT>/* условие выполнено и тест дает истину только если значение в буфере маски равно 1 */</SPAN>
glStencilFunc (GL_EQUAL, 0x1, 0xffffffff);
<SPAN class=COMMENT>/* ничего не меняем в буфере */</SPAN>
glStencilOp (GL_KEEP, GL_KEEP, GL_KEEP);
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>и рисуем сцену еще раз (без зеркальных объектов)</P>
<DIV id=XSLTCODE172128155120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE>glPushMatrix();
glMultMatrixf((<SPAN class=KEYWORD>float</SPAN> *)reflection_matrix);
RenderScene();
glPopMatrix();
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>Наконец, отключаем маскирование</P>
<DIV id=XSLTCODE176128155120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE>glDisable(GL_STENCIL_TEST);
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>После этого можно опционально еще раз вывести зеркальный объект, например, с 
альфа-смешением – для создания эффекта замутнения зеркала и т.д.</P>
<P>Существует несколько модификаций этого алгоритма, отличающиеся 
последовательностью действий, ограничениями на геометрию и т.д.</P>
<H4>Контрольные вопросы</H4>
<P>В результате чего возникает эффект ступенчатости изображения?</P>
<P>Опишите алгоритм устранения ступенчатости.</P>
<P>Почему в OpenGL нет встроенной поддержки построения теней?</P>
<P>Кратко опишите предложенный метод визуализации зеркальных объектов.</P>
<H2>Оптимизация программ<A name=XSLTPART157120120></A></H2>
<H3>Организация приложения<A name=XSLTSECTION122157120120></A></H3>
<P>На первый взгляд может показаться, что производительность приложений, 
основанных на OpenGL, определяется в первую очередь производительностью 
реализации самой библиотеки OpenGL. Это верно, однако организация всего 
приложения также очень важна.</P>
<H4>Высокоуровневая оптимизация</H4>
<P>Обычно от программы под OpenGL требуется визуализация высокого качества на 
интерактивных скоростях. Но, как правило, и то и другое сразу получить не 
удается. Следовательно, необходим поиск компромисса между качеством и 
производительностью. Существует множество различных подходов, но их подробное 
описание выходит за пределы этого пособия. Приведем лишь несколько примеров. 
</P>
<P>Можно отображать геометрию сцены с низким качеством во время анимации, а в 
моменты остановок показывать ее с наилучшим качеством. Во время интерактивного 
вращения (например, при нажатой клавише мыши) визуализировать модель с 
уменьшенным количеством примитивов. При рисовании статичного изображения 
отображать модель полностью. </P>
<P>Аналогично, объекты, которые располагаются далеко от наблюдателя, могут быть 
представлены моделями пониженной сложности. Это значительно снизит нагрузку на 
все ступени конвейера OpenGL. Объекты, которые находятся полностью вне поля 
видимости, могут быть эффективно отсечены без передачи на конвейер OpenGL с 
помощью проверки попадания ограничивающих их простых объемов (сфер или кубов) в 
пирамиду зрения.</P>
<P>Во время анимации можно отключить псевдотонирование (dithering), плавную 
заливку, текстуры. Опять-таки включать все это во время демонстрации статичных 
изображений. Этот подход особенно эффективен для систем без аппаратной поддержки 
OpenGL.</P>
<H4>Низкоуровневая оптимизация</H4>
<P>Объекты, отображаемые с помощью OpenGL, хранятся в некоторых структурах 
данных. Одни типы таких структур более эффективны в использовании, чем другие, 
что определяет скорость визуализации. </P>
<P>Желательно, чтобы использовались структуры данных, которые могут быть быстро 
и эффективно переданы на конвейер OpenGL. Например, если мы хотим отобразить 
массив треугольников, то использование указателя на этот массив значительно 
более эффективно, чем передача его OpenGL поэлементно. </P>
<P>Пример:</P>
<P>Предположим, что мы пишем приложение, которое реализует рисование карты 
местности. Один из компонентов базы данных – список городов с их шириной, 
долготой и названием. Соответствующая структура данных может быть такой: </P>
<DIV id=XSLTCODE130126122157120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>struct</SPAN> city
{
&nbsp;&nbsp; <SPAN class=KEYWORD>float</SPAN> latitute, longitude; <SPAN class=COMMENT>/* положение города */</SPAN>
   <SPAN class=KEYWORD>char</SPAN> *name;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  <SPAN class=COMMENT>/* название  */</SPAN>
&nbsp;&nbsp; <SPAN class=KEYWORD>int</SPAN> large_flag;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       <SPAN class=COMMENT>/* 0 = маленький, 1 = большой */</SPAN>
};
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>Список городов может храниться как массив таких структур. Допустим, мы пишем 
функцию, которая рисует города на карте в виде точек разного размера с 
подписями:</P>
<DIV id=XSLTCODE134126122157120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void</SPAN> draw_cities( <SPAN class=KEYWORD>int</SPAN> n, <SPAN class=KEYWORD>struct</SPAN> city citylist[] )
{
&nbsp;&nbsp; <SPAN class=KEYWORD>int</SPAN> i;
&nbsp;&nbsp; <SPAN class=KEYWORD>for</SPAN> (i=0; i &lt; n; i++) 
     {
  &nbsp;&nbsp; <SPAN class=KEYWORD>if</SPAN> (citylist[i].large_flag) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glPointSize( 4.0 );
&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class=KEYWORD>else</SPAN>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glPointSize( 2.0 );

  &nbsp;&nbsp; glBegin( GL_POINTS );
&nbsp;&nbsp; &nbsp; glVertex2f( citylist[i].longitude,
                 citylist[i].latitude );
 &nbsp;&nbsp;  glEnd();
     <SPAN class=COMMENT>/* рисуем название города */</SPAN>
    &nbsp;DrawText(citylist[i].longitude,
              citylist[i].latitude,
              citylist[i].name);
&nbsp;&nbsp;&nbsp; }
}
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>Это реализация неудачна по следующим причинам: </P>
<P>glPointSize вызывается для каждой итерации цикла.</P>
<P>между glBegin и glEnd рисуется только одна точка.</P>
<P>вершины определяются в неоптимальном формате. </P>
<P>Ниже приведено более рациональное решение: </P>
<DIV id=XSLTCODE146126122157120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void</SPAN> draw_cities( <SPAN class=KEYWORD>int</SPAN> n, <SPAN class=KEYWORD>struct</SPAN> city citylist[] )
{
&nbsp;&nbsp;&nbsp; <SPAN class=KEYWORD>int</SPAN> i;
&nbsp;&nbsp;&nbsp; <SPAN class=COMMENT>/* сначала рисуем маленькие точки */</SPAN>
&nbsp;&nbsp;&nbsp; glPointSize( 2.0 );
&nbsp;&nbsp;&nbsp; glBegin( GL_POINTS );
&nbsp;&nbsp;&nbsp; <SPAN class=KEYWORD>for</SPAN> (i=0; i &lt; n ;i++) 
    {
&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<SPAN class=KEYWORD>if</SPAN> (citylist[i].large_flag==0)
      {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; glVertex2f( citylist[i].longitude,
                      citylist[i].latitude );
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; glEnd();
&nbsp;&nbsp; &nbsp;<SPAN class=COMMENT>/* большие точки рисуем во вторую очередь */</SPAN>
&nbsp;&nbsp;&nbsp;&nbsp;glPointSize( 4.0 );
&nbsp;&nbsp;&nbsp;&nbsp;glBegin( GL_POINTS );
&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=KEYWORD>for</SPAN> (i=0; i &lt; n ;i++) 
    {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class=KEYWORD>if</SPAN> (citylist[i].large_flag==1) 
      {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glVertex2f( citylist[i].longitude,
                    citylist[i].latitude );
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;}
 &nbsp;&nbsp;&nbsp;glEnd();
    <SPAN class=COMMENT>/* затем рисуем названия городов */</SPAN>
&nbsp;&nbsp;  <SPAN class=KEYWORD>for</SPAN> (i=0; i &lt; n ;i++) 
    {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DrawText(citylist[i].longitude,
               citylist[i].latitude,
               citylist[i].name);
&nbsp;&nbsp;  }
}
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>В такой реализации мы вызываем glPointSize дважды и увеличиваем число вершин 
между glBegin и glEnd.</P>
<P>Однако остаются еще пути для оптимизации. Если мы поменяем наши структуры 
данных, то можем еще повысить эффективность рисования точек. Например:</P>
<DIV id=XSLTCODE152126122157120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>struct</SPAN> city_list 
{
  <SPAN class=KEYWORD>int</SPAN> num_cities;&nbsp;<SPAN class=COMMENT>/* число городов в списке */</SPAN>
  <SPAN class=KEYWORD>float</SPAN> *position;<SPAN class=COMMENT>/* координаты города */</SPAN>
  <SPAN class=KEYWORD>char</SPAN> **name;&nbsp;&nbsp;&nbsp; <SPAN class=COMMENT>/* указатель на названия городов */</SPAN>
&nbsp; <SPAN class=KEYWORD>float</SPAN> size;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class=COMMENT>/* размер точки, обозначающей город */</SPAN>
};
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>Теперь города разных размеров хранятся в разных списках. Положения точек 
хранятся отдельно в динамическом массиве. После реорганизации мы исключаем 
необходимость в условном операторе внутри glBegin/glEnd и получаем возможность 
использовать массивы вершин для оптимизации. В результате наша функция выглядит 
следующим образом:</P>
<DIV id=XSLTCODE156126122157120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void</SPAN> draw_cities( <SPAN class=KEYWORD>struct</SPAN> city_list *list )
  {
&nbsp; <SPAN class=KEYWORD>int</SPAN> i;

&nbsp; <SPAN class=COMMENT>/* рисуем точки */</SPAN>
&nbsp; glPointSize( list-&gt;size );

&nbsp; glVertexPointer( 2, GL_FLOAT, 0, 
                   list-&gt;num_cities, 
                   list-&gt;position );
&nbsp; glDrawArrays( GL_POINTS, 0, list-&gt;num_cities );
&nbsp;&nbsp;<SPAN class=COMMENT>/* рисуем название города */</SPAN>
&nbsp; <SPAN class=KEYWORD>for</SPAN> (i=0; i &lt; list-&gt;num_cities ;i++)
  {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawText(citylist[i].longitude,
              citylist[i].latitude
              citylist[i].name);
  }
</PRE></TD></TR></TBODY></TABLE></DIV>
<H3>Оптимизация вызовов OpenGL<A name=XSLTSECTION124157120120></A></H3>
<P>Существует много возможностей улучшения производительности OpenGL. К тому же 
разные подходы к оптимизации приводят к разным эффектам при аппаратной и 
программной визуализации. Например, интерполяция цветов может быть очень дорогой 
операцией без аппаратной поддержки, а при аппаратной визуализации почти не дает 
задержек. </P>
<P>После каждой из следующих методик следуют квадратные скобки, в которых указан 
один из символов, обозначающих значимость данной методики для конкретной системы 
</P>
<P>[А] – предпочтительно для систем с аппаратной поддержкой OpenGL </P>
<P>[П] – предпочтительно для программных реализаций </P>
<P>[все] – вероятно предпочтительно для всех реализаций </P>
<H4>Передача данных в OpenGL</H4>
<P>В данном разделе рассмотрим способы минимизации времени на передачу данных о 
примитивах в OpenGL </P>
<P><STRONG>Используйте связанные примитивы.</STRONG></P>
<P>Связанные примитивы, такие как <STRONG>GL_LINES</STRONG>, 
<STRONG>GL_LINE_LOOP</STRONG>, <STRONG>GL_TRIANGLE_STRIP</STRONG>, 
<STRONG>GL_TRIANGLE_FAN</STRONG>, и <STRONG>GL_QUAD_STRIP</STRONG> требуют для 
определения меньше вершин, чем&nbsp; отдельные линия или многоугольник. Это 
уменьшает количество данных, передаваемых OpenGL [все] </P>
<P><STRONG>Используйте массивы вершин.</STRONG></P>
<P>На большинстве архитектур замена множественных вызовов 
glVertex/glColor/glNormal на механизм массивов вершин может быть очень 
выигрышной. [все] </P>
<P><STRONG>Используйте индексированные примитивы.</STRONG></P>
<P>В некоторых случаях даже при использовании связанных примитивов 
<STRONG>GL_TRIANGLE_STRIP</STRONG> (<STRONG>GL_QUAD_STRIP</STRONG>) вершины 
дублируются.</P>
<P>Чтобы не передавать в OpenGL дубли, увеличивая нагрузку на шину, используйте 
команду glDrawElements() (см. раздел 0.) [все]</P>
<P><STRONG>Задавайте необходимые массивы одной командой.</STRONG></P>
<P>Вместо использования команд</P>
<P>glVertexPointer/glColorPointer/glNormalPointer лучше пользоваться одной 
командой</P>
<DIV id=XSLTCODE144132124157120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void</SPAN> glInterleavedArrays ( Glint format, 
                           Glsizei stride, 
                           <SPAN class=KEYWORD>void</SPAN> * ptr);
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>так, если имеется структура</P>
<DIV id=XSLTCODE148132124157120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>typedef</SPAN> <SPAN class=KEYWORD>struct</SPAN> tag_VERTEX_DATA
{
  <SPAN class=KEYWORD>float</SPAN> color[4];
  <SPAN class=KEYWORD>float</SPAN> normal[3];
  <SPAN class=KEYWORD>float</SPAN> vertex[3];
}VERTEX_DATA;
VERTEX_DATA * pData;
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>то параметры можно передать с помощью следующей команды</P>
<DIV id=XSLTCODE152132124157120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE>glInterleavedArrays (GL_C4F_N3F_V3F, 0, pData);
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>что означает, что первые четыре float относятся к цвету, затем три float к 
нормали, и последние три float задают координаты вершины. Более подробное 
описание команды смотрите в спецификации OpenGL. [все]</P>
<P><STRONG>Храните данные о вершинах в памяти последовательно. </STRONG></P>
<P>Последовательное расположение данных в памяти улучшает скорость обмена между 
основной памятью и графической подсистемой. [А] </P>
<P><STRONG>Используйте векторные версии </STRONG>glVertex, glColor, glNormal и 
glTexCoord.</P>
<P>Функции glVertex*(), glColor*() и т.д., которые в качестве аргументов 
принимают указатели (например, glVertex3fv(v)) могут работать значительно 
быстрее, чем их соответствующие версии glVertex3f(x,y,z) [все] </P>
<P><STRONG>Уменьшайте сложность примитивов. </STRONG></P>
<P>Во многих случаях будьте внимательны, чтобы не разбивать большие плоскости на 
части сильнее, чем необходимо. Поэкспериментируйте, например, с примитивами GLU 
для определения наилучшего соотношения качества и производительности. 
Текстурированные объекты, например, могут быть качественно отображены с 
небольшой сложностью геометрии.&nbsp; [все] </P>
<P><STRONG>Используйте дисплейные списки. </STRONG></P>
<P>Используйте дисплейные списки для наиболее часто выводимых объектов. 
Дисплейные списки могут храниться в памяти графической подсистемы и, 
следовательно, исключать частые перемещения данных из основной памяти. [А] </P>
<P><STRONG>Не указывайте ненужные атрибуты вершин </STRONG></P>
<P>Если освещение выключено, не вызывайте glNormal. Если не используются 
текстуры, не вызывайте glTexCoord, и т.д. [все] </P>
<P><STRONG>Минимизируйте количество лишнего кода между glBegin/glEnd 
</STRONG></P>
<P>Для максимальной производительности на high-end системах важно, чтобы 
информация о вершинах была передана графической подсистеме максимально быстро. 
Избегайте лишнего кода между glBegin/glEnd. &nbsp; </P>
<P>&nbsp; Пример неудачного решения:</P>
<DIV id=XSLTCODE182132124157120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE> glBegin(GL_TRIANGLE_STRIP);
 <SPAN class=KEYWORD>for</SPAN> (i=0; i &lt; n; i++) 
 {
&nbsp;&nbsp;&nbsp; <SPAN class=KEYWORD>if</SPAN> (lighting)
    {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glNormal3fv(norm[i]);
&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp; glVertex3fv(vert[i]);
&nbsp;}
&nbsp;glEnd();
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>Эта конструкция плоха тем, что мы проверяем переменную lighting перед каждой 
вершиной. Этого можно избежать, за счет частичного дублирования кода: </P>
<DIV id=XSLTCODE186132124157120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>if</SPAN> (lighting)
{
&nbsp;&nbsp; glBegin(GL_TRIANGLE_STRIP);
&nbsp;&nbsp; <SPAN class=KEYWORD>for</SPAN> (i=0; i &lt; n ;i++) 
   {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glNormal3fv(norm[i]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glVertex3fv(vert[i]);
&nbsp;&nbsp; }
&nbsp;&nbsp; glEnd();
 }
 <SPAN class=KEYWORD>else</SPAN> 
 {
&nbsp;&nbsp; glBegin(GL_TRIANGLE_STRIP);
&nbsp;&nbsp; <SPAN class=KEYWORD>for</SPAN> (i=0; i &lt; n ;i++) 
   {
   &nbsp;&nbsp; glVertex3fv(vert[i]);
&nbsp;&nbsp; }
&nbsp;&nbsp; glEnd();
}
</PRE></TD></TR></TBODY></TABLE></DIV>
<H4>Преобразования</H4>
<P>Преобразования включают в себя трансформации вершин от координат, указанных в 
glVertex*(), к оконным координатам, отсечение, освещение и т.д. </P>
<P><STRONG>Освещение </STRONG></P>
<P>Избегайте использования локальных источников света, т.е. координаты источника 
должны быть в форме (x,y,z,0) [П] </P>
<P>Избегайте использования точечных источников света. [все] </P>
<P>Избегайте использования двухстороннего освещения (two-sided lighting). [все] 
</P>
<P>Избегайте использования отрицательные коэффициентов в параметрах материала и 
цвета. [П] </P>
<P>Избегайте использования локальной модели освещения&nbsp;.[все] </P>
<P>Избегайте частой смены параметра материала&nbsp; 
<STRONG>GL_SHININESS</STRONG> [П] </P>
<P>Некоторые реализации OpenGL оптимизированы для случая одного источника света 
[А, П] </P>
<P>Рассмотрите возможность заранее просчитать освещение. Можно получить эффект 
освещения, задавая цвета вершин вместо нормалей. [все] </P>
<P><STRONG>Отключайте нормализацию векторов нормалей, когда это не необходимо. 
</STRONG></P>
<P>Команда glEnable/Disable(GL_NORMALIZE) управляет нормализацией векторов 
нормалей перед использованием. Если вы не используете команду glScale, то 
нормализацию можно отключить без посторонних эффектов. По умолчанию эта опция 
выключена. [все] </P>
<P><STRONG>Используйте связанные примитивы. </STRONG></P>
<P>Связанные примитивы, такие как <STRONG>GL_LINES</STRONG>, 
<STRONG>GL_LINE_LOOP</STRONG>, <STRONG>GL_TRIANGLE_STRIP</STRONG>, 
<STRONG>GL_TRIANGLE_FAN</STRONG>, и <STRONG>GL_QUAD_STRIP</STRONG> уменьшают 
нагрузку на конвейер OpenGL, а также уменьшают количество данных, передаваемых 
графической подсистеме. </P>
<H4>Растеризация</H4>
<P>Растеризация часто является узким местом программных реализаций OpenGL. </P>
<P><STRONG>Отключайте интерполяцию цветов, когда в этом нет необходимости 
</STRONG></P>
<P>Интерполяция цветов включена по умолчанию. Плоское затенение не требует 
интерполяции четырех компонент цвета и, как правило, быстрее на программных 
реализациях OpenGL. Аппаратные реализации обычно выполняют оба вида затенения с 
одинаковой скоростью. Для отключения используйте команду glShadeModel(GL_FLAT) 
[П] </P>
<P><STRONG>Отключайте тест на глубину, когда в этом нет необходимости. 
</STRONG></P>
<P>Фоновые объекты, например, могут быть нарисованы без теста на глубину, если 
они визуализируется первыми [все] </P>
<P><STRONG>Используйте отсечение обратных граней полигонов</STRONG></P>
<P>Замкнутые объекты могут быть нарисованы с установленным режимом отсечения 
обратных граней glEnable(GL_CULL_FACE) Иногда это позволяет отбросить до 
половины многоугольников, не растеризуя их.[все] </P>
<P><STRONG>Избегайте лишних операций с пикселями</STRONG></P>
<P>Маскирование, альфа-смешивание и другие попиксельные операции могут занимать 
существенное время на этапе растеризации. Отключайте все операции, которые вы не 
используете. [все] </P>
<P><STRONG>Уменьшайте размер окна или разрешение экрана</STRONG></P>
<P>Простой способ уменьшить время растеризации – уменьшить число пикселей, 
которые будут нарисованы. Если меньшие размеры окна или меньшее разрешение 
экрана приемлемы, то это хороший путь для увеличения скорости растеризации. 
[все] </P>
<H4>Текстурирование</H4>
<P>Наложение текстур является дорогой операцией, как в программных, так и в 
аппаратных реализациях.</P>
<P><STRONG>Используйте эффективные форматы хранения изображений </STRONG></P>
<P>Формат GL_UNSIGNED_BYTE обычно наиболее всего подходит для передачи текстуры 
в OpenGL. [все] </P>
<P><STRONG>Объединяйте текстуры в текстурные объекты или дисплейные списки. 
</STRONG></P>
<P>Это особенно важно, если вы используете несколько текстур и позволяет 
графической подсистеме эффективно управлять размещением текстур в видеопамяти. 
[все] </P>
<P><STRONG>Не используйте текстуры большого размера</STRONG></P>
<P>Небольшие текстуры быстрее обрабатываются&nbsp; и занимают меньше памяти, что 
позволят хранить сразу несколько текстур в памяти графической подсистемы [all] 
</P>
<P><STRONG>Комбинируйте небольшие текстуры в одну</STRONG></P>
<P>Если вы используете несколько маленьких текстур, можно объединить их в одну 
большего размера и изменить текстурные координаты для работы нужной 
подтекстурой. Это позволяет уменьшить число переключений текстур. </P>
<P><STRONG>Анимированные текстуры</STRONG></P>
<P>Если вы хотите использовать анимированные текстуры, не используйте команду 
glTexImage2D чтобы обновлять образ текстуры. Вместо этого используйте 
glTexSubImage2D или glTexCopyTexSubImage2D. </P>
<H4>Очистка буферов</H4>
<P>Очистка буферов цвета, глубины, маски и буфера-накопителя может требовать 
много времени, особенно в программных реализациях OpenGL. В этом разделе описаны 
некоторые приемы, которые могут помочь оптимизировать эту операцию. </P>
<P><STRONG>Используйте команду </STRONG>glClear<STRONG> с осторожностью 
[все]</STRONG> </P>
<P>Очищайте все нужные буферы с помощью одной команды glClear. &nbsp; </P>
<P>Неверно: </P>
<DIV id=XSLTCODE130140124157120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE>glClear(GL_COLOR_BUFFER_BIT);
<SPAN class=KEYWORD>if</SPAN> (stenciling)  <SPAN class=COMMENT>/* очистить буфер маски? */</SPAN>
{
&nbsp;&nbsp;&nbsp; glClear(GL_STENCIL_BUFFER_BIT);
}
</PRE></TD></TR></TBODY></TABLE></DIV>
<P></P>
<P>Верно: </P>
<DIV id=XSLTCODE136140124157120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>if</SPAN> (stenciling) <SPAN class=COMMENT>/* очистить буфер маски? */</SPAN>
{
&nbsp;&nbsp; glClear(GL_COLOR_BUFFER_BIT |
           STENCIL_BUFFER_BIT);
}
<SPAN class=KEYWORD>else</SPAN> 
{
  glClear(GL_COLOR_BUFFER_BIT);
}
</PRE></TD></TR></TBODY></TABLE></DIV>
<P><STRONG>Отключайте размывание (dithering) </STRONG></P>
<P>Отключайте размывание перед очисткой буфера. Обычно различие между очистками 
с включенным размыванием и без него незаметно. [П]</P>
<P><STRONG>Используйте ножницы (scissors) для очистки меньшей области 
</STRONG></P>
<P>Если вы не хотите очищать весь буфер, используйте&nbsp; glScissor() для 
ограничения очистки по заданной области [все]. </P>
<P><STRONG>Не очищайте буфер цвета полностью </STRONG></P>
<P>Если ваша сцена занимает только часть окна, нет необходимости очищать весь 
буфер цвета. [П]</P>
<P><STRONG>Избегайте команды glClearDepth(d), где&nbsp; d!=1.0</STRONG></P>
<P>Некоторые программные реализации оптимизированы для очистки буфера с глубиной 
1.0. [П] </P>
<H4>Разное</H4>
<P><STRONG>Проверяйте ошибки GL во время написания программ. 
</STRONG>[все]<STRONG> </STRONG></P>
<P>Вызывайте команду glGetError() для проверки, не произошла ли ошибки во время 
вызова одной из функций OpenGL. Как правило, ошибки возникают из-за неверных 
параметров команд OpenGL или неверной последовательности команд. Для финальных 
версий кода отключайте эти проверки, так как они могут существенно замедлить 
работу. Для проверки можно использовать, например, такой макрос:</P>
<DIV id=XSLTCODE126142124157120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>#include</SPAN> &lt;assert.h&gt;
<SPAN class=KEYWORD>#define</SPAN> CHECK_GL \
   assert(glGetError() != GL_NO_ERROR);

Использовать его можно так:

glBegin(GL_TRIANGLES);
glVertex3f(1,1,1);
glEnd();
CHECK_GL
</PRE></TD></TR></TBODY></TABLE></DIV>
<P><STRONG>Используйте glColorMaterial вместо glMaterial </STRONG></P>
<P>Если в сцене материалы объектов различаются лишь одним параметром, команда 
glColorMaterial может быть быстрее, чем glMaterial [все] </P>
<P><STRONG>Минимизируйте число изменений состояния OpenGL </STRONG></P>
<P>Команды, изменяющие состояние OpenGL (glEnable/glDisable/glBindTexture и 
другие), вызывают повторные внутренние проверки целостности, создание 
дополнительных структур данных и т.д., что может приводить к задержкам [все] 
</P>
<P><STRONG>Избегайте использования команды glPolygonMode </STRONG></P>
<P>Если вам необходимо рисовать много незакрашенных многоугольников, используйте 
glBegin с <STRONG>GL_POINTS</STRONG>, <STRONG>GL_LINES</STRONG>, 
<STRONG>GL_LINE_LOOP</STRONG> или <STRONG>GL_LINE_STRIP</STRONG> вместо 
изменения режима рисования примитивов, так как это может быть намного быстрее 
[все] </P>
<P>Конечно, эти рекомендации охватывают лишь малую часть возможностей по 
оптимизации OpenGL-приложений. Тем не менее, при их правильном использовании 
можно достичь существенного ускорения работы ваших программ.</P>
<H4>Контрольные вопросы</H4>
<P>Перечислите известные вам методы высокоуровневой оптимизации 
OpenGL-приложений</P>
<P>Почему предпочтительнее использование связанных примитивов?</P>
<P>Какая из двух команд выполняется OpenGL быстрее?</P>
<DIV id=XSLTCODE128144124157120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE>glVertex3f(1,1,1) 
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>или </P>
<DIV id=XSLTCODE132144124157120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE>float vct[3] = {1,1,1};
glVertex3fv(vct)
</PRE></TD></TR></TBODY></TABLE></DIV>
<H2>Структура GLUT-приложения<A name=XSLTPART159120120></A></H2>
<P>Далее будем рассматривать построение консольного приложения при помощи 
библиотеки GLUT. Эта библиотека обеспечивает единый интерфейс для работы с 
окнами вне зависимости от платформы, поэтому описываемая ниже структура 
приложения остается неизменной для операционных систем Windows, Linux и 
других.</P>
<P>Функции GLUT могут быть классифицированы на несколько групп по своему 
назначению: </P>
<P>Инициализация </P>
<P>Начало обработки событий </P>
<P>Управление окнами </P>
<P>Управление меню </P>
<P>Регистрация функций с обратным вызовом </P>
<P>Управление индексированной палитрой цветов </P>
<P>Отображение шрифтов </P>
<P>Отображение дополнительных геометрических фигур (тор, конус и др.)</P>
<P></P>
<P>Инициализация проводится с помощью функции:</P>
<DIV id=XSLTCODE146159120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE>glutInit (<SPAN class=KEYWORD>int</SPAN> *argcp, <SPAN class=KEYWORD>char</SPAN> **argv)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>Переменная <I>argcp</I> есть указатель на стандартную переменную argc 
описываемую в функции main(), а <I>argv</I> – указатель на параметры, 
передаваемые программе при запуске, который описывается там же. Эта функция 
проводит необходимые начальные действия для построения окна приложения, и только 
несколько функций GLUT могут быть вызваны до нее. К ним относятся:</P>
<DIV id=XSLTCODE150159120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE>glutInitWindowPosition  (<SPAN class=KEYWORD>int</SPAN> x, <SPAN class=KEYWORD>int</SPAN> y)  
glutInitWindowSize  (<SPAN class=KEYWORD>int</SPAN> width, <SPAN class=KEYWORD>int</SPAN> height)
glutInitDisplayMode  (<SPAN class=KEYWORD>unsigned</SPAN> <SPAN class=KEYWORD>int</SPAN> mode) 
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>Первые две функции задают соответственно положение и размер окна, а последняя 
функция определяет различные режимы отображения информации, которые могут 
совместно задаваться с использованием операции побитового “или” ( “ | “ ) :</P>
<TABLE cellSpacing=2 cellPadding=5 border=0>
  <TBODY>
  <TR>
    <TD><STRONG>GLUT_RGBA</STRONG></TD>
    <TD>Режим RGBA. Используется по умолчанию, если не указаны явно режимы 
      GLUT_RGBA или GLUT_INDEX.</TD></TR>
  <TR>
    <TD><STRONG>GLUT_RGB</STRONG></TD>
    <TD>То же, что и GLUT_RGBA.</TD></TR>
  <TR>
    <TD><STRONG>GLUT_INDEX</STRONG></TD>
    <TD>Режим индексированных цветов (использование палитры). Отменяет 
      GLUT_RGBA.</TD></TR>
  <TR>
    <TD><STRONG>GLUT_SINGLE</STRONG></TD>
    <TD>Окно с одиночным буфером. Используется по умолчанию.</TD></TR>
  <TR>
    <TD><STRONG>GLUT_DOUBLE</STRONG></TD>
    <TD>Окно с двойным буфером. Отменяет GLUT_SINGLE.</TD></TR>
  <TR>
    <TD><STRONG>GLUT_STENCIL</STRONG></TD>
    <TD>Окно с трафаретным буфером.</TD></TR>
  <TR>
    <TD><STRONG>GLUT_ACCUM</STRONG> </TD>
    <TD>Окно с буфером накопления.</TD></TR>
  <TR>
    <TD><STRONG>GLUT_DEPTH</STRONG></TD>
    <TD>Окно с буфером глубины.</TD></TR></TBODY></TABLE>
<P>Это неполный список параметров для данной функции, однако для большинства 
случаев этого бывает достаточно. </P>
<P>Работа с буфером маски и буфером накопления описана в главе 6.</P>
<P>Функции библиотеки GLUT реализуют так называемый событийно-управляемый 
механизм. Это означает, что есть некоторый внутренний цикл, который запускается 
после соответствующей инициализации и обрабатывает одно за другим все события, 
объявленные во время инициализации. К событиям относятся: щелчок мыши, закрытие 
окна, изменение свойств окна, передвижение курсора, нажатие клавиши, и "пустое" 
(idle) событие, когда ничего не происходит. Для проведения периодической 
проверки совершения того или иного события надо зарегистрировать функцию, 
которая будет его обрабатывать. Для этого используются функции вида:</P>
<DIV id=XSLTCODE162159120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void</SPAN> glutDisplayFunc  (<SPAN class=KEYWORD>void</SPAN> (*func) (<SPAN class=KEYWORD>void</SPAN>))
<SPAN class=KEYWORD>void</SPAN> glutReshapeFunc (<SPAN class=KEYWORD>void</SPAN> (*func) (<SPAN class=KEYWORD>int</SPAN> width, 
                                    <SPAN class=KEYWORD>int</SPAN> height))
<SPAN class=KEYWORD>void</SPAN> glutMouseFunc  (<SPAN class=KEYWORD>void</SPAN> (*func) (<SPAN class=KEYWORD>int</SPAN> button, 
                     <SPAN class=KEYWORD>int</SPAN> state, <SPAN class=KEYWORD>int</SPAN> x, <SPAN class=KEYWORD>int</SPAN> y))
<SPAN class=KEYWORD>void</SPAN> glutIdleFunc (<SPAN class=KEYWORD>void</SPAN> (*func) (<SPAN class=KEYWORD>void</SPAN>))
<SPAN class=KEYWORD>void</SPAN> glutMotionFunc (<SPAN class=KEYWORD>void</SPAN> (*func)(<SPAN class=KEYWORD>int</SPAN> x, <SPAN class=KEYWORD>int</SPAN> y));
<SPAN class=KEYWORD>void</SPAN> glutPassiveMotionFunc (<SPAN class=KEYWORD>void</SPAN> (*func)(<SPAN class=KEYWORD>int</SPAN> x, <SPAN class=KEYWORD>int</SPAN> y));
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>Параметром для них является имя соответствующей функции заданного типа. С 
помощью <STRONG>glutDisplayFunc()</STRONG> задается функция рисования для окна 
приложения, которая вызывается при необходимости создания или восстановления 
изображения. Для явного указания, что окно надо обновить, иногда удобно 
использовать функцию</P>
<DIV id=XSLTCODE166159120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void </SPAN><STRONG>glutPostRedisplay</STRONG> (<SPAN class=KEYWORD>void</SPAN>)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>Через <STRONG>glutReshapeFunc(</STRONG>) устанавливается функция обработки 
изменения размеров окна пользователем, которой передаются новые размеры.</P>
<P><STRONG>glutMouseFunc()</STRONG> определяет функцию – обработчик команд от 
мыши, а <STRONG>glutIdleFunc()</STRONG> задает функцию, которая будет вызываться 
каждый раз, когда нет событий от пользователя.</P>
<P>Функция, определяемая <STRONG>glutMotionFunс</STRONG> вызывается, когда 
пользователь двигает указатель мыши, удерживая нажатой кнопку мыши. 
<STRONG>glutPassiveMotionFunc</STRONG> регистрирует функцию, вызываемую, если 
пользователь двигает указатель мыши и <I>не</I> нажато ни одной кпопки мыши.</P>
<P>Контроль всех событий происходит внутри бесконечного цикла в функции </P>
<DIV id=XSLTCODE176159120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void </SPAN><STRONG>glutMainLoop </STRONG>(<SPAN class=KEYWORD>void</SPAN>)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>которая обычно вызывается в конце любой программы, использующей GLUT. 
Структура приложения, использующего анимацию, будет следующей:</P>
<P></P>
<DIV id=XSLTCODE182159120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE> <SPAN class=KEYWORD>#include</SPAN> &lt;GL/glut.h&gt;  

 <SPAN class=KEYWORD>void</SPAN> MyIdle(<SPAN class=KEYWORD>void</SPAN>)
 {
 <SPAN class=COMMENT>/*Код, который меняет переменные, определяющие следующий  кадр */</SPAN>
…
};

<SPAN class=KEYWORD>void</SPAN> MyDisplay(<SPAN class=KEYWORD>void</SPAN>)
{
 <SPAN class=COMMENT>/* Код OpenGL, который отображает кадр */</SPAN>
  …
 <SPAN class=COMMENT>/* После рисования переставляем  буферы */</SPAN>
  glutSwapBuffers();
 };


<SPAN class=KEYWORD>void</SPAN> main(<SPAN class=KEYWORD>int</SPAN> argcp, <SPAN class=KEYWORD>char</SPAN> **argv)
{  
 <SPAN class=COMMENT>/* Инициализация GLUT */</SPAN>
 glutInit(&amp;argcp, argv);   
 glutInitWindowSize(640, 480);  
 glutInitWindowPosition(0, 0);  
 <SPAN class=COMMENT>/* Открытие окна */</SPAN>
 glutCreateWindow(<SPAN class=STRING>"My OpenGL Application"</SPAN>);  
 <SPAN class=COMMENT>/* Выбор режима:  двойной буфер и RGBA цвета */</SPAN> 
 glutInitDisplayMode(GLUT_RGBA | GLUT_DOUBLE | GLUT_DEPTH);  
 <SPAN class=COMMENT>/* Регистрация вызываемых функций */</SPAN>  
 glutDisplayFunc(MyDisplay);  
 glutIdleFunc(MyIdle);  
 <SPAN class=COMMENT>/* Запуск механизма обработки событий */</SPAN>  
 glutMainLoop();  
};
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>В случае , если приложение должно строить статичное изображение, можно 
заменить <STRONG>GLUT_DOUBLE</STRONG> на <STRONG>GLUT_SINGLE</STRONG>, так как 
одного буфера в этом случае будет достаточно, и убрать вызов функции 
<I>glutIdleFunc().</I> </P>
<H2>Примитивы библиотек GLU и GLUT<A name=XSLTPART161120120></A></H2>
<P>Рассмотрим стандартные команды построения примитивов, которые реализованы в 
библиотеках GLU и GLUT.</P>
<P>Чтобы построить примитив из библиотеки GLU, надо сначала создать указатель на 
quadric-объект с помощью команды gluNewQuadric(), а затем вызвать одну из команд 
gluSphere(), gluCylinder(), gluDisk(), gluPartialDisk(). Рассмотрим эти команды 
отдельно:</P>
<DIV id=XSLTCODE126161120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void </SPAN><STRONG>gluSphere</STRONG> (GLUquadricObj  *<I>qobj</I>, GLdouble<I> radius</I>,
                GLint<I> slices</I>, GLint<I> stacks</I>)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>Эта функция строит сферу с центром в начале координат и радиусом 
<I>radius</I>. При этом число разбиений сферы вокруг оси z задается параметром 
<I>slices</I>, а вдоль оси z – параметром <I>stacks</I>.</P>
<DIV id=XSLTCODE130161120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void </SPAN><STRONG>gluCylinder</STRONG> (GLUquadricObj  *<I>qobj</I><STRONG>,
                  </STRONG>GLdouble<I> baseRadius</I><STRONG>,
                  </STRONG>GLdouble <I>topRadius</I><STRONG>, 
                  </STRONG>GLdouble<I> height</I><STRONG>, </STRONG>GLint<I> slices</I><STRONG>, 
                  </STRONG>GLint<I> stacks</I>)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>Данная функция строит цилиндр без оснований (то есть кольцо), продольная ось 
параллельна оси z, заднее основание имеет радиус <I>baseRadius</I>, и 
расположено в плоскости z=0, переднее основание имеет радиус <I>topRadius</I> и 
расположено в плоскости z= <I>height</I>. Если задать один из радиусов равным 
нулю, то будет построен конус.</P>
<P>Параметры <I>slices</I> и<I> stacks</I> имеют аналогичный смысл, что и в 
предыдущей команде.</P>
<DIV id=XSLTCODE136161120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void </SPAN><STRONG>gluDisk </STRONG>(GLUquadricObj  *<I>qobj</I>, 
              GLdouble <I>innerRadius</I>, 
              GLdouble <I>outerRadius</I>, GLint <I>slices</I>, 
              GLint <I>loops</I>) 
</PRE></TD></TR></TBODY></TABLE></DIV>
<P></P>
<P>Функция строит плоский диск (то есть круг) с центром в начале координат и 
радиусом <I>outerRadius</I>. При этом если значение <I>innerRadius</I> отлично 
от нуля, то в центре диска будет находиться отверстие радиусом 
<I>innerRadius</I>. Параметр <I>slices</I> задает число разбиений диска вокруг 
оси z, а параметр <I>loops</I> –число концентрических колец, перпендикулярных 
оси z.</P>
<DIV id=XSLTCODE142161120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void </SPAN><STRONG>gluPartialDisk </STRONG>(GLUquadricObj *<I>qobj</I>, 
                     GLdouble <I>innerRadius</I>, 
                     GLdouble <I>outerRadius</I>, GLint <I>slices</I>, 
                     GLint <I>loops</I>, GLdouble <I>startAngle</I>,
                     GLdouble <I>sweepAngle</I>);
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>Отличие этой команды от предыдущей заключается в том, что она строит сектор 
круга, начальный и конечный углы которого отсчитываются против часовой стрелки 
от положительного направления оси y и задаются параметрами <I>startAngle</I> и 
<I>sweepAngle</I>. Углы измеряются в градусах.</P>
<P>Команды, проводящие построение примитивов из библиотеки GLUT, реализованы 
через стандартные примитивы OpenGL и GLU. Для построения нужного примитива 
достаточно произвести вызов соответствующей команды.</P>
<DIV id=XSLTCODE148161120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void </SPAN><STRONG>glutSolidSphere </STRONG>(GLdouble <I>radius</I>, GLint <I>slices</I>, 
                      GLint <I>stacks</I>)
<SPAN class=KEYWORD>void </SPAN><STRONG>glutWireSphere </STRONG>(GLdouble <I>radius</I>, GLint <I>slices</I>, 
                     GLint <I>stacks</I>)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P></P>
<P>Команда <STRONG>glutSolidSphere()</STRONG> строит сферу, а 
<STRONG>glutWireSphere()–</STRONG>каркас сферы радиусом <I>radius</I>. Остальные 
параметры те же, что и в предыдущих командах.</P>
<DIV id=XSLTCODE154161120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void </SPAN><STRONG>glutSolidCube </STRONG>(GLdouble <I>size</I>)
<SPAN class=KEYWORD>void </SPAN><STRONG>glutWireCube </STRONG> (GLdouble <I>size</I>)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P></P>
<P>Команды строят куб или каркас куба с центром в начале координат и длиной 
ребра <I>size</I>.</P>
<DIV id=XSLTCODE160161120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void </SPAN><STRONG>glutSolidCone </STRONG>(GLdouble <I>base</I>, GLdouble <I>height</I>, 
                    GLint <I>slices</I>, GLint <I>stacks</I>)
<SPAN class=KEYWORD>void </SPAN><STRONG>glutWireCone </STRONG>(GLdouble base, GLdouble height, 
                   GLint <I>slices</I>, GLint <I>stacks</I>)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>Эти команды строят конус или его каркас высотой <I>height</I> и радиусом 
основания <I>base</I>, расположенный вдоль оси z. Основание находится в 
плоскости z=0. </P>
<DIV id=XSLTCODE164161120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void </SPAN><STRONG>glutSolidTorus </STRONG>(GLdouble <I>innerRadius</I>, 
                     GLdouble <I>outerRadius</I>, GLint <I>nsides</I>, 
                     GLint <I>rings</I>)
<SPAN class=KEYWORD>void </SPAN><STRONG>glutWireTorus </STRONG>(GLdouble <I>innerRadius</I>, 
                    GLdouble <I>outerRadius</I>, GLint <I>nsides</I>,
                    GLint <I>rings</I>)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>Эти команды строят тор или его каркас в плоскости z=0. Внутренний и внешний 
радиусы задаются параметрами <I>innerRadius</I>, <I>outerRadius</I>. Параметр 
<I>nsides</I> задает число сторон в кольцах, составляющих ортогональное сечение 
тора, а <I>rings </I>– число радиальных разбиений тора.</P>
<DIV id=XSLTCODE168161120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void </SPAN><STRONG>glutSolidTetrahedron</STRONG> (<SPAN class=KEYWORD>void</SPAN>)
<SPAN class=KEYWORD>void </SPAN><STRONG>glutWireTetrahedron</STRONG> (<SPAN class=KEYWORD>void</SPAN>)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P></P>
<P>Эти команды строят тетраэдр (правильную треугольную пирамиду) или его каркас, 
при этом радиус описанной сферы вокруг него равен 1. </P>
<DIV id=XSLTCODE174161120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void </SPAN><STRONG>glutSolidOctahedron</STRONG> (<SPAN class=KEYWORD>void</SPAN>)
<SPAN class=KEYWORD>void </SPAN><STRONG>glutWireOctahedron </STRONG>(<SPAN class=KEYWORD>void</SPAN>)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P></P>
<P>Эти команды строят октаэдр или его каркас, радиус описанной вокруг него сферы 
равен 1.</P>
<DIV id=XSLTCODE180161120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void </SPAN><STRONG>glutSolidDodecahedron</STRONG> (<SPAN class=KEYWORD>void</SPAN>)
<SPAN class=KEYWORD>void </SPAN><STRONG>glutWireDodecahedron</STRONG> (<SPAN class=KEYWORD>void</SPAN>)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P></P>
<P>Эти команды строят додекаэдр или его каркас, радиус описанной вокруг него 
сферы равен квадратному корню из трех.</P>
<DIV id=XSLTCODE186161120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>void </SPAN><STRONG>glutSolidIcosahedron </STRONG>(<SPAN class=KEYWORD>void</SPAN>)
<SPAN class=KEYWORD>void </SPAN><STRONG>glutWireIcosahedron</STRONG> (<SPAN class=KEYWORD>void</SPAN>)
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>Эти команды строят икосаэдр или его каркас, радиус описанной вокруг него 
сферы равен 1.</P>
<P>Для корректного построения перечисленных примитивов необходимо удалять 
невидимые линии и поверхности, для чего надо включить соответствующий режим 
вызовом команды <STRONG>glEnable</STRONG>(GL_DEPTH_TEST). </P>
<H2>Настройка приложений OpenGL<A name=XSLTPART163120120></A></H2>
<H3>Создание приложения в среде Borland C++ 5.02<A 
name=XSLTSECTION122163120120></A></H3>
<P>Вначале необходимо обеспечить наличие файлов glut.h, glut32.lib, glut32.dll в 
каталогах BorlandC\Include\Gl, BorlandC\Lib, Windows\System соответственно. 
Также в этих каталогах надо проверить наличие файлов gl.h, glu.h, opengl32.lib, 
glu32.lib, opengl32.dll, glu32.dll, которые обычно входят в состав BorlandC++ и 
Windows. При этом надо учитывать, что версии Microsoft файлов opengl32.lib, 
glu32.lib, glut32.lib для Borland C++ не подходят, и следует использовать только 
совместимые версии. Чтобы создать такие версии, надо использовать стандартную 
программу ‘implib’, которая находится в каталоге BorlandC\Bin. Для этого надо 
выполнить команды вида</P>
<DIV id=XSLTCODE124122163120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE>implib  BorlandC\Lib\filename.lib  filename.dll
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>для перечисленных файлов, которые создают нужный *.lib файл из 
соответствующего *.dll файла. Кроме того, надо отметить, что компилятор BorlandC 
не может по неизвестным причинам использовать файл glaux.lib, входящий в состав 
BorlandC++5.02, при компиляции приложения, использующего библиотеку GLAUX, 
поэтому возможно от этой библиотеки придется отказаться. Для создания приложения 
надо выполнить следующие действия:</P>
<P>Создание проекта: для этого надо выбрать <I>Project-&gt;New Project</I> и 
заполнить поля в окне <I>Target Expert</I> следующим образом: в поле 
<I>Platform</I> выбрать Win32, в поле <I>Taget Model</I> выбрать <I>Сonsole</I>, 
нажать <I>Advanced</I> и отменить выбор пунктов ‘ *.rc ‘ и ‘ *.def ‘.</P>
<P>Подключить к проекту библиотеки OpenGL. Для этого надо выбрать в окне проекта 
название исполняемого файла проекта (*.exe) и, нажав правую кнопку мыши, выбрать 
в контекстном меню пункт <I>Add node</I>. Затем надо определить положение файлов 
opengl32.lib, glu32.lib, glut32.lib.</P>
<P>Для компиляции выбрать <I>Project-&gt;Build All</I>, для выполнения – 
<I>Debug-&gt;Run</I>. </P>
<H3>Создание приложения в среде MS Visual C++ 6.0<A 
name=XSLTSECTION124163120120></A></H3>
<P>Перед началом работы необходимо скопировать файлы glut.h, glut32.lib 
glut32.dll в каталоги MSVC\Include\Gl, MSVC\Lib, Windows\System соответственно. 
Также в этих каталогах надо проверить наличие файлов gl.h, glu.h, opengl32.lib, 
glu32.lib, opengl32.dll, glu32.dll, которые обычно входят в состав Visual C++ и 
Windows. При использовании команд из библиотеки GLAUX к перечисленным файлам 
надо добавить glaux.h, glaux.lib. </P>
<P>Для создания приложения надо выполнить следующие действия:</P>
<P>Создание проекта: для этого надо выбрать 
<I>File-&gt;New-&gt;Projects-&gt;Win32 Console Application</I>, набрать имя 
проекта, OK.</P>
<P>В появившемся окне выбрать ‘<I>An empty project</I>’, Finish,OK.</P>
<P>Текст программы можно либо разместить в созданном текстовом файле (выбрав 
<I>File-&gt;New-&gt;Files-&gt;Text File</I>), либо добавиьб файл с расширением 
*.c или *.cpp в проект (выбрав <I>Project-&gt;Add To Project-&gt;Files</I>).</P>
<P>Подключить к проекту библиотеки OpenGL. Для этого надо выбрать 
<I>Project-&gt;Settings-&gt;Link</I> и в поле <I>Object/library modules</I> 
набрать названия нужных библиотек: opengl32.lib, glu32.lib, glut32.lib и, если 
надо, glaux.lib.</P>
<P>Для компиляции выбрать <I>Build-&gt;Build program.exe</I>, для выполнения – 
<I>Build-&gt;Execute program.exe</I>.</P>
<P>Чтобы при запуске не появлялось текстовое окно, надо выбрать 
<I>Project-&gt;Settings-&gt;Link</I> и в поле <I>Project Options</I> вместо 
‘subsystem:console’ набрать ‘subsystem:windows’, и набрать там же строку 
‘/entry:mainCRTStartup’</P>
<P>Когда программа готова, рекомендуется перекомпилировать ее в режиме ‘Release’ 
для оптимизации по быстродействию и объему. Для этого сначала надо выбрать 
<I>Build-&gt;Set Active Configuration…</I> и отметить ‘…-Win32 Release’, а затем 
заново подключить необходимые библиотеки.</P>
<H2>Демонстрационные программы<A name=XSLTPART165120120></A></H2>
<H3>Пример 1: Простое GLUT-приложение<A name=XSLTSECTION122165120120></A></H3>
<P>Этот простой пример предназначен для демонстрации структуры GLUT-приложения и 
простейших основ OpenGL. Результатом работы программы является случайный набор 
цветных прямоугольников, который меняется при нажатии левой кнопки мыши. С 
помощью правой кнопки мыши можно менять режим заливки прямоугольников.</P><A 
href="javascript:ToggleCode('XSLTCODE124122165120120')"><IMG 
id=imgXSLTCODE124122165120120 height=16 src="ogltut2.files/ls1.gif" width=32 
align=absMiddle border=0>Пример №1</A><BR>
<DIV id=XSLTCODE124122165120120 style="DISPLAY: none">
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>#include</SPAN> &lt;stdlib.h&gt;
<SPAN class=KEYWORD>#include</SPAN> &lt;gl/glut.h&gt;

<SPAN class=KEYWORD>#ifdef</SPAN> random
<SPAN class=KEYWORD>#undef</SPAN> random
<SPAN class=KEYWORD>#endif</SPAN>

<SPAN class=KEYWORD>#define</SPAN> random(m) (<SPAN class=KEYWORD>float</SPAN>)rand()*m/RAND_MAX

<SPAN class=COMMENT>/* ширина и высота окна */</SPAN>
GLint Width = 512, Height = 512;
<SPAN class=COMMENT>/* число прямоугольников в окне */</SPAN>
<SPAN class=KEYWORD>int</SPAN>   Times = 100;
<SPAN class=COMMENT>/* с заполнением ?*/</SPAN>
<SPAN class=KEYWORD>int</SPAN>   FillFlag  = 1;

<SPAN class=KEYWORD>long</SPAN>  Seed = 0;

<SPAN class=COMMENT>/* функция отображает прямоугольник */</SPAN>
<SPAN class=KEYWORD>void</SPAN>
DrawRect( <SPAN class=KEYWORD>float</SPAN> x1, <SPAN class=KEYWORD>float</SPAN> y1, <SPAN class=KEYWORD>float</SPAN> x2, <SPAN class=KEYWORD>float</SPAN> y2,
          <SPAN class=KEYWORD>int</SPAN> FillFlag )
{
  glBegin(FillFlag ? GL_QUADS : GL_LINE_LOOP);
  glVertex2f(x1, y1);
  glVertex2f(x2, y1);
  glVertex2f(x2, y2);
  glVertex2f(x1, y2);
  glEnd();
}

<SPAN class=COMMENT>/* управляет всем выводом на экран */</SPAN>
<SPAN class=KEYWORD>void</SPAN>
Display(<SPAN class=KEYWORD>void</SPAN>)
{
  <SPAN class=KEYWORD>int</SPAN> i;
  <SPAN class=KEYWORD>float</SPAN> x1, y1, x2, y2;
  <SPAN class=KEYWORD>float</SPAN> r, g, b;

  srand(Seed);

  glClearColor(0, 0, 0, 1);
  glClear(GL_COLOR_BUFFER_BIT);

  <SPAN class=KEYWORD>for</SPAN>( i = 0; i &lt; Times; i++ ) {
    r = random(1);
    g = random(1);
    b = random(1);
    glColor3f( r, g, b );

    x1 = random(1) * Width;
    y1 = random(1) * Height;
    x2 = random(1) * Width;
    y2 = random(1) * Height;
    DrawRect(x1, y1, x2, y2, FillFlag);
  }

  glFinish();
}

<SPAN class=COMMENT>/* Вызывается при изменении размеров окна */</SPAN>
<SPAN class=KEYWORD>void</SPAN>
Reshape(GLint w, GLint h)
{
  Width = w;
  Height = h;

  glViewport(0, 0, w, h);

  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  glOrtho(0, w, 0, h, -1.0, 1.0);

  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();
}

<SPAN class=COMMENT>/* Обрабатывает сообщения от мыши */</SPAN>
<SPAN class=KEYWORD>void</SPAN>
Mouse(<SPAN class=KEYWORD>int</SPAN> button, <SPAN class=KEYWORD>int</SPAN> state, <SPAN class=KEYWORD>int</SPAN> x, <SPAN class=KEYWORD>int</SPAN> y)
{
  <SPAN class=KEYWORD>if</SPAN>( state == GLUT_DOWN ) {
    <SPAN class=KEYWORD>switch</SPAN>( button ) {
      <SPAN class=KEYWORD>case</SPAN> GLUT_LEFT_BUTTON:
        Seed = random(RAND_MAX);
        <SPAN class=KEYWORD>break</SPAN>;
      <SPAN class=KEYWORD>case</SPAN> GLUT_RIGHT_BUTTON:
        FillFlag = !FillFlag;
        <SPAN class=KEYWORD>break</SPAN>;
    }
    glutPostRedisplay();
  }
}

<SPAN class=COMMENT>/* Обрабатывает сообщения от клавиатуры */</SPAN>
<SPAN class=KEYWORD>void</SPAN>
Keyboard( <SPAN class=KEYWORD>unsigned</SPAN> <SPAN class=KEYWORD>char</SPAN> key, <SPAN class=KEYWORD>int</SPAN> x, <SPAN class=KEYWORD>int</SPAN> y )
{
<SPAN class=KEYWORD>#define</SPAN> ESCAPE '\033'

  <SPAN class=KEYWORD>if</SPAN>( key == ESCAPE )
      exit(0);
}

main(<SPAN class=KEYWORD>int</SPAN> argc, <SPAN class=KEYWORD>char</SPAN> *argv[])
{
  glutInit(&amp;argc, argv);
  glutInitDisplayMode(GLUT_RGB);
  glutInitWindowSize(Width, Height);
  glutCreateWindow(<SPAN class=STRING>"Rect draw example (RGB)"</SPAN>);

  glutDisplayFunc(Display);
  glutReshapeFunc(Reshape);
  glutKeyboardFunc(Keyboard);
  glutMouseFunc(Mouse);

  glutMainLoop();
}
</PRE></TD></TR></TBODY></TABLE></DIV>
<H3>Пример 2: Модель освещения OpenGL<A name=XSLTSECTION124165120120></A></H3>
<P>Программа предназначена для демонстрации модели освещения OpenGL на примере 
простой сцена, состоящей из тора, конуса и шара. Объектам назначаются разные 
материалы. В сцене присутствует точечный источник света.</P><A 
href="javascript:ToggleCode('XSLTCODE124124165120120')"><IMG 
id=imgXSLTCODE124124165120120 height=16 src="ogltut2.files/ls1.gif" width=32 
align=absMiddle border=0>Пример №2</A><BR>
<DIV id=XSLTCODE124124165120120 style="DISPLAY: none">
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>#include</SPAN> &lt;GL/glut.h&gt;
<SPAN class=KEYWORD>#include</SPAN> &lt;stdlib.h&gt;

<SPAN class=COMMENT>/* параметры материала тора */</SPAN>
<SPAN class=KEYWORD>float</SPAN> mat1_dif[]={0.8f,0.8f,0.0f};
<SPAN class=KEYWORD>float</SPAN> mat1_amb[]= {0.2f,0.2f,0.2f};
<SPAN class=KEYWORD>float</SPAN> mat1_spec[]={0.6f,0.6f,0.6f};
<SPAN class=KEYWORD>float</SPAN> mat1_shininess=0.5f*128;

<SPAN class=COMMENT>/* параметры материала конуса */</SPAN>
<SPAN class=KEYWORD>float</SPAN> mat2_dif[]={0.0f,0.0f,0.8f};
<SPAN class=KEYWORD>float</SPAN> mat2_amb[]= {0.2f,0.2f,0.2f};
<SPAN class=KEYWORD>float</SPAN> mat2_spec[]={0.6f,0.6f,0.6f};
<SPAN class=KEYWORD>float</SPAN> mat2_shininess=0.7f*128;

<SPAN class=COMMENT>/* параметры материала шара */</SPAN>
<SPAN class=KEYWORD>float</SPAN> mat3_dif[]={0.9f,0.2f,0.0f};
<SPAN class=KEYWORD>float</SPAN> mat3_amb[]= {0.2f,0.2f,0.2f};
<SPAN class=KEYWORD>float</SPAN> mat3_spec[]={0.6f,0.6f,0.6f};
<SPAN class=KEYWORD>float</SPAN> mat3_shininess=0.1f*128;

<SPAN class=COMMENT>/* Инициализируем параметры материалов и
 * источника света
 */</SPAN>
<SPAN class=KEYWORD>void</SPAN> init (<SPAN class=KEYWORD>void</SPAN>)
{
   GLfloat light_ambient[] = { 0.0, 0.0, 0.0, 1.0 };
   GLfloat light_diffuse[] = { 1.0, 1.0, 1.0, 1.0 };
   GLfloat light_specular[] = { 1.0, 1.0, 1.0, 1.0 };
   GLfloat light_position[] = { 1.0, 1.0, 1.0, 0.0 };

   <SPAN class=COMMENT>/* устанавливаем параметры источника света */</SPAN>
   glLightfv (GL_LIGHT0, GL_AMBIENT, light_ambient);
   glLightfv (GL_LIGHT0, GL_DIFFUSE, light_diffuse);
   glLightfv (GL_LIGHT0, GL_SPECULAR, light_specular);
   glLightfv (GL_LIGHT0, GL_POSITION, light_position);

   <SPAN class=COMMENT>/* включаем освещение и источник света */</SPAN>
   glEnable (GL_LIGHTING);
   glEnable (GL_LIGHT0);

   <SPAN class=COMMENT>/* включаем z-буфер */</SPAN>
   glEnable(GL_DEPTH_TEST);

}

<SPAN class=COMMENT>/* Функция вызывается при необходимости
 * перерисовки изображения. В ней осуществляется
 * весь вывод геометрии.
 */</SPAN>
<SPAN class=KEYWORD>void</SPAN> display (<SPAN class=KEYWORD>void</SPAN>)
{
   <SPAN class=COMMENT>/* очищаем буфер кадра и буфер глубины */</SPAN>
   glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

   glPushMatrix ();
   glRotatef (20.0, 1.0, 0.0, 0.0);

   <SPAN class=COMMENT>/* отображаем тор */</SPAN>
   glMaterialfv (GL_FRONT,GL_AMBIENT,mat1_amb);
   glMaterialfv (GL_FRONT,GL_DIFFUSE,mat1_dif);
   glMaterialfv (GL_FRONT,GL_SPECULAR,mat1_spec);
   glMaterialf  (GL_FRONT,GL_SHININESS,mat1_shininess);

   glPushMatrix ();
   glTranslatef (-0.75, 0.5, 0.0);
   glRotatef (90.0, 1.0, 0.0, 0.0);
   glutSolidTorus (0.275, 0.85, 15, 15);
   glPopMatrix ();

   <SPAN class=COMMENT>/* отображаем конус */</SPAN>
   glMaterialfv (GL_FRONT,GL_AMBIENT,mat2_amb);
   glMaterialfv (GL_FRONT,GL_DIFFUSE,mat2_dif);
   glMaterialfv (GL_FRONT,GL_SPECULAR,mat2_spec);
   glMaterialf  (GL_FRONT,GL_SHININESS,mat2_shininess);

   glPushMatrix ();
   glTranslatef (-0.75, -0.5, 0.0);
   glRotatef (270.0, 1.0, 0.0, 0.0);
   glutSolidCone (1.0, 2.0, 15, 15);
   glPopMatrix ();

   <SPAN class=COMMENT>/* отображаем шар */</SPAN>
   glMaterialfv (GL_FRONT,GL_AMBIENT,mat3_amb);
   glMaterialfv (GL_FRONT,GL_DIFFUSE,mat3_dif);
   glMaterialfv (GL_FRONT,GL_SPECULAR,mat3_spec);
   glMaterialf  (GL_FRONT,GL_SHININESS,mat3_shininess);

   glPushMatrix ();
   glTranslatef (0.75, 0.0, -1.0);
   glutSolidSphere (1.0, 15, 15);
   glPopMatrix ();

   glPopMatrix ();
   <SPAN class=COMMENT>/* выводим сцену на экран */</SPAN>
   glFlush ();
}

<SPAN class=COMMENT>/* Вызывается при изменении пользователем размеров окна  
 */</SPAN>
<SPAN class=KEYWORD>void</SPAN> reshape(<SPAN class=KEYWORD>int</SPAN> w, <SPAN class=KEYWORD>int</SPAN> h)
{
  <SPAN class=COMMENT>/* устанавливаем размер области вывода
   * равным размеру окна
   */</SPAN>
  glViewport (0, 0, (GLsizei) w, (GLsizei) h);

  <SPAN class=COMMENT>/* задаем матрицу проекции с учетом размеров окна */</SPAN>
  glMatrixMode (GL_PROJECTION);
  glLoadIdentity ();

  gluPerspective(
    40.0, <SPAN class=COMMENT>/* угол зрения в градусах */</SPAN>
    (GLfloat)w/h, <SPAN class=COMMENT>/* коэффициент сжатия окна */</SPAN>
    1,100.0);  <SPAN class=COMMENT>/* расстояние до плоскостей отсечения */</SPAN>
  glMatrixMode (GL_MODELVIEW);

  glLoadIdentity ();
  gluLookAt(
   0.0f,0.0f,8.0f, <SPAN class=COMMENT>/* положение камеры */</SPAN>
   0.0f,0.0f,0.0f, <SPAN class=COMMENT>/* центр сцены */</SPAN>
   0.0f,1.0f,0.0f); <SPAN class=COMMENT>/* положительное направление оси y */</SPAN>
}

<SPAN class=COMMENT>/* Вызывается при нажатии клавиши на клавиатуре */</SPAN>
<SPAN class=KEYWORD>void</SPAN> keyboard(<SPAN class=KEYWORD>unsigned</SPAN> <SPAN class=KEYWORD>char</SPAN> key, <SPAN class=KEYWORD>int</SPAN> x, <SPAN class=KEYWORD>int</SPAN> y)
{
   <SPAN class=KEYWORD>switch</SPAN> (key) {
      <SPAN class=KEYWORD>case</SPAN> 27: <SPAN class=COMMENT>/* escape */</SPAN>
         exit(0);
         <SPAN class=KEYWORD>break</SPAN>;
   }
}

<SPAN class=COMMENT>/* Главный цикл приложения.
 * Создается окно, устанавливается режим
 * экрана с буфером глубины
 */</SPAN>
<SPAN class=KEYWORD>int</SPAN> main(<SPAN class=KEYWORD>int</SPAN> argc, <SPAN class=KEYWORD>char</SPAN>** argv)
{
   glutInit(&amp;argc, argv);
   glutInitDisplayMode (GLUT_SINGLE | GLUT_RGB
                        | GLUT_DEPTH);
   glutInitWindowSize (500, 500);
   glutCreateWindow (argv[0]);
   init ();
   glutReshapeFunc (reshape);
   glutDisplayFunc (display);
   glutKeyboardFunc (keyboard);
   glutMainLoop();
   <SPAN class=KEYWORD>return</SPAN> 0;
}
</PRE></TD></TR></TBODY></TABLE></DIV>
<H3>Пример 3: Текстурирование<A name=XSLTSECTION126165120120></A></H3>
<P>Результатом выполнения этой программы является построение тетраэдра с 
вращающимися вокруг него кольцами, на которые нанесена текстура. В среде MS 
Visual C++ программа может компилироваться без изменений, а при компиляции в 
Borland C++ придется закомментировать вызов и описание функции TextureInit(), 
после чего не будет проводиться наложение текстур. Как было сказано выше, 
попытка использовать функции из библиотеки GLAUX приводит к сообщению об ошибке 
при компиляции программы.</P>
<P>При компиляции программы в MS Visual C++ файл ‘texture.bmp’ надо поместить в 
каталог проекта или указать полный путь к нему, используя символ ‘/’. Если путь 
не указан, то при запуске исполняемого файла из операционной системы, файл с 
текстурой должен находиться в том же каталоге.</P><A 
href="javascript:ToggleCode('XSLTCODE126126165120120')"><IMG 
id=imgXSLTCODE126126165120120 height=16 src="ogltut2.files/ls1.gif" width=32 
align=absMiddle border=0>Пример №3</A><BR>
<DIV id=XSLTCODE126126165120120 style="DISPLAY: none">
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>#include</SPAN> &lt;GL\glut.h&gt;
<SPAN class=KEYWORD>#include</SPAN> &lt;gl\glaux.h&gt;
<SPAN class=KEYWORD>#include</SPAN> &lt;math.h&gt;

<SPAN class=KEYWORD>#define</SPAN> TETR_LIST 1

GLfloat light_col[] = {1,1,1};
<SPAN class=KEYWORD>float</SPAN> mat_diff1[]={0.8,0.8,0.8};
<SPAN class=KEYWORD>float</SPAN> mat_diff2[]={0.0,0.0,0.9};
<SPAN class=KEYWORD>float</SPAN> mat_amb[]= {0.2,0.2,0.2};
<SPAN class=KEYWORD>float</SPAN> mat_spec[]={0.6,0.6,0.6};
<SPAN class=KEYWORD>float</SPAN> shininess=0.7*128,
<SPAN class=KEYWORD>float</SPAN> CurAng=0, RingRad=1, RingHeight=0.1;
GLUquadricObj* QuadrObj;
GLuint TexId;
GLfloat TetrVertex[4][3], TetrNormal[4][3];

<SPAN class=COMMENT>/* Вычисление нормали к плоскости,
 * задаваемой точками a,b,c
 */</SPAN>
<SPAN class=KEYWORD>void</SPAN> getnorm (<SPAN class=KEYWORD>float</SPAN> a[3],<SPAN class=KEYWORD>float</SPAN> b[3],<SPAN class=KEYWORD>float</SPAN> c[3],<SPAN class=KEYWORD>float</SPAN> *n)
{
 <SPAN class=KEYWORD>float</SPAN> mult=0,sqr;
 <SPAN class=KEYWORD>int</SPAN> i,j;
 n[0]=(b[1]-a[1])*(c[2]-a[2])-(b[2]-a[2])*(c[1]-a[1]);
 n[1]=(c[0]-a[0])*(b[2]-a[2])-(b[0]-a[0])*(c[2]-a[2]);
 n[2]=(b[0]-a[0])*(c[1]-a[1])-(c[0]-a[0])*(b[1]-a[1]);
 <SPAN class=COMMENT>/* Определение нужного направления нормали: от точки (0,0,0) */</SPAN>
 <SPAN class=KEYWORD>for</SPAN> (i=0;i&lt;3;i++)  mult+=a[i]*n[i];
 <SPAN class=KEYWORD>if</SPAN> (mult&lt;0) <SPAN class=KEYWORD>for</SPAN> (j=0;j&lt;3;j++) n[j]=-n[j];
}

<SPAN class=COMMENT>/* Вычисление координат вершин тетраэдра */</SPAN>
<SPAN class=KEYWORD>void</SPAN> InitVertexTetr()
{
 <SPAN class=KEYWORD>float</SPAN> alpha=0;
 <SPAN class=KEYWORD>int</SPAN> i;
 TetrVertex[0][0]=0;
 TetrVertex[0][1]=1.3;
 TetrVertex[0][2]=0;
 <SPAN class=COMMENT>/* Вычисление координат основания тетраэдра */</SPAN>
 <SPAN class=KEYWORD>for</SPAN> (i=1;i&lt;4;i++)
 {
  TetrVertex[i][0]=0.94*cos(alpha);
  TetrVertex[i][1]=0;
  TetrVertex[i][2]=0.94*sin(alpha);
  alpha+=120.0*3.14/180.0;
 }
}

<SPAN class=COMMENT>/* Вычисление нормалей сторон тетраэдра */</SPAN>
<SPAN class=KEYWORD>void</SPAN> InitNormsTetr()
{
 getnorm(TetrVertex[0], TetrVertex[1], 
         TetrVertex[2], TetrNormal[0]);
 getnorm(TetrVertex[0], TetrVertex[2], 
         TetrVertex[3], TetrNormal[1]);
 getnorm(TetrVertex[0], TetrVertex[3], 
         TetrVertex[1], TetrNormal[2]);
 getnorm(TetrVertex[1], TetrVertex[2], 
         TetrVertex[3], TetrNormal[3]);
}

<SPAN class=COMMENT>/* Создание списка построения тетраэдра */</SPAN>
<SPAN class=KEYWORD>void</SPAN> MakeTetrList()
{
    <SPAN class=KEYWORD>int</SPAN> i;
  glNewList(TETR_LIST,GL_COMPILE);
  <SPAN class=COMMENT>/* Задание сторон тетраэдра */</SPAN>
  glBegin(GL_TRIANGLES);
  <SPAN class=KEYWORD>for</SPAN> (i=1;i&lt;4;i++)
  {
   glNormal3fv(TetrNormal[i-1]);
   glVertex3fv(TetrVertex[0]);
   glVertex3fv(TetrVertex[i]);
   <SPAN class=KEYWORD>if</SPAN> (i!=3) glVertex3fv(TetrVertex[i+1]);
     <SPAN class=KEYWORD>else</SPAN> glVertex3fv(TetrVertex[1]);
  }
  glNormal3fv(TetrNormal[3]);
  glVertex3fv(TetrVertex[1]);
  glVertex3fv(TetrVertex[2]);
  glVertex3fv(TetrVertex[3]);

  glEnd();
  glEndList();
}

<SPAN class=KEYWORD>void</SPAN> DrawRing()
{
 <SPAN class=COMMENT>/* Построение цилиндра (кольца), расположенного
  * параллельно оси z. Второй и третий параметры
  * задают радиусы оснований, четвертый высоту,
  * последние два-число разбиений вокруг и вдоль
  * оси z. При этом дальнее основание цилиндра
  * находится в плоскости z=0
  */</SPAN>
  gluCylinder (QuadrObj,RingRad,RingRad,RingHeight,30,2);
}

<SPAN class=KEYWORD>void</SPAN> TextureInit()
{
 <SPAN class=KEYWORD>char</SPAN> strFile[]=<SPAN class=STRING>"texture.bmp"</SPAN>;
 AUX_RGBImageRec *pImage;

 <SPAN class=COMMENT>/* Выравнивание в *.bmp по байту */</SPAN>
 glPixelStorei(GL_UNPACK_ALIGNMENT,1);
 <SPAN class=COMMENT>/* Создание идентификатора для текстуры */</SPAN>
 glGenTextures(1,&amp;TexId);
 <SPAN class=COMMENT>/* Загрузка изображения в память */</SPAN>
 pImage = auxDIBImageLoad(strFile);

 <SPAN class=COMMENT>/* Начало описания свойств текстуры */</SPAN>
 glBindTexture (GL_TEXTURE_2D,TexId);
 <SPAN class=COMMENT>/* Создание уровней детализации и инициализация текстуры
  */</SPAN>
 gluBuild2DMipmaps(GL_TEXTURE_2D,3,pImage-&gt;sizeX,
                   pImage-&gt;sizeY,GL_RGB,GL_UNSIGNED_BYTE,
                   pImage-&gt;data);
 <SPAN class=COMMENT>/* Разрешение наложения этой текстуры на quadric-объекты
  */</SPAN>   
 gluQuadricTexture (QuadrObj, GL_TRUE);
 <SPAN class=COMMENT>/* Задание параметров текстуры */</SPAN>
 <SPAN class=COMMENT>/* Повтор изображения по параметрическим осям s и t */</SPAN>
 glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
 glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
 <SPAN class=COMMENT>/* Не использовать интерполяцию при выборе точки на
* текстуре
  */</SPAN>
 glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
 glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
 <SPAN class=COMMENT>/* Совмещать текстуру и материал объекта */</SPAN>
 glTexEnvi (GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
}


<SPAN class=KEYWORD>void</SPAN> Init(<SPAN class=KEYWORD>void</SPAN>)
{
 InitVertexTetr();
 InitNormsTetr();
 MakeTetrList();
 <SPAN class=COMMENT>/* Определение свойств материала */</SPAN>
 glMaterialfv (GL_FRONT_AND_BACK, GL_AMBIENT, mat_amb);
 glMaterialfv (GL_FRONT_AND_BACK, GL_SPECULAR, mat_spec);
 glMaterialf  (GL_FRONT, GL_SHININESS, shininess);
 <SPAN class=COMMENT>/* Определение свойств освещения */</SPAN>
 glLightfv(GL_LIGHT0, GL_DIFFUSE, light_col);
 glEnable(GL_LIGHTING);
 glEnable(GL_LIGHT0);
 <SPAN class=COMMENT>/* Проводить удаление невидимых линий и поверхностей */</SPAN>
 glEnable(GL_DEPTH_TEST);
 <SPAN class=COMMENT>/* Проводить нормирование нормалей */</SPAN>
 glEnable(GL_NORMALIZE);
 <SPAN class=COMMENT>/* Материалы объектов отличаются только цветом диффуз-
  * ного отражения   
  */</SPAN>
 glEnable(GL_COLOR_MATERIAL);
 glColorMaterial(GL_FRONT_AND_BACK,GL_DIFFUSE);
 <SPAN class=COMMENT>/* Создания указателя на quadric-объект для построения 
* колец
  */</SPAN>
 QuadrObj=gluNewQuadric();
 <SPAN class=COMMENT>/* Определение свойств текстуры */</SPAN>
 TextureInit();
 <SPAN class=COMMENT>/* Задание перспективной проекции */</SPAN>
 glMatrixMode(GL_PROJECTION);
 gluPerspective(89.0,1.0,0.5,100.0);
 <SPAN class=COMMENT>/* Далее будет проводиться только
  * преобразование объектов сцены  
  */</SPAN>
 glMatrixMode(GL_MODELVIEW);
}

<SPAN class=KEYWORD>void</SPAN> DrawFigures(<SPAN class=KEYWORD>void</SPAN>)
{
 <SPAN class=COMMENT>/* Включение режима нанесения текстуры */</SPAN>
 glEnable(GL_TEXTURE_2D);
 <SPAN class=COMMENT>/* Задаем цвет диффузного отражения для колец */</SPAN>
 glColor3fv(mat_diff1);
 <SPAN class=COMMENT>/* Чтобы не проводить перемножение с предыдущей матрицей
* загружаем единичную матрицу
  */</SPAN>
 glLoadIdentity();
 <SPAN class=COMMENT>/* Определяем точку наблюдения */</SPAN>
 gluLookAt(0.0, 0.0, 2.5,0.0, 0.0, 0.0, 0.0, 1.0, 0.0);
 <SPAN class=COMMENT>/* Сохраняем видовую матрицу, так как дальше будет
* проводиться поворот колец
*/</SPAN>
 glPushMatrix();
  <SPAN class=COMMENT>/* Производим несколько поворотов на новый
   * угол (это быстрее, чем  умножать предыдущую
   * видовую матрицу на матрицу поворота с фиксированным
* углом поворота)
*/</SPAN>
  glRotatef (-CurAng,1,1,0);
  glRotatef (CurAng,1,0,0);
  <SPAN class=COMMENT>/* Для рисования колец каждое из них надо
   * преобразовать отдельно, поэтому сначала сохраняем
* видовую матрицу, затем восстанавливаем
*/</SPAN>
  glPushMatrix();
   glTranslatef (0,0,-RingHeight/2);
   DrawRing();
  glPopMatrix();
  glPushMatrix();
   glTranslatef (0,RingHeight/2,0);
   glRotatef (90,1,0,0);
   DrawRing();
  glPopMatrix();
  glPushMatrix();
   glTranslatef (-RingHeight/2,0,0);
   glRotatef (90,0,1,0);
   DrawRing();
  glPopMatrix();
 <SPAN class=COMMENT>/* Восстанавливаем матрицу для поворотов тераэдра */</SPAN>
 glPopMatrix();
 <SPAN class=COMMENT>/* Выключаем режим наложения текстуры */</SPAN>
 glDisable(GL_TEXTURE_2D);
 <SPAN class=COMMENT>/* Проводим повороты */</SPAN>
 glRotatef (CurAng,1,0,0);
 glRotatef (CurAng/2,1,0,1);
 <SPAN class=COMMENT>/* Чтобы тетраэдр вращался вокруг центра, его
* надо сдвинуть вниз по  оси oz
*/</SPAN>
 glTranslatef (0,-0.33,0);
 <SPAN class=COMMENT>/* Задаем цвет диффузного отражения для тетраэдра */</SPAN>
 glColor3fv(mat_diff2);
 <SPAN class=COMMENT>/* Проводим построение тетраэдра */</SPAN>
 glCallList(TETR_LIST);
}

<SPAN class=KEYWORD>void</SPAN> Display(<SPAN class=KEYWORD>void</SPAN>)
{
 <SPAN class=COMMENT>/* Инициализация (очистка) текущего буфера кадра и
  * глубины    
  */</SPAN>
 glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
 <SPAN class=COMMENT>/* Построение объектов */</SPAN>
 DrawFigures();
 <SPAN class=COMMENT>/* Перестановка буферов кадра */</SPAN>
 glutSwapBuffers();
}

<SPAN class=KEYWORD>void</SPAN> Redraw(<SPAN class=KEYWORD>void</SPAN>)
{
 <SPAN class=COMMENT>/* Увеличение текущего угла поворота */</SPAN>
 CurAng+=1;
 <SPAN class=COMMENT>/* Сигнал для вызова процедуры создания
* изображения (для обновления)
*/</SPAN>
 glutPostRedisplay();
}

<SPAN class=KEYWORD>int</SPAN> main(<SPAN class=KEYWORD>int</SPAN> argc, <SPAN class=KEYWORD>char</SPAN> **argv)
{
  <SPAN class=COMMENT>/* Инициализация функций библиотеки GLUT */</SPAN>
  glutInit(&amp;argc, argv);
  <SPAN class=COMMENT>/* Задание режима с двойной буферизацией,
   * представление цвета в  формате RGB, использование
* буфера глубины
*/</SPAN>
  glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
  <SPAN class=COMMENT>/* Создание окна приложения */</SPAN>
  glutCreateWindow(<SPAN class=STRING>"Example of using OpenGL"</SPAN>);
  <SPAN class=COMMENT>/* Регистрация функции построения изображения */</SPAN>
  glutDisplayFunc(Display);
  <SPAN class=COMMENT>/* Регистрация функции обновления изображения */</SPAN>
  glutIdleFunc(Redraw);
  <SPAN class=COMMENT>/* Инициализация функций OpenGL */</SPAN>
  Init();
  <SPAN class=COMMENT>/* Цикл обработки событий */</SPAN>
  glutMainLoop();
  <SPAN class=KEYWORD>return</SPAN> 0;
}
</PRE></TD></TR></TBODY></TABLE></DIV>
<H2>Примеры практических заданий<A name=XSLTPART167120120></A></H2>
<H3>Cornell Box<A name=XSLTSECTION122167120120></A></H3>
<P>Целью задания является создание изображения&nbsp; заданной трехмерной 
статичной сцены средствами OpenGL с использованием, возможно, стандартных 
геометрических примитивов. </P>
<P>Требуется создать изображение сцены Cornell Box. Эта классическая сцена 
представляет собой комнату кубического вида, с отсутствующей передней стенкой. В 
комнате находятся геометрические предметы различных форм и свойств (кубы, 
параллелепипеды, шары), и протяженный источник света на потолке. Присутствует 
также камера с заданными параметрами (обычно она расположена так, чтобы была 
видна вся комната). В одной из лабораторий Корнельского университета (<U><A 
href="http://graphics.cornell.edu/">http://graphics.cornell.edu/</A></U>) такая 
комната существует в реальности, и ее фотографии сравниваются с изображениями, 
построенными методами трассировки лучей для оценки точности методов. На странице 
лаборатории можно найти описание геометрии сцены в текстовом формате.</P>
<P>Реализации сцены, приведенной на рисунке достаточно для выполнения задания, 
хотя возможно введение новых предметов дополнительно к существующим, или вместо 
них. Приветствуется использование примитивов библиотек GLUT и GLU.&nbsp; 
Внимание! Сцена не должна превращаться в набор разнородных предметов. 
Эстетичность и оригинальность выполненного задания принимается во внимание. </P>
<P>Протяженный источник света на потолке комнаты можно эмулировать несколькими 
точечными источниками. </P>
<P>За&nbsp; простейшую реализацию сцены ставится 7 баллов. </P>
<P>Реалистичность сцены можно значительно повысить за счет разбиение 
многоугольников. Суть этого в том, что модели освещение OpenGL освещенность 
вычисляется в вершинах многоугольника с учетом направления нормалей в этих 
вершинах, а затем линейно интерполируется&nbsp; по всей поверхности. Если 
используются относительно большие многоугольники, то, очевидно, невозможно 
получить действительно плавные переходы&nbsp; и затенения. Для преодоления этого 
недостатка можно разбивать большие грани (стены, например) на множество меньших 
по размерам. Соответственно разброс в направлении нормалей в вершинах одного 
многоугольника не будет столь велик и затенение станет более плавным. (1 балл) 
</P>
<P>Наложение текстур на объекты сцены поощряется 2-мя баллами. </P>
<P>Дополнительными баллами оценивается присутствие в сцене теней. Один из 
простейших алгоритмов наложения теней приведен в разделе 0. За его реализацию 
можно получить до 2 баллов. Использование более продвинутых алгоритмов 
(например, shadow volumes) будет оценено дополнительными баллами. </P>
<P>Реализация устранения ступенчатости (antialiasing) методом, предложенным в 
разделе 0. или каким-либо другим оценивается в 2 балла. </P>
<P>За введение в сцену прозрачных объектов и корректный их вывод дается 1 балл. 
Механизм работы с прозрачными объектами описан в разделе 0. </P>
<P>Задание оценивается, исходя из 15 баллов. </P>
<P>В приведенной ниже таблице указано распределение баллов в зависимости от 
реализованных требований:</P>
<P> </P>
<TABLE cellSpacing=2 cellPadding=5 border=0>
  <TBODY>
  <TR>
    <TD>Простейший вариант сцены (только освещение)</TD>
    <TD>7 баллов</TD></TR>
  <TR>
    <TD>Разбиение полигонов</TD>
    <TD>+1 балл</TD></TR>
  <TR>
    <TD>Использование текстур</TD>
    <TD>+2 балла</TD></TR>
  <TR>
    <TD>Наложение теней</TD>
    <TD>+2 балла</TD></TR>
  <TR>
    <TD>Устранение ступенчатости</TD>
    <TD>+2 балла</TD></TR>
  <TR>
    <TD>Использование прозрачных объектов</TD>
    <TD>+1 балл</TD></TR></TBODY></TABLE>
<P></P>
<P>Дополнительные баллы можно получить за хорошую оптимизацию программы, 
необычные решения, эстетичность и т.д.&nbsp; </P>
<H3>Виртуальные часы<A name=XSLTSECTION124167120120></A></H3>
<P>Целью задания является создание трехмерной интерактивной модели аналоговых 
часов.&nbsp; </P>
<P>Обязательные требования к программе:&nbsp; </P>
<P>Программа должна демонстрировать на экране трехмерную модель часов. Часы 
могут быть любые, от наручных до кремлевских. Проявите в полной мере Вашу 
фантазию и чувство меры! Постарайтесь сделать как можно более реалистичную 
сцену. Поощряется подробная детализация элементов часов.&nbsp; </P>
<P>Часы на экране обязательно должны иметь минутную и часовую стрелки. Секундная 
- по желанию, но очень приветствуется (иначе трудно будет определить, ходят часы 
или нет). </P>
<P>Время на часах должно совпадать с системным временем компьютера. Часы 
обязательно должны ходить, т.е. стрелки должны двигаться и скорость их движения 
не должна зависеть от производительности компьютера, а определяться только 
текущим временем. </P>
<P>Сцена должна быть интерактивной, т.е. давать приемлемую частоту кадров в 
секунду (&gt;10) при визуализации на машине с аппаратным ускорителем трехмерной 
графики. Если программа будет работать медленно, баллы могут быть снижены</P>
<P>Необходимо реализовать вращения часов (или, возможно, камеры) с помощью мыши 
(предпочтительно) или клавиатуры. Можно также предусмотреть режимы с 
автоматическим вращением. </P>
<P>Пожелания к программе:&nbsp; </P>
<P>Поощряется введение дополнительной геометрии. Например, ремешков, маятников и 
т.д. Можно сделать часы с кукушкой, будильник и т.п.&nbsp; </P>
<P>Желательно наличие возможностей для управления процессом визуализации. 
Например, наличие/отсутствие текстур, режимы заливки, детализации и т.д. </P>
<P>Приветствуется выполнение задания в виде демонстрации, т.е.&nbsp; c 
возможностью работы в полноэкранном режиме и немедленным выходом по клавише 
Escape. Можно написать программу как Screen Saver. </P>
<P>Постарайтесь использовать максимум возможностей OpenGL. Блики, отражения, 
спецэффекты - за все это обязательно даются дополнительные баллы. </P>
<P>Проявите вкус - сделайте так, чтобы нравилось прежде всего Вам. Но не 
увлекайтесь - оставайтесь реалистами. </P>
<P>Максимальная оценка - 20 баллов. За минимальную реализацию требований 
ставиться 10 баллов. Еще до 10 баллов можно получить за использование в работе 
возможностей OpenGL (текстур, прозрачности , environment mapping и пр.), 
оригинальных и продвинутых алгоритмов, количество настроек, а также за 
эстетичность и красоту сцены.&nbsp; </P>
<H3>Интерактивный ландшафт<A name=XSLTSECTION126167120120></A></H3>
<P>Целью данного задания является генерация и вывод с помощью OpenGL поверхности 
ландшафта, а также обеспечение интерактивного передвижения над ней.</P>
<P><STRONG>Обязательная часть задания </STRONG></P>
<P>Для выполнения обязательной части задания необходимы: </P>
<P>генерация трехмерного ландшафта </P>
<P>раскраска для придания реалистичности </P>
<P>эффект тумана</P>
<P>возможность "полета" над ландшафтом (управление) </P>
<P>Более подробное описание: </P>
<P><I>Генерация ландшафта</I> </P>
<P>Один из вариантов задания поверхности ландшафта - задание так называемого 
"поля высот" - функции вида z=f(x, y), которая сопоставляет каждой точке (x, y) 
плоскости OXY число z - высоту поверхности ландшафта в этой точке. Один из 
способов задания функции f - табличный, когда функция f представляется матрицей 
T размера M x N, и для целых x и y f=T[x, y], а для дробных x и y из диапазонов 
[0..M-1] и [0..N-1] соответственно f вычисляется интерполяцией значений f в 
ближайших точках плоскости OXY с целыми x и y, а вне указанных диапазонов x и y 
значение функции считается неопределенным.</P>
<P>Допустим, в памяти лежит двухмерный массив со значениями матрицы T. Пусть 
N=M. Если теперь для каждого квадрата [x, x+1] x [y, y+1], где x и y принадлежат 
диапазону [0..N-2] построить две грани: ((x, y, T[x, y]), (x+1, y, T[x+1, y]), 
(x+1, y+1, T[x+1, y+1])) и ((x, y, T[x, y]), (x+1, y+1, T[x+1, y+1]), (x, y+1, 
T[x, y+1])), то мы получим трехмерную модель поверхности, описываемой матрицей 
Т.</P>
<P>Но каким образом задать массив значений матрицы Т? Один из способов - 
сгенерировать псевдослучайную поверхность с помощью фрактального разбиения. Для 
этого положим размерность матрицы T равной 2^N+1, где N - натуральное число. 
Зададим некоторые произвольные (псевдослучайные) значения для четырех угловых 
элементов матрицы Т. Теперь для каждого из четырех ребер матрицы Т (это столбцы 
или строки элементов, соединяющие угловые элементы) вычислим значение элемента 
матрицы Т, соответствующего середине ребра. Для этого возьмем среднее 
арифметическое значений элементов матрицы Т в вершинах ребра и прибавим к 
получившемуся значению некоторое псевдослучайное число, пропорциональное длине 
ребра. Значение центрального элемента матрицы Т вычислим аналогично, только 
будем брать среднее арифметическое четырех значений элементов матрицы в 
серединах ее ребер. </P>
<P>Теперь разобьем матрицу Т на четыре квадратные подматрицы. Значения их 
угловых элементов уже определены и мы можем рекурсивно применить к подматрицам Т 
описанную выше процедуру. Будем спускаться рекурсивно по дереву подматриц, пока 
все элементы Т не будут определены. С помощью подбора коэффициентов генерации 
псевдослучайной добавки можно регулировать "изрезанность" поверхности. Для 
реалистичности поверхности важно сделать величину псевдослучайной добавки 
зависящей от длины текущего ребра - с уменьшением размера ребра должно 
уменьшаться и возможное отклонение высоты его середины от среднего 
арифметического высот его вершин.</P>
<P>Один из других вариантов - использовать изображения в градациях серого для 
карты высот. (В этом случае ландшафт можно оттекстурировать с помощью 
соответствующей цветной картинки и линейной генерации текстурных координат)</P>
<P>Внимание: использование NURBS возможно, но не приветствуется в силу 
ограниченности использования NURBS для реальных приложений.</P>
<P><I>Раскраска ландшафта </I></P>
<P>Чтобы сделать получившуюся модель немного более напоминающей ландшафт, ее 
можно раскрасить. Каждой вершине можно сопоставить свой цвет, зависящий от 
высоты этой вершины. Например, вершины выше определенного уровня можно покрасить 
в белый цвет в попытке сымитировать шапки гор, вершины пониже - в коричневый 
цвет скал, а вершины уровнем еще ниже - в зеленый цвет травы. Значения "уровней" 
раскраски поверхности следует подобрать из эстетических соображений. </P>
<P><I>Освещение ландшафта</I></P>
<P>Для еще большего реализма и для подчеркивания рельефа осветить модель 
ландшафта бесконечно удаленным источником света (как бы солнцем). </P>
<P>Цвет вершин можно задавать через glColor*() совместно с 
glColorMaterial(GL_FRONT, GL_AMBIENT_AND_DIFFUSE); </P>
<P><I>Туман</I> </P>
<P>Чтобы усилить (или хотя бы создать) иллюзию больших размеров модели и ее 
протяженности, можно воспользоваться эффектом тумана. Тип тумана (линейный или 
экспоненциальный) следует выбрать из индивидуальных эстетических предпочтений. 
Способ создания тумана описан в разделе 0.</P>
<P><I>Управление</I></P>
<P>Элементарное управление движением камеры по клавиатурным "стрелочкам". 
Нажатие на стрелку "вверх" - передвижение по направлению взгляда вперед. "Назад" 
- по направлению взгляда назад. "Влево", "Вправо" по аналогии, "Page Up", "Page 
Down" - вверх, вниз, соответственно.</P>
<P>В GLUT'е получать нажатия не алфавитно-цифровых клавиш можно через функцию 
glutSpecialFunc(void (*)(int key, int x, int y)), где key - константа, 
обозначающая клавишу (см. в glut.h - <STRONG>GLUT_KEY_</STRONG>). Функция 
используется аналогично glutKeyboardFunc().</P>
<P><STRONG>Дополнительная часть</STRONG></P>
<P><I>Управление мышью:</I></P>
<P>Движение мыши в горизонтальной плоскости (смещение по оси X) управляет углом 
поворота направления взгляда в горизонтальной плоскости (альфа, от 0 до 2*PI). 
Движение мыши в вертикальной плоскости (смещение по оси Y) управляет углом 
поворота направления взгляда в вертикальной плоскости относительно горизонта 
(бета, от -PI до PI). Зная оба угла, вектор направления взгляда в мировых 
координатах вычисляется следующим образом:</P>
<P>direction_z = sin(бета);</P>
<P>direction_x = cos(альфа) * cos(бета);</P>
<P>direction_y = sin(альфа) * cos(бета),</P>
<P>а затем нормализуется. </P>
<P>Вектор направления "вбок" вычисляется как векторное произведение вектора 
направления вертикально вверх, то есть вектора (0, 0, 1) и уже известного 
вектора направления взгляда.</P>
<P>Вектор направления "вверх" вычисляется как векторное произведение вектора 
направления взгляда и вектора направления "вбок".</P>
<P>Положение камеры в OpenGL можно передать через gluLookAt(). Подсказка: 
параметр <I>target </I>можно положить равным <I>position</I> + 
<I>direction</I></P>
<P>Смещение позиции камеры должно происходить не на фиксированное расстояние за 
один кадр, а вычисляться, исходя из скорости передвижения камеры, и времени, 
ушедшего на обсчет последнего кадра. Передвижение камеры должно осуществляться в 
направлении взгляда. Скажем, по левой кнопке мыши - вперед, а по правой - назад. 
Для того, чтобы засечь время, можно воспользоваться функцией timeGetTime(), 
описанной в "mmsystem.h", и реализованной в библиотеке "winmm.lib" (только для 
Windows)</P>
<DIV id=XSLTCODE194126167120120>
<TABLE class=code width="98%">
  <TBODY>
  <TR>
    <TD><PRE><SPAN class=KEYWORD>#include</SPAN> <SPAN class=STRING>"mmsystem.h"</SPAN>
...
<SPAN class=KEYWORD>void</SPAN> Display()
{
...
<SPAN class=KEYWORD>int</SPAN> system_time_before_rendering;
system_time_before_rendering = timeGetTime();
RenderFrame();
<SPAN class=KEYWORD>int</SPAN> time_spent_rendering_msec = 
        timeGetTime() -system_time_before_rendering;
...
}
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>В GLUT'е для этого есть специальный вызов </P>
<P>time = glutGet(GLUT_ELAPSED_TIME) (аналогично timeGetTime())</P>
<P><I>Вода, или нечто на нее похожее</I></P>
<P>При раскраске ландшафта можно добавить еще один, самый нижний "уровень" - 
уровень воды. Вершины, располагающиеся на этом уровне можно покрасить в цвет 
воды - предположительно, синий. Для того, чтобы получившиеся "водоемы" не 
выглядели продолжением поверхности ландшафта просто покрашенным в синий цвет, а 
имели плоскую поверхность, при генерации поля высот можно установить порог 
высоты, ниже которого "опускаться" вершинам запрещается. Если для элемента 
матрицы генерируется значение высоты ниже этого порога, элемент инициализируется 
пороговым значением.</P>
<P><I>Объекты</I></P>
<P>По ландшафту можно раскидать в художественном беспорядке от пятидесяти (50) 
объектов, встречающихся на ландшафте в обычной жизни, например домов или 
деревьев. При этом ель считается деревом, а две равнобедренные вытянутые 
вертикально грани, поставленные на ландшафт крест накрест и покрашенные в 
зеленый цвет, считаются елью.</P>
<P><I>Отражения в воде</I></P>
<P>Сделать так, чтобы ландшафт отражался в воде, которая уже должна 
присутствовать на ландшафте (то есть подразумевается, что это дополнительное 
задание является развитием дополнительного задания 2). Один из вариантов 
реализации: рассчитав текущую матрицу камеры, отразить ее относительно плоскости 
воды и изображение ландшафта, не выводя при этом грани поверхности воды. Затем, 
пользуясь еще не отраженной матрицей камеры, визуализировать грани поверхности 
воды полупрозрачными. Это создаст иллюзию поверхности воды, сквозь которую видно 
отражение. Затем, опять же с неотраженной матрицей камеры, нужно нарисовать сам 
ландшафт. (этот подход является частным случаем описанного в разделе 0.)</P>
<P><I>Тени</I></P>
<P>На этапе раскраски вершин ландшафта (то есть это надо сделать один раз, а не 
каждый кадр) из каждой вершины можно выпустить луч, противоположный направлению 
солнца. Если луч не пересекся с поверхностью ландшафта - раскрашивать как 
запланировано, если пересекся - значит данная вершина ландшафта находится в тени 
и для нее нужно взять менее интенсивный цвет. Примечание: реализация теней 
является задачей повышенной сложности (придется писать нахождение пересечений 
луча с гранями, что в общем случае нетривиально).</P>
<P><STRONG>Оценка: </STRONG></P>
<TABLE cellSpacing=2 cellPadding=5 border=0>
  <TBODY>
  <TR>
    <TD><I>База</I></TD>
    <TD></TD></TR>
  <TR>
    <TD>Ландшафт</TD>
    <TD>8 баллов </TD></TR>
  <TR>
    <TD>Раскраска</TD>
    <TD>2 балла </TD></TR>
  <TR>
    <TD>Управление</TD>
    <TD>2 балла </TD></TR>
  <TR>
    <TD><I>Дополнительно</I></TD>
    <TD></TD></TR>
  <TR>
    <TD>Управление мышью</TD>
    <TD>+2 балла </TD></TR>
  <TR>
    <TD>Объекты</TD>
    <TD>+3 балла </TD></TR>
  <TR>
    <TD>Вода</TD>
    <TD>+4 балла </TD></TR>
  <TR>
    <TD>Отражение</TD>
    <TD>+4 балла </TD></TR>
  <TR>
    <TD>*Тени</TD>
    <TD>+5 баллов </TD></TR>
  <TR>
    <TD></TD>
    <TD></TD></TR>
  <TR>
    <TD><I>Всего</I></TD>
    <TD>30 баллов </TD></TR></TBODY></TABLE>
<P></P>
<P>В таблице указано максимальное число баллов по каждому пункту. Система 
выставления баллов - гибкая, зависит от правдоподобности и впечатления от 
работы.</P>
<P><STRONG>Дополнительные источники информации: </STRONG></P>
<P><A href="http://www.vterrain.org/">http://www.vterrain.org/</A></P>
<H2>Литература<A name=XSLTPART169120120></A></H2>
<P>Эйнджел Э. Интерактивная компьютерная графика. Вводный курс на базе OpenGL, 2 
изд. Пер. с англ.- Москва, «Вильямс», 2001.</P>
<P>Порев В.Н. Компьютерная графика. СПб., BHV, 2002. </P>
<P>Шикин А. В., Боресков А. В. Компьютерная графика. Полигональные модели. 
Москва, ДИАЛОГ-МИФИ, 2001.</P>
<P>Тихомиров Ю. Программирование трехмерной графики. СПб, BHV, 1998. </P>
<P>Performance OpenGL: Platform Independent Techniques. SIGGRAPH 2001 
course.</P>
<P>OpenGL performance optimization, Siggraph’97 course.</P>
<P>Visual Introduction in OpenGL, SIGGRAPH’98.</P>
<P>The OpenGL graphics system: a specification (version 1.1). </P>
<P>Программирование GLUT: окна и анимация. Miguel Angel Sepulveda, 
LinuxFocus.</P>
<P>The OpenGL Utility Toolkit (GLUT) Programming Interface, API version 3, 
specification.</P>
<P></P>
<DIV align=right><FONT 
style="FONT-SIZE: 9pt; COLOR: #8088a0; FONT-FAMILY: arial"><I>
<HR width="100%" color=#8088a0 SIZE=1>
Любой из материалов, опубликованных на этом сервере, не может быть воспроизведен 
в какой бы то ни было форме и какими бы то ни было средствами без письменного 
разрешения владельцев авторских прав. </I></FONT></DIV>
<TABLE 
style="BORDER-RIGHT: #9daabd 1px solid; PADDING-RIGHT: 5px; BORDER-TOP: #9daabd 1px solid; PADDING-LEFT: 5px; FONT-WEIGHT: bold; PADDING-BOTTOM: 0px; BORDER-LEFT: #9daabd 1px solid; COLOR: #646464; PADDING-TOP: 0px; BORDER-BOTTOM: #9daabd 1px solid; FONT-FAMILY: verdana; BACKGROUND-COLOR: #e6e6e6" 
cellSpacing=0 width="100%" border=0 celpadding="2">
  <TBODY>
  <TR>
    <TD noWrap><FONT style="FONT-WEIGHT: normal" size=1>
      <SCRIPT language=javascript src="ogltut2.files/shMenu.js" 
      type=text/javascript></SCRIPT>
      </FONT></TD>
    <TD noWrap align=right width="100%"><FONT size=2>&nbsp;<A 
      title="Версия для печати" 
      href="http://www.rsdn.ru/article/opengl/ogltut2.xml?print" 
      target=_blank><IMG height=14 src="ogltut2.files/printer2.gif" width=16 
      align=absMiddle border=0></A>&nbsp;&nbsp;<A 
      title="Перейти к обсуждению статьи" 
      href="http://www.rsdn.ru/forum/?mid=338827" target=_self><FONT 
      color=#646464 size=1> Сообщений </FONT><FONT 
      color=black>0</FONT></A>&nbsp;&nbsp;<A title="Перейти к обсуждению статьи" 
      href="http://www.rsdn.ru/forum/?mid=338827" target=_self><IMG height=14 
      src="ogltut2.files/showfr.gif" width=18 align=absMiddle 
      border=0></A>&nbsp;<A 
      href="http://www.rsdn.ru/Forum/RateList.aspx?mid=338827"><FONT 
      color=#646464><FONT size=1> Оценка </FONT><FONT 
      color=black>225</FONT></FONT></A>&nbsp;&nbsp; <A 
      title="Добавить в избранное" 
      href="http://www.rsdn.ru/Users/Private/AddFav.aspx?mid=338827" 
      target=_blank><IMG onclick="AddFav(338827);return false;" height=14 
      src="ogltut2.files/fav.gif" align=absMiddle border=0></A>&nbsp;&nbsp;<A 
      title="Подписка на сообщения" href="javascript:SubMsg(338827)"><IMG 
      class=i height=14 src="ogltut2.files/sub.gif" width=18 align=absMiddle 
      border=0></A>&nbsp;&nbsp;&nbsp;<FONT size=1>Оценить </FONT><A title=+1 
      href="http://www.rsdn.ru/forum/Private/Rate.aspx?mid=338827&amp;rate=-3" 
      target=_blank><IMG onclick="RateMsg(338827,-3);return false;" height=14 
      src="ogltut2.files/n11.gif" width=18 align=absMiddle border=0></A><A 
      title=Интересно 
      href="http://www.rsdn.ru/forum/Private/Rate.aspx?mid=338827&amp;rate=1" 
      target=_blank><IMG onclick="RateMsg(338827,1);return false;" height=14 
      src="ogltut2.files/n1.gif" width=18 align=absMiddle border=0></A><A 
      title=Спасибо 
      href="http://www.rsdn.ru/forum/Private/Rate.aspx?mid=338827&amp;rate=2" 
      target=_blank><IMG onclick="RateMsg(338827,2);return false;" height=14 
      src="ogltut2.files/n2.gif" width=18 align=absMiddle border=0></A><A 
      title=Супер 
      href="http://www.rsdn.ru/forum/Private/Rate.aspx?mid=338827&amp;rate=3" 
      target=_blank><IMG onclick="RateMsg(338827,3);return false;" height=14 
      src="ogltut2.files/n3.gif" width=18 align=absMiddle border=0></A><A 
      title="Удалить оценку" 
      href="http://www.rsdn.ru/forum/Private/Rate.aspx?mid=338827&amp;rate=-1" 
      target=_blank><IMG onclick="RateMsg(338827,-1);return false;" height=14 
      src="ogltut2.files/nx.gif" width=18 align=absMiddle border=0></A><A 
      title=Согласен 
      href="http://www.rsdn.ru/forum/Private/Rate.aspx?mid=338827&amp;rate=-4" 
      target=_blank><IMG onclick="RateMsg(338827,-4);return false;" height=14 
      src="ogltut2.files/np.gif" width=18 align=absMiddle border=0></A><A 
      title="Не согласен" 
      href="http://www.rsdn.ru/forum/Private/Rate.aspx?mid=338827&amp;rate=0" 
      target=_blank><IMG onclick="RateMsg(338827,0);return false;" 
      src="ogltut2.files/nm.gif" width=18 align=absMiddle border=0 
      eight="14px"></A>&nbsp; </FONT></TD></TR></TBODY></TABLE></BODY></HTML>
